// https://www.rosettacode.org/wiki/100_doors#Python
V doors = [0B] * 100
L(i) 100
   L(j) (i .< 100).step(i + 1)
      doors[j] = !doors[j]
   print(‘Door ’(i + 1)‘: ’(I doors[i] {‘open’} E ‘close’))
===
auto doors = create_array({false}) * 100;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (int i = 0; i < 100; i++) {
            for (auto j : range_el(i, 100).step(i + 1))
                doors.set(j, !doors[j]);
            print(u"Door "_S + (i + 1) + u": "_S + (doors[i] ? u"open"_S : u"close"_S));
        }
    }
} code_block_1;


// https://www.rosettacode.org/wiki/Abundant,_deficient_and_perfect_number_classifications#Kotlin
F sum_proper_divisors(n)
   R I n < 2 {0} E sum((1 .. n I/ 2).filter(it -> (@n % it) == 0))

V deficient = 0
V perfect = 0
V abundant = 0

L(n) 1..20000
   V sp = sum_proper_divisors(n)
   I sp < n
      deficient++
   E I sp == n
      perfect++
   E I sp > n
      abundant++

print(‘Deficient = ’deficient)
print(‘Perfect   = ’perfect)
print(‘Abundant  = ’abundant)
===
template <typename T1> auto sum_proper_divisors(const T1 &n)
{
    return n < 2 ? 0 : sum(range_ee(1, int(n)/int(2)).filter([&n](const auto &it){return (mod(n, it)) == 0;}));
}
auto deficient = 0;
auto perfect = 0;
auto abundant = 0;

struct CodeBlock1
{
    CodeBlock1()
    {

        for (auto n : range_ee(1, 20000)) {
            auto sp = sum_proper_divisors(n);
            if (sp < n)
                deficient++;
            else if (sp == n)
                perfect++;
            else if (sp > n)
                abundant++;
        }
        print(u"Deficient = "_S + deficient);
        print(u"Perfect   = "_S + perfect);
        print(u"Abundant  = "_S + abundant);
    }
} code_block_1;


// https://www.rosettacode.org/wiki/Amb#Nim
F amb(comp, options, prev = ‘’) -> [String]
   I options.empty
      R []

   L(opt) options[0]
      // If this is the base call, prev is empty and we need to continue.
      I prev != ‘’ & !comp(prev, opt)
         L.continue

      // Take care of the case where we have no options left.
      I options.len == 1
         R [opt]

      // Traverse into the tree.
      V res = amb(comp, options[1..], opt)

      // If it was a failure, try the next one.
      if !res.empty
         R opt [+] res // We have a match

   R []

V sets = [[‘the’, ‘that’, ‘a’],
          [‘frog’, ‘elephant’, ‘thing’],
          [‘walked’, ‘treaded’, ‘grows’],
          [‘slowly’, ‘quickly’]]

V result = amb((s, t) -> s.last == t[0], sets)
print(result.join(‘ ’))
===
template <typename T1, typename T2, typename T3 = decltype(u""_S)> Array<String> amb(const T1 &comp, const T2 &options, const T3 &prev = u""_S)
{
    if (options.empty())
        return Array<String>();

    for (auto opt : _get<0>(options)) {
        if (prev != u"" && !comp(prev, opt))
            continue;
        if (options.len() == 1)
            return create_array({opt});
        auto res = amb(comp, options[range_ei(1)], opt);
        if (!res.empty())
            return opt + res;
    }
    return Array<String>();
}
auto sets = create_array({create_array({u"the"_S, u"that"_S, u"a"_S}), create_array({u"frog"_S, u"elephant"_S, u"thing"_S}), create_array({u"walked"_S, u"treaded"_S, u"grows"_S}), create_array({u"slowly"_S, u"quickly"_S})});
auto result = amb([](const auto &s, const auto &t){return s.last() == _get<0>(t);}, sets);

struct CodeBlock1
{
    CodeBlock1()
    {
        print(result.join(u" "_S));
    }
} code_block_1;


// https://www.rosettacode.org/wiki/Amicable_pairs
F sum_proper_divisors(n)
   R I n < 2 {0} E sum((1 .. n I/ 2).filter(it -> (@n % it) == 0))

L(n) 1..20000
   V m = sum_proper_divisors(n)
   I m > n & sum_proper_divisors(m) == n
      print(n"\t"m)
===
template <typename T1> auto sum_proper_divisors(const T1 &n)
{
    return n < 2 ? 0 : sum(range_ee(1, int(n)/int(2)).filter([&n](const auto &it){return (mod(n, it)) == 0;}));
}

struct CodeBlock1
{
    CodeBlock1()
    {

        for (auto n : range_ee(1, 20000)) {
            auto m = sum_proper_divisors(n);
            if (m > n && sum_proper_divisors(m) == n)
                print(n + u"\t"_S + m);
        }
    }
} code_block_1;


// https://www.rosettacode.org/wiki/Arithmetic/Integer#C
V a = Int(input())
V b = Int(input())

print(‘a + b = ’(a + b))
print(‘a - b = ’(a - b))
print(‘a * b = ’(a * b))
print(‘a / b = ’(a I/ b))
print(‘a % b = ’(a % b))
print(‘a ^ b = ’(a ^ b))
===
auto a = to_int(input());
auto b = to_int(input());

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"a + b = "_S + (a + b));
        print(u"a - b = "_S + (a - b));
        print(u"a * b = "_S + (a * b));
        print(u"a / b = "_S + (int(a)/int(b)));
        print(u"a % b = "_S + (mod(a, b)));
        print(u"a ^ b = "_S + (pow(a, b)));
    }
} code_block_1;


// https://www.rosettacode.org/wiki/Averages/Pythagorean_means#Python
F amean(num)
   R sum(num)/Float(num.len)
 
F gmean(num)
   R product(num) ^ (1.0/num.len)
 
F hmean(num)
   return num.len / sum(num.map(n -> 1.0/n))
 
V numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
print(amean(numbers))
print(gmean(numbers))
print(hmean(numbers))
===
template <typename T1> auto amean(const T1 &num)
{
    return sum(num) / to_float(num.len());
}

template <typename T1> auto gmean(const T1 &num)
{
    return pow(product(num), (1.0 / num.len()));
}

template <typename T1> auto hmean(const T1 &num)
{
    return num.len() / sum(num.map([](const auto &n){return 1.0 / n;}));
}
auto numbers = create_array({1, 2, 3, 4, 5, 6, 7, 8, 9, 10});

struct CodeBlock1
{
    CodeBlock1()
    {
        print(amean(numbers));
        print(gmean(numbers));
        print(hmean(numbers));
    }
} code_block_1;


// https://www.rosettacode.org/wiki/Binary_digits
L(n) [0, 5, 50, 9000]
   print(‘#4 = #.’.format(n, bin(n)))
===
struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto n : create_array({0, 5, 50, 9000}))
            print(u"#4 = #."_S.format(n, bin(n)));
    }
} code_block_1;