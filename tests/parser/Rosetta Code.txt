// https://www.rosettacode.org/wiki/100_doors#Python
V doors = [0B] * 100
L(i) 100
   L(j) (i .< 100).step(i + 1)
      doors[j] = !doors[j]
   print(‘Door ’(i + 1)‘: ’(I doors[i] {‘open’} E ‘close’))
===
auto doors = create_array({false}) * 100;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (int i = 0; i < 100; i++) {
            for (auto j : range_el(i, 100).step(i + 1))
                doors.set(j, !doors[j]);
            print(u"Door "_S + (i + 1) + u": "_S + (doors[i] ? u"open"_S : u"close"_S));
        }
    }
} code_block_1;


// https://www.rosettacode.org/wiki/Abundant,_deficient_and_perfect_number_classifications#Kotlin
F sum_proper_divisors(n)
   R I n < 2 {0} E sum((1 .. n I/ 2).filter(it -> (@n % it) == 0))

V deficient = 0
V perfect = 0
V abundant = 0

L(n) 1..20000
   V sp = sum_proper_divisors(n)
   I sp < n
      deficient++
   E I sp == n
      perfect++
   E I sp > n
      abundant++

print(‘Deficient = ’deficient)
print(‘Perfect   = ’perfect)
print(‘Abundant  = ’abundant)
===
template <typename T1> auto sum_proper_divisors(const T1 &n)
{
    return n < 2 ? 0 : sum(range_ee(1, int(n)/int(2)).filter([&n](const auto &it){return (mod(n, it)) == 0;}));
}
auto deficient = 0;
auto perfect = 0;
auto abundant = 0;

struct CodeBlock1
{
    CodeBlock1()
    {

        for (auto n : range_ee(1, 20000)) {
            auto sp = sum_proper_divisors(n);
            if (sp < n)
                deficient++;
            else if (sp == n)
                perfect++;
            else if (sp > n)
                abundant++;
        }
        print(u"Deficient = "_S + deficient);
        print(u"Perfect   = "_S + perfect);
        print(u"Abundant  = "_S + abundant);
    }
} code_block_1;


// https://www.rosettacode.org/wiki/Amb#Nim
F amb(comp, options, prev = ‘’) -> [String]
   I options.empty
      R []

   L(opt) options[0]
      // If this is the base call, prev is empty and we need to continue.
      I prev != ‘’ & !comp(prev, opt)
         L.continue

      // Take care of the case where we have no options left.
      I options.len == 1
         R [opt]

      // Traverse into the tree.
      V res = amb(comp, options[1..], opt)

      // If it was a failure, try the next one.
      if !res.empty
         R opt [+] res // We have a match

   R []

V sets = [[‘the’, ‘that’, ‘a’],
          [‘frog’, ‘elephant’, ‘thing’],
          [‘walked’, ‘treaded’, ‘grows’],
          [‘slowly’, ‘quickly’]]

V result = amb((s, t) -> s.last == t[0], sets)
print(result.join(‘ ’))
===
template <typename T1, typename T2, typename T3 = decltype(u""_S)> Array<String> amb(const T1 &comp, const T2 &options, const T3 &prev = u""_S)
{
    if (options.empty())
        return Array<String>();

    for (auto &&opt : _get<0>(options)) {
        if (prev != u"" && !comp(prev, opt))
            continue;
        if (options.len() == 1)
            return create_array({opt});
        auto res = amb(comp, options[range_ei(1)], opt);
        if (!res.empty())
            return opt + res;
    }
    return Array<String>();
}
auto sets = create_array({create_array({u"the"_S, u"that"_S, u"a"_S}), create_array({u"frog"_S, u"elephant"_S, u"thing"_S}), create_array({u"walked"_S, u"treaded"_S, u"grows"_S}), create_array({u"slowly"_S, u"quickly"_S})});
auto result = amb([](const auto &s, const auto &t){return s.last() == _get<0>(t);}, sets);

struct CodeBlock1
{
    CodeBlock1()
    {
        print(result.join(u" "_S));
    }
} code_block_1;


// https://www.rosettacode.org/wiki/Amicable_pairs
F sum_proper_divisors(n)
   R I n < 2 {0} E sum((1 .. n I/ 2).filter(it -> (@n % it) == 0))

L(n) 1..20000
   V m = sum_proper_divisors(n)
   I m > n & sum_proper_divisors(m) == n
      print(n"\t"m)
===
template <typename T1> auto sum_proper_divisors(const T1 &n)
{
    return n < 2 ? 0 : sum(range_ee(1, int(n)/int(2)).filter([&n](const auto &it){return (mod(n, it)) == 0;}));
}

struct CodeBlock1
{
    CodeBlock1()
    {

        for (auto n : range_ee(1, 20000)) {
            auto m = sum_proper_divisors(n);
            if (m > n && sum_proper_divisors(m) == n)
                print(n + u"\t"_S + m);
        }
    }
} code_block_1;


// https://www.rosettacode.org/wiki/Arithmetic/Integer#C
V a = Int(input())
V b = Int(input())

print(‘a + b = ’(a + b))
print(‘a - b = ’(a - b))
print(‘a * b = ’(a * b))
print(‘a / b = ’(a I/ b))
print(‘a % b = ’(a % b))
print(‘a ^ b = ’(a ^ b))
===
auto a = to_int(input());
auto b = to_int(input());

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"a + b = "_S + (a + b));
        print(u"a - b = "_S + (a - b));
        print(u"a * b = "_S + (a * b));
        print(u"a / b = "_S + (int(a)/int(b)));
        print(u"a % b = "_S + (mod(a, b)));
        print(u"a ^ b = "_S + (pow(a, b)));
    }
} code_block_1;


// https://www.rosettacode.org/wiki/Averages/Pythagorean_means#Python
F amean(num)
   R sum(num)/Float(num.len)
 
F gmean(num)
   R product(num) ^ (1.0/num.len)
 
F hmean(num)
   return num.len / sum(num.map(n -> 1.0/n))
 
V numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
print(amean(numbers))
print(gmean(numbers))
print(hmean(numbers))
===
template <typename T1> auto amean(const T1 &num)
{
    return sum(num) / to_float(num.len());
}

template <typename T1> auto gmean(const T1 &num)
{
    return pow(product(num), (1.0 / num.len()));
}

template <typename T1> auto hmean(const T1 &num)
{
    return num.len() / sum(num.map([](const auto &n){return 1.0 / n;}));
}
auto numbers = create_array({1, 2, 3, 4, 5, 6, 7, 8, 9, 10});

struct CodeBlock1
{
    CodeBlock1()
    {
        print(amean(numbers));
        print(gmean(numbers));
        print(hmean(numbers));
    }
} code_block_1;


// https://www.rosettacode.org/wiki/Binary_digits
L(n) [0, 5, 50, 9000]
   print(‘#4 = #.’.format(n, bin(n)))
===
struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&n : create_array({0, 5, 50, 9000}))
            print(u"#4 = #."_S.format(n, bin(n)));
    }
} code_block_1;


// https://www.rosettacode.org/wiki/Bitwise_operations#Kotlin
V x = 10
V y = 2
print(‘x       = ’x)
print(‘y       = ’y)
print(‘NOT x   = ’(-)x)
print(‘x AND y = ’(x [&] y))
print(‘x OR  y = ’(x [|] y))
print(‘x XOR y = ’(x (+) y))
print(‘x SHL y = ’(x << y))
print(‘x SHR y = ’(x >> y))
print(‘x ROL y = ’rotl(x, y))
print(‘x ROR y = ’rotr(x, y))
===
auto x = 10;
auto y = 2;

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"x       = "_S + x);
        print(u"y       = "_S + y);
        print(u"NOT x   = "_S + ~x);
        print(u"x AND y = "_S + (x & y));
        print(u"x OR  y = "_S + (x | y));
        print(u"x XOR y = "_S + (x ^ y));
        print(u"x SHL y = "_S + (x << y));
        print(u"x SHR y = "_S + (x >> y));
        print(u"x ROL y = "_S + rotl(x, y));
        print(u"x ROR y = "_S + rotr(x, y));
    }
} code_block_1;


// https://www.rosettacode.org/wiki/Caesar_cipher
F caesar(string, =key, decode = 0B)
   I decode
      key = 26 - key

   V r = ‘ ’ * string.len
   L(c) string
      r[L.index] = S c
                      ‘a’..‘z’
                         Char(code' (c.code - ‘a’.code + key) % 26 + ‘a’.code)
                      ‘A’..‘Z’
                         Char(code' (c.code - ‘A’.code + key) % 26 + ‘A’.code)
                      E
                         c
   R r

V msg = ‘The quick brown fox jumped over the lazy dogs’
print(msg)
V enc = caesar(msg, 11)
print(enc)
print(caesar(enc, 11, decode' 1B))
===
template <typename T1, typename T2, typename T3 = decltype(false)> auto caesar(const T1 &string, T2 key, const T3 &decode = false)
{
    if (decode)
        key = 26 - key;
    auto r = u" "_S * string.len();
    {int Lindex = 0;
    for (auto &&c : string) {
        r.set(Lindex, [&](const auto &a){return in(a, range_ee(u'a'_C, u'z'_C)) ? Char(mod((c.code - u'a'_C.code + key), 26) + u'a'_C.code) : in(a, range_ee(u'A'_C, u'Z'_C)) ? Char(mod((c.code - u'A'_C.code + key), 26) + u'A'_C.code) : c;}(c));
        Lindex++;
    }}
    return r;
}
auto msg = u"The quick brown fox jumped over the lazy dogs"_S;

struct CodeBlock1
{
    CodeBlock1()
    {
        print(msg);
    }
} code_block_1;
auto enc = caesar(msg, 11);

struct CodeBlock2
{
    CodeBlock2()
    {
        print(enc);
        print(caesar(enc, 11, true));
    }
} code_block_2;


// https://www.rosettacode.org/wiki/Carmichael_3_strong_pseudoprimes#D
F mod_(n, m)
   R ((n % m) + m) % m
 
F is_prime(n)
   I n C (2, 3)
      R 1B
   E I n < 2 | n % 2 == 0 | n % 3 == 0
      R 0B
   V div = 5
   V inc = 2
   L div ^ 2 <= n
      I n % div == 0
         R 0B
      div += inc
      inc = 6 - inc
   R 1B
 
L(p) 2 .< 62
   I !is_prime(p)
      L.continue
   L(h3) 2 .< p
      V g = h3 + p
      L(d) 1 .< g
         I (g * (p - 1)) % d != 0 | mod_(-p * p, h3) != d % h3
            L.continue
         V q = 1 + (p - 1) * g I/ d
         I !is_prime(q)
            L.continue
         V r = 1 + (p * q I/ h3)
         I !is_prime(r) | (q * r) % (p - 1) != 1
            L.continue
         print(p‘ x ’q‘ x ’r)
===
template <typename T1, typename T2> auto mod_(const T1 &n, const T2 &m)
{
    return mod(((mod(n, m)) + m), m);
}

template <typename T1> auto is_prime(const T1 &n)
{
    if (in(n, make_tuple(2, 3)))
        return true;
    else if (n < 2 || mod(n, 2) == 0 || mod(n, 3) == 0)
        return false;
    auto div = 5;
    auto inc = 2;
    while (pow(div, 2) <= n) {
        if (mod(n, div) == 0)
            return false;
        div += inc;
        inc = 6 - inc;
    }
    return true;
}

struct CodeBlock1
{
    CodeBlock1()
    {

        for (auto p : range_el(2, 62)) {
            if (!is_prime(p))
                continue;
            for (auto h3 : range_el(2, p)) {
                auto g = h3 + p;
                for (auto d : range_el(1, g)) {
                    if (mod((g * (p - 1)), d) != 0 || mod_(-p * p, h3) != mod(d, h3))
                        continue;
                    auto q = 1 + int((p - 1) * g)/int(d);
                    if (!is_prime(q))
                        continue;
                    auto r = 1 + (int(p * q)/int(h3));
                    if (!is_prime(r) || mod((q * r), (p - 1)) != 1)
                        continue;
                    print(p + u" x "_S + q + u" x "_S + r);
                }
            }
        }
    }
} code_block_1;


// https://www.rosettacode.org/wiki/Combinations#D
F comb(arr, k)
   [[Int]] result
   I k == 0
      [Int] empty_array
      result [+]= empty_array
      R result

   L(x) arr
      V i = L.index
      L(suffix) comb(arr[i+1..], k-1)
         result [+]= x [+] suffix

   R result

print(comb([0, 1, 2, 3, 4], 3))
===
template <typename T1, typename T2> auto comb(const T1 &arr, const T2 &k)
{
    Array<Array<int>> result;
    if (k == 0) {
        Array<int> empty_array;
        result.append(empty_array);
        return result;
    }
    {int Lindex = 0;

    for (auto &&x : arr) {
        auto i = Lindex;
        for (auto &&suffix : comb(arr[range_ei(i + 1)], k - 1))
            result.append(x + suffix);
        Lindex++;
    }}
    return result;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(comb(create_array({0, 1, 2, 3, 4}), 3));
    }
} code_block_1;


// https://www.rosettacode.org/wiki/Comma_quibbling
F quibble(words)
   R S words.len
      0
         ‘{}’
      1
         ‘{’words[0]‘}’
      E
         ‘{’words[0.<(len)-1].join(‘, ’)‘ and ’words.last‘}’

print(quibble([‘’] * 0))
print(quibble([‘ABC’]))
print(quibble([‘ABC’, ‘DEF’]))
print(quibble([‘ABC’, ‘DEF’, ‘G’, ‘H’]))
===
template <typename T1> auto quibble(const T1 &words)
{
    return [&](const auto &a){return a == 0 ? u"{}"_S : a == 1 ? u"{"_S + _get<0>(words) + u"}"_S : u"{"_S + words[range_e_llen(0,  - 1)].join(u", "_S) + u" and "_S + words.last() + u"}"_S;}(words.len());
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(quibble(create_array({u""_S}) * 0));
        print(quibble(create_array({u"ABC"_S})));
        print(quibble(create_array({u"ABC"_S, u"DEF"_S})));
        print(quibble(create_array({u"ABC"_S, u"DEF"_S, u"G"_S, u"H"_S})));
    }
} code_block_1;


// https://www.rosettacode.org/wiki/Command-line_arguments
:start:
print(‘Program name: ’:argv[0])
print("Arguments:\n":argv[1..].join("\n"))
===
Array<String> argv;

int MAIN_WITH_ARGV()
{
    INIT_ARGV();

    print(u"Program name: "_S + _get<0>(::argv));
    print(u"Arguments:\n"_S + ::argv[range_ei(1)].join(u"\n"_S));
}


// https://www.rosettacode.org/wiki/Constrained_random_points_on_a_circle#Julia
F print_circle(lo, hi, ndots)
   V canvas = [[0B] * (2*hi+1)] * (2*hi+1)
   V i = 0
   L i < ndots
      V x = random:(-hi..hi)
      V y = random:(-hi..hi)
      I x^2 + y^2 C lo^2 .. hi^2
         canvas[x + hi][y + hi] = 1B
         i++

   L(i) 0 .. 2*hi
      print(canvas[i].map(j -> I j {‘♦ ’} E ‘  ’).join(‘’))
 
print_circle(10, 15, 100)
===
template <typename T1, typename T2, typename T3> auto print_circle(const T1 &lo, const T2 &hi, const T3 &ndots)
{
    auto canvas = create_array({create_array({false}) * (2 * hi + 1)}) * (2 * hi + 1);
    auto i = 0;
    while (i < ndots) {
        auto x = randomns::_(range_ee(-hi, hi));
        auto y = randomns::_(range_ee(-hi, hi));
        if (in(pow(x, 2) + pow(y, 2), range_ee(pow(lo, 2), pow(hi, 2)))) {
            canvas[x + hi].set(y + hi, true);
            i++;
        }
    }
    for (auto i : range_ee(0, 2 * hi))
        print(canvas[i].map([](const auto &j){return j ? u"♦ "_S : u"  "_S;}).join(u""_S));
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print_circle(10, 15, 100);
    }
} code_block_1;


// https://www.rosettacode.org/wiki/Conway%27s_Game_of_Life
V cellcountx = 6
V cellcounty = 5
V celltable = [(1, 2) = 1,
               (1, 3) = 1,
               (0, 3) = 1]
DefaultDict[(Int, Int), Int] universe
universe[(1, 1)] = 1
universe[(2, 1)] = 1
universe[(3, 1)] = 1
universe[(1, 4)] = 1
universe[(2, 4)] = 1
universe[(3, 4)] = 1

L(i) 4
   print("\nGeneration "i‘:’)
   L(row) 0 .< cellcounty
      print(‘  ’(0 .< cellcountx).map(col -> [‘. ’, ‘O ’][:universe[(@row, col)]]).join(‘’))

   DefaultDict[(Int, Int), Int] nextgeneration
   L(row) 0 .< cellcounty
      L(col) 0 .< cellcountx
         nextgeneration[(row, col)] = celltable.get(
              (universe[(row, col)],
              -universe[(row, col)] + sum(multiloop(row-1..row+1,
                                                    col-1..col+1, (r, c) -> :universe[(r, c)]))
              ), 0)
   universe = nextgeneration
===
auto cellcountx = 6;
auto cellcounty = 5;
auto celltable = create_dict(dict_of(make_tuple(1, 2), 1)(make_tuple(1, 3), 1)(make_tuple(0, 3), 1));
DefaultDict<Tuple<int, int>, int> universe;

struct CodeBlock1
{
    CodeBlock1()
    {
        universe.set(make_tuple(1, 1), 1);
        universe.set(make_tuple(2, 1), 1);
        universe.set(make_tuple(3, 1), 1);
        universe.set(make_tuple(1, 4), 1);
        universe.set(make_tuple(2, 4), 1);
        universe.set(make_tuple(3, 4), 1);

        for (int i = 0; i < 4; i++) {
            print(u"\nGeneration "_S + i + u":"_S);
            for (auto row : range_el(0, cellcounty))
                print(u"  "_S + range_el(0, cellcountx).map([&row](const auto &col){return create_array({u". "_S, u"O "_S})[::universe[make_tuple(row, col)]];}).join(u""_S));
            DefaultDict<Tuple<int, int>, int> nextgeneration;
            for (auto row : range_el(0, cellcounty))
                for (auto col : range_el(0, cellcountx))
                    nextgeneration.set(make_tuple(row, col), celltable.get(make_tuple(universe[make_tuple(row, col)], -universe[make_tuple(row, col)] + sum(multiloop(range_ee(row - 1, row + 1), range_ee(col - 1, col + 1), [](const auto &r, const auto &c){return ::universe[make_tuple(r, c)];}))), 0));
            universe = nextgeneration;
        }
    }
} code_block_1;


// https://www.rosettacode.org/wiki/Conway%27s_Game_of_Life#More_optimal_solution
V cellcountx = 6
V cellcounty = 5
V universe = [[0B] * cellcountx] * cellcounty
universe[1][1] = 1B
universe[2][1] = 1B
universe[3][1] = 1B
universe[1][4] = 1B
universe[2][4] = 1B
universe[3][4] = 1B
V nextgeneration = [[0B] * cellcountx] * cellcounty

L(i) 4
   print("\nGeneration "i‘:’)
   L(row) 0 .< cellcounty
      print(‘  ’, end' ‘’)
      L(col) 0 .< cellcountx
         print(I universe[row][col] {‘O ’} E ‘. ’, end' ‘’)
      print()

   L(row) 0 .< cellcounty
      L(col) 0 .< cellcountx
         V s = 0
         I row > 0
            s = universe[row-1][col]
            I col > 0
               s += universe[row-1][col-1]
            I col < cellcountx-1
               s += universe[row-1][col+1]
         I col > 0
            s += universe[row][col-1]
         I col < cellcountx-1
            s += universe[row][col+1]
         I row < cellcounty-1
            s += universe[row+1][col]
            I col > 0
               s += universe[row+1][col-1]
            I col < cellcountx-1
               s += universe[row+1][col+1]
         nextgeneration[row][col] = I universe[row][col] {s C 2..3} E s == 3
   universe = nextgeneration
===
auto cellcountx = 6;
auto cellcounty = 5;
auto universe = create_array({create_array({false}) * cellcountx}) * cellcounty;

struct CodeBlock1
{
    CodeBlock1()
    {
        _set<1>(_get<1>(universe), true);
        _set<1>(_get<2>(universe), true);
        _set<1>(_get<3>(universe), true);
        _set<4>(_get<1>(universe), true);
        _set<4>(_get<2>(universe), true);
        _set<4>(_get<3>(universe), true);
    }
} code_block_1;
auto nextgeneration = create_array({create_array({false}) * cellcountx}) * cellcounty;

struct CodeBlock2
{
    CodeBlock2()
    {

        for (int i = 0; i < 4; i++) {
            print(u"\nGeneration "_S + i + u":"_S);
            for (auto row : range_el(0, cellcounty)) {
                print(u"  "_S, u""_S);
                for (auto col : range_el(0, cellcountx))
                    print(universe[row][col] ? u"O "_S : u". "_S, u""_S);
                print();
            }
            for (auto row : range_el(0, cellcounty))
                for (auto col : range_el(0, cellcountx)) {
                    auto s = 0;
                    if (row > 0) {
                        s = universe[row - 1][col];
                        if (col > 0)
                            s += universe[row - 1][col - 1];
                        if (col < cellcountx - 1)
                            s += universe[row - 1][col + 1];
                    }
                    if (col > 0)
                        s += universe[row][col - 1];
                    if (col < cellcountx - 1)
                        s += universe[row][col + 1];
                    if (row < cellcounty - 1) {
                        s += universe[row + 1][col];
                        if (col > 0)
                            s += universe[row + 1][col - 1];
                        if (col < cellcountx - 1)
                            s += universe[row + 1][col + 1];
                    }
                    nextgeneration[row].set(col, universe[row][col] ? in(s, range_ee(2, 3)) : s == 3);
                }
            universe = nextgeneration;
        }
    }
} code_block_2;


// https://www.rosettacode.org/wiki/Count_in_factors#C.2B.2B
F get_prime_factors(=li)
   I li == 1
      R ‘1’
   E
      V res = ‘’
      V f = 2
      L
         I li % f == 0
            res ‘’= f
            li /= f
            I li == 1
               L.break
            res ‘’= ‘ x ’
         E
            f++
      R res

L(x) 1..17
   print(‘#4: #.’.format(x, get_prime_factors(x)))
print(‘2144: ’get_prime_factors(2144))
===
template <typename T1> auto get_prime_factors(T1 li)
{
    if (li == 1)
        return u"1"_S;
    else {
        auto res = u""_S;
        auto f = 2;
        while (true)
            if (mod(li, f) == 0) {
                res += f;
                li /= f;
                if (li == 1)
                    break;
                res += u" x "_S;
            }
            else
                f++;
        return res;
    }
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto x : range_ee(1, 17))
            print(u"#4: #."_S.format(x, get_prime_factors(x)));
        print(u"2144: "_S + get_prime_factors(2144));
    }
} code_block_1;


// https://www.rosettacode.org/wiki/Count_occurrences_of_a_substring
print(‘the three truths’.count(‘th’))
print(‘ababababab’.count(‘abab’))
===
struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"the three truths"_S.count(u"th"_S));
        print(u"ababababab"_S.count(u"abab"_S));
    }
} code_block_1;


// https://www.rosettacode.org/wiki/Create_a_two-dimensional_array_at_runtime#Python
V width = 3
V height = 5
V myarray = [[0] * width] * height
print(myarray[height-1][width-1])
===
auto width = 3;
auto height = 5;
auto myarray = create_array({create_array({0}) * width}) * height;

struct CodeBlock1
{
    CodeBlock1()
    {
        print(myarray[height - 1][width - 1]);
    }
} code_block_1;


// https://www.rosettacode.org/wiki/Benford%27s_law#D
F get_fibs()
   V a = 1.0
   V b = 1.0
   [Float] r
   L 1000
      r [+]= a
      (a, b) = (b, a + b)
   R r

F benford(seq)
   V freqs = [(0.0, 0.0)] * 9
   V seq_len = 0
   L(d) seq
      I d != 0
         freqs[String(d)[0].code - ‘1’.code][1]++
         seq_len++

   L(&f) freqs
      f = (log10(1.0 + 1.0 / (L.index + 1)), f[1] / seq_len)
   R freqs

print(‘#9 #9 #9’.format(‘Actual’, ‘Expected’, ‘Deviation’))

L(p) benford(get_fibs())
   print(‘#.: #2.2% | #2.2% | #0.4%’.format(L.index + 1, p[1] * 100, p[0] * 100, abs(p[1] - p[0]) * 100))
===
auto get_fibs()
{
    auto a = 1.0;
    auto b = 1.0;
    Array<double> r;
    for (int Lindex = 0; Lindex < 1000; Lindex++) {
        r.append(a);
        std::tie(a, b) = make_tuple(b, a + b);
    }
    return r;
}

template <typename T1> auto benford(const T1 &seq)
{
    auto freqs = create_array({make_tuple(0.0, 0.0)}) * 9;
    auto seq_len = 0;
    for (auto &&d : seq)
        if (d != 0) {
            _get<1>(freqs[_get<0>(String(d)).code - u'1'_C.code])++;
            seq_len++;
        }
    {int Lindex = 0;

    for (auto &f : freqs) {
        f = make_tuple(log10(1.0 + 1.0 / (Lindex + 1)), _get<1>(f) / seq_len);
        Lindex++;
    }}
    return freqs;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"#9 #9 #9"_S.format(u"Actual"_S, u"Expected"_S, u"Deviation"_S));
        {int Lindex = 0;

        for (auto &&p : benford(get_fibs())) {
            print(u"#.: #2.2% | #2.2% | #0.4%"_S.format(Lindex + 1, _get<1>(p) * 100, _get<0>(p) * 100, abs(_get<1>(p) - _get<0>(p)) * 100));
            Lindex++;
        }}
    }
} code_block_1;


// https://www.rosettacode.org/wiki/CSV_data_manipulation#Nim
L(=line) File(‘data.csv’).read_lines()
   I L.index == 0
      line ‘’= ‘,SUM’
   E
      line ‘’= ‘,’sum(line.split(‘,’).map(i -> Int(i)))
   print(line)
===
struct CodeBlock1
{
    CodeBlock1()
    {
        {int Lindex = 0;
        for (auto line : File(u"data.csv"_S).read_lines()) {
            if (Lindex == 0)
                line += u",SUM"_S;
            else
                line += u","_S + sum(line.split(u","_S).map([](const auto &i){return to_int(i);}));
            print(line);
            Lindex++;
        }}
    }
} code_block_1;