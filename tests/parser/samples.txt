---
\‘res = '['
for i in range(len(self.children)):
    res += self.children[i].to_str()
    if i < len(self.children)-1:
        res += ', '
return res + ']'’
A res = ‘[’
L(c) .children
   res ‘’= c.to_str()
   I L.next != N
      res ‘’= ‘, ’
R res‘]’


String token
F f()
   R S :token {‘None’ {‘N’}; ‘False’ {‘0B’}; ‘True’ {‘1B’}}
===
String token;
auto f()
{
    return [&](const auto &a){return a == u"None" ? u"N"_S : a == u"False" ? u"0B"_S : a == u"True" ? u"1B"_S : throw KeyError(a);}(::token);
}


F func(arg = 1)
   R arg + 1
===
template <typename T1 = decltype(1)> auto func(const T1 &arg = 1)
{
    return arg + 1;
}


F sign(x)
   I x < 0
      R -1
   E I x > 0
      R 1
   E
      R 0
===
template <typename T1> auto sign(const T1 &x)
{
    if (x < 0)
        return -1;
    else if (x > 0)
        return 1;
    else
        return 0;
}


F f()
   I 1B
   {
   }
===
auto f()
{
    if (true) {
    }
}


// Inspired by sample from ‘Nemerle Wiki’[https://github.com/rsdn/nemerle/wiki/The-basics-(tutorial)#Rewriting_Line_Counter_without_the_loop]
fn m1() {}
fn m2() {}
fn f()
   if foo
      if bar
          m1()
   else
       m2()
===
auto m1()
{
}
auto m2()
{
}
auto f()
{
    if (foo) {
        if (bar)
            m1();
    }
    else
        m2();
}


fn m1() {}
fn m2() {}
fn m3() {}
fn m4() {}
fn f()
{
   if foo
      if bar
          m1()
      else if z
          if e
             m3()
      else
          m4()
   else
       m2()
}
===
auto m1()
{
}
auto m2()
{
}
auto m3()
{
}
auto m4()
{
}
auto f()
{
    if (foo) {
        if (bar)
            m1();
        else if (z) {
            if (e)
                m3();
        }
        else
            m4();
    }
    else
        m2();
}


T Shape
   Tuple[Int, Int] position

T Circle(Shape, Object)
   Int radious
===
class Shape
{
public:
    Tuple<int, int> position;
};

class Circle : public Shape, public Object
{
public:
    int radious;
};


T Person
   String name
   Int age

   F ()
      .age = 1

   F (name, age)
      .name = name
      .age = age

   F ()(name)
      .name = name
      R 1
===
class Person
{
public:
    String name;
    int age;

    Person()
    {
        age = 1;
    }

    template <typename T1, typename T2> Person(const T1 &name, const T2 &age)
    {
        this->name = name;
        this->age = age;
    }

    template <typename T1> auto operator()(const T1 &name)
    {
        this->name = name;
        return 1;
    }
};


A l1 = () -> N
A l2 = x -> x[0]
A l3 = self -> self
A l4 = (x, y, reverse = 0B) -> I reverse {y < x} E x < y
A r = I reverse {y < x} E I eq {x == y} E x < y
===
auto l1 = [](){return nullptr;};
auto l2 = [](const auto &x){return _get<0>(x);};
auto l3 = [](const auto &self){return self;};
auto l4 = [](const auto &x, const auto &y, const auto &reverse = false){return reverse ? y < x : x < y;};
auto r = reverse ? y < x : eq ? x == y : x < y;


F f()
   String ch
   I ch C ‘0’..‘9’ {
   }
   if ch in ‘0’..‘9’ {
   }
   I ch !C ‘0’..‘9’ {
   }
   if ch !in ‘0’..‘9’ {
   }
===
auto f()
{
    String ch;
    if (in(ch, range_ee(u'0'_C, u'9'_C))) {
    }

    if (in(ch, range_ee(u'0'_C, u'9'_C))) {
    }

    if (!in(ch, range_ee(u'0'_C, u'9'_C))) {
    }

    if (!in(ch, range_ee(u'0'_C, u'9'_C))) {
    }
}


A id = 0
F f(str) {}
f(‘id=’id)
A s = ‘str’"\n"
A s2 = a‘’b
F to_str(indent)
   A t = ‘str’(.expression.to_str())
   R (‘ ’ * (indent * 3))‘’(.expression.to_str())"\n"
String tag = ‘<a href="’link‘"’
tag ‘’= s
===
auto id = 0;
template <typename T1> auto f(const T1 &str)
{
}

struct CodeBlock1
{
    CodeBlock1()
    {
        f(u"id="_S + id);
    }
} code_block_1;
auto s = u"str"_S + u"\n"_S;
auto s2 = a + b;
template <typename T1> auto to_str(const T1 &indent)
{
    auto t = u"str"_S + (expression.to_str());
    return (u" "_S * (indent * 3)) + (expression.to_str()) + u"\n"_S;
}
String tag = u"<a href=\""_S + link + u"\""_S;

struct CodeBlock2
{
    CodeBlock2()
    {
        tag += s;
    }
} code_block_2;


F f()
   r = abc‘’
     ‘1’
   r = abc‘’
     ‘1’def
   r = abc‘1’
     ‘’def
   r = abc‘’
     ‘’def
   r = abc‘some big ...’""
     ‘... string’
   r = abc"some big \n ..."‘’
     "... string\n"
   r = abc‘’
     '‘‘it’s’
   r = abc'‘‘it’s’
     ‘’def
   // This is a preferred way for including \r in string literals:
   r = ‘Host: api.dropboxapi.com’"\r\n"‘’
       ‘Connection: close’"\r\n"
   // ‘‘
===
auto f()
{
    r = abc + u"1"_S;
    r = abc + u"1"_S + def;
    r = abc + u"1"_S + def;
    r = abc + def;
    r = abc + u"some big ..."_S + u"... string"_S;
    r = abc + u"some big \n ..."_S + u"... string\n"_S;
    r = abc + u"it’s"_S;
    r = abc + u"it’s"_S + def;
    r = u"Host: api.dropboxapi.com"_S + u"\r\n"_S + u"Connection: close"_S + u"\r\n"_S;
}


F f()
   A arr = [1, 2, 3]
   print(arr[0..1])  // [1, 2]
   print(arr[0.<1])  // [1]
   print(arr[0<.1])  // [2]
   print(arr[0<.<2]) // [2]
   print(arr[1..])   // [2, 3]
   arr[1] = 4
   print(arr[1..])   // [4, 3]
   arr [+]= [5, 6]
   assert(arr[(0..4).step(2)] == [1, 3, 6])
   assert(arr[(1..).step(2)] == [4, 5])
   Dict[String, Int] dict
   [String = Int] dict2
   dict[‘key’] = 1
   [Int] arr2
   arr2 [+]= 10
===
auto f()
{
    auto arr = create_array({1, 2, 3});
    print(arr[range_ee(0, 1)]);
    print(arr[range_el(0, 1)]);
    print(arr[range_le(0, 1)]);
    print(arr[range_ll(0, 2)]);
    print(arr[range_ei(1)]);
    arr.set(1, 4);
    print(arr[range_ei(1)]);
    arr.append(create_array({5, 6}));
    assert(arr[range_ee(0, 4).step(2)] == create_array({1, 3, 6}));
    assert(arr[range_ei(1).step(2)] == create_array({4, 5}));
    Dict<String, int> dict;
    Dict<String, int> dict2;
    dict.set(u"key"_S, 1);
    Array<int> arr2;
    arr2.append(10);
}


F f()
   A s = ‘154’
   A a = [1, 5, 4]
   s[2] = ‘3’
   a[2] = 3
   assert(s[(len)-2] == ‘5’)
   assert(a[(len)-2] == 5)
   s[(len)-2] = ‘2’
   a[(len)-2] = 2
   assert(s[0.<(len)-1] == ‘12’)
   assert(a[0.<(len)-1] == [1, 2])
   assert(s[(len)-2..] == ‘23’)
   assert(a[(len)-2..] == [2, 3])
   assert(s[(len)-3..(len)-1] == ‘123’)
   assert(a[(len)-3..(len)-1] == [1, 2, 3])
   assert(s[(len)-3.<(len)-1] == ‘12’)
   assert(a[(len)-3.<(len)-1] == [1, 2])
===
auto f()
{
    auto s = u"154"_S;
    auto a = create_array({1, 5, 4});
    s.set(2, u'3'_C);
    a.set(2, 3);
    assert(s.at_plus_len( - 2) == u'5');
    assert(a.at_plus_len( - 2) == 5);
    s.set_plus_len( - 2, u'2'_C);
    a.set_plus_len( - 2, 2);
    assert(s[range_e_llen(0,  - 1)] == u"12");
    assert(a[range_e_llen(0,  - 1)] == create_array({1, 2}));
    assert(s[range_elen_i( - 2)] == u"23");
    assert(a[range_elen_i( - 2)] == create_array({2, 3}));
    assert(s[range_elen_elen( - 3,  - 1)] == u"123");
    assert(a[range_elen_elen( - 3,  - 1)] == create_array({1, 2, 3}));
    assert(s[range_elen_llen( - 3,  - 1)] == u"12");
    assert(a[range_elen_llen( - 3,  - 1)] == create_array({1, 2}));
}


F newlines()
   R ‘’
F f()
   A indent = 0
   A r = newlines()‘’(‘ ’ * (indent * 3))‘F ’(I .function_name != ‘__init__’ {.function_name} E ‘’)‘(’(I .function_arguments.empty | .function_arguments[0] != ‘self’ {.function_arguments} E .function_arguments[1..]).join(‘, ’)")\n"
   r = newlines()‘’(‘ ’ * (indent * 3))‘F ’(I .function_name != ‘__init__’ {.function_name} E ‘’)‘(’
     ‘’(I .function_arguments.empty | .function_arguments[0] != ‘self’ {.function_arguments} E .function_arguments[1..]).join(‘, ’)")\n"
   r = newlines()‘’(‘ ’ * (indent * 3))‘F ’(I .function_name != ‘__init__’ {.function_name} E ‘’)‘’
     ‘(’(I .function_arguments.empty | .function_arguments[0] != ‘self’ {.function_arguments} E .function_arguments[1..]).join(‘, ’)")\n"
   r = newlines()‘’(‘ ’ * (indent * 3))‘F ’(I .function_name != ‘__init__’ {.function_name} E ‘’)‘’ // ((
     ‘’(I .function_arguments.empty | .function_arguments[0] != ‘self’ {.function_arguments} E .function_arguments[1..]).join(‘, ’)")\n"
   r = newlines()‘’(‘ ’ * (indent * 3))‘F ’(I .function_name != ‘__init__’ {.function_name} E ‘’)‘(some big ...’""
     ‘... string’(I .function_arguments.empty | .function_arguments[0] != ‘self’ {.function_arguments} E .function_arguments[1..]).join(‘, ’)")\n"
===
auto newlines()
{
    return u""_S;
}
auto f()
{
    auto indent = 0;
    auto r = newlines() + (u" "_S * (indent * 3)) + u"F "_S + (function_name != u"__init__" ? function_name : u""_S) + u"("_S + (function_arguments.empty() || _get<0>(function_arguments) != u"self" ? function_arguments : function_arguments[range_ei(1)]).join(u", "_S) + u")\n"_S;
    r = newlines() + (u" "_S * (indent * 3)) + u"F "_S + (function_name != u"__init__" ? function_name : u""_S) + u"("_S + (function_arguments.empty() || _get<0>(function_arguments) != u"self" ? function_arguments : function_arguments[range_ei(1)]).join(u", "_S) + u")\n"_S;
    r = newlines() + (u" "_S * (indent * 3)) + u"F "_S + (function_name != u"__init__" ? function_name : u""_S) + u"("_S + (function_arguments.empty() || _get<0>(function_arguments) != u"self" ? function_arguments : function_arguments[range_ei(1)]).join(u", "_S) + u")\n"_S;
    r = newlines() + (u" "_S * (indent * 3)) + u"F "_S + (function_name != u"__init__" ? function_name : u""_S) + (function_arguments.empty() || _get<0>(function_arguments) != u"self" ? function_arguments : function_arguments[range_ei(1)]).join(u", "_S) + u")\n"_S;
    r = newlines() + (u" "_S * (indent * 3)) + u"F "_S + (function_name != u"__init__" ? function_name : u""_S) + u"(some big ..."_S + u"... string"_S + (function_arguments.empty() || _get<0>(function_arguments) != u"self" ? function_arguments : function_arguments[range_ei(1)]).join(u", "_S) + u")\n"_S;
}


F tag(ch)
   R S ch {‘*’ {‘b’}; ‘_’ {‘u’}; ‘-’ {‘s’}; ‘~’ {‘i’}}
F tag2(ch)
   R S ch {‘*’ {‘b’}; ‘**’ {‘bb’}}
===
template <typename T1> auto tag(const T1 &ch)
{
    return [&](const auto &a){return a == u'*' ? u'b'_C : a == u'_' ? u'u'_C : a == u'-' ? u's'_C : a == u'~' ? u'i'_C : throw KeyError(a);}(ch);
}
template <typename T1> auto tag2(const T1 &ch)
{
    return [&](const auto &a){return a == u'*' ? u"b"_S : a == u"**" ? u"bb"_S : throw KeyError(a);}(ch);
}


F f()
   R .children[0].to_str()‘ ’(S .symbol.id {‘and’ {‘&’}; ‘or’ {‘|’}; ‘in’ {‘C’} E {‘symbol-’(.symbol.id)}})‘ ’(.children[1].to_str())
   R .children[0].to_str()‘ ’(S .symbol.id {‘and’ {‘&’}; ‘or’ {‘|’}; ‘in’ {‘C’} E  ‘symbol-’(.symbol.id) })‘ ’(.children[1].to_str())
===
auto f()
{
    return _get<0>(children).to_str() + u" "_S + ([&](const auto &a){return a == u"and" ? u"&"_S : a == u"or" ? u"|"_S : a == u"in" ? u"C"_S : u"symbol-"_S + (symbol.id);}(symbol.id)) + u" "_S + (_get<1>(children).to_str());
    return _get<0>(children).to_str() + u" "_S + ([&](const auto &a){return a == u"and" ? u"&"_S : a == u"or" ? u"|"_S : a == u"in" ? u"C"_S : u"symbol-"_S + (symbol.id);}(symbol.id)) + u" "_S + (_get<1>(children).to_str());
}


---
A source = ‘code’
A s = copy(source).rtrim()
line_start = source.rfind("\n", source.len - 1)


F f()
   A i = 0
   A source = ‘abc_123 ’
   L i < source.len & source[i] C (‘0’..‘9’, ‘a’..‘z’, ‘A’..‘Z’, ‘_’)
      i++
   assert(i == 7)
===
auto f()
{
    auto i = 0;
    auto source = u"abc_123 "_S;
    while (i < source.len() && in(source[i], make_tuple(range_ee(u'0'_C, u'9'_C), range_ee(u'a'_C, u'z'_C), range_ee(u'A'_C, u'Z'_C), u"_"_S)))
        i++;
    assert(i == 7);
}


F to_html()
   A i = 0
   A writepos = 1
   F write_to_pos(npos)
      @writepos = @i + npos
   write_to_pos(2)
   R writepos
===
auto to_html()
{
    auto i = 0;
    auto writepos = 1;
    auto write_to_pos = [&i, &writepos](const auto &npos)
    {
        writepos = i + npos;
    };
    write_to_pos(2);
    return writepos;
}


F f(active_window, s)
   A width = active_window.rect. {.right - .left}
   active_window.pos.
      .x = 10
      .y = 20
   assert(‘string’. {.find(‘.’) ? .len} == 6)
   assert(‘str.ng’. {.find(‘.’) ? .len} == 3)
   R s.find(‘.’) ? s.len
===
template <typename T1, typename T2> auto f(const T1 &active_window, const T2 &s)
{
    auto width = [&](auto &&T){return T.right - T.left;}(active_window.rect);
    [&](auto &&T) {
        T.x = 10;
        T.y = 20;
    }(active_window.pos);
    assert([&](auto &&T){auto X = T.find(u"."_S); return X != nullptr ? *X : T.len();}(u"string"_S) == 6);
    assert([&](auto &&T){auto X = T.find(u"."_S); return X != nullptr ? *X : T.len();}(u"str.ng"_S) == 3);
    return [&]{auto R = s.find(u"."_S); return R != nullptr ? *R : s.len();}();
}


F f()
   L(n) [1, 2, 3, 4]
      I n == 30
         L.break
      print(n)
   
      L.was_no_break
         print(‘no break’)
===
auto f()
{
    {bool was_break = false;
    for (auto n : create_array({1, 2, 3, 4})) {
        if (n == 30) {
            was_break = true;
            break;
        }
        print(n);
    }
    if (!was_break)
        print(u"no break"_S);
    }
}


F f()
   L(i) 4 {L(j) 4 {I i + j == 5 {L(i).break}; print(i + j)}}
   print(0)
===
auto f()
{
    for (int i = 0; i < 4; i++)
        for (int j = 0; j < 4; j++) {
            if (i + j == 5)
                goto break_;
            print(i + j);
        }
    break_:
    print(0);
}


F f()
   L(v) [10, 20, 30]
      print(L.index‘: ’v)
===
auto f()
{
    {int Lindex = 0;
    for (auto v : create_array({10, 20, 30})) {
        print(Lindex + u": "_S + v);
        Lindex++;
    }}
}


F f()
   L(v) [10, 20, 30]
      print(L.index‘: ’v, end' ‘’)
      I L.next
         print(‘, ’, end' ‘’)
===
auto f()
{
    {int Lindex = 0;
    {auto &&__range = create_array({10, 20, 30});
    for (auto __begin = __range.begin(), __end = __range.end(); __begin != __end;) {
        auto &&v = *__begin; ++__begin;
        print(Lindex + u": "_S + v, u""_S);
        if (__begin != __end)
            print(u", "_S, u""_S);
        Lindex++;
    }}}
}


F f()
   L(ch) [‘a’, ‘b’, ‘c’]
      print(ch, end' ‘’)
      I L.next
         print(‘, ’, end' ‘’)
===
auto f()
{
    {auto &&__range = create_array({u'a'_C, u'b'_C, u'c'_C});
    for (auto __begin = __range.begin(), __end = __range.end(); __begin != __end;) {
        auto &&ch = *__begin; ++__begin;
        print(ch, u""_S);
        if (__begin != __end)
            print(u", "_S, u""_S);
    }}
}


[String] dirs, files
===
Array<String> dirs, files;


T TypeName
   F.destructor
      print(‘TypeName object destructed’)
===
class TypeName
{
public:
    ~TypeName()
    {
        print(u"TypeName object destructed"_S);
    }
};