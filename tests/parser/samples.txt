---
\‘res = '['
for i in range(len(self.children)):
    res += self.children[i].to_str()
    if i < len(self.children)-1:
        res += ', '
return res + ']'’
A res = ‘[’
L(c) .children
   res ‘’= c.to_str()
   I L.next != N
      res ‘’= ‘, ’
R res‘]’


String token
F f()
   R S :token {‘None’ {‘N’}; ‘False’ {‘0B’}; ‘True’ {‘1B’}}
===
String token;
auto f()
{
    return [](const auto &a){return a == u"None"_S ? u"N"_S : a == u"False"_S ? u"0B"_S : a == u"True"_S ? u"1B"_S : throw KeyError(a);}(::token);
}


F func(arg = 1)
   R arg + 1
===
template <typename T1> auto func(const T1 &arg = 1)
{
    return arg + 1;
}


F sign(x)
   I x < 0
      R -1
   E I x > 0
      R 1
   E
      R 0
===
template <typename T1> auto sign(const T1 &x)
{
    if (x < 0)
        return -1;
    else if (x > 0)
        return 1;
    else
        return 0;
}


F f()
   I 1B
   {
   }
===
auto f()
{
    if (true) {
    }
}


// Inspired by sample from ‘Nemerle Wiki’[https://github.com/rsdn/nemerle/wiki/The-basics-(tutorial)#Rewriting_Line_Counter_without_the_loop]
if foo
   if bar
       m1()
else
    m2()
===
if (foo) {
    if (bar)
        m1();
}
else
    m2();



if foo
   if bar
       m1()
   else if z
       if e
          m3()
   else
       m4()
else
    m2()
===
if (foo) {
    if (bar)
        m1();
    else if (z) {
        if (e)
            m3();
    }
    else
        m4();
}
else
    m2();


T Shape
   Tuple[Int, Int] position

T Circle(Shape, Object)
   Int radious
===
class Shape
{
public:
    Tuple<int, int> position;
};

class Circle : public Shape, public Object
{
public:
    int radious;
};


T Person
   String name
   Int age

   F ()
      .age = 1

   F (name, age)
      .name = name
      .age = age

   F ()(name)
      .name = name
      R 1
===
class Person
{
public:
    String name;
    int age;

    Person()
    {
        age = 1;
    }

    template <typename T1, typename T2> Person(const T1 &name, const T2 &age)
    {
        this->name = name;
        this->age = age;
    }

    template <typename T1> auto operator()(const T1 &name)
    {
        this->name = name;
        return 1;
    }
};


A l1 = () -> N
A l2 = x -> x[0]
A l3 = self -> self
A l4 = (x, y, reverse = 0B) -> I reverse {y < x} E x < y
A r = I reverse {y < x} E I eq {x == y} E x < y
===
auto l1 = [](){return nullptr;};
auto l2 = [](const auto &x){return x[0];};
auto l3 = [](const auto &self){return self;};
auto l4 = [](const auto &x, const auto &y, const auto &reverse = false){return reverse ? y < x : x < y;};
auto r = reverse ? y < x : eq ? x == y : x < y;


String ch
I ch C ‘0’..‘9’
{
}
===
String ch;
if (in(ch, range_ee(u'0'_C, u'9'_C))) {
}


A id = 0
f(‘id=’id)
A s = ‘str’"\n"
A s2 = a‘’b
F to_str(indent)
   A t = ‘str’(.expression.to_str())
   R (‘ ’ * (indent * 3))‘’(.expression.to_str())"\n"
String tag = ‘<a href="’link‘"’
tag ‘’= s
===
auto id = 0;
f(u"id="_S + id);
auto s = u"str"_S + u"\n"_S;
auto s2 = a + b;
template <typename T1> auto to_str(const T1 &indent)
{
    auto t = u"str"_S + (expression.to_str());
    return (u" "_S * (indent * 3)) + (expression.to_str()) + u"\n"_S;
}
String tag = u"<a href=\""_S + link + u"\""_S;
tag += s;


r = abc‘’
  ‘1’
r = abc‘1’
  ‘’def
r = abc‘’
  ‘’def
r = abc‘some big ...’""
  ‘... string’
===
r = abc + u"1"_S;
r = abc + u"1"_S + def;
r = abc + def;
r = abc + u"some big ..."_S + u"... string"_S;


A indent = 0
A r = .newlines()‘’(‘ ’ * (indent * 3))‘F ’(I .function_name != ‘__init__’ {.function_name} E ‘’)‘(’(I .function_arguments.empty | .function_arguments[0] != ‘self’ {.function_arguments} E .function_arguments[1..]).join(‘, ’)")\n"
r = .newlines()‘’(‘ ’ * (indent * 3))‘F ’(I .function_name != ‘__init__’ {.function_name} E ‘’)‘(’
  ‘’(I .function_arguments.empty | .function_arguments[0] != ‘self’ {.function_arguments} E .function_arguments[1..]).join(‘, ’)")\n"
r = .newlines()‘’(‘ ’ * (indent * 3))‘F ’(I .function_name != ‘__init__’ {.function_name} E ‘’)‘’
  ‘(’(I .function_arguments.empty | .function_arguments[0] != ‘self’ {.function_arguments} E .function_arguments[1..]).join(‘, ’)")\n"
r = .newlines()‘’(‘ ’ * (indent * 3))‘F ’(I .function_name != ‘__init__’ {.function_name} E ‘’)‘’ // ((
  ‘’(I .function_arguments.empty | .function_arguments[0] != ‘self’ {.function_arguments} E .function_arguments[1..]).join(‘, ’)")\n"
r = .newlines()‘’(‘ ’ * (indent * 3))‘F ’(I .function_name != ‘__init__’ {.function_name} E ‘’)‘(some big ...’""
  ‘... string’(I .function_arguments.empty | .function_arguments[0] != ‘self’ {.function_arguments} E .function_arguments[1..]).join(‘, ’)")\n"
===
auto indent = 0;
auto r = newlines() + (u" "_S * (indent * 3)) + u"F "_S + (function_name != u"__init__"_S ? function_name : u""_S) + u"("_S + (function_arguments.empty || function_arguments[0] != u"self"_S ? function_arguments : function_arguments[1..]).join(u", "_S) + u")\n"_S;
r = newlines() + (u" "_S * (indent * 3)) + u"F "_S + (function_name != u"__init__"_S ? function_name : u""_S) + u"("_S + (function_arguments.empty || function_arguments[0] != u"self"_S ? function_arguments : function_arguments[1..]).join(u", "_S) + u")\n"_S;
r = newlines() + (u" "_S * (indent * 3)) + u"F "_S + (function_name != u"__init__"_S ? function_name : u""_S) + u"("_S + (function_arguments.empty || function_arguments[0] != u"self"_S ? function_arguments : function_arguments[1..]).join(u", "_S) + u")\n"_S;
r = newlines() + (u" "_S * (indent * 3)) + u"F "_S + (function_name != u"__init__"_S ? function_name : u""_S) + (function_arguments.empty || function_arguments[0] != u"self"_S ? function_arguments : function_arguments[1..]).join(u", "_S) + u")\n"_S;
r = newlines() + (u" "_S * (indent * 3)) + u"F "_S + (function_name != u"__init__"_S ? function_name : u""_S) + u"(some big ..."_S + u"... string"_S + (function_arguments.empty || function_arguments[0] != u"self"_S ? function_arguments : function_arguments[1..]).join(u", "_S) + u")\n"_S;


F tag(ch)
   R S ch {‘*’ {‘b’}; ‘_’ {‘u’}; ‘-’ {‘s’}; ‘~’ {‘i’}}
===
template <typename T1> auto tag(const T1 &ch)
{
    return [](const auto &a){return a == u'*'_C ? u'b'_C : a == u'_'_C ? u'u'_C : a == u'-'_C ? u's'_C : a == u'~'_C ? u'i'_C : throw KeyError(a);}(ch);
}


R .children[0].to_str()‘ ’(S .symbol.id {‘and’ {‘&’}; ‘or’ {‘|’}; ‘in’ {‘C’} E {‘symbol-’(.symbol.id)}})‘ ’(.children[1].to_str())
R .children[0].to_str()‘ ’(S .symbol.id {‘and’ {‘&’}; ‘or’ {‘|’}; ‘in’ {‘C’} E ‘symbol-’(.symbol.id)})‘ ’(.children[1].to_str())
===
return children[0].to_str() + u" "_S + ([](const auto &a){return a == u"and"_S ? u"&"_S : a == u"or"_S ? u"|"_S : a == u"in"_S ? u"C"_S : u"symbol-"_S + (symbol.id);}(symbol.id)) + u" "_S + (children[1].to_str());
return children[0].to_str() + u" "_S + ([](const auto &a){return a == u"and"_S ? u"&"_S : a == u"or"_S ? u"|"_S : a == u"in"_S ? u"C"_S : u"symbol-"_S + (symbol.id);}(symbol.id)) + u" "_S + (children[1].to_str());