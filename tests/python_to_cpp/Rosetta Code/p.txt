# https://www.rosettacode.org/wiki/Pangram_checker
def is_pangram(sentence):
    return len(set(ch for ch in sentence.lower() if 'a' <= ch <= 'z')) == 26

for sentence in ['The quick brown fox jumps over the lazy dog.',
                 'The quick brown fox jumped over the lazy dog.']:
    print("'%s' is %sa pangram" % (sentence, 'not ' * (not is_pangram(sentence))))
===
F is_pangram(sentence)
   R Set(sentence.lowercase().filter(ch -> ch C ‘a’..‘z’)).len == 26

L(sentence) [‘The quick brown fox jumps over the lazy dog.’, ‘The quick brown fox jumped over the lazy dog.’]
   print(‘'#.' is #.a pangram’.format(sentence, ‘not ’ * (!is_pangram(sentence))))
===
template <typename T1> auto is_pangram(const T1 &sentence)
{
    return create_set(sentence.lowercase().filter([](const auto &ch){return in(ch, range_ee(u'a'_C, u'z'_C));})).len() == 26;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&sentence : create_array({u"The quick brown fox jumps over the lazy dog."_S, u"The quick brown fox jumped over the lazy dog."_S}))
            print(u"'#.' is #.a pangram"_S.format(sentence, u"not "_S * (!is_pangram(sentence))));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Parsing/Shunting-yard_algorithm#Java
import re

def infix_to_postfix(infix):
    ops = '-+/*^'
    sb = ''
    s : List[int] = []

    for token in re.split(r'\s', infix):
        if len(token) == 0:
            continue

        c = token[0]
        idx = ops.find(c)
        if idx != -1:
            if len(s) == 0:
                s.append(idx)
            else:
                while len(s) != 0:
                    prec2 = s[-1] // 2
                    prec1 = idx // 2
                    if prec2 > prec1 or (prec2 == prec1 and c != '^'):
                        sb += ops[s.pop()] + ' '
                    else:
                        break
                s.append(idx)

        elif c == '(': # )
            s.append(-2) # -2 stands for '('

        elif c == ')':
            while s[-1] != -2:
                sb += ops[s.pop()] + ' '
            s.pop()

        else:
            sb += token + ' '

    while len(s) != 0:
        sb += ops[s.pop()] + ' '

    return sb

infix = '3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3'
print('infix:   ' + infix)
print('postfix: ' + infix_to_postfix(infix))
===
F infix_to_postfix(infix)
   V ops = ‘-+/*^’
   V sb = ‘’
   [Int] s

   L(token) infix.split(re:‘\s’)
      I token.empty
         L.continue

      V c = token[0]
      V idx = ops.findi(c)
      I idx != -1
         I s.empty
            s.append(idx)
         E
            L !s.empty
               V prec2 = s.last I/ 2
               V prec1 = idx I/ 2
               I prec2 > prec1 | (prec2 == prec1 & c != ‘^’)
                  sb ‘’= ops[s.pop()]‘ ’
               E
                  L.break
            s.append(idx)

      E I c == ‘(’
         s.append(-2)

      E I c == ‘)’
         L s.last != -2
            sb ‘’= ops[s.pop()]‘ ’
         s.pop()

      E
         sb ‘’= token‘ ’

   L !s.empty
      sb ‘’= ops[s.pop()]‘ ’

   R sb

V infix = ‘3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3’
print(‘infix:   ’infix)
print(‘postfix: ’infix_to_postfix(infix))
===
template <typename T1> auto infix_to_postfix(const T1 &infix)
{
    auto ops = u"-+/*^"_S;
    auto sb = u""_S;
    Array<int> s;

    for (auto &&token : infix.split(re::_(uR"(\s)"_S))) {
        if (token.empty())
            continue;

        auto c = _get<0>(token);
        auto idx = ops.findi(c);
        if (idx != -1) {
            if (s.empty())
                s.append(idx);
            else {
                while (!s.empty()) {
                    auto prec2 = idiv(s.last(), 2);
                    auto prec1 = idiv(idx, 2);
                    if (prec2 > prec1 || (prec2 == prec1 && c != u'^'))
                        sb &= ops[s.pop()] & u" "_S;
                    else
                        break;
                }
                s.append(idx);
            }
        }

        else if (c == u'(')
            s.append(-2);

        else if (c == u')') {
            while (s.last() != -2)
                sb &= ops[s.pop()] & u" "_S;
            s.pop();
        }

        else
            sb &= token & u" "_S;
    }

    while (!s.empty())
        sb &= ops[s.pop()] & u" "_S;

    return sb;
}

auto infix = u"3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3"_S;

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"infix:   "_S & infix);
        print(u"postfix: "_S & infix_to_postfix(infix));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Parsing/RPN_to_infix_conversion#Java
import re

ops = '-+/*^'

def postfix_to_infix(postfix):
    class Expression:
        op : str
        ex : str
        prec = 3

        def __init__(self, e1 : str, e2 : str = '', o : str = ''):
            if o == '':
                self.ex = e1
            else:
                self.ex = e1 + ' ' + o + ' ' + e2
                self.op = o
                self.prec = ops.index(o) // 2

        def __str__(self):
            return self.ex

        def __repr__(self):
            return self.ex

    expr : List[Expression] = []

    for token in re.split(r'\s+', postfix):
        c = token[0]
        idx = ops.find(c)
        if idx != -1:# and len(token) == 1:
            r = expr.pop()
            l = expr.pop()
            opPrec = idx // 2

            if l.prec < opPrec or (l.prec == opPrec and c == '^'):
                l.ex = '(' + l.ex + ')'

            if r.prec < opPrec or (r.prec == opPrec and c != '^'):
                r.ex = '(' + r.ex + ')'

            expr.append(Expression(l.ex, r.ex, token))

        else:
            expr.append(Expression(token))

        print(token + ' -> ' + str(expr))

    assert(len(expr) == 1)
    return expr[0].ex

for e in ['3 4 2 * 1 5 - 2 3 ^ ^ / +',
          '1 2 + 3 4 + ^ 5 6 + ^']:
    print('Postfix : ' + e)
    print('Infix : ' + postfix_to_infix(e))
    print()
===
V ops = ‘-+/*^’

F postfix_to_infix(postfix)
   T Expression
      String op
      String ex
      prec = 3

      F (String e1, String e2 = ‘’, String o = ‘’)
         I o == ‘’
            .ex = e1
         E
            .ex = e1‘ ’o‘ ’e2
            .op = o
            .prec = :ops.index(o) I/ 2

      F String()
         R .ex

      F __repr__()
         R .ex

   [Expression] expr

   L(token) postfix.split(re:‘\s+’)
      V c = token[0]
      V idx = :ops.findi(c)
      I idx != -1
         V r = expr.pop()
         V l = expr.pop()
         V opPrec = idx I/ 2

         I l.prec < opPrec | (l.prec == opPrec & c == ‘^’)
            l.ex = ‘(’l.ex‘)’

         I r.prec < opPrec | (r.prec == opPrec & c != ‘^’)
            r.ex = ‘(’r.ex‘)’

         expr.append(Expression(l.ex, r.ex, token))

      E
         expr.append(Expression(token))

      print(token‘ -> ’String(expr))

   assert(expr.len == 1)
   R expr[0].ex

L(e) [‘3 4 2 * 1 5 - 2 3 ^ ^ / +’, ‘1 2 + 3 4 + ^ 5 6 + ^’]
   print(‘Postfix : ’e)
   print(‘Infix : ’postfix_to_infix(e))
   print()
===
auto ops = u"-+/*^"_S;

template <typename T1> auto postfix_to_infix(const T1 &postfix)
{
    class Expression
    {
    public:
        String op;
        String ex;
        decltype(3) prec = 3;

        Expression(const String &e1, const String &e2 = u""_S, const String &o = u""_S)
        {
            if (o == u"")
                ex = e1;
            else {
                ex = e1 & u" "_S & o & u" "_S & e2;
                op = o;
                prec = idiv(::ops.index(o), 2);
            }
        }

        operator String() const
        {
            return ex;
        }

        auto __repr__()
        {
            return ex;
        }
    };

    Array<Expression> expr;

    for (auto &&token : postfix.split(re::_(uR"(\s+)"_S))) {
        auto c = _get<0>(token);
        auto idx = ::ops.findi(c);
        if (idx != -1) {
            auto r = expr.pop();
            auto l = expr.pop();
            auto opPrec = idiv(idx, 2);

            if (l.prec < opPrec || (l.prec == opPrec && c == u'^'))
                l.ex = u"("_S & l.ex & u")"_S;

            if (r.prec < opPrec || (r.prec == opPrec && c != u'^'))
                r.ex = u"("_S & r.ex & u")"_S;

            expr.append(Expression(l.ex, r.ex, token));
        }

        else
            expr.append(Expression(token));

        print(token & u" -> "_S & String(expr));
    }

    assert(expr.len() == 1);
    return _get<0>(expr).ex;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&e : create_array({u"3 4 2 * 1 5 - 2 3 ^ ^ / +"_S, u"1 2 + 3 4 + ^ 5 6 + ^"_S})) {
            print(u"Postfix : "_S & e);
            print(u"Infix : "_S & postfix_to_infix(e));
            print();
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Pascal_matrix_generation#Python
def pascal_upp(n):
    s = [[0] * n for _ in range(n)]
    s[0] = [1] * n
    for i in range(1, n):
        for j in range(i, n):
            s[i][j] = s[i-1][j-1] + s[i][j-1]
    return s

def pascal_low(n):
    # transpose of pascal_upp(n)
    upp = pascal_upp(n)
    s = [[0] * n for _ in range(n)]
    for x in range(n):
        for y in range(n):
            s[y][x] = upp[x][y]
    return s

def pascal_sym(n):
    s = [[1] * n for _ in range(n)]
    for i in range(1, n):
        for j in range(1, n):
            s[i][j] = s[i-1][j] + s[i][j-1]
    return s

def pp(mat):
    print('[' + ",\n ".join(map(str, mat)) + ']')

n = 5
print("Upper:")
pp(pascal_upp(n))
print("\nLower:")
pp(pascal_low(n))
print("\nSymmetric:")
pp(pascal_sym(n))
===
F pascal_upp(n)
   V s = [[0] * n] * n
   s[0] = [1] * n
   L(i) 1 .< n
      L(j) i .< n
         s[i][j] = s[i - 1][j - 1] + s[i][j - 1]
   R s

F pascal_low(n)
   V upp = pascal_upp(n)
   V s = [[0] * n] * n
   L(x) 0 .< n
      L(y) 0 .< n
         s[y][x] = upp[x][y]
   R s

F pascal_sym(n)
   V s = [[1] * n] * n
   L(i) 1 .< n
      L(j) 1 .< n
         s[i][j] = s[i - 1][j] + s[i][j - 1]
   R s

F pp(mat)
   print(‘[’mat.map(String).join(",\n ")‘]’)

V n = 5
print(‘Upper:’)
pp(pascal_upp(n))
print("\nLower:")
pp(pascal_low(n))
print("\nSymmetric:")
pp(pascal_sym(n))
===
template <typename T1> auto pascal_upp(const T1 &n)
{
    auto s = create_array({create_array({0}) * n}) * n;
    _set<0>(s, create_array({1}) * n);
    for (auto i : range_el(1, n))
        for (auto j : range_el(i, n))
            s[i].set(j, s[i - 1][j - 1] + s[i][j - 1]);
    return s;
}

template <typename T1> auto pascal_low(const T1 &n)
{
    auto upp = pascal_upp(n);
    auto s = create_array({create_array({0}) * n}) * n;
    for (auto x : range_el(0, n))
        for (auto y : range_el(0, n))
            s[y].set(x, upp[x][y]);
    return s;
}

template <typename T1> auto pascal_sym(const T1 &n)
{
    auto s = create_array({create_array({1}) * n}) * n;
    for (auto i : range_el(1, n))
        for (auto j : range_el(1, n))
            s[i].set(j, s[i - 1][j] + s[i][j - 1]);
    return s;
}

template <typename T1> auto pp(const T1 &mat)
{
    print(u"["_S & mat.map([](const auto &x){return String(x);}).join(u",\n "_S) & u"]"_S);
}

auto n = 5;

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"Upper:"_S);
        pp(pascal_upp(n));
        print(u"\nLower:"_S);
        pp(pascal_low(n));
        print(u"\nSymmetric:"_S);
        pp(pascal_sym(n));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Perfect_numbers#Python
def perf(n):
    sum = 0
    for i in range(1, n):
        if n % i == 0:
            sum += i
    return sum == n

for i in range(1, 10001):
    if perf(i):
        print(i, end = ' ')
===
F perf(n)
   V sum = 0
   L(i) 1 .< n
      I n % i == 0
         sum += i
   R sum == n

L(i) 1..10000
   I perf(i)
      print(i, end' ‘ ’)
===
template <typename T1> auto perf(const T1 &n)
{
    auto sum = 0;
    for (auto i : range_el(1, n))
        if (mod(n, i) == 0)
            sum += i;
    return sum == n;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto i : range_ee(1, 10000))
            if (perf(i))
                print(i, u" "_S);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Perfect_shuffle#Python
def flatten(lst):
    r : List[int] = []
    for sublst in lst:
        for i in sublst:
            r += [i]
    return r

def magic_shuffle(deck):
    half = len(deck) // 2
    return flatten(zip(deck[:half], deck[half:]))

def after_how_many_is_equal(start, end):
    deck = magic_shuffle(start)
    counter = 1
    while deck != end:
        deck = magic_shuffle(deck)
        counter += 1
    return counter

print("Length of the deck of cards | Perfect shuffles needed to obtain the same deck back")
for length in (8, 24, 52, 100, 1020, 1024, 10000):
    deck = list(range(length))
    shuffles_needed = after_how_many_is_equal(deck,deck)
    print("%-5d | %d" % (length,shuffles_needed))
===
F flatten(lst)
   [Int] r
   L(sublst) lst
      L(i) sublst
         r [+]= i
   R r

F magic_shuffle(deck)
   V half = deck.len I/ 2
   R flatten(zip(deck[0 .< half], deck[half ..]))

F after_how_many_is_equal(start, end)
   V deck = magic_shuffle(start)
   V counter = 1
   L deck != end
      deck = magic_shuffle(deck)
      counter++
   R counter

print(‘Length of the deck of cards | Perfect shuffles needed to obtain the same deck back’)
L(length) (8, 24, 52, 100, 1020, 1024, 10000)
   V deck = Array(0 .< length)
   V shuffles_needed = after_how_many_is_equal(deck, deck)
   print(‘#<5 | #.’.format(length, shuffles_needed))
===
template <typename T1> auto flatten(const T1 &lst)
{
    Array<int> r;
    for (auto &&sublst : lst)
        for (auto &&i : sublst)
            r.append(i);
    return r;
}

template <typename T1> auto magic_shuffle(const T1 &deck)
{
    auto half = idiv(deck.len(), 2);
    return flatten(zip(deck[range_el(0, half)], deck[range_ei(half)]));
}

template <typename T1, typename T2> auto after_how_many_is_equal(const T1 &start, const T2 &end)
{
    auto deck = magic_shuffle(start);
    auto counter = 1;
    while (deck != end) {
        deck = magic_shuffle(deck);
        counter++;
    }
    return counter;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"Length of the deck of cards | Perfect shuffles needed to obtain the same deck back"_S);
        for (auto &&length : make_tuple(8, 24, 52, 100, 1020, 1024, 10000)) {
            auto deck = create_array(range_el(0, length));
            auto shuffles_needed = after_how_many_is_equal(deck, deck);
            print(u"#<5 | #."_S.format(length, shuffles_needed));
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Perfect_totient_numbers#Python
import math, itertools

def φ(n):
    return sum(1 for k in range(1, n + 1) if math.gcd(n, k) == 1)

def perfect_totient(cnt):
    r : List[int] = []

    for n0 in itertools.count(1):
        parts = 0
        n = n0
        while n != 1:
            n = φ(n)
            parts += n
        if parts == n0:
            r += [n0]
            if len(r) == cnt:
                return r

print(perfect_totient(20))
===
F φ(n)
   R sum((1 .. n).filter(k -> gcd(@n, k) == 1).map(k -> 1))

F perfect_totient(cnt)
   [Int] r

   L(n0) 1..
      V parts = 0
      V n = n0
      L n != 1
         n = φ(n)
         parts += n
      I parts == n0
         r [+]= n0
         I r.len == cnt
            R r

print(perfect_totient(20))
===
template <typename T1> auto φ(const T1 &n)
{
    return sum_map(range_ee(1, n).filter([&n](const auto &k){return gcd(n, k) == 1;}), [](const auto &k){return 1;});
}

template <typename T1> auto perfect_totient(const T1 &cnt)
{
    Array<int> r;

    for (auto n0 : range_ei(1)) {
        auto parts = 0;
        auto n = n0;
        while (n != 1) {
            n = φ(n);
            parts += n;
        }
        if (parts == n0) {
            r.append(n0);
            if (r.len() == cnt)
                return r;
        }
    }
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(perfect_totient(20));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Permutation_test#Kotlin
data = [85, 88, 75, 66, 25, 29, 83, 39, 97,
    68, 41, 10, 49, 16, 65, 32, 92, 28, 98]

def pick(at, remain, accu, treat):
    if remain == 0:
        return 1 if accu > treat else 0
    return pick(at - 1, remain - 1, accu + data[at - 1], treat) + \
          (pick(at - 1, remain, accu, treat) if at > remain else 0)

treat = 0
total = 1.0
for i in range(0, 9):
    treat += data[i]
for i in range(19, 10, -1):
    total *= i
for i in range(9, 0, -1):
    total /= i

gt = pick(19, 9, 0, treat)
le = int(total - gt)

print('<= : %f%%  %d' % (100 * le / total, le))
print(' > : %f%%  %d' % (100 * gt / total, gt))
===
V data = [85, 88, 75, 66, 25, 29, 83, 39, 97, 68, 41, 10, 49, 16, 65, 32, 92, 28, 98]

F pick(at, remain, accu, treat)
   I remain == 0
      R I accu > treat {1} E 0
   R pick(at - 1, remain - 1, accu + :data[at - 1], treat) + (I at > remain {pick(at - 1, remain, accu, treat)} E 0)

V treat = 0
V total = 1.0
L(i) 0..8
   treat += data[i]
L(i) (19.<10).step(-1)
   total *= i
L(i) (9.<0).step(-1)
   total /= i

V gt = pick(19, 9, 0, treat)
V le = Int(total - gt)

print(‘<= : #.6%  #.’.format(100 * le / total, le))
print(‘ > : #.6%  #.’.format(100 * gt / total, gt))
===
auto data = create_array({85, 88, 75, 66, 25, 29, 83, 39, 97, 68, 41, 10, 49, 16, 65, 32, 92, 28, 98});

template <typename T1, typename T2, typename T3, typename T4> auto pick(const T1 &at, const T2 &remain, const T3 &accu, const T4 &treat)
{
    if (remain == 0)
        return accu > treat ? 1 : 0;
    return pick(at - 1, remain - 1, accu + ::data[at - 1], treat) + (at > remain ? pick(at - 1, remain, accu, treat) : 0);
}

auto treat = 0;
auto total = 1.0;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto i : range_ee(0, 8))
            treat += data[i];
        for (auto i : range_el(19, 10).step(-1))
            total *= i;
        for (auto i : range_el(9, 0).step(-1))
            total /= i;
    }
} code_block_1;

auto gt = pick(19, 9, 0, treat);
auto le = to_int(total - gt);

struct CodeBlock2
{
    CodeBlock2()
    {
        print(u"<= : #.6%  #."_S.format(100 * le / total, le));
        print(u" > : #.6%  #."_S.format(100 * gt / total, gt));
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Permutations_with_repetitions#Kotlin
import sys

n = 3
values = ['A', 'B', 'C', 'D']
k = len(values)
decide = lambda pc: pc[0] == 'B' and pc[1] == 'C'
pn = [0] * n
pc = ["\0"] * n
while True:
    for i, x in enumerate(pn):
        pc[i] = values[x]
    print(pc)

    if decide(pc):
        break

    i = 0
    while True:
        pn[i] += 1
        if pn[i] < k: break
        pn[i] = 0
        i += 1
        if i == n:
            sys.exit(0) # ^L.break
===
V n = 3
V values = [‘A’, ‘B’, ‘C’, ‘D’]
V k = values.len
V decide = pc -> pc[0] == ‘B’ & pc[1] == ‘C’
V pn = [0] * n
V pc = ["\0"] * n
L
   L(x) pn
      V i = L.index
      pc[i] = values[x]
   print(pc)

   I decide(pc)
      L.break

   V i = 0
   L
      pn[i]++
      I pn[i] < k
         L.break
      pn[i] = 0
      i++
      I i == n
         exit(0)
===
auto n = 3;
auto values = create_array({u'A'_C, u'B'_C, u'C'_C, u'D'_C});
auto k = values.len();
auto decide = [](const auto &pc){return _get<0>(pc) == u'B' && _get<1>(pc) == u'C';};
auto pn = create_array({0}) * n;
auto pc = create_array({u'\0'_C}) * n;

struct CodeBlock1
{
    CodeBlock1()
    {
        while (true) {
            {int Lindex = 0;
            for (auto &&x : pn) {
                auto i = Lindex;
                pc.set(i, values[x]);
                Lindex++;
            }}
            print(pc);

            if (decide(pc))
                break;

            auto i = 0;
            while (true) {
                pn[i]++;
                if (pn[i] < k)
                    break;
                pn.set(i, 0);
                i++;
                if (i == n)
                    exit(0);
            }
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Pernicious_numbers#Python
import math

def popcount(n):
    return bin(n).count('1')

def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(math.sqrt(n)) + 1):
        if n % i == 0:
            return False
    return True

i = 0
cnt = 0
while True:
    if is_prime(popcount(i)):
        print(i, end = ' ')
        cnt += 1
        if cnt == 25:
            break
    i += 1

print()
for i in range(888888877, 888888888 + 1):
    if is_prime(popcount(i)):
        print(i, end = ' ')
===
F popcount(n)
   R bin(n).count(‘1’)

F is_prime(n)
   I n < 2
      R 0B
   L(i) 2 .. Int(sqrt(n))
      I n % i == 0
         R 0B
   R 1B

V i = 0
V cnt = 0
L
   I is_prime(popcount(i))
      print(i, end' ‘ ’)
      cnt++
      I cnt == 25
         L.break
   i++

print()
L(i) 888888877 .. 888888888
   I is_prime(popcount(i))
      print(i, end' ‘ ’)
===
template <typename T1> auto popcount(const T1 &n)
{
    return bin(n).count(u"1"_S);
}

template <typename T1> auto is_prime(const T1 &n)
{
    if (n < 2)
        return false;
    for (auto i : range_ee(2, to_int(sqrt(n))))
        if (mod(n, i) == 0)
            return false;
    return true;
}

auto i = 0;
auto cnt = 0;

struct CodeBlock1
{
    CodeBlock1()
    {
        while (true) {
            if (is_prime(popcount(i))) {
                print(i, u" "_S);
                cnt++;
                if (cnt == 25)
                    break;
            }
            i++;
        }

        print();
        for (auto i : range_ee(888888877, 888888888))
            if (is_prime(popcount(i)))
                print(i, u" "_S);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Phrase_reversals#Python
phrase = 'rosetta code phrase reversal'
print(phrase[::-1])
print(' '.join(word[::-1] for word in phrase.split(' ')))
print(' '.join(phrase.split(' ')[::-1]))
===
V phrase = ‘rosetta code phrase reversal’
print(reversed(phrase))
print(phrase.split(‘ ’).map(word -> reversed(word)).join(‘ ’))
print((reversed(phrase.split(‘ ’))).join(‘ ’))
===
auto phrase = u"rosetta code phrase reversal"_S;

struct CodeBlock1
{
    CodeBlock1()
    {
        print(reversed(phrase));
        print(phrase.split(u" "_S).map([](const auto &word){return reversed(word);}).join(u" "_S));
        print((reversed(phrase.split(u" "_S))).join(u" "_S));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Polynomial_regression#Swift
def average(arr):
    return sum(arr) / float(len(arr))

def poly_regression(x, y):
    xm = average(x)
    ym = average(y)
    x2m = average(list(map(lambda i: i * i,  x)))
    x3m = average(list(map(lambda i: i ** 3, x)))
    x4m = average(list(map(lambda i: i ** 4, x)))
    xym = average(list(map(lambda ij: ij[0] * ij[1], zip(x,y))))
    x2ym = average(list(map(lambda ij: ij[0] * ij[0] * ij[1], zip(x,y))))

    sxx = x2m - xm * xm
    sxy = xym - xm * ym
    sxx2 = x3m - xm * x2m
    sx2x2 = x4m - x2m * x2m
    sx2y = x2ym - x2m * ym

    b = (sxy * sx2x2 - sx2y * sxx2) / (sxx * sx2x2 - sxx2 * sxx2)
    c = (sx2y * sxx - sxy * sxx2) / (sxx * sx2x2 - sxx2 * sxx2)
    a = ym - b * xm - c * x2m

    def abc(xx):
        return (a + b * xx) + (c * xx * xx)

    print("y = %g + %gx + %gx^2\n" % (a, b, c))
    print(' Input  Approximation')
    print(' x   y     y1')

    for i in range(len(x)):
        print('%2d %3d  %5.1f' % (x[i], y[i], abc(i)))

x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
y = [1, 6, 17, 34, 57, 86, 121, 162, 209, 262, 321]
poly_regression(x, y)
===
F average(arr)
   R sum(arr) / Float(arr.len)

F poly_regression(x, y)
   V xm = average(x)
   V ym = average(y)
   V x2m = average(x.map(i -> i * i))
   V x3m = average(x.map(i -> i ^ 3))
   V x4m = average(x.map(i -> i ^ 4))
   V xym = average(zip(x, y).map(ij -> ij[0] * ij[1]))
   V x2ym = average(zip(x, y).map(ij -> ij[0] * ij[0] * ij[1]))

   V sxx = x2m - xm * xm
   V sxy = xym - xm * ym
   V sxx2 = x3m - xm * x2m
   V sx2x2 = x4m - x2m * x2m
   V sx2y = x2ym - x2m * ym

   V b = (sxy * sx2x2 - sx2y * sxx2) / (sxx * sx2x2 - sxx2 * sxx2)
   V c = (sx2y * sxx - sxy * sxx2) / (sxx * sx2x2 - sxx2 * sxx2)
   V a = ym - b * xm - c * x2m

   F abc(xx)
      R (@a + @b * xx) + (@c * xx * xx)

   print("y = #. + #.x + #.x^2\n".format(a, b, c))
   print(‘ Input  Approximation’)
   print(‘ x   y     y1’)

   L(i) 0 .< x.len
      print(‘#2 #3  #3.1’.format(x[i], y[i], abc(i)))

V x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
V y = [1, 6, 17, 34, 57, 86, 121, 162, 209, 262, 321]
poly_regression(x, y)
===
template <typename T1> auto average(const T1 &arr)
{
    return sum(arr) / to_float(arr.len());
}

template <typename T1, typename T2> auto poly_regression(const T1 &x, const T2 &y)
{
    auto xm = average(x);
    auto ym = average(y);
    auto x2m = average(x.map([](const auto &i){return i * i;}));
    auto x3m = average(x.map([](const auto &i){return cube(i);}));
    auto x4m = average(x.map([](const auto &i){return pow(i, 4);}));
    auto xym = average(zip(x, y).map([](const auto &ij){return _get<0>(ij) * _get<1>(ij);}));
    auto x2ym = average(zip(x, y).map([](const auto &ij){return _get<0>(ij) * _get<0>(ij) * _get<1>(ij);}));

    auto sxx = x2m - xm * xm;
    auto sxy = xym - xm * ym;
    auto sxx2 = x3m - xm * x2m;
    auto sx2x2 = x4m - x2m * x2m;
    auto sx2y = x2ym - x2m * ym;

    auto b = (sxy * sx2x2 - sx2y * sxx2) / (sxx * sx2x2 - sxx2 * sxx2);
    auto c = (sx2y * sxx - sxy * sxx2) / (sxx * sx2x2 - sxx2 * sxx2);
    auto a = ym - b * xm - c * x2m;

    auto abc = [&a, &b, &c](const auto &xx)
    {
        return (a + b * xx) + (c * xx * xx);
    };

    print(u"y = #. + #.x + #.x^2\n"_S.format(a, b, c));
    print(u" Input  Approximation"_S);
    print(u" x   y     y1"_S);

    for (auto i : range_el(0, x.len()))
        print(u"#2 #3  #3.1"_S.format(x[i], y[i], abc(i)));
}

auto x = create_array({0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10});
auto y = create_array({1, 6, 17, 34, 57, 86, 121, 162, 209, 262, 321});

struct CodeBlock1
{
    CodeBlock1()
    {
        poly_regression(x, y);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Polynomial_synthetic_division#Python
def extended_synthetic_division(dividend, divisor):
    '''Fast polynomial division by using Extended Synthetic Division. Also works with non-monic polynomials.'''
    # dividend and divisor are both polynomials, which are here simply lists of coefficients. Eg: x^2 + 3x + 5 will be represented as [1, 3, 5]

    out = dividend[:] # Copy the dividend
    normalizer = divisor[0]
    for i in range(len(dividend)-(len(divisor)-1)):
        out[i] /= normalizer # for general polynomial division (when polynomials are non-monic),
                                 # we need to normalize by dividing the coefficient with the divisor's first coefficient
        coef = out[i]
        if coef != 0: # useless to multiply if coef is 0
            for j in range(1, len(divisor)): # in synthetic division, we always skip the first coefficient of the divisor,
                                              # because it's only used to normalize the dividend coefficients
                out[i + j] += -divisor[j] * coef

    # The resulting out contains both the quotient and the remainder, the remainder being the size of the divisor (the remainder
    # has necessarily the same degree as the divisor since it's what we couldn't divide from the dividend), so we compute the index
    # where this separation is, and return the quotient and remainder.
    separator = len(divisor)-1
    return (out[:-separator], out[-separator:]) # return quotient, remainder.

print("POLYNOMIAL SYNTHETIC DIVISION")
n = [1, -12, 0, -42]
D = [1, -3]
print("  %s / %s =" % (n,D), end = ' ')
(a, b) = extended_synthetic_division(n, D)
print("%s remainder %s" % (a, b))
===
F extended_synthetic_division(dividend, divisor)
   ‘Fast polynomial division by using Extended Synthetic Division. Also works with non-monic polynomials.’

   V out = copy(dividend)
   V normalizer = divisor[0]
   L(i) 0 .< dividend.len - (divisor.len - 1)
      out[i] /= normalizer
      V coef = out[i]
      I coef != 0
         L(j) 1 .< divisor.len
            out[i + j] += -divisor[j] * coef

   V separator = divisor.len - 1
   R (out[0 .< (len)-separator], out[(len)-separator ..])

print(‘POLYNOMIAL SYNTHETIC DIVISION’)
V n = [1, -12, 0, -42]
V D = [1, -3]
print(‘  #. / #. =’.format(n, D), end' ‘ ’)
V (a, b) = extended_synthetic_division(n, D)
print(‘#. remainder #.’.format(a, b))
===
template <typename T1, typename T2> auto extended_synthetic_division(const T1 &dividend, const T2 &divisor)
{
    u"Fast polynomial division by using Extended Synthetic Division. Also works with non-monic polynomials."_S;

    auto out = copy(dividend);
    auto normalizer = _get<0>(divisor);
    for (auto i : range_el(0, dividend.len() - (divisor.len() - 1))) {
        out[i] /= normalizer;
        auto coef = out[i];
        if (coef != 0)
            for (auto j : range_el(1, divisor.len()))
                out[i + j] += -divisor[j] * coef;
    }

    auto separator = divisor.len() - 1;
    return make_tuple(out[range_e_llen(0,  - separator)], out[range_elen_i( - separator)]);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"POLYNOMIAL SYNTHETIC DIVISION"_S);
    }
} code_block_1;

auto n = create_array({1, -12, 0, -42});
auto D = create_array({1, -3});

struct CodeBlock2
{
    CodeBlock2()
    {
        print(u"  #. / #. ="_S.format(n, D), u" "_S);
    }
} code_block_2;

auto [a, b] = extended_synthetic_division(n, D);

struct CodeBlock3
{
    CodeBlock3()
    {
        print(u"#. remainder #."_S.format(a, b));
    }
} code_block_3;


# https://www.rosettacode.org/wiki/Population_count#Python
from typing import List
Int64 = int

def popcount(n):
    return bin(n).count('1')

print([popcount(Int64(3)**i) for i in range(30)])

evil : List[int] = []
odious : List[int] = []
i = 0
while len(evil) < 30 or len(odious) < 30:
    p = popcount(i)
    if (p % 2) != 0: odious.append(i)
    else: evil.append(i)
    i += 1

print(evil[:30])
print(odious[:30])
===
F popcount(n)
   R bin(n).count(‘1’)

print((0.<30).map(i -> popcount(Int64(3) ^ i)))

[Int] evil
[Int] odious
V i = 0
L evil.len < 30 | odious.len < 30
   V p = popcount(i)
   I (p % 2) != 0
      odious.append(i)
   E
      evil.append(i)
   i++

print(evil[0.<30])
print(odious[0.<30])
===
template <typename T1> auto popcount(const T1 &n)
{
    return bin(n).count(u"1"_S);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(range_el(0, 30).map([](const auto &i){return popcount(pow(to_int64(3), i));}));
    }
} code_block_1;

Array<int> evil;
Array<int> odious;
auto i = 0;

struct CodeBlock2
{
    CodeBlock2()
    {
        while (evil.len() < 30 || odious.len() < 30) {
            auto p = popcount(i);
            if ((mod(p, 2)) != 0)
                odious.append(i);
            else
                evil.append(i);
            i++;
        }

        print(evil[range_el(0, 30)]);
        print(odious[range_el(0, 30)]);
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Power_set#Python
def list_powerset(lst):
    # the power set of the empty set has one element, the empty set
    empty_list : List[int] = []
    result = [empty_list]
    for x in lst:
        # for every additional element in our set
        # the power set consists of the subsets that don't
        # contain this element (just take the previous power set)
        # plus the subsets that do contain the element (use list
        # comprehension to add [x] onto everything in the
        # previous power set)
        result.extend([subset + [x] for subset in result])
    return result

print(list_powerset([1,2,3]))
===
F list_powerset(lst)
   [Int] empty_list
   V result = [empty_list]
   L(x) lst
      result.extend(result.map(subset -> subset [+] [@x]))
   R result

print(list_powerset([1, 2, 3]))
===
template <typename T1> auto list_powerset(const T1 &lst)
{
    Array<int> empty_list;
    auto result = create_array({empty_list});
    for (auto &&x : lst)
        result.extend(result.map([&x](const auto &subset){return subset + create_array({x});}));
    return result;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(list_powerset(create_array({1, 2, 3})));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Primality_by_Wilson%27s_theorem#Python
import math
Int64 = int

def is_wprime(n : Int64):
    return n > 1 and (n == 2 or
                      (n % 2 and (math.factorial(n - 1) + 1) % n == 0))

c = 20
print("Primes under %d:" % c, end="\n  ")
print([n for n in range(c) if is_wprime(n)])
===
F is_wprime(Int64 n)
   R n > 1 & (n == 2 | (n % 2 & (factorial(n - 1) + 1) % n == 0))

V c = 20
print(‘Primes under #.:’.format(c), end' "\n  ")
print((0 .< c).filter(n -> is_wprime(n)))
===
auto is_wprime(const Int64 &n)
{
    return n > 1 && (n == 2 || (mod(n, 2) && mod((factorial(n - 1) + 1), n) == 0));
}

auto c = 20;

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"Primes under #.:"_S.format(c), u"\n  "_S);
        print(range_el(0, c).filter([](const auto &n){return is_wprime(n);}));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Prime_conspiracy#Python
import math, collections

limit = 1000000
k = limit
n = k * 17
primes = [True] * n
primes[0] = primes[1] = False

for i in range(2, int(math.sqrt(n)) + 1):
    if not primes[i]:
        continue
    for j in range(i * i, n, i):
        primes[j] = False

trans_map = collections.defaultdict(int) # Tuple[int, int]
prev = -1

for i in range(n):
    if primes[i]:
        if prev != -1:
            trans_map[(prev, i % 10)] += 1
        prev = i % 10

        if k == 1:
            break
        k -= 1

print("First %d primes. Transitions prime %% 10 > next-prime %% 10." % limit)
for trans in sorted(trans_map.keys()):
    print('%d -> %d count %5d frequency: %.4f%%' % (trans[0], trans[1], trans_map[trans], 100.0 * trans_map[trans] / limit))
===
V limit = 1000000
V k = limit
V n = k * 17
V primes = [1B] * n
primes[0] = primes[1] = 0B

L(i) 2 .. Int(sqrt(n))
   I !primes[i]
      L.continue
   L(j) (i * i .< n).step(i)
      primes[j] = 0B

V trans_map = DefaultDict[(Int, Int), Int]()
V prev = -1

L(i) 0 .< n
   I primes[i]
      I prev != -1
         trans_map[(prev, i % 10)]++
      prev = i % 10

      I k == 1
         L.break
      k--

print(‘First #. primes. Transitions prime % 10 > next-prime % 10.’.format(limit))
L(trans) sorted(trans_map.keys())
   print(‘#. -> #. count #5 frequency: #.4%’.format(trans[0], trans[1], trans_map[trans], 100.0 * trans_map[trans] / limit))
===
auto limit = 1000000;
auto k = limit;
auto n = k * 17;
auto primes = create_array({true}) * n;

struct CodeBlock1
{
    CodeBlock1()
    {
        _set<0>(primes, _set<1>(primes, false));

        for (auto i : range_ee(2, to_int(sqrt(n)))) {
            if (!primes[i])
                continue;
            for (auto j : range_el(i * i, n).step(i))
                primes.set(j, false);
        }
    }
} code_block_1;

auto trans_map = DefaultDict<ivec2, int>();
auto prev = -1;

struct CodeBlock2
{
    CodeBlock2()
    {
        for (auto i : range_el(0, n))
            if (primes[i]) {
                if (prev != -1)
                    trans_map[make_tuple(prev, mod(i, 10))]++;
                prev = mod(i, 10);

                if (k == 1)
                    break;
                k--;
            }

        print(u"First #. primes. Transitions prime % 10 > next-prime % 10."_S.format(limit));
        for (auto &&trans : sorted(trans_map.keys()))
            print(u"#. -> #. count #5 frequency: #.4%"_S.format(_get<0>(trans), _get<1>(trans), trans_map[trans], 100.0 * trans_map[trans] / limit));
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Priority_queue#Python
import heapq
items = [(3, "Clear drains"), (4, "Feed cat"), (5, "Make tea"), (1, "Solve RC tasks"), (2, "Tax return")]
heapq.heapify(items)
while len(items):
    print(heapq.heappop(items))
===
V items = [(3, ‘Clear drains’), (4, ‘Feed cat’), (5, ‘Make tea’), (1, ‘Solve RC tasks’), (2, ‘Tax return’)]
minheap:heapify(&items)
L !items.empty
   print(minheap:pop(&items))
===
auto items = create_array({make_tuple(3, u"Clear drains"_S), make_tuple(4, u"Feed cat"_S), make_tuple(5, u"Make tea"_S), make_tuple(1, u"Solve RC tasks"_S), make_tuple(2, u"Tax return"_S)});

struct CodeBlock1
{
    CodeBlock1()
    {
        minheap::heapify(items);
        while (!items.empty())
            print(minheap::pop(items));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Product_of_divisors#Python
def product_of_divisors(n):
    ans = 1
    i = 1
    j = 1
    while i*i <= n:
        if 0 == n%i:
            ans *= i
            j = n//i
            if j != i:
                ans *= j
        i += 1
    return ans

print([product_of_divisors(n) for n in range(1,51)])
===
F product_of_divisors(n)
   V ans = 1
   V i = 1
   V j = 1
   L i * i <= n
      I 0 == n % i
         ans *= i
         j = n I/ i
         I j != i
            ans *= j
      i++
   R ans

print((1..50).map(n -> product_of_divisors(n)))
===
template <typename T1> auto product_of_divisors(const T1 &n)
{
    auto ans = 1;
    auto i = 1;
    auto j = 1;
    while (i * i <= n) {
        if (0 == mod(n, i)) {
            ans *= i;
            j = idiv(n, i);
            if (j != i)
                ans *= j;
        }
        i++;
    }
    return ans;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(range_ee(1, 50).map([](const auto &n){return product_of_divisors(n);}));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Proper_divisors#Python
def proper_divs(n):
    return list({x for x in range(1, (n + 1) // 2 + 1) if n % x == 0 and n != x})

print([proper_divs(n) for n in range(1, 11)])

(n, leng) = max(((n, len(proper_divs(n))) for n in range(1, 20001)), key=lambda pd: pd[1])
print(n, leng)
===
F proper_divs(n)
   R Array(Set((1 .. (n + 1) I/ 2).filter(x -> @n % x == 0 & @n != x)))

print((1..10).map(n -> proper_divs(n)))

V (n, leng) = max(((1..20000).map(n -> (n, proper_divs(n).len))), key' pd -> pd[1])
print(n‘ ’leng)
===
template <typename T1> auto proper_divs(const T1 &n)
{
    return create_array(create_set(range_ee(1, idiv((n + 1), 2)).filter([&n](const auto &x){return mod(n, x) == 0 && n != x;})));
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(range_ee(1, 10).map([](const auto &n){return proper_divs(n);}));
    }
} code_block_1;

auto [n, leng] = max_with_key((range_ee(1, 20000).map([](const auto &n){return make_tuple(n, proper_divs(n).len());})), [](const auto &pd){return _get<1>(pd);});

struct CodeBlock2
{
    CodeBlock2()
    {
        print(n & u" "_S & leng);
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Pythagorean_quadruples#Python
def quad(top = 2200):
    r = [False] * top
    ab = [False] * (top * 2)**2
    for a in range(1, top):
        for b in range(a, top):
            ab[a * a + b * b] = True
    s = 3
    for c in range(1, top):
        (s1, s, s2) = (s, s + 2, s + 2)
        for d in range(c + 1, top):
            if ab[s1]:
                r[d] = True
            s1 += s2
            s2 += 2
    return [i for i, val in enumerate(r) if not val and i]

print(quad())
===
F quad(top = 2200)
   V r = [0B] * top
   V ab = [0B] * (top * 2) ^ 2
   L(a) 1 .< top
      L(b) a .< top
         ab[a * a + b * b] = 1B
   V s = 3
   L(c) 1 .< top
      (V s1, s, V s2) = (s, s + 2, s + 2)
      L(d) c + 1 .< top
         I ab[s1]
            r[d] = 1B
         s1 += s2
         s2 += 2
   R enumerate(r).filter((i, val) -> !val & i).map((i, val) -> i)

print(quad())
===
template <typename T1 = decltype(2200)> auto quad(const T1 &top = 2200)
{
    auto r = create_array({false}) * top;
    auto ab = create_array({false}) * square((top * 2));
    for (auto a : range_el(1, top))
        for (auto b : range_el(a, top))
            ab.set(a * a + b * b, true);
    auto s = 3;
    for (auto c : range_el(1, top)) {
        TUPLE_ELEMENT_T(0, make_tuple(s, s + 2, s + 2)) s1;
        TUPLE_ELEMENT_T(2, make_tuple(s, s + 2, s + 2)) s2;
        assign_from_tuple(s1, s, s2, make_tuple(s, s + 2, s + 2));
        for (auto d : range_el(c + 1, top)) {
            if (ab[s1])
                r.set(d, true);
            s1 += s2;
            s2 += 2;
        }
    }
    return enumerate(r).filter([](const auto &i, const auto &val){return !val && i;}).map([](const auto &i, const auto &val){return i;});
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(quad());
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Partition_function_P#Python
import time
BigInt = int

def partitions(n):
    """Count partitions."""
    p = [BigInt(1)] + [BigInt(0)] * n
    for i in range(1, n + 1):
        k = 0
        while True:
            k += 1
            j = (k * (3*k - 1)) // 2
            if j > i:
                break
            if k & 1:
                p[i] += p[i - j]
            else:
                p[i] -= p[i - j]
            j = (k * (3*k + 1)) // 2
            if j > i:
                break
            if k & 1:
                p[i] += p[i - j]
            else:
                p[i] -= p[i - j]

    return p[n]

print("Partitions:", [partitions(x) for x in range(15)])

start = time.perf_counter()
print(partitions(6666))
print(time.perf_counter() - start)
===
F partitions(n)
   ‘Count partitions.’
   V p = [BigInt(1)] [+] [BigInt(0)] * n
   L(i) 1 .. n
      V k = 0
      L
         k++
         V j = (k * (3 * k - 1)) I/ 2
         I j > i
            L.break
         I k [&] 1
            p[i] += p[i - j]
         E
            p[i] -= p[i - j]
         j = (k * (3 * k + 1)) I/ 2
         I j > i
            L.break
         I k [&] 1
            p[i] += p[i - j]
         E
            p[i] -= p[i - j]

   R p[n]

print(‘Partitions: ’(0.<15).map(x -> partitions(x)))

V start = time:perf_counter()
print(partitions(6666))
print(time:perf_counter() - start)
===
template <typename T1> auto partitions(const T1 &n)
{
    u"Count partitions."_S;
    auto p = create_array({BigInt(1)}) + create_array({BigInt(0)}) * n;
    for (auto i : range_ee(1, n)) {
        auto k = 0;
        while (true) {
            k++;
            auto j = idiv((k * (3 * k - 1)), 2);
            if (j > i)
                break;
            if (k & 1)
                p[i] += p[i - j];
            else
                p[i] -= p[i - j];
            j = idiv((k * (3 * k + 1)), 2);
            if (j > i)
                break;
            if (k & 1)
                p[i] += p[i - j];
            else
                p[i] -= p[i - j];
        }
    }

    return p[n];
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"Partitions: "_S & range_el(0, 15).map([](const auto &x){return partitions(x);}));
    }
} code_block_1;

auto start = timens::perf_counter();

struct CodeBlock2
{
    CodeBlock2()
    {
        print(partitions(6666));
        print(timens::perf_counter() - start);
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Prime_decomposition#D
# Slow BigInt
BigInt = int

def decompose(number : BigInt):
    result : List[BigInt] = []
    n = number
    i : BigInt = 2
    while n % i == 0:
        result.append(i)
        n //= i
    i = 3
    while n >= i * i:
        while n % i == 0:
            result.append(i)
            n //= i
        i += 2
    if n != 1:
        result.append(n)
    return result

for i in range(2, 10):
    print(decompose(i))
print(decompose(1023 * 1024))
print(decompose(2 * 3 * 5 * 7 * 11 * 11 * 13 * 17))
print(decompose(BigInt(16860167264933) * 179951))
===
F decompose(BigInt number)
   [BigInt] result
   V n = number
   BigInt i = 2
   L n % i == 0
      result.append(i)
      n I/= i
   i = 3
   L n >= i * i
      L n % i == 0
         result.append(i)
         n I/= i
      i += 2
   I n != 1
      result.append(n)
   R result

L(i) 2..9
   print(decompose(i))
print(decompose(1023 * 1024))
print(decompose(2 * 3 * 5 * 7 * 11 * 11 * 13 * 17))
print(decompose(BigInt(16860167264933) * 179951))
===
auto decompose(const BigInt &number)
{
    Array<BigInt> result;
    auto n = number;
    BigInt i = 2;
    while (mod(n, i) == 0) {
        result.append(i);
        n = idiv(n, i);
    }
    i = 3;
    while (n >= i * i) {
        while (mod(n, i) == 0) {
            result.append(i);
            n = idiv(n, i);
        }
        i += 2;
    }
    if (n != 1)
        result.append(n);
    return result;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto i : range_ee(2, 9))
            print(decompose(i));
        print(decompose(1023 * 1024));
        print(decompose(2 * 3 * 5 * 7 * 11 * 11 * 13 * 17));
        print(decompose(BigInt(16860167264933) * 179951));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Primorial_numbers#Python
BigInt = int

def get_primes(primes_count):
    limit = 17 * primes_count
    is_prime = [False] * 2 + [True] * (limit - 1)
    for n in range(int(limit**0.5 + 1.5)): # stop at ``sqrt(limit)``
        if is_prime[n]:
            for i in range(n*n, limit+1, n):
                is_prime[i] = False

    primes : List[int] = []
    for i, prime in enumerate(is_prime):
        if prime:
            primes.append(i)
            if len(primes) == primes_count:
                break
    return primes

primes = get_primes(100000)

def primorial(n):
    r : BigInt = 1
    for i in range(n):
        r *= primes[i]
    return r

print('First ten primorials:', [primorial(n) for n in range(10)])
for e in range(6):
    n = 10**e
    print('primorial(%i) has %i digits' % (n, len(str(primorial(n)))))
===
F get_primes(primes_count)
   V limit = 17 * primes_count
   V is_prime = [0B] * 2 [+] [1B] * (limit - 1)
   L(n) 0 .< Int(limit ^ 0.5 + 1.5)
      I is_prime[n]
         L(i) (n * n .. limit).step(n)
            is_prime[i] = 0B

   [Int] primes
   L(prime) is_prime
      V i = L.index
      I prime
         primes.append(i)
         I primes.len == primes_count
            L.break
   R primes

V primes = get_primes(100000)

F primorial(n)
   BigInt r = 1
   L(i) 0 .< n
      r *= :primes[i]
   R r

print(‘First ten primorials: ’(0.<10).map(n -> primorial(n)))
L(e) 6
   V n = 10 ^ e
   print(‘primorial(#.) has #. digits’.format(n, String(primorial(n)).len))
===
template <typename T1> auto get_primes(const T1 &primes_count)
{
    auto limit = 17 * primes_count;
    auto is_prime = create_array({false}) * 2 + create_array({true}) * (limit - 1);
    for (auto n : range_el(0, to_int(pow(limit, 0.5) + 1.5)))
        if (is_prime[n])
            for (auto i : range_ee(n * n, limit).step(n))
                is_prime.set(i, false);

    Array<int> primes;
    {int Lindex = 0;
    for (auto &&prime : is_prime) {
        auto i = Lindex;
        if (prime) {
            primes.append(i);
            if (primes.len() == primes_count)
                break;
        }
        Lindex++;
    }}
    return primes;
}

auto primes = get_primes(100000);

template <typename T1> auto primorial(const T1 &n)
{
    BigInt r = 1;
    for (auto i : range_el(0, n))
        r *= ::primes[i];
    return r;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"First ten primorials: "_S & range_el(0, 10).map([](const auto &n){return primorial(n);}));
        for (int e = 0; e < 6; e++) {
            auto n = pow(10, e);
            print(u"primorial(#.) has #. digits"_S.format(n, String(primorial(n)).len()));
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Partition_an_integer_x_into_n_primes#D
def is_prime(a):
    return not (a < 2 or any(a % x == 0 for x in range(2, int(a**0.5) + 1)))

def generate_primes(n):
    r = [2]
    i = 3
    while True:
        if is_prime(i):
            r.append(i)
            if len(r) == n:
                break
        i += 2
    return r

primes = generate_primes(50_000)

def find_combo(k, x, m, n, combo : list):
    if k >= m:
        if sum(primes[idx] for idx in combo) == x:
            print('Partitioned %5d with %2d %s: ' % (x, m, 'primes' if m > 1 else 'prime '), end = '')
            for i in range(m):
                print(primes[combo[i]], end = '+' if i < m - 1 else "\n") # L.last_iteration
            return True
    else:
        for j in range(n):
            if k == 0 or j > combo[k-1]:
                combo[k] = j
                if find_combo(k+1, x, m, n, combo):
                    return True
    return False

def partition(x, m):
    n = len([a for a in primes if a <= x])
    combo = [0] * m
    if not find_combo(0, x, m, n, combo):
        print('Partitioned %5d with %2d %s: (not possible)' % (x, m, 'primes' if m > 1 else 'prime '))

data = [(99809, 1), (18, 2), (19, 3), (20, 4), (2017, 24),
        (22699, 1), (22699, 2), (22699, 3), (22699, 4), (40355, 3)]

for n, cnt in data:
    partition(n, cnt)
===
F is_prime(a)
   R !(a < 2 | any((2 .. Int(a ^ 0.5)).map(x -> @a % x == 0)))

F generate_primes(n)
   V r = [2]
   V i = 3
   L
      I is_prime(i)
         r.append(i)
         I r.len == n
            L.break
      i += 2
   R r

V primes = generate_primes(50'000)

F find_combo(k, x, m, n, &combo)
   I k >= m
      I sum(combo.map(idx -> :primes[idx])) == x
         print(‘Partitioned #5 with #2 #.: ’.format(x, m, I m > 1 {‘primes’} E ‘prime ’), end' ‘’)
         L(i) 0 .< m
            print(:primes[combo[i]], end' I i < m - 1 {‘+’} E "\n")
         R 1B
   E
      L(j) 0 .< n
         I k == 0 | j > combo[k - 1]
            combo[k] = j
            I find_combo(k + 1, x, m, n, &combo)
               R 1B
   R 0B

F partition(x, m)
   V n = :primes.filter(a -> a <= @x).len
   V combo = [0] * m
   I !find_combo(0, x, m, n, &combo)
      print(‘Partitioned #5 with #2 #.: (not possible)’.format(x, m, I m > 1 {‘primes’} E ‘prime ’))

V data = [(99809, 1), (18, 2), (19, 3), (20, 4), (2017, 24), (22699, 1), (22699, 2), (22699, 3), (22699, 4), (40355, 3)]

L(n, cnt) data
   partition(n, cnt)
===
template <typename T1> auto is_prime(const T1 &a)
{
    return !(a < 2 || any_map(range_ee(2, to_int(pow(a, 0.5))), [&a](const auto &x){return mod(a, x) == 0;}));
}

template <typename T1> auto generate_primes(const T1 &n)
{
    auto r = create_array({2});
    auto i = 3;
    while (true) {
        if (is_prime(i)) {
            r.append(i);
            if (r.len() == n)
                break;
        }
        i += 2;
    }
    return r;
}

auto primes = generate_primes(50'000);

template <typename T1, typename T2, typename T3, typename T4, typename T5> auto find_combo(const T1 &k, const T2 &x, const T3 &m, const T4 &n, T5 &combo)
{
    if (k >= m) {
        if (sum_map(combo, [](const auto &idx){return ::primes[idx];}) == x) {
            print(u"Partitioned #5 with #2 #.: "_S.format(x, m, m > 1 ? u"primes"_S : u"prime "_S), u""_S);
            for (auto i : range_el(0, m))
                print(::primes[combo[i]], i < m - 1 ? u"+"_S : u"\n"_S);
            return true;
        }
    }
    else
        for (auto j : range_el(0, n))
            if (k == 0 || j > combo[k - 1]) {
                combo.set(k, j);
                if (find_combo(k + 1, x, m, n, combo))
                    return true;
            }
    return false;
}

template <typename T1, typename T2> auto partition(const T1 &x, const T2 &m)
{
    auto n = ::primes.filter([&x](const auto &a){return a <= x;}).len();
    auto combo = create_array({0}) * m;
    if (!find_combo(0, x, m, n, combo))
        print(u"Partitioned #5 with #2 #.: (not possible)"_S.format(x, m, m > 1 ? u"primes"_S : u"prime "_S));
}

auto data = create_array({make_tuple(99809, 1), make_tuple(18, 2), make_tuple(19, 3), make_tuple(20, 4), make_tuple(2017, 24), make_tuple(22699, 1), make_tuple(22699, 2), make_tuple(22699, 3), make_tuple(22699, 4), make_tuple(40355, 3)});

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&[n, cnt] : data)
            partition(n, cnt);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Pascal%27s_triangle/Puzzle#D
def e(x : list, row, col): # -> &
    return x[row * (row + 1) // 2 + col]

def iterate(v : list, diff : list, do_print = True):
    tot = 0.0
    while True:
        e(v, 0, 0) = 151
        e(v, 2, 0) = 40
        e(v, 4, 1) = 11
        e(v, 4, 3) = 4

        for i in range(1, 5):
            for j in range(i + 1):
                e(diff, i, j) = 0
                if j < i:
                    e(diff, i, j) += e(v, i - 1, j) - e(v, i, j + 1) - e(v, i, j)
                if j != 0:
                    e(diff, i, j) += e(v, i - 1, j - 1) - e(v, i, j - 1) - e(v, i, j)

        for i in range(1, 4):
            for j in range(0, i):
                e(diff, i, j) += e(v, i + 1, j) + e(v, i + 1, j + 1) - e(v, i, j)

        e(diff, 4, 2) += e(v, 4, 0) + e(v, 4, 4) - e(v, 4, 2)

        for i in range(len(v)):
            v[i] += diff[i] / 4

        tot = sum(a * a for a in diff)
        if do_print:
            print('dev:', tot)
        if tot < 0.1:
            break

v = [0.0] * 15
diff = [0.0] * 15
iterate(v, diff)

idx = 0
for i in range(5):
    for j in range(i + 1):
        print('%4d' % int(0.5 + v[idx]), end = ' ' if j < i else "\n")
        idx += 1
===
F e(&x, row, col) -> &
   R x[row * (row + 1) I/ 2 + col]

F iterate(&v, &diff, do_print = 1B)
   V tot = 0.0
   L
      e(&v, 0, 0) = 151
      e(&v, 2, 0) = 40
      e(&v, 4, 1) = 11
      e(&v, 4, 3) = 4

      L(i) 1..4
         L(j) 0 .. i
            e(&diff, i, j) = 0
            I j < i
               e(&diff, i, j) += e(&v, i - 1, j) - e(&v, i, j + 1) - e(&v, i, j)
            I j != 0
               e(&diff, i, j) += e(&v, i - 1, j - 1) - e(&v, i, j - 1) - e(&v, i, j)

      L(i) 1..3
         L(j) 0 .< i
            e(&diff, i, j) += e(&v, i + 1, j) + e(&v, i + 1, j + 1) - e(&v, i, j)

      e(&diff, 4, 2) += e(&v, 4, 0) + e(&v, 4, 4) - e(&v, 4, 2)

      L(i) 0 .< v.len
         v[i] += diff[i] / 4

      tot = sum(diff.map(a -> a * a))
      I do_print
         print(‘dev: ’tot)
      I tot < 0.1
         L.break

V v = [0.0] * 15
V diff = [0.0] * 15
iterate(&v, &diff)

V idx = 0
L(i) 5
   L(j) 0 .. i
      print(‘#4’.format(Int(0.5 + v[idx])), end' I j < i {‘ ’} E "\n")
      idx++
===
template <typename T1, typename T2, typename T3> auto& e(T1 &x, const T2 &row, const T3 &col)
{
    return x[idiv(row * (row + 1), 2) + col];
}

template <typename T1, typename T2, typename T3 = decltype(true)> auto iterate(T1 &v, T2 &diff, const T3 &do_print = true)
{
    auto tot = 0.0;
    while (true) {
        e(v, 0, 0) = 151;
        e(v, 2, 0) = 40;
        e(v, 4, 1) = 11;
        e(v, 4, 3) = 4;

        for (auto i : range_ee(1, 4))
            for (auto j : range_ee(0, i)) {
                e(diff, i, j) = 0;
                if (j < i)
                    e(diff, i, j) += e(v, i - 1, j) - e(v, i, j + 1) - e(v, i, j);
                if (j != 0)
                    e(diff, i, j) += e(v, i - 1, j - 1) - e(v, i, j - 1) - e(v, i, j);
            }

        for (auto i : range_ee(1, 3))
            for (auto j : range_el(0, i))
                e(diff, i, j) += e(v, i + 1, j) + e(v, i + 1, j + 1) - e(v, i, j);

        e(diff, 4, 2) += e(v, 4, 0) + e(v, 4, 4) - e(v, 4, 2);

        for (auto i : range_el(0, v.len()))
            v[i] += diff[i] / 4.0;

        tot = sum_map(diff, [](const auto &a){return a * a;});
        if (do_print)
            print(u"dev: "_S & tot);
        if (tot < 0.1)
            break;
    }
}

auto v = create_array({0.0}) * 15;
auto diff = create_array({0.0}) * 15;

struct CodeBlock1
{
    CodeBlock1()
    {
        iterate(v, diff);
    }
} code_block_1;

auto idx = 0;

struct CodeBlock2
{
    CodeBlock2()
    {
        for (int i = 0; i < 5; i++)
            for (auto j : range_ee(0, i)) {
                print(u"#4"_S.format(to_int(0.5 + v[idx])), j < i ? u" "_S : u"\n"_S);
                idx++;
            }
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Peaceful_chess_queen_armies#D
from enum import IntEnum
from typing import List, Tuple

class Piece(IntEnum):
    EMPTY = 0
    BLACK = 1
    WHITE = 2

def isAttacking(queen, pos):
    return queen[0] == pos[0] \
        or queen[1] == pos[1] \
        or abs(queen[0] - pos[0]) == abs(queen[1] - pos[1])

def place(m, n, pBlackQueens : list, pWhiteQueens : list):
    if m == 0:
        return True

    placingBlack = True
    for i in range(n):
        for j in range(n):
            pos = (i, j)
            for queen in pBlackQueens:
                if queen == pos or ((not placingBlack) and isAttacking(queen, pos)):
                    break # `L(j).continue`
            else:
                for queen in pWhiteQueens:
                    if queen == pos or (placingBlack and isAttacking(queen, pos)):
                        break
                else:
                    if placingBlack:
                        pBlackQueens += [pos]
                        placingBlack = False
                    else:
                        pWhiteQueens += [pos]
                        if place(m - 1, n, pBlackQueens, pWhiteQueens):
                            return True
                        pBlackQueens.pop()
                        pWhiteQueens.pop()
                        placingBlack = True

    if not placingBlack:
        pBlackQueens.pop()
    return False

def printBoard(n, blackQueens, whiteQueens):
    board = [Piece.EMPTY] * (n * n)

    for queen in blackQueens:
        board[queen[0] * n + queen[1]] = Piece.BLACK

    for queen in whiteQueens:
        board[queen[0] * n + queen[1]] = Piece.WHITE

    for i, b in enumerate(board):
        if i != 0 and i % n == 0:
            print()
        if b == Piece.BLACK:
            print('B ', end = '')
        elif b == Piece.WHITE:
            print('W ', end = '')
        else:
            j = i // n
            k = i - j * n
            if j % 2 == k % 2:
                print('x ', end = '')
            else:
                print('o ', end = '')
    print("\n")

nms = [
        (2, 1), (3, 1), (3, 2), (4, 1), (4, 2), (4, 3),
        (5, 1), (5, 2), (5, 3), (5, 4), (5, 5),
        (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6),
        (7, 1), (7, 2), (7, 3), (7, 4), (7, 5), (7, 6), (7, 7),
      ]

for nm in nms:
    print("%d black and %d white queens on a %d x %d board:" % (nm[1], nm[1], nm[0], nm[0]))
    blackQueens : List[Tuple[int, int]] = []
    whiteQueens : List[Tuple[int, int]] = []
    if place(nm[1], nm[0], blackQueens, whiteQueens):
        printBoard(nm[0], blackQueens, whiteQueens)
    else:
        print("No solution exists.\n")
===
T.enum Piece
   EMPTY
   BLACK
   WHITE

F isAttacking(queen, pos)
   R queen[0] == pos[0] | queen[1] == pos[1] | abs(queen[0] - pos[0]) == abs(queen[1] - pos[1])

F place(m, n, &pBlackQueens, &pWhiteQueens)
   I m == 0
      R 1B

   V placingBlack = 1B
   L(i) 0 .< n
      L(j) 0 .< n
         V pos = (i, j)
         L(queen) pBlackQueens
            I queen == pos | ((!placingBlack) & isAttacking(queen, pos))
               L.break
         L.was_no_break
            L(queen) pWhiteQueens
               I queen == pos | (placingBlack & isAttacking(queen, pos))
                  L.break
            L.was_no_break
               I placingBlack
                  pBlackQueens [+]= pos
                  placingBlack = 0B
               E
                  pWhiteQueens [+]= pos
                  I place(m - 1, n, &pBlackQueens, &pWhiteQueens)
                     R 1B
                  pBlackQueens.pop()
                  pWhiteQueens.pop()
                  placingBlack = 1B

   I !placingBlack
      pBlackQueens.pop()
   R 0B

F printBoard(n, blackQueens, whiteQueens)
   V board = [Piece.EMPTY] * (n * n)

   L(queen) blackQueens
      board[queen[0] * n + queen[1]] = Piece.BLACK

   L(queen) whiteQueens
      board[queen[0] * n + queen[1]] = Piece.WHITE

   L(b) board
      V i = L.index
      I i != 0 & i % n == 0
         print()
      I b == BLACK
         print(‘B ’, end' ‘’)
      E I b == WHITE
         print(‘W ’, end' ‘’)
      E
         V j = i I/ n
         V k = i - j * n
         I j % 2 == k % 2
            print(‘x ’, end' ‘’)
         E
            print(‘o ’, end' ‘’)
   print("\n")

V nms = [(2, 1), (3, 1), (3, 2), (4, 1), (4, 2), (4, 3), (5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6), (7, 1), (7, 2), (7, 3), (7, 4), (7, 5), (7, 6), (7, 7)]

L(nm) nms
   print(‘#. black and #. white queens on a #. x #. board:’.format(nm[1], nm[1], nm[0], nm[0]))
   [(Int, Int)] blackQueens
   [(Int, Int)] whiteQueens
   I place(nm[1], nm[0], &blackQueens, &whiteQueens)
      printBoard(nm[0], blackQueens, whiteQueens)
   E
      print("No solution exists.\n")
===
enum class Piece {
    EMPTY,
    BLACK,
    WHITE
};

template <typename T1, typename T2> auto isAttacking(const T1 &queen, const T2 &pos)
{
    return _get<0>(queen) == _get<0>(pos) || _get<1>(queen) == _get<1>(pos) || abs(_get<0>(queen) - _get<0>(pos)) == abs(_get<1>(queen) - _get<1>(pos));
}

template <typename T1, typename T2, typename T3, typename T4> auto place(const T1 &m, const T2 &n, T3 &pBlackQueens, T4 &pWhiteQueens)
{
    if (m == 0)
        return true;

    auto placingBlack = true;
    for (auto i : range_el(0, n))
        for (auto j : range_el(0, n)) {
            auto pos = make_tuple(i, j);
            for (auto &&queen : pBlackQueens)
                if (queen == pos || ((!placingBlack) && isAttacking(queen, pos)))
                    goto break_;
            for (auto &&queen : pWhiteQueens)
                if (queen == pos || (placingBlack && isAttacking(queen, pos)))
                    goto break_1;
            if (placingBlack) {
                pBlackQueens.append(pos);
                placingBlack = false;
            }
            else {
                pWhiteQueens.append(pos);
                if (place(m - 1, n, pBlackQueens, pWhiteQueens))
                    return true;
                pBlackQueens.pop();
                pWhiteQueens.pop();
                placingBlack = true;
            }
            break_1:;
            break_:;
        }

    if (!placingBlack)
        pBlackQueens.pop();
    return false;
}

template <typename T1, typename T2, typename T3> auto printBoard(const T1 &n, const T2 &blackQueens, const T3 &whiteQueens)
{
    auto board = create_array({Piece::EMPTY}) * (n * n);

    for (auto &&queen : blackQueens)
        board.set(_get<0>(queen) * n + _get<1>(queen), Piece::BLACK);

    for (auto &&queen : whiteQueens)
        board.set(_get<0>(queen) * n + _get<1>(queen), Piece::WHITE);
    {int Lindex = 0;

    for (auto &&b : board) {
        auto i = Lindex;
        if (i != 0 && mod(i, n) == 0)
            print();
        if (b == TYPE_RM_REF(b)::BLACK)
            print(u"B "_S, u""_S);
        else if (b == TYPE_RM_REF(b)::WHITE)
            print(u"W "_S, u""_S);
        else {
            auto j = idiv(i, n);
            auto k = i - j * n;
            if (mod(j, 2) == mod(k, 2))
                print(u"x "_S, u""_S);
            else
                print(u"o "_S, u""_S);
        }
        Lindex++;
    }}
    print(u"\n"_S);
}

auto nms = create_array({make_tuple(2, 1), make_tuple(3, 1), make_tuple(3, 2), make_tuple(4, 1), make_tuple(4, 2), make_tuple(4, 3), make_tuple(5, 1), make_tuple(5, 2), make_tuple(5, 3), make_tuple(5, 4), make_tuple(5, 5), make_tuple(6, 1), make_tuple(6, 2), make_tuple(6, 3), make_tuple(6, 4), make_tuple(6, 5), make_tuple(6, 6), make_tuple(7, 1), make_tuple(7, 2), make_tuple(7, 3), make_tuple(7, 4), make_tuple(7, 5), make_tuple(7, 6), make_tuple(7, 7)});

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&nm : nms) {
            print(u"#. black and #. white queens on a #. x #. board:"_S.format(_get<1>(nm), _get<1>(nm), _get<0>(nm), _get<0>(nm)));
            Array<ivec2> blackQueens;
            Array<ivec2> whiteQueens;
            if (place(_get<1>(nm), _get<0>(nm), blackQueens, whiteQueens))
                printBoard(_get<0>(nm), blackQueens, whiteQueens);
            else
                print(u"No solution exists.\n"_S);
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Pi#D
# Slow BigInt
BigInt = int

ndigits = 0
q = BigInt(1)
r = BigInt(0)
t = q
k = q
n = BigInt(3)
l = n

first = True
while ndigits < 1_000:
    if 4 * q + r - t < n * t:
        print(n, end = '')
        ndigits += 1
        if ndigits % 70 == 0:
            print()
        if first:
            first = False
            print('.', end = '')
        nr = 10 * (r - n * t)
        n = ((10 * (3 * q + r)) // t) - 10 * n
        q *= 10
        r = nr
    else:
        nr = (2 * q + r) * l
        nn = (q * (7 * k + 2) + r * l) // (t * l)
        q *= k
        t *= l
        l += 2
        k += 1
        n = nn
        r = nr
===
V ndigits = 0
V q = BigInt(1)
V r = BigInt(0)
V t = q
V k = q
V n = BigInt(3)
V l = n

V first = 1B
L ndigits < 1'000
   I 4 * q + r - t < n * t
      print(n, end' ‘’)
      ndigits++
      I ndigits % 70 == 0
         print()
      I first
         first = 0B
         print(‘.’, end' ‘’)
      V nr = 10 * (r - n * t)
      n = ((10 * (3 * q + r)) I/ t) - 10 * n
      q *= 10
      r = nr
   E
      V nr = (2 * q + r) * l
      V nn = (q * (7 * k + 2) + r * l) I/ (t * l)
      q *= k
      t *= l
      l += 2
      k++
      n = nn
      r = nr
===
auto ndigits = 0;
auto q = BigInt(1);
auto r = BigInt(0);
auto t = q;
auto k = q;
auto n = BigInt(3);
auto l = n;

auto first = true;

struct CodeBlock1
{
    CodeBlock1()
    {
        while (ndigits < 1'000)
            if (4 * q + r - t < n * t) {
                print(n, u""_S);
                ndigits++;
                if (mod(ndigits, 70) == 0)
                    print();
                if (first) {
                    first = false;
                    print(u"."_S, u""_S);
                }
                auto nr = 10 * (r - n * t);
                n = (idiv((10 * (3 * q + r)), t)) - 10 * n;
                q *= 10;
                r = nr;
            }
            else {
                auto nr = (2 * q + r) * l;
                auto nn = idiv((q * (7 * k + 2) + r * l), (t * l));
                q *= k;
                t *= l;
                l += 2;
                k++;
                n = nn;
                r = nr;
            }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Poker_hand_analyser#D
def analyzeHandHelper(faceCount, suitCount):
    p1 = False
    p2 = False
    t = False
    f = False
    fl = False
    st = False

    for fc in faceCount:
        fc = fc
        if fc == 2:
            if p1:
                p2 = True
            else:
                p1 = True
        elif fc == 3:
            t = True
        elif fc == 4:
            f = True

    for sc in suitCount:
        if sc == 5:
            fl = True

    if (not p1) and (not p2) and (not t) and (not f):
        s = 0
        for fc in faceCount:
            if fc != 0:
                s += 1
            else:
                s = 0
            if s == 5:
                break

        st = (s == 5) or (s == 4 and faceCount[0] != 0 and faceCount[1] == 0)

    if st and fl:   return "straight-flush"
    elif f:         return "four-of-a-kind"
    elif p1 and t:  return "full-house"
    elif fl:        return "flush"
    elif st:        return "straight"
    elif t:         return "three-of-a-kind"
    elif p1 and p2: return "two-pair"
    elif p1:        return "one-pair"
    else:           return "high-card"

def analyzeHand(inHand):
    handLen = 5
    face = "A23456789TJQK"
    suit = "SHCD"
    errorMessage = "invalid hand."

    hand = sorted(inHand.split(' '))
    if len(hand) != handLen:
        return errorMessage
    if len(set(hand)) != handLen:
        return errorMessage + " Duplicated cards."

    faceCount = [0] * len(face)
    suitCount = [0] * len(suit)
    for card in hand:
        if len(card) != 2:
            return errorMessage
        n = face.find(card[0])
        l = suit.find(card[1])
        if n < 0 or l < 0:
            return errorMessage
        faceCount[n] += 1
        suitCount[l] += 1

    return analyzeHandHelper(faceCount, suitCount)

for hand in ["2H 2D 2S KS QD",
             "2H 5H 7D 8S 9D",
             "AH 2D 3S 4S 5S",
             "2H 3H 2D 3S 3D",
             "2H 7H 2D 3S 3D",
             "2H 7H 7D 7S 7C",
             "TH JH QH KH AH",
             "4H 4C KC 5D TC",
             "QC TC 7C 6C 4C"]:
    print(hand + ":", analyzeHand(hand))
===
F analyzeHandHelper(faceCount, suitCount)
   V p1 = 0B
   V p2 = 0B
   V t = 0B
   V f = 0B
   V fl = 0B
   V st = 0B

   L(=fc) faceCount
      S fc
         2
            I p1
               p2 = 1B
            E
               p1 = 1B
         3
            t = 1B
         4
            f = 1B

   L(sc) suitCount
      I sc == 5
         fl = 1B

   I (!p1) & (!p2) & (!t) & (!f)
      V s = 0
      L(fc) faceCount
         I fc != 0
            s++
         E
            s = 0
         I s == 5
            L.break

      st = (s == 5) | (s == 4 & faceCount[0] != 0 & faceCount[1] == 0)

   I st & fl
      R ‘straight-flush’
   E I f
      R ‘four-of-a-kind’
   E I p1 & t
      R ‘full-house’
   E I fl
      R ‘flush’
   E I st
      R ‘straight’
   E I t
      R ‘three-of-a-kind’
   E I p1 & p2
      R ‘two-pair’
   E I p1
      R ‘one-pair’
   E
      R ‘high-card’

F analyzeHand(inHand)
   V handLen = 5
   V face = ‘A23456789TJQK’
   V suit = ‘SHCD’
   V errorMessage = ‘invalid hand.’

   V hand = sorted(inHand.split(‘ ’))
   I hand.len != handLen
      R errorMessage
   I Set(hand).len != handLen
      R errorMessage‘ Duplicated cards.’

   V faceCount = [0] * face.len
   V suitCount = [0] * suit.len
   L(card) hand
      I card.len != 2
         R errorMessage
      V n = face.findi(card[0])
      V l = suit.findi(card[1])
      I n < 0 | l < 0
         R errorMessage
      faceCount[n]++
      suitCount[l]++

   R analyzeHandHelper(faceCount, suitCount)

L(hand) [‘2H 2D 2S KS QD’, ‘2H 5H 7D 8S 9D’, ‘AH 2D 3S 4S 5S’, ‘2H 3H 2D 3S 3D’, ‘2H 7H 2D 3S 3D’, ‘2H 7H 7D 7S 7C’, ‘TH JH QH KH AH’, ‘4H 4C KC 5D TC’, ‘QC TC 7C 6C 4C’]
   print((hand‘:’)‘ ’analyzeHand(hand))
===
template <typename T1, typename T2> auto analyzeHandHelper(const T1 &faceCount, const T2 &suitCount)
{
    auto p1 = false;
    auto p2 = false;
    auto t = false;
    auto f = false;
    auto fl = false;
    auto st = false;

    for (auto fc : faceCount)
        switch (fc)
        {
        case 2:
            if (p1)
                p2 = true;
            else
                p1 = true;
            break;
        case 3:
            t = true;
            break;
        case 4:
            f = true;
            break;
        }

    for (auto &&sc : suitCount)
        if (sc == 5)
            fl = true;

    if ((!p1) && (!p2) && (!t) && (!f)) {
        auto s = 0;
        for (auto &&fc : faceCount) {
            if (fc != 0)
                s++;
            else
                s = 0;
            if (s == 5)
                break;
        }

        st = (s == 5) || (s == 4 && _get<0>(faceCount) != 0 && _get<1>(faceCount) == 0);
    }

    if (st && fl)
        return u"straight-flush"_S;
    else if (f)
        return u"four-of-a-kind"_S;
    else if (p1 && t)
        return u"full-house"_S;
    else if (fl)
        return u"flush"_S;
    else if (st)
        return u"straight"_S;
    else if (t)
        return u"three-of-a-kind"_S;
    else if (p1 && p2)
        return u"two-pair"_S;
    else if (p1)
        return u"one-pair"_S;
    else
        return u"high-card"_S;
}

template <typename T1> auto analyzeHand(const T1 &inHand)
{
    auto handLen = 5;
    auto face = u"A23456789TJQK"_S;
    auto suit = u"SHCD"_S;
    auto errorMessage = u"invalid hand."_S;

    auto hand = sorted(inHand.split(u" "_S));
    if (hand.len() != handLen)
        return errorMessage;
    if (create_set(hand).len() != handLen)
        return errorMessage & u" Duplicated cards."_S;

    auto faceCount = create_array({0}) * face.len();
    auto suitCount = create_array({0}) * suit.len();
    for (auto &&card : hand) {
        if (card.len() != 2)
            return errorMessage;
        auto n = face.findi(_get<0>(card));
        auto l = suit.findi(_get<1>(card));
        if (n < 0 || l < 0)
            return errorMessage;
        faceCount[n]++;
        suitCount[l]++;
    }

    return analyzeHandHelper(faceCount, suitCount);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&hand : create_array({u"2H 2D 2S KS QD"_S, u"2H 5H 7D 8S 9D"_S, u"AH 2D 3S 4S 5S"_S, u"2H 3H 2D 3S 3D"_S, u"2H 7H 2D 3S 3D"_S, u"2H 7H 7D 7S 7C"_S, u"TH JH QH KH AH"_S, u"4H 4C KC 5D TC"_S, u"QC TC 7C 6C 4C"_S}))
            print((hand & u":"_S) & u" "_S & analyzeHand(hand));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Price_fraction#Python
def bisect_right(a, x):
    lo = 0
    hi = len(a)
    while lo < hi:
        mid = (lo+hi)//2
        if x < a[mid]: hi = mid
        else: lo = mid+1
    return lo

_cin  = [0.06, 0.11, 0.16, 0.21, 0.26, 0.31, 0.36, 0.41, 0.46, 0.51, 0.56, 0.61, 0.66, 0.71, 0.76, 0.81, 0.86, 0.91, 0.96, 1.01]
_cout = [0.10, 0.18, 0.26, 0.32, 0.38, 0.44, 0.50, 0.54, 0.58, 0.62, 0.66, 0.70, 0.74, 0.78, 0.82, 0.86, 0.90, 0.94, 0.98, 1.00]
def pricerounder(pricein):
    return _cout[ bisect_right(_cin, pricein) ]

for i in range(11):
    print('%.2f %.2f' % (i / 10, pricerounder(i / 10)))
===
F bisect_right(a, x)
   V lo = 0
   V hi = a.len
   L lo < hi
      V mid = (lo + hi) I/ 2
      I x < a[mid]
         hi = mid
      E
         lo = mid + 1
   R lo

V _cin = [0.06, 0.11, 0.16, 0.21, 0.26, 0.31, 0.36, 0.41, 0.46, 0.51, 0.56, 0.61, 0.66, 0.71, 0.76, 0.81, 0.86, 0.91, 0.96, 1.01]
V _cout = [0.10, 0.18, 0.26, 0.32, 0.38, 0.44, 0.50, 0.54, 0.58, 0.62, 0.66, 0.70, 0.74, 0.78, 0.82, 0.86, 0.90, 0.94, 0.98, 1.00]
F pricerounder(pricein)
   R :_cout[bisect_right(:_cin, pricein)]

L(i) 11
   print(‘#.2 #.2’.format(i / 10, pricerounder(i / 10)))
===
template <typename T1, typename T2> auto bisect_right(const T1 &a, const T2 &x)
{
    auto lo = 0;
    auto hi = a.len();
    while (lo < hi) {
        auto mid = idiv((lo + hi), 2);
        if (x < a[mid])
            hi = mid;
        else
            lo = mid + 1;
    }
    return lo;
}

auto _cin = create_array({0.06, 0.11, 0.16, 0.21, 0.26, 0.31, 0.36, 0.41, 0.46, 0.51, 0.56, 0.61, 0.66, 0.71, 0.76, 0.81, 0.86, 0.91, 0.96, 1.01});
auto _cout = create_array({0.10, 0.18, 0.26, 0.32, 0.38, 0.44, 0.50, 0.54, 0.58, 0.62, 0.66, 0.70, 0.74, 0.78, 0.82, 0.86, 0.90, 0.94, 0.98, 1.00});
template <typename T1> auto pricerounder(const T1 &pricein)
{
    return ::_cout[bisect_right(::_cin, pricein)];
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (int i = 0; i < 11; i++)
            print(u"#.2 #.2"_S.format(i / 10.0, pricerounder(i / 10.0)));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Primes_-_allocate_descendants_to_their_ancestors#Python
Int64 = int

maxsum = 99

def get_primes(max):
    # if max < 2:
    #     return []
    lprimes = [2]
    for x in range(3, max + 1, 2):
        for p in lprimes:
            if x % p == 0:
                break
        else:
            lprimes.append(x)
    return lprimes

descendants = [[Int64(0)]*0 for _ in range(maxsum + 1)]
ancestors = [[Int64(0)]*0 for _ in range(maxsum + 1)]

primes = get_primes(maxsum)

for p in primes:
    descendants[p].append(p)
    for s in range(1, len(descendants) - p):
        descendants[s + p] += [p * pr for pr in descendants[s]]

for p in primes + [4]:
    descendants[p].pop()

total = 0
for s in range(1, maxsum + 1):
    descendants[s].sort()
    for d in descendants[s]:
        if d > maxsum:
            break
        ancestors[int(d)] = ancestors[s] + [Int64(s)]
    print([s], "Level:", len(ancestors[s]))
    print("Ancestors:", str(ancestors[s]) if len(ancestors[s]) else "None")
    print("Descendants:", str(len(descendants[s])) if len(descendants[s]) else "None")
    if len(descendants[s]):
        print(descendants[s])
    print()
    total += len(descendants[s])

print("Total descendants", total)
===
V maxsum = 99

F get_primes(max)
   V lprimes = [2]
   L(x) (3 .. max).step(2)
      L(p) lprimes
         I x % p == 0
            L.break
      L.was_no_break
         lprimes.append(x)
   R lprimes

V descendants = [[Int64(0)] * 0] * (maxsum + 1)
V ancestors = [[Int64(0)] * 0] * (maxsum + 1)

V primes = get_primes(maxsum)

L(p) primes
   descendants[p].append(p)
   L(s) 1 .< descendants.len - p
      descendants[s + p] [+]= descendants[s].map(pr -> @p * pr)

L(p) primes [+] [4]
   descendants[p].pop()

V total = 0
L(s) 1 .. maxsum
   descendants[s].sort()
   L(d) descendants[s]
      I d > maxsum
         L.break
      ancestors[Int(d)] = ancestors[s] [+] [Int64(s)]
   print([s]‘ Level: ’ancestors[s].len)
   print(‘Ancestors: ’(I !ancestors[s].empty {String(ancestors[s])} E ‘None’))
   print(‘Descendants: ’(I !descendants[s].empty {String(descendants[s].len)} E ‘None’))
   I !descendants[s].empty
      print(descendants[s])
   print()
   total += descendants[s].len

print(‘Total descendants ’total)
===
auto maxsum = 99;

template <typename T1> auto get_primes(const T1 &max)
{
    auto lprimes = create_array({2});
    for (auto x : range_ee(3, max).step(2)) {
        for (auto &&p : lprimes)
            if (mod(x, p) == 0)
                goto break_;
        lprimes.append(x);
        break_:;
    }
    return lprimes;
}

auto descendants = create_array({create_array({to_int64(0)}) * 0}) * (maxsum + 1);
auto ancestors = create_array({create_array({to_int64(0)}) * 0}) * (maxsum + 1);

auto primes = get_primes(maxsum);

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&p : primes) {
            descendants[p].append(p);
            for (auto s : range_el(1, descendants.len() - p))
                descendants[s + p].append(descendants[s].map([&p](const auto &pr){return p * pr;}));
        }

        for (auto &&p : primes + create_array({4}))
            descendants[p].pop();
    }
} code_block_1;

auto total = 0;

struct CodeBlock2
{
    CodeBlock2()
    {
        for (auto s : range_ee(1, maxsum)) {
            descendants[s].sort();
            for (auto &&d : descendants[s]) {
                if (d > maxsum)
                    break;
                ancestors.set(to_int(d), ancestors[s] + create_array({to_int64(s)}));
            }
            print(create_array({s}) & u" Level: "_S & ancestors[s].len());
            print(u"Ancestors: "_S & (!ancestors[s].empty() ? String(ancestors[s]) : u"None"_S));
            print(u"Descendants: "_S & (!descendants[s].empty() ? String(descendants[s].len()) : u"None"_S));
            if (!descendants[s].empty())
                print(descendants[s]);
            print();
            total += descendants[s].len();
        }

        print(u"Total descendants "_S & total);
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Problem_of_Apollonius#Python
from typing import NamedTuple
import math

class Circle(NamedTuple):
    x : float
    y : float
    r : float
    def __str__(self):
        return 'Circle(x=%s, y=%s, r=%s)' % (self.x, self.y, self.r)

def solveApollonius(c1, c2, c3, s1, s2, s3):
    (x1, y1, r1) = c1
    (x2, y2, r2) = c2
    (x3, y3, r3) = c3

    v11 = 2*x2 - 2*x1
    v12 = 2*y2 - 2*y1
    v13 = x1*x1 - x2*x2 + y1*y1 - y2*y2 - r1*r1 + r2*r2
    v14 = 2*s2*r2 - 2*s1*r1

    v21 = 2*x3 - 2*x2
    v22 = 2*y3 - 2*y2
    v23 = x2*x2 - x3*x3 + y2*y2 - y3*y3 - r2*r2 + r3*r3
    v24 = 2*s3*r3 - 2*s2*r2

    w12 = v12/v11
    w13 = v13/v11
    w14 = v14/v11

    w22 = v22/v21-w12
    w23 = v23/v21-w13
    w24 = v24/v21-w14

    P = -w23/w22
    Q = w24/w22
    M = -w12*P-w13
    n = w14 - w12*Q

    a = n*n + Q*Q - 1
    b = 2*M*n - 2*n*x1 + 2*P*Q - 2*Q*y1 + 2*s1*r1
    c = x1*x1 + M*M - 2*M*x1 + P*P + y1*y1 - 2*P*y1 - r1*r1

    # Find a root of a quadratic equation. This requires the circle centers not to be e.g. colinear
    D = b*b-4*a*c
    rs = (-b-math.sqrt(D))/(2*a)

    xs = M+n*rs
    ys = P+Q*rs

    return Circle(xs, ys, rs)

(c1, c2, c3) = (Circle(0, 0, 1), Circle(4, 0, 1), Circle(2, 4, 2))
print(solveApollonius(c1, c2, c3, 1, 1, 1))    #Expects "Circle[x=2.00,y=2.10,r=3.90]" (green circle in image)
print(solveApollonius(c1, c2, c3, -1, -1, -1)) #Expects "Circle[x=2.00,y=0.83,r=1.17]" (red circle in image)
===
T Circle
   Float x
   Float y
   Float r
   F String()
      R ‘Circle(x=#., y=#., r=#.)’.format(.x, .y, .r)
   F (x, y, r)
      .x = x
      .y = y
      .r = r

F solveApollonius(c1, c2, c3, s1, s2, s3)
   V (x1, y1, r1) = c1
   V (x2, y2, r2) = c2
   V (x3, y3, r3) = c3

   V v11 = 2 * x2 - 2 * x1
   V v12 = 2 * y2 - 2 * y1
   V v13 = x1 * x1 - x2 * x2 + y1 * y1 - y2 * y2 - r1 * r1 + r2 * r2
   V v14 = 2 * s2 * r2 - 2 * s1 * r1

   V v21 = 2 * x3 - 2 * x2
   V v22 = 2 * y3 - 2 * y2
   V v23 = x2 * x2 - x3 * x3 + y2 * y2 - y3 * y3 - r2 * r2 + r3 * r3
   V v24 = 2 * s3 * r3 - 2 * s2 * r2

   V w12 = v12 / v11
   V w13 = v13 / v11
   V w14 = v14 / v11

   V w22 = v22 / v21 - w12
   V w23 = v23 / v21 - w13
   V w24 = v24 / v21 - w14

   V P = -w23 / w22
   V Q = w24 / w22
   V M = -w12 * P - w13
   V n = w14 - w12 * Q

   V a = n * n + Q * Q - 1
   V b = 2 * M * n - 2 * n * x1 + 2 * P * Q - 2 * Q * y1 + 2 * s1 * r1
   V c = x1 * x1 + M * M - 2 * M * x1 + P * P + y1 * y1 - 2 * P * y1 - r1 * r1

   V D = b * b - 4 * a * c
   V rs = (-b - sqrt(D)) / (2 * a)

   V xs = M + n * rs
   V ys = P + Q * rs

   R Circle(xs, ys, rs)

V (c1, c2, c3) = (Circle(0, 0, 1), Circle(4, 0, 1), Circle(2, 4, 2))
print(solveApollonius(c1, c2, c3, 1, 1, 1))
print(solveApollonius(c1, c2, c3, -1, -1, -1))
===
class Circle
{
public:
    double x;
    double y;
    double r;
    operator String() const
    {
        return u"Circle(x=#., y=#., r=#.)"_S.format(x, y, r);
    }
    template <typename T1, typename T2, typename T3> Circle(const T1 &x, const T2 &y, const T3 &r) :
        x(x),
        y(y),
        r(r)
    {
    }
};

template <typename T1, typename T2, typename T3, typename T4, typename T5, typename T6> auto solveApollonius(const T1 &c1, const T2 &c2, const T3 &c3, const T4 &s1, const T5 &s2, const T6 &s3)
{
    auto [x1, _y1_, r1] = c1;
    auto [x2, y2, r2] = c2;
    auto [x3, y3, r3] = c3;

    auto v11 = 2 * x2 - 2 * x1;
    auto v12 = 2 * y2 - 2 * _y1_;
    auto v13 = x1 * x1 - x2 * x2 + _y1_ * _y1_ - y2 * y2 - r1 * r1 + r2 * r2;
    auto v14 = 2 * s2 * r2 - 2 * s1 * r1;

    auto v21 = 2 * x3 - 2 * x2;
    auto v22 = 2 * y3 - 2 * y2;
    auto v23 = x2 * x2 - x3 * x3 + y2 * y2 - y3 * y3 - r2 * r2 + r3 * r3;
    auto v24 = 2 * s3 * r3 - 2 * s2 * r2;

    auto w12 = v12 / v11;
    auto w13 = v13 / v11;
    auto w14 = v14 / v11;

    auto w22 = v22 / v21 - w12;
    auto w23 = v23 / v21 - w13;
    auto w24 = v24 / v21 - w14;

    auto P = -w23 / w22;
    auto Q = w24 / w22;
    auto M = -w12 * P - w13;
    auto n = w14 - w12 * Q;

    auto a = n * n + Q * Q - 1;
    auto b = 2 * M * n - 2 * n * x1 + 2 * P * Q - 2 * Q * _y1_ + 2 * s1 * r1;
    auto c = x1 * x1 + M * M - 2 * M * x1 + P * P + _y1_ * _y1_ - 2 * P * _y1_ - r1 * r1;

    auto D = b * b - 4 * a * c;
    auto rs = (-b - sqrt(D)) / (2 * a);

    auto xs = M + n * rs;
    auto ys = P + Q * rs;

    return Circle(xs, ys, rs);
}

auto [c1, c2, c3] = make_tuple(Circle(0, 0, 1), Circle(4, 0, 1), Circle(2, 4, 2));

struct CodeBlock1
{
    CodeBlock1()
    {
        print(solveApollonius(c1, c2, c3, 1, 1, 1));
        print(solveApollonius(c1, c2, c3, -1, -1, -1));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Padovan_n-step_number_sequences#Nim
from typing import List

def rn(n, k) -> List[int]:
    assert k >= 2
    result = [1, 1, 1] if n == 2 else rn(n - 1, n + 1)
    while len(result) != k:
        result.append(sum(result[-n-1:-1]))
    return result

for n in range(2, 9):
    print(str(n) + ': ' + ' '.join('%3d' % it for it in rn(n, 15)))
===
F rn(n, k) -> [Int]
   assert(k >= 2)
   V result = I n == 2 {[1, 1, 1]} E rn(n - 1, n + 1)
   L result.len != k
      result.append(sum(result[(len)-n - 1 .< (len)-1]))
   R result

L(n) 2..8
   print(String(n)‘: ’rn(n, 15).map(it -> ‘#3’.format(it)).join(‘ ’))
===
template <typename T1, typename T2> Array<int> rn(const T1 &n, const T2 &k)
{
    assert(k >= 2);
    auto result = n == 2 ? create_array({1, 1, 1}) : rn(n - 1, n + 1);
    while (result.len() != k)
        result.append(sum(result[range_elen_llen( - n - 1,  - 1)]));
    return result;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto n : range_ee(2, 8))
            print(String(n) & u": "_S & rn(n, 15).map([](const auto &it){return u"#3"_S.format(it);}).join(u" "_S));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Padovan_sequence#Nim
pp = 1.324717957244746025960908854
ss = 1.0453567932525329623
Rules = {'A': "B", 'B': "C", 'C': "AB"}

def padovan1(n):
    r = [1] * min(n, 3)
    (a, b, c) = (1, 1, 1)
    count = 3
    while count < n:
        (a, b, c) = (b, c, a + b)
        r += [c]
        count += 1
    return r

def padovan2(n):
    r = [1] * (n > 1)
    p = 1.0
    count = 1
    while count < n:
        r += [int(round(p / ss))]
        p *= pp
        count += 1
    return r

def padovan3(n):
    r : List[str] = []
    s = 'A'
    count = 0
    while count < n:
        r += [s]
        next = ''
        for ch in s:
            next += Rules[ch]
        s = next
        count += 1
    return r

print('First 20 terms of the Padovan sequence:')
print(' '.join(map(str, padovan1(20))))

list1 = padovan1(64)
list2 = padovan2(64)
print('The first 64 iterative and calculated values', 'are the same.' if list1 == list2 else 'differ.')

print()
print('First 10 L-system strings:')
print(' '.join(padovan3(10)))
print()
print('Lengths of the 32 first L-system strings:')
list3 = [len(x) for x in padovan3(32)]
print(' '.join(map(str, list3)))
print('These lengths are', ' ' if list3 == list1[:32] else ' not ', 'the 32 first terms of the Padovan sequence.', sep = '')
===
V pp = 1.324717957244746025960908854
V ss = 1.0453567932525329623
V Rules = [‘A’ = ‘B’, ‘B’ = ‘C’, ‘C’ = ‘AB’]

F padovan1(n)
   V r = [1] * min(n, 3)
   V (a, b, c) = (1, 1, 1)
   V count = 3
   L count < n
      (a, b, c) = (b, c, a + b)
      r [+]= c
      count++
   R r

F padovan2(n)
   V r = [1] * (n > 1)
   V p = 1.0
   V count = 1
   L count < n
      r [+]= Int(round(p / :ss))
      p *= :pp
      count++
   R r

F padovan3(n)
   [String] r
   V s = ‘A’
   V count = 0
   L count < n
      r [+]= s
      V next = ‘’
      L(ch) s
         next ‘’= Rules[ch]
      s = next
      count++
   R r

print(‘First 20 terms of the Padovan sequence:’)
print(padovan1(20).map(String).join(‘ ’))

V list1 = padovan1(64)
V list2 = padovan2(64)
print(‘The first 64 iterative and calculated values ’(I list1 == list2 {‘are the same.’} E ‘differ.’))

print()
print(‘First 10 L-system strings:’)
print(padovan3(10).join(‘ ’))
print()
print(‘Lengths of the 32 first L-system strings:’)
V list3 = padovan3(32).map(x -> x.len)
print(list3.map(String).join(‘ ’))
print(‘These lengths are’(I list3 == list1[0.<32] {‘ ’} E ‘ not ’)‘the 32 first terms of the Padovan sequence.’)
===
auto pp = 1.324717957244746025960908854;
auto ss = 1.0453567932525329623;
auto Rules = create_dict(dict_of(u'A'_C, u"B"_S)(u'B'_C, u"C"_S)(u'C'_C, u"AB"_S));

template <typename T1> auto padovan1(const T1 &n)
{
    auto r = create_array({1}) * min(n, 3);
    auto [a, b, c] = make_tuple(1, 1, 1);
    auto count = 3;
    while (count < n) {
        assign_from_tuple(a, b, c, make_tuple(b, c, a + b));
        r.append(c);
        count++;
    }
    return r;
}

template <typename T1> auto padovan2(const T1 &n)
{
    auto r = create_array({1}) * (n > 1);
    auto p = 1.0;
    auto count = 1;
    while (count < n) {
        r.append(to_int(round(p / ::ss)));
        p *= ::pp;
        count++;
    }
    return r;
}

template <typename T1> auto padovan3(const T1 &n)
{
    Array<String> r;
    auto s = u"A"_S;
    auto count = 0;
    while (count < n) {
        r.append(s);
        auto next = u""_S;
        for (auto &&ch : s)
            next &= Rules[ch];
        s = next;
        count++;
    }
    return r;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"First 20 terms of the Padovan sequence:"_S);
        print(padovan1(20).map([](const auto &x){return String(x);}).join(u" "_S));
    }
} code_block_1;

auto list1 = padovan1(64);
auto list2 = padovan2(64);

struct CodeBlock2
{
    CodeBlock2()
    {
        print(u"The first 64 iterative and calculated values "_S & (list1 == list2 ? u"are the same."_S : u"differ."_S));

        print();
        print(u"First 10 L-system strings:"_S);
        print(padovan3(10).join(u" "_S));
        print();
        print(u"Lengths of the 32 first L-system strings:"_S);
    }
} code_block_2;

auto list3 = padovan3(32).map([](const auto &x){return x.len();});

struct CodeBlock3
{
    CodeBlock3()
    {
        print(list3.map([](const auto &x){return String(x);}).join(u" "_S));
        print(u"These lengths are"_S & (list3 == list1[range_el(0, 32)] ? u" "_S : u" not "_S) & u"the 32 first terms of the Padovan sequence."_S);
    }
} code_block_3;


# https://www.rosettacode.org/wiki/Palindromic_primes
import math

def is_prime(a):
    if a == 2: return True
    if a < 2 or a % 2 == 0: return False
    for i in range(3, int(math.sqrt(a)) + 1, 2):
        if a % i == 0:
            return False
    return True

for n in range(1000):
    if is_prime(n):
        s = str(n)
        if s == s[::-1]:
            print(n, end = ' ')
print()
===
F is_prime(a)
   I a == 2
      R 1B
   I a < 2 | a % 2 == 0
      R 0B
   L(i) (3 .. Int(sqrt(a))).step(2)
      I a % i == 0
         R 0B
   R 1B

L(n) 1000
   I is_prime(n)
      V s = String(n)
      I s == reversed(s)
         print(n, end' ‘ ’)
print()
===
template <typename T1> auto is_prime(const T1 &a)
{
    if (a == 2)
        return true;
    if (a < 2 || mod(a, 2) == 0)
        return false;
    for (auto i : range_ee(3, to_int(sqrt(a))).step(2))
        if (mod(a, i) == 0)
            return false;
    return true;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (int n = 0; n < 1000; n++)
            if (is_prime(n)) {
                auto s = String(n);
                if (s == reversed(s))
                    print(n, u" "_S);
            }
        print();
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Paraffins#Nim
BigInt = int

nMax = 250
nBranches = 4
rooted = [BigInt(0)] * (nMax + 1)
unrooted = [BigInt(0)] * (nMax + 1)
rooted[0] = BigInt(1)
rooted[1] = BigInt(1)
unrooted[0] = BigInt(1)
unrooted[1] = BigInt(1)

def choose(m, k):
    if k == 1:
        return m
    result = m
    for i in range(1, k):
        result = result * (m + i) // (i + 1)
    return result

def tree(br, n, l, sum, cnt):
    s = 0
    for b in range(br + 1, nBranches + 1):
        s = sum + (b - br) * n
        if s > nMax: return

        c = choose(rooted[n], b - br) * cnt

        if l * 2 < s: unrooted[s] += c
        if b == nBranches: return
        rooted[s] += c
        for m in range(n-1, 0, -1):
            tree(b, m, l, s, c)

def bicenter(s):
    if (s & 1) == 0:
        unrooted[s] += rooted[s // 2] * (rooted[s // 2] + 1) // 2

for n in range(1, nMax + 1):
    tree(0, n, n, 1, BigInt(1))
    bicenter(n)
    print(n, ": ", unrooted[n], sep = '')
===
V nMax = 250
V nBranches = 4
V rooted = [BigInt(0)] * (nMax + 1)
V unrooted = [BigInt(0)] * (nMax + 1)
rooted[0] = BigInt(1)
rooted[1] = BigInt(1)
unrooted[0] = BigInt(1)
unrooted[1] = BigInt(1)

F choose(m, k)
   I k == 1
      R m
   V result = m
   L(i) 1 .< k
      result = result * (m + i) I/ (i + 1)
   R result

F tree(br, n, l, sum, cnt)
   V s = 0
   L(b) br + 1 .. :nBranches
      s = sum + (b - br) * n
      I s > :nMax
         R

      V c = choose(:rooted[n], b - br) * cnt

      I l * 2 < s
         :unrooted[s] += c
      I b == :nBranches
         R
      :rooted[s] += c
      L(m) (n - 1 .< 0).step(-1)
         tree(b, m, l, s, c)

F bicenter(s)
   I (s [&] 1) == 0
      :unrooted[s] += :rooted[s I/ 2] * (:rooted[s I/ 2] + 1) I/ 2

L(n) 1 .. nMax
   tree(0, n, n, 1, BigInt(1))
   bicenter(n)
   print(n‘: ’unrooted[n])
===
auto nMax = 250;
auto nBranches = 4;
auto rooted = create_array({BigInt(0)}) * (nMax + 1);
auto unrooted = create_array({BigInt(0)}) * (nMax + 1);

struct CodeBlock1
{
    CodeBlock1()
    {
        _set<0>(rooted, BigInt(1));
        _set<1>(rooted, BigInt(1));
        _set<0>(unrooted, BigInt(1));
        _set<1>(unrooted, BigInt(1));
    }
} code_block_1;

template <typename T1, typename T2> auto choose(const T1 &m, const T2 &k)
{
    if (k == 1)
        return m;
    auto result = m;
    for (auto i : range_el(1, k))
        result = idiv(result * (m + i), (i + 1));
    return result;
}

template <typename T1, typename T2, typename T3, typename T4, typename T5> auto tree(const T1 &br, const T2 &n, const T3 &l, const T4 &sum, const T5 &cnt)
{
    auto s = 0;
    for (auto b : range_ee(br + 1, ::nBranches)) {
        s = sum + (b - br) * n;
        if (s > ::nMax)
            return;

        auto c = choose(::rooted[n], b - br) * cnt;

        if (l * 2 < s)
            ::unrooted[s] += c;
        if (b == ::nBranches)
            return;
        ::rooted[s] += c;
        for (auto m : range_el(n - 1, 0).step(-1))
            tree(b, m, l, s, c);
    }
}

template <typename T1> auto bicenter(const T1 &s)
{
    if ((s & 1) == 0)
        ::unrooted[s] += idiv(::rooted[idiv(s, 2)] * (::rooted[idiv(s, 2)] + 1), 2);
}

struct CodeBlock2
{
    CodeBlock2()
    {
        for (auto n : range_ee(1, nMax)) {
            tree(0, n, n, 1, BigInt(1));
            bicenter(n);
            print(n & u": "_S & unrooted[n]);
        }
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Partial_function_application#Python
def partial(f, g):
    def fg(x): return f(g, x)
    return fg

def main():
    def ffs(f, x): return [f(a) for a in x]
    def f1(a): return a * 2
    def f2(a): return a * a

    fsf1 = partial(ffs, f1)
    fsf2 = partial(ffs, f2)

    print(fsf1([1, 2, 3, 4]))
    print(fsf2([1, 2, 3, 4]))

main()
===
F partial(f, g)
   F fg(x)
      R @f(@g, x)
   R fg

F main()
   F ffs(f, x)
      R x.map(a -> @f(a))
   F f1(a)
      R a * 2
   F f2(a)
      R a * a

   V fsf1 = partial(ffs, f1)
   V fsf2 = partial(ffs, f2)

   print(fsf1([1, 2, 3, 4]))
   print(fsf2([1, 2, 3, 4]))

main()
===
template <typename T1, typename T2> auto partial(const T1 &f, const T2 &g)
{
    auto fg = [&f, &g](const auto &x)
    {
        return f(g, x);
    };
    return fg;
}

auto _main_()
{
    auto ffs = [](const auto &f, const auto &x)
    {
        return x.map([&f](const auto &a){return f(a);});
    };
    auto f1 = [](const auto &a)
    {
        return a * 2;
    };
    auto f2 = [](const auto &a)
    {
        return a * a;
    };

    auto fsf1 = partial(ffs, f1);
    auto fsf2 = partial(ffs, f2);

    print(fsf1(create_array({1, 2, 3, 4})));
    print(fsf2(create_array({1, 2, 3, 4})));
}

struct CodeBlock1
{
    CodeBlock1()
    {
        _main_();
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Penney%27s_game#Python
import random, time

first = random.choice([True, False])

you = ''
me = ''
ht = 'HT' # to get round ‘bug in MSVC 2017’[https://developercommunity.visualstudio.com/t/bug-with-operator-in-c/565417]
if first:
    me = ''.join(random.sample(list('HT'*3), 3))
    print('I choose first and will win on first seeing {} in the list of tosses'.format(me))
    while len(you) != 3 or any(ch not in ht for ch in you) or you == me:
        you = input('What sequence of three Heads/Tails will you win with: ')
else:
    while len(you) != 3 or any(ch not in ht for ch in you):
        you = input('After you: What sequence of three Heads/Tails will you win with: ')
    me = ('H' if you[1] == 'T' else 'T') + you[:2]
    print('I win on first seeing {} in the list of tosses'.format(me))

print('Rolling:\n  ', end='')
rolled = ''
while True:
    rolled += random.choice('HT')
    print(rolled[-1], end='')
    if rolled.endswith(you):
        print('\n  You win!')
        break
    if rolled.endswith(me):
        print('\n  I win!')
        break
    time.sleep(1)    # For dramatic effect
===
V first = random:choice([1B, 0B])

V you = ‘’
V me = ‘’
V ht = ‘HT’
I first
   me = random:sample(Array(‘HT’ * 3), 3).join(‘’)
   print(‘I choose first and will win on first seeing #. in the list of tosses’.format(me))
   L you.len != 3 | any(you.map(ch -> ch !C :ht)) | you == me
      you = input(‘What sequence of three Heads/Tails will you win with: ’)
E
   L you.len != 3 | any(you.map(ch -> ch !C :ht))
      you = input(‘After you: What sequence of three Heads/Tails will you win with: ’)
   me = (I you[1] == ‘T’ {‘H’} E ‘T’)‘’you[0.<2]
   print(‘I win on first seeing #. in the list of tosses’.format(me))

print("Rolling:\n  ", end' ‘’)
V rolled = ‘’
L
   rolled ‘’= random:choice(‘HT’)
   print(rolled.last, end' ‘’)
   I rolled.ends_with(you)
      print("\n  You win!")
      L.break
   I rolled.ends_with(me)
      print("\n  I win!")
      L.break
   sleep(1)
===
auto first = randomns::choice(create_array({true, false}));

auto you = u""_S;
auto me = u""_S;
auto ht = u"HT"_S;

struct CodeBlock1
{
    CodeBlock1()
    {
        if (first) {
            me = randomns::sample(create_array(u"HT"_S * 3), 3).join(u""_S);
            print(u"I choose first and will win on first seeing #. in the list of tosses"_S.format(me));
            while (you.len() != 3 || any_map(you, [](const auto &ch){return !in(ch, ::ht);}) || you == me)
                you = input(u"What sequence of three Heads/Tails will you win with: "_S);
        }
        else {
            while (you.len() != 3 || any_map(you, [](const auto &ch){return !in(ch, ::ht);}))
                you = input(u"After you: What sequence of three Heads/Tails will you win with: "_S);
            me = (_get<1>(you) == u'T' ? u"H"_S : u"T"_S) & you[range_el(0, 2)];
            print(u"I win on first seeing #. in the list of tosses"_S.format(me));
        }

        print(u"Rolling:\n  "_S, u""_S);
    }
} code_block_1;

auto rolled = u""_S;

struct CodeBlock2
{
    CodeBlock2()
    {
        while (true) {
            rolled &= randomns::choice(u"HT"_S);
            print(rolled.last(), u""_S);
            if (rolled.ends_with(you)) {
                print(u"\n  You win!"_S);
                break;
            }
            if (rolled.ends_with(me)) {
                print(u"\n  I win!"_S);
                break;
            }
            sleep(1);
        }
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Perceptron#Python
from typing import List
import random
Char = str

TRAINING_LENGTH = 2000

class Perceptron:
    c = .01
    weights : List[float]

    def __init__(self,n):
        self.weights = [random.uniform(-1.0, 1.0) for _ in range(n)]

    def feed_forward(self, inputs):
        vars : List[float] = []
        for i in range(len(inputs)):
            vars.append(inputs[i] * self.weights[i])
        return self.activate(sum(vars))

    def activate(self, value):
        return 1 if value > 0 else -1

    def train(self, inputs, desired):
        guess = self.feed_forward(inputs)
        error = desired - guess
        for i in range(len(inputs)):
            self.weights[i] += self.c * error * inputs[i]

class Trainer:
    inputs : List[float]
    answer : int

    def __init__(self, x, y, a):
        self.inputs = [x, y, 1.0]
        self.answer = a

def f(x):
    return 2 * x + 1

ptron = Perceptron(3)
training : List[Trainer] = []
for i in range(TRAINING_LENGTH):
    x = random.uniform(-10.0, 10.0)
    y = random.uniform(-10.0, 10.0)
    answer = 1
    if y < f(x): answer = -1
    training.append(Trainer(x,y,answer))
result : List[List[Char]] = []
for y in range(-10,10):
    temp : List[Char] = []
    for x in range(-10,10):
        if ptron.feed_forward([x,y,1]) == 1:
            temp.append(Char('^'))
        else:
            temp.append(Char('.'))
    result.append(temp)

print('Untrained')
for row in result:
    print(''.join(v for v in row))

for t in training:
    ptron.train(t.inputs, t.answer)

result.clear()
for y in range(-10,10):
    temp : List[Char] = []
    for x in range(-10,10):
        if ptron.feed_forward([x,y,1]) == 1:
            temp.append(Char('^'))
        else:
            temp.append(Char('.'))
    result.append(temp)

print('Trained')
for row in result:
    print(''.join(v for v in row))
===
V TRAINING_LENGTH = 2000

T Perceptron
   c = .01
   [Float] weights

   F (n)
      .weights = (0 .< n).map(_ -> random:(-1.0 .. 1.0))

   F feed_forward(inputs)
      [Float] vars
      L(i) 0 .< inputs.len
         vars.append(inputs[i] * .weights[i])
      R .activate(sum(vars))

   F activate(value)
      R I value > 0 {1} E -1

   F train(inputs, desired)
      V guess = .feed_forward(inputs)
      V error = desired - guess
      L(i) 0 .< inputs.len
         .weights[i] += .c * error * inputs[i]

T Trainer
   [Float] inputs
   Int answer

   F (x, y, a)
      .inputs = [x, y, 1.0]
      .answer = a

F f(x)
   R 2 * x + 1

V ptron = Perceptron(3)
[Trainer] training
L(i) 0 .< TRAINING_LENGTH
   V x = random:(-10.0 .. 10.0)
   V y = random:(-10.0 .. 10.0)
   V answer = 1
   I y < f(x)
      answer = -1
   training.append(Trainer(x, y, answer))
[[Char]] result
L(y) -10 .< 10
   [Char] temp
   L(x) -10 .< 10
      I ptron.feed_forward([x, y, 1]) == 1
         temp.append(Char(‘^’))
      E
         temp.append(Char(‘.’))
   result.append(temp)

print(‘Untrained’)
L(row) result
   print(row.join(‘’))

L(t) training
   ptron.train(t.inputs, t.answer)

result.clear()
L(y) -10 .< 10
   [Char] temp
   L(x) -10 .< 10
      I ptron.feed_forward([x, y, 1]) == 1
         temp.append(Char(‘^’))
      E
         temp.append(Char(‘.’))
   result.append(temp)

print(‘Trained’)
L(row) result
   print(row.join(‘’))
===
auto TRAINING_LENGTH = 2000;

class Perceptron
{
public:
    decltype(.01) c = .01;
    Array<double> weights;

    template <typename T1> Perceptron(const T1 &n)
    {
        weights = range_el(0, n).map([](const auto &_){return randomns::_(range_ee(-1.0, 1.0));});
    }

    template <typename T1> auto feed_forward(const T1 &inputs)
    {
        Array<double> vars;
        for (auto i : range_el(0, inputs.len()))
            vars.append(inputs[i] * weights[i]);
        return activate(sum(vars));
    }

    template <typename T1> auto activate(const T1 &value)
    {
        return value > 0 ? 1 : -1;
    }

    template <typename T1, typename T2> auto train(const T1 &inputs, const T2 &desired)
    {
        auto guess = feed_forward(inputs);
        auto error = desired - guess;
        for (auto i : range_el(0, inputs.len()))
            weights[i] += c * error * inputs[i];
    }
};

class Trainer
{
public:
    Array<double> inputs;
    int answer;

    template <typename T1, typename T2, typename T3> Trainer(const T1 &x, const T2 &y, const T3 &a) :
        answer(a)
    {
        inputs = create_array({x, y, 1.0});
    }
};

template <typename T1> auto f(const T1 &x)
{
    return 2 * x + 1;
}

auto ptron = Perceptron(3);
Array<Trainer> training;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto i : range_el(0, TRAINING_LENGTH)) {
            auto x = randomns::_(range_ee(-10.0, 10.0));
            auto y = randomns::_(range_ee(-10.0, 10.0));
            auto answer = 1;
            if (y < f(x))
                answer = -1;
            training.append(Trainer(x, y, answer));
        }
    }
} code_block_1;

Array<Array<Char>> result;

struct CodeBlock2
{
    CodeBlock2()
    {
        for (auto y : range_el(-10, 10)) {
            Array<Char> temp;
            for (auto x : range_el(-10, 10))
                if (ptron.feed_forward(create_array({x, y, 1})) == 1)
                    temp.append(u'^'_C);
                else
                    temp.append(u'.'_C);
            result.append(temp);
        }

        print(u"Untrained"_S);
        for (auto &&row : result)
            print(row.join(u""_S));

        for (auto &&t : training)
            ptron.train(t.inputs, t.answer);

        result.clear();
        for (auto y : range_el(-10, 10)) {
            Array<Char> temp;
            for (auto x : range_el(-10, 10))
                if (ptron.feed_forward(create_array({x, y, 1})) == 1)
                    temp.append(u'^'_C);
                else
                    temp.append(u'.'_C);
            result.append(temp);
        }

        print(u"Trained"_S);
        for (auto &&row : result)
            print(row.join(u""_S));
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Percolation/Bond_percolation#Python
from typing import NamedTuple, List, Tuple, Optional, Dict
UInt32 = int

seed : UInt32 = 0
def nonrandom():
    global seed
    seed = (1664525 * seed + 1013904223) & 0xFFFF_FFFF
    return (seed >> 16) / float(0xFFFF)

class Grid(NamedTuple):
    cell : List[List[int]]
    hwall : List[List[int]]
    vwall : List[List[int]]

(M, nn, t) = (10, 10, 100)

class PercolatedException(Exception):
    t : Tuple[int, int]

    def __init__(self, t):
        self.t = t

HVF = ([' .', ' _'], [':', '|'], [' ', '#'])  # Horiz, vert, fill chars

def newgrid(p):
    hwall = [[int(nonrandom() < p) for m in range(M)]
             for n in range(nn+1)]
    vwall = [[(1 if m in (0, M) else int(nonrandom() < p)) for m in range(M+1)]
             for n in range(nn)]
    cell = [[0 for m in range(M)]
             for n in range(nn)]
    return Grid(cell, hwall, vwall)

def pgrid(grid, percolated):
    (cell, hwall, vwall) = grid
    (h, v, f) = HVF
    for n in range(nn):
        print('    ' + ''.join(h[hwall[n][m]] for m in range(M)))
        print('%i)  ' % (n % 10) + ''.join(v[vwall[n][m]] + '' + f[cell[n][m] if m < M else 0]
                                          for m in range(M+1))[:-1])
    n = nn
    print('    ' + ''.join(h[hwall[n][m]] for m in range(M)))
    if percolated != (-1, -1):
        where = percolated[0]
        print('!)  ' + '  ' * where + ' ' + f[1])

def flood_fill(m, n, cell : list, hwall, vwall) -> None:
    # fill cell
    cell[n][m] = 1
    # bottom
    if n < nn - 1 and not hwall[n + 1][m] and not cell[n+1][m]:
        flood_fill(m, n+1, cell, hwall, vwall)
    # THE bottom
    elif n == nn - 1 and not hwall[n + 1][m]:
        raise PercolatedException((m, n+1))
    # left
    if m and not vwall[n][m] and not cell[n][m - 1]:
        flood_fill(m-1, n, cell, hwall, vwall)
    # right
    if m < M - 1 and not vwall[n][m + 1] and not cell[n][m + 1]:
        flood_fill(m+1, n, cell, hwall, vwall)
    # top
    if n != 0 and not hwall[n][m] and not cell[n-1][m]:
        flood_fill(m, n-1, cell, hwall, vwall)

def pour_on_top(grid : "Grid") -> Optional[Tuple[int, int]]:
    n = 0
    try:
        for m in range(M):
            if grid.hwall[n][m] == 0:
                flood_fill(m, n, grid.cell, grid.hwall, grid.vwall)
    except PercolatedException as ex:
        return ex.t
    return None

sample_printed = False
pcount : Dict[float, int] = {}
for p10 in range(11):
    p = (10 - p10) / 10.0    # count down so sample print is interesting
    pcount[p] = 0
    for tries in range(t):
        grid = newgrid(p)
        percolated : Optional[Tuple[int, int]] = pour_on_top(grid)
        if percolated is not None:
            pcount[p] += 1
            if not sample_printed:
                print('\nSample percolating %i x %i grid' % (M, nn))
                pgrid(grid, percolated if percolated is not None else (-1, -1))
                sample_printed = True
print('\n p: Fraction of %i tries that percolate through' % t )

for p, c in sorted(pcount.items()):
    print('%.1f: %s' % (p, c/float(t)))
===
UInt32 seed = 0
F nonrandom()
   :seed = (1664525 * :seed + 1013904223) [&] FFFF'FFFF
   R (:seed >> 16) / Float(FF'FF)

T Grid
   [[Int]] cell
   [[Int]] hwall
   [[Int]] vwall
   F (cell, hwall, vwall)
      .cell = cell
      .hwall = hwall
      .vwall = vwall

V (M, nn, t) = (10, 10, 100)

T PercolatedException
   (Int, Int) t

   F (t)
      .t = t

V HVF = ([‘ .’, ‘ _’], [‘:’, ‘|’], [‘ ’, ‘#’])

F newgrid(p)
   V hwall = (0 .. :nn).map(n -> (0 .< :M).map(m -> Int(nonrandom() < @@p)))
   V vwall = (0 .< :nn).map(n -> (0 .. :M).map(m -> (I m C (0, :M) {1} E Int(nonrandom() < @@p))))
   V cell = (0 .< :nn).map(n -> (0 .< :M).map(m -> 0))
   R Grid(cell, hwall, vwall)

F pgrid(grid, percolated)
   V (cell, hwall, vwall) = grid
   V (h, v, f) = :HVF
   L(n) 0 .< :nn
      print(‘    ’(0 .< :M).map(m -> @h[@hwall[@n][m]]).join(‘’))
      print(‘#.)  ’.format(n % 10)‘’(0 .. :M).map(m -> @v[@vwall[@n][m]]‘’@f[I m < :M {@cell[@n][m]} E 0]).join(‘’)[0 .< (len)-1])
   V n = :nn
   print(‘    ’(0 .< :M).map(m -> @h[@hwall[@n][m]]).join(‘’))
   I percolated != (-1, -1)
      V where = percolated[0]
      print(‘!)  ’(‘  ’ * where)‘ ’f[1])

F flood_fill(m, n, &cell, hwall, vwall) -> N
   cell[n][m] = 1
   I n < :nn - 1 & !hwall[n + 1][m] & !cell[n + 1][m]
      flood_fill(m, n + 1, &cell, hwall, vwall)
   E I n == :nn - 1 & !hwall[n + 1][m]
      X PercolatedException((m, n + 1))
   I m & !vwall[n][m] & !cell[n][m - 1]
      flood_fill(m - 1, n, &cell, hwall, vwall)
   I m < :M - 1 & !vwall[n][m + 1] & !cell[n][m + 1]
      flood_fill(m + 1, n, &cell, hwall, vwall)
   I n != 0 & !hwall[n][m] & !cell[n - 1][m]
      flood_fill(m, n - 1, &cell, hwall, vwall)

F pour_on_top(Grid &grid) -> (Int, Int)?
   V n = 0
   X.try
      L(m) 0 .< :M
         I grid.hwall[n][m] == 0
            flood_fill(m, n, &grid.cell, grid.hwall, grid.vwall)
   X.catch PercolatedException ex
      R ex.t
   R N

V sample_printed = 0B
[Float = Int] pcount
L(p10) 11
   V p = (10 - p10) / 10.0
   pcount[p] = 0
   L(tries) 0 .< t
      V grid = newgrid(p)
      (Int, Int)? percolated = pour_on_top(&grid)
      I percolated != N
         pcount[p]++
         I !sample_printed
            print("\nSample percolating #. x #. grid".format(M, nn))
            pgrid(grid, percolated ? (-1, -1))
            sample_printed = 1B
print("\n p: Fraction of #. tries that percolate through".format(t))

L(p, c) sorted(pcount.items())
   print(‘#.1: #.’.format(p, c / Float(t)))
===
uint32_t seed = 0;
auto nonrandom()
{
    ::seed = (1664525 * ::seed + 1013904223) & 0xFFFF'FFFF;
    return (::seed >> 16) / to_float(0xFF'FF);
}

class Grid
{
public:
    Array<Array<int>> cell;
    Array<Array<int>> hwall;
    Array<Array<int>> vwall;
    template <typename T1, typename T2, typename T3> Grid(const T1 &cell, const T2 &hwall, const T3 &vwall) :
        cell(cell),
        hwall(hwall),
        vwall(vwall)
    {
    }
};

auto [M, nn, t] = make_tuple(10, 10, 100);

class PercolatedException
{
public:
    ivec2 t;

    template <typename T1> PercolatedException(const T1 &t) :
        t(t)
    {
    }
};

auto HVF = make_tuple(create_array({u" ."_S, u" _"_S}), create_array({u':'_C, u'|'_C}), create_array({u' '_C, u'#'_C}));

template <typename T1> auto newgrid(const T1 &p)
{
    auto hwall = range_ee(0, ::nn).map([&p](const auto &n){return range_el(0, ::M).map([&p](const auto &m){return to_int(nonrandom() < p);});});
    auto vwall = range_el(0, ::nn).map([&p](const auto &n){return range_ee(0, ::M).map([&p](const auto &m){return (in(m, make_tuple(0, ::M)) ? 1 : to_int(nonrandom() < p));});});
    auto cell = range_el(0, ::nn).map([](const auto &n){return range_el(0, ::M).map([](const auto &m){return 0;});});
    return Grid(cell, hwall, vwall);
}

template <typename T1, typename T2> auto pgrid(const T1 &grid, const T2 &percolated)
{
    auto [cell, hwall, vwall] = grid;
    auto [h, v, f] = ::HVF;
    for (auto n : range_el(0, ::nn)) {
        print(u"    "_S & range_el(0, ::M).map([&h, &hwall, &n](const auto &m){return h[hwall[n][m]];}).join(u""_S));
        print(u"#.)  "_S.format(mod(n, 10)) & range_ee(0, ::M).map([&cell, &f, &n, &v, &vwall](const auto &m){return v[vwall[n][m]] & f[m < ::M ? cell[n][m] : 0];}).join(u""_S)[range_e_llen(0,  - 1)]);
    }
    auto n = ::nn;
    print(u"    "_S & range_el(0, ::M).map([&h, &hwall, &n](const auto &m){return h[hwall[n][m]];}).join(u""_S));
    if (percolated != make_tuple(-1, -1)) {
        auto where = _get<0>(percolated);
        print(u"!)  "_S & (u"  "_S * where) & u" "_S & _get<1>(f));
    }
}

template <typename T1, typename T2, typename T3, typename T4, typename T5> void flood_fill(const T1 &m, const T2 &n, T3 &cell, const T4 &hwall, const T5 &vwall)
{
    cell[n].set(m, 1);
    if (n < ::nn - 1 && !hwall[n + 1][m] && !cell[n + 1][m])
        flood_fill(m, n + 1, cell, hwall, vwall);
    else if (n == ::nn - 1 && !hwall[n + 1][m])
        throw PercolatedException(make_tuple(m, n + 1));
    if (m && !vwall[n][m] && !cell[n][m - 1])
        flood_fill(m - 1, n, cell, hwall, vwall);
    if (m < ::M - 1 && !vwall[n][m + 1] && !cell[n][m + 1])
        flood_fill(m + 1, n, cell, hwall, vwall);
    if (n != 0 && !hwall[n][m] && !cell[n - 1][m])
        flood_fill(m, n - 1, cell, hwall, vwall);
}

Nullable<ivec2> pour_on_top(Grid &grid)
{
    auto n = 0;
    try
    {
        for (auto m : range_el(0, ::M))
            if (grid.hwall[n][m] == 0)
                flood_fill(m, n, grid.cell, grid.hwall, grid.vwall);
    }
    catch (const PercolatedException& ex)
    {
        return ex.t;
    }
    return nullptr;
}

auto sample_printed = false;
Dict<double, int> pcount;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (int p10 = 0; p10 < 11; p10++) {
            auto p = (10 - p10) / 10.0;
            pcount.set(p, 0);
            for (auto tries : range_el(0, t)) {
                auto grid = newgrid(p);
                Nullable<ivec2> percolated = pour_on_top(grid);
                if (percolated != nullptr) {
                    pcount[p]++;
                    if (!sample_printed) {
                        print(u"\nSample percolating #. x #. grid"_S.format(M, nn));
                        pgrid(grid, [&]{auto R = percolated; return R != nullptr ? *R : make_tuple(-1, -1);}());
                        sample_printed = true;
                    }
                }
            }
        }
        print(u"\n p: Fraction of #. tries that percolate through"_S.format(t));

        for (auto &&[p, c] : sorted(pcount.items()))
            print(u"#.1: #."_S.format(p, c / to_float(t)));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Percolation/Mean_run_density#Python
UInt32 = int

seed : UInt32 = 0
def nonrandom():
    global seed
    seed = (1664525 * seed + 1013904223) & 0xFFFF_FFFF
    return (seed >> 16) / float(0xFFFF)

(p, t) = (0.5, 500)

def newv(n, p):
    return [int(nonrandom() < p) for i in range(n)]

def runs(v):
    return sum((a & ~b) for a, b in zip(v, v[1:] + [0]))

def mean_run_density(n, p):
    return runs(newv(n, p)) / float(n)

for p10 in range(1, 10, 2):
    p = p10 / 10
    limit = p * (1 - p)
    print('')
    for n2 in range(10, 16, 2):
        n = 2**n2
        sim = sum(mean_run_density(n, p) for i in range(t)) / t
        print('t=%3i p=%4.2f n=%5i p(1-p)=%5.3f sim=%5.3f delta=%3.1f%%'
              % (t, p, n, limit, sim, abs(sim - limit) / limit * 100 if limit else sim * 100))
===
UInt32 seed = 0
F nonrandom()
   :seed = (1664525 * :seed + 1013904223) [&] FFFF'FFFF
   R (:seed >> 16) / Float(FF'FF)

V (p, t) = (0.5, 500)

F newv(n, p)
   R (0 .< n).map(i -> Int(nonrandom() < @p))

F runs(v)
   R sum(zip(v, v[1..] [+] [0]).map((a, b) -> (a [&] (-)b)))

F mean_run_density(n, p)
   R runs(newv(n, p)) / Float(n)

L(p10) (1.<10).step(2)
   p = p10 / 10
   V limit = p * (1 - p)
   print(‘’)
   L(n2) (10.<16).step(2)
      V n = 2 ^ n2
      V sim = sum((0 .< t).map(i -> mean_run_density(@n, :p))) / t
      print(‘t=#3 p=#.2 n=#5 p(1-p)=#.3 sim=#.3 delta=#.1%’.format(t, p, n, limit, sim, I limit {abs(sim - limit) / limit * 100} E sim * 100))
===
uint32_t seed = 0;
auto nonrandom()
{
    ::seed = (1664525 * ::seed + 1013904223) & 0xFFFF'FFFF;
    return (::seed >> 16) / to_float(0xFF'FF);
}

auto [p, t] = make_tuple(0.5, 500);

template <typename T1, typename T2> auto newv(const T1 &n, const T2 &p)
{
    return range_el(0, n).map([&p](const auto &i){return to_int(nonrandom() < p);});
}

template <typename T1> auto runs(const T1 &v)
{
    return sum_map(zip(v, v[range_ei(1)] + create_array({0})), [](const auto &a, const auto &b){return (a & ~b);});
}

template <typename T1, typename T2> auto mean_run_density(const T1 &n, const T2 &p)
{
    return runs(newv(n, p)) / to_float(n);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto p10 : range_el(1, 10).step(2)) {
            p = p10 / 10.0;
            auto limit = p * (1 - p);
            print(u""_S);
            for (auto n2 : range_el(10, 16).step(2)) {
                auto n = pow(2, n2);
                auto sim = sum_map(range_el(0, t), [&n](const auto &i){return mean_run_density(n, ::p);}) / t;
                print(u"t=#3 p=#.2 n=#5 p(1-p)=#.3 sim=#.3 delta=#.1%"_S.format(t, p, n, limit, sim, limit ? abs(sim - limit) / limit * 100 : sim * 100));
            }
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Percolation/Site_percolation#Python
from typing import Tuple, Optional, Dict
UInt32 = int

seed : UInt32 = 0
def nonrandom():
    global seed
    seed = (1664525 * seed + 1013904223) & 0xFFFF_FFFF
    return (seed >> 16) / float(0xFFFF)

(M, nn, t) = (15, 15, 100)

cell2char = ' #abcdefghijklmnopqrstuvwxyz'
NOT_VISITED = 1     # filled cell not walked

class PercolatedException(Exception):
    t : Tuple[int, int]

    def __init__(self, t):
        self.t = t

def newgrid(p):
    return [[int(nonrandom() < p) for m in range(M)] for n in range(nn)] # cell

def pgrid(cell, percolated):
    for n in range(nn):
        print( '%i)  ' % (n % 10)
               + ' '.join(cell2char[cell[n][m]] for m in range(M)))
    if percolated != (-1, -1):
        where = percolated[0]
        print('!)  ' + '  ' * where + cell2char[cell[nn - 1][where]])

def walk_maze(m, n, cell : list, indx) -> None:
    # fill cell
    cell[n][m] = indx
    # down
    if n < nn - 1 and cell[n+1][m] == NOT_VISITED:
        walk_maze(m, n+1, cell, indx)
    # THE bottom
    elif n == nn - 1:
        raise PercolatedException((m, indx))
    # left
    if m and cell[n][m - 1] == NOT_VISITED:
        walk_maze(m-1, n, cell, indx)
    # right
    if m < M - 1 and cell[n][m + 1] == NOT_VISITED:
        walk_maze(m+1, n, cell, indx)
    # up
    if n and cell[n-1][m] == NOT_VISITED:
        walk_maze(m, n-1, cell, indx)

def check_from_top(cell : list) -> Optional[Tuple[int, int]]:
    (n, walk_index) = (0, 1)
    try:
        for m in range(M):
            if cell[n][m] == NOT_VISITED:
                walk_index += 1
                walk_maze(m, n, cell, walk_index)
    except PercolatedException as ex:
        return ex.t
    return None

sample_printed = False
pcount : Dict[float, int] = {}
for p10 in range(11):
    p = p10 / 10.0
    pcount[p] = 0
    for tries in range(t):
        cell = newgrid(p)
        percolated : Optional[Tuple[int, int]] = check_from_top(cell)
        if percolated is not None:
            pcount[p] += 1
            if not sample_printed:
                print('\nSample percolating %i x %i, p = %5.2f grid\n' % (M, nn, p))
                pgrid(cell, percolated)
                sample_printed = True
print('\n p: Fraction of %i tries that percolate through\n' % t )

for p, c in sorted(pcount.items()):
    print('%.1f: %s' % (p, c/float(t)))
===
UInt32 seed = 0
F nonrandom()
   :seed = (1664525 * :seed + 1013904223) [&] FFFF'FFFF
   R (:seed >> 16) / Float(FF'FF)

V (M, nn, t) = (15, 15, 100)

V cell2char = ‘ #abcdefghijklmnopqrstuvwxyz’
V NOT_VISITED = 1

T PercolatedException
   (Int, Int) t

   F (t)
      .t = t

F newgrid(p)
   R (0 .< :nn).map(n -> (0 .< :M).map(m -> Int(nonrandom() < @@p)))

F pgrid(cell, percolated)
   L(n) 0 .< :nn
      print(‘#.)  ’.format(n % 10)‘’(0 .< :M).map(m -> :cell2char[@cell[@n][m]]).join(‘ ’))
   I percolated != (-1, -1)
      V where = percolated[0]
      print(‘!)  ’(‘  ’ * where)‘’:cell2char[cell[:nn - 1][where]])

F walk_maze(m, n, &cell, indx) -> N
   cell[n][m] = indx
   I n < :nn - 1 & cell[n + 1][m] == :NOT_VISITED
      walk_maze(m, n + 1, &cell, indx)
   E I n == :nn - 1
      X PercolatedException((m, indx))
   I m & cell[n][m - 1] == :NOT_VISITED
      walk_maze(m - 1, n, &cell, indx)
   I m < :M - 1 & cell[n][m + 1] == :NOT_VISITED
      walk_maze(m + 1, n, &cell, indx)
   I n & cell[n - 1][m] == :NOT_VISITED
      walk_maze(m, n - 1, &cell, indx)

F check_from_top(&cell) -> (Int, Int)?
   V (n, walk_index) = (0, 1)
   X.try
      L(m) 0 .< :M
         I cell[n][m] == :NOT_VISITED
            walk_index++
            walk_maze(m, n, &cell, walk_index)
   X.catch PercolatedException ex
      R ex.t
   R N

V sample_printed = 0B
[Float = Int] pcount
L(p10) 11
   V p = p10 / 10.0
   pcount[p] = 0
   L(tries) 0 .< t
      V cell = newgrid(p)
      (Int, Int)? percolated = check_from_top(&cell)
      I percolated != N
         pcount[p]++
         I !sample_printed
            print("\nSample percolating #. x #., p = #2.2 grid\n".format(M, nn, p))
            pgrid(cell, percolated)
            sample_printed = 1B
print("\n p: Fraction of #. tries that percolate through\n".format(t))

L(p, c) sorted(pcount.items())
   print(‘#.1: #.’.format(p, c / Float(t)))
===
uint32_t seed = 0;
auto nonrandom()
{
    ::seed = (1664525 * ::seed + 1013904223) & 0xFFFF'FFFF;
    return (::seed >> 16) / to_float(0xFF'FF);
}

auto [M, nn, t] = make_tuple(15, 15, 100);

auto cell2char = u" #abcdefghijklmnopqrstuvwxyz"_S;
auto NOT_VISITED = 1;

class PercolatedException
{
public:
    ivec2 t;

    template <typename T1> PercolatedException(const T1 &t) :
        t(t)
    {
    }
};

template <typename T1> auto newgrid(const T1 &p)
{
    return range_el(0, ::nn).map([&p](const auto &n){return range_el(0, ::M).map([&p](const auto &m){return to_int(nonrandom() < p);});});
}

template <typename T1, typename T2> auto pgrid(const T1 &cell, const T2 &percolated)
{
    for (auto n : range_el(0, ::nn))
        print(u"#.)  "_S.format(mod(n, 10)) & range_el(0, ::M).map([&cell, &n](const auto &m){return ::cell2char[cell[n][m]];}).join(u" "_S));
    if (percolated != make_tuple(-1, -1)) {
        auto where = _get<0>(percolated);
        print(u"!)  "_S & (u"  "_S * where) & ::cell2char[cell[::nn - 1][where]]);
    }
}

template <typename T1, typename T2, typename T3, typename T4> void walk_maze(const T1 &m, const T2 &n, T3 &cell, const T4 &indx)
{
    cell[n].set(m, indx);
    if (n < ::nn - 1 && cell[n + 1][m] == ::NOT_VISITED)
        walk_maze(m, n + 1, cell, indx);
    else if (n == ::nn - 1)
        throw PercolatedException(make_tuple(m, indx));
    if (m && cell[n][m - 1] == ::NOT_VISITED)
        walk_maze(m - 1, n, cell, indx);
    if (m < ::M - 1 && cell[n][m + 1] == ::NOT_VISITED)
        walk_maze(m + 1, n, cell, indx);
    if (n && cell[n - 1][m] == ::NOT_VISITED)
        walk_maze(m, n - 1, cell, indx);
}

template <typename T1> Nullable<ivec2> check_from_top(T1 &cell)
{
    auto [n, walk_index] = make_tuple(0, 1);
    try
    {
        for (auto m : range_el(0, ::M))
            if (cell[n][m] == ::NOT_VISITED) {
                walk_index++;
                walk_maze(m, n, cell, walk_index);
            }
    }
    catch (const PercolatedException& ex)
    {
        return ex.t;
    }
    return nullptr;
}

auto sample_printed = false;
Dict<double, int> pcount;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (int p10 = 0; p10 < 11; p10++) {
            auto p = p10 / 10.0;
            pcount.set(p, 0);
            for (auto tries : range_el(0, t)) {
                auto cell = newgrid(p);
                Nullable<ivec2> percolated = check_from_top(cell);
                if (percolated != nullptr) {
                    pcount[p]++;
                    if (!sample_printed) {
                        print(u"\nSample percolating #. x #., p = #2.2 grid\n"_S.format(M, nn, p));
                        pgrid(cell, *percolated);
                        sample_printed = true;
                    }
                }
            }
        }
        print(u"\n p: Fraction of #. tries that percolate through\n"_S.format(t));

        for (auto &&[p, c] : sorted(pcount.items()))
            print(u"#.1: #."_S.format(p, c / to_float(t)));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Percolation/Mean_cluster_density#Nim
UInt32 = int

seed : UInt32 = 0
def nonrandom():
    global seed
    seed = (1664525 * seed + 1013904223) & 0xFFFF_FFFF
    return (seed >> 16) / float(0xFFFF)

nn = 15
tt = 5
pp = 0.5
NotClustered = 1
Cell2Char = " #abcdefghijklmnopqrstuvwxyz"
NRange = [4, 64, 256, 1024, 4096]

def newGrid(n, p):
    return [[int(nonrandom() < p) for i in range(n)] for i in range(n)]

def walkMaze(grid : list, m, n, idx) -> None:
    grid[n][m] = idx
    if n < len(grid) - 1 and grid[n + 1][m] == NotClustered:
        walkMaze(grid, m, n + 1, idx)
    if m < len(grid[0]) - 1 and grid[n][m + 1] == NotClustered:
        walkMaze(grid, m + 1, n, idx)
    if m > 0 and grid[n][m - 1] == NotClustered:
        walkMaze(grid, m - 1, n, idx)
    if n > 0 and grid[n - 1][m] == NotClustered:
        walkMaze(grid, m, n - 1, idx)

def clusterCount(grid : list):
    walkIndex = 1
    for n in range(len(grid)):
        for m in range(len(grid[0])):
            if grid[n][m] == NotClustered:
                walkIndex += 1
                walkMaze(grid, m, n, walkIndex)
    return walkIndex - 1

def clusterDensity(n, p):
    grid = newGrid(n, p)
    return clusterCount(grid) / float(n * n)

def print_grid(grid):
    for n, row in enumerate(grid):
        print(n % 10, end = ') ')
        for cell in row:
            print('', Cell2Char[cell], end = '')
        print()

grid = newGrid(nn, 0.5)
print('Found', clusterCount(grid), 'clusters in this', nn, 'by', nn, "grid\n")
print_grid(grid)
print()

for n in NRange:
    sum = 0.0
    for _ in range(tt):
        sum += clusterDensity(n, pp)
    sim = sum / tt
    print('t = %d  p = %4.2f  n = %4d  sim = %7.5f' % (tt, pp, n, sim))
===
UInt32 seed = 0
F nonrandom()
   :seed = (1664525 * :seed + 1013904223) [&] FFFF'FFFF
   R (:seed >> 16) / Float(FF'FF)

V nn = 15
V tt = 5
V pp = 0.5
V NotClustered = 1
V Cell2Char = ‘ #abcdefghijklmnopqrstuvwxyz’
V NRange = [4, 64, 256, 1024, 4096]

F newGrid(n, p)
   R (0 .< n).map(i -> (0 .< @n).map(i -> Int(nonrandom() < @@p)))

F walkMaze(&grid, m, n, idx) -> N
   grid[n][m] = idx
   I n < grid.len - 1 & grid[n + 1][m] == NotClustered
      walkMaze(&grid, m, n + 1, idx)
   I m < grid[0].len - 1 & grid[n][m + 1] == NotClustered
      walkMaze(&grid, m + 1, n, idx)
   I m > 0 & grid[n][m - 1] == NotClustered
      walkMaze(&grid, m - 1, n, idx)
   I n > 0 & grid[n - 1][m] == NotClustered
      walkMaze(&grid, m, n - 1, idx)

F clusterCount(&grid)
   V walkIndex = 1
   L(n) 0 .< grid.len
      L(m) 0 .< grid[0].len
         I grid[n][m] == NotClustered
            walkIndex++
            walkMaze(&grid, m, n, walkIndex)
   R walkIndex - 1

F clusterDensity(n, p)
   V grid = newGrid(n, p)
   R clusterCount(&grid) / Float(n * n)

F print_grid(grid)
   L(row) grid
      V n = L.index
      print(n % 10, end' ‘) ’)
      L(cell) row
         print(‘ ’Cell2Char[cell], end' ‘’)
      print()

V grid = newGrid(nn, 0.5)
print(‘Found ’clusterCount(&grid)‘ clusters in this ’nn‘ by ’nn" grid\n")
print_grid(grid)
print()

L(n) NRange
   V sum = 0.0
   L(_) 0 .< tt
      sum += clusterDensity(n, pp)
   V sim = sum / tt
   print(‘t = #.  p = #.2  n = #4  sim = #.5’.format(tt, pp, n, sim))
===
uint32_t seed = 0;
auto nonrandom()
{
    ::seed = (1664525 * ::seed + 1013904223) & 0xFFFF'FFFF;
    return (::seed >> 16) / to_float(0xFF'FF);
}

auto nn = 15;
auto tt = 5;
auto pp = 0.5;
auto NotClustered = 1;
auto Cell2Char = u" #abcdefghijklmnopqrstuvwxyz"_S;
auto NRange = create_array({4, 64, 256, 1024, 4096});

template <typename T1, typename T2> auto newGrid(const T1 &n, const T2 &p)
{
    return range_el(0, n).map([&n, &p](const auto &i){return range_el(0, n).map([&p](const auto &i){return to_int(nonrandom() < p);});});
}

template <typename T1, typename T2, typename T3, typename T4> void walkMaze(T1 &grid, const T2 &m, const T3 &n, const T4 &idx)
{
    grid[n].set(m, idx);
    if (n < grid.len() - 1 && grid[n + 1][m] == NotClustered)
        walkMaze(grid, m, n + 1, idx);
    if (m < _get<0>(grid).len() - 1 && grid[n][m + 1] == NotClustered)
        walkMaze(grid, m + 1, n, idx);
    if (m > 0 && grid[n][m - 1] == NotClustered)
        walkMaze(grid, m - 1, n, idx);
    if (n > 0 && grid[n - 1][m] == NotClustered)
        walkMaze(grid, m, n - 1, idx);
}

template <typename T1> auto clusterCount(T1 &grid)
{
    auto walkIndex = 1;
    for (auto n : range_el(0, grid.len()))
        for (auto m : range_el(0, _get<0>(grid).len()))
            if (grid[n][m] == NotClustered) {
                walkIndex++;
                walkMaze(grid, m, n, walkIndex);
            }
    return walkIndex - 1;
}

template <typename T1, typename T2> auto clusterDensity(const T1 &n, const T2 &p)
{
    auto grid = newGrid(n, p);
    return clusterCount(grid) / to_float(n * n);
}

template <typename T1> auto print_grid(const T1 &grid)
{
    {int Lindex = 0;
    for (auto &&row : grid) {
        auto n = Lindex;
        print(mod(n, 10), u") "_S);
        for (auto &&cell : row)
            print(u" "_S & Cell2Char[cell], u""_S);
        print();
        Lindex++;
    }}
}

auto grid = newGrid(nn, 0.5);

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"Found "_S & clusterCount(grid) & u" clusters in this "_S & nn & u" by "_S & nn & u" grid\n"_S);
        print_grid(grid);
        print();

        for (auto &&n : NRange) {
            auto sum = 0.0;
            for (auto _ : range_el(0, tt))
                sum += clusterDensity(n, pp);
            auto sim = sum / tt;
            print(u"t = #.  p = #.2  n = #4  sim = #.5"_S.format(tt, pp, n, sim));
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Permutations/Rank_of_a_permutation#Nim
import math
UInt32 = int

seed : UInt32 = 0
def nonrandom():
    global seed
    seed = (1664525 * seed + 1013904223) & 0xFFFF_FFFF
    return (seed >> 16) / float(0xFFFF)

def mrUnrank1(vec : list, rank, n):
    if n < 1: return
    (q, r) = divmod(rank, n)
    (vec[r], vec[n - 1]) = (vec[n - 1], vec[r])
    mrUnrank1(vec, q, n - 1)

def mrRank1(vec : list, inv : list, n):
    if n < 2: return 0
    s = vec[n - 1]
    (vec[n - 1], vec[inv[n - 1]]) = (vec[inv[n - 1]], vec[n - 1])
    (inv[s], inv[n - 1]) = (inv[n - 1], inv[s])
    return s + n * mrRank1(vec, inv, n - 1)

def getPermutation(vec : list, rank):
    for i in range(len(vec)): vec[i] = i
    mrUnrank1(vec, rank, len(vec))

def getRank(vec):
    v = [0] * len(vec)
    inv = [0] * len(vec)
    for i, val in enumerate(vec):
        v[i] = val
        inv[val] = i
    return mrRank1(v, inv, len(vec))

tv3 = [0] * 3
for r in range(6):
    getPermutation(tv3, r)
    print('%2d -> %s -> %d' % (r, tv3, getRank(tv3)))

print()
tv4 = [0] * 4
for r in range(24):
    getPermutation(tv4, r)
    print('%2d -> %s -> %d' % (r, tv4, getRank(tv4)))

print()
tv12 = [0] * 12
for i in range(4):
    r = int(nonrandom() * math.factorial(12))
    getPermutation(tv12, r)
    print('%9d -> %s -> %d' % (r, tv12, getRank(tv12)))
===
UInt32 seed = 0
F nonrandom()
   :seed = (1664525 * :seed + 1013904223) [&] FFFF'FFFF
   R (:seed >> 16) / Float(FF'FF)

F mrUnrank1(&vec, rank, n)
   I n < 1
      R
   V (q, r) = divmod(rank, n)
   swap(&vec[r], &vec[n - 1])
   mrUnrank1(&vec, q, n - 1)

F mrRank1(&vec, &inv, n)
   I n < 2
      R 0
   V s = vec[n - 1]
   swap(&vec[n - 1], &vec[inv[n - 1]])
   swap(&inv[s], &inv[n - 1])
   R s + n * mrRank1(&vec, &inv, n - 1)

F getPermutation(&vec, rank)
   L(i) 0 .< vec.len
      vec[i] = i
   mrUnrank1(&vec, rank, vec.len)

F getRank(vec)
   V v = [0] * vec.len
   V inv = [0] * vec.len
   L(val) vec
      V i = L.index
      v[i] = val
      inv[val] = i
   R mrRank1(&v, &inv, vec.len)

V tv3 = [0] * 3
L(r) 6
   getPermutation(&tv3, r)
   print(‘#2 -> #. -> #.’.format(r, tv3, getRank(tv3)))

print()
V tv4 = [0] * 4
L(r) 24
   getPermutation(&tv4, r)
   print(‘#2 -> #. -> #.’.format(r, tv4, getRank(tv4)))

print()
V tv12 = [0] * 12
L(i) 4
   V r = Int(nonrandom() * factorial(12))
   getPermutation(&tv12, r)
   print(‘#9 -> #. -> #.’.format(r, tv12, getRank(tv12)))
===
uint32_t seed = 0;
auto nonrandom()
{
    ::seed = (1664525 * ::seed + 1013904223) & 0xFFFF'FFFF;
    return (::seed >> 16) / to_float(0xFF'FF);
}

template <typename T1, typename T2, typename T3> auto mrUnrank1(T1 &vec, const T2 &rank, const T3 &n)
{
    if (n < 1)
        return;
    auto [q, r] = divmod(rank, n);
    swap(vec[r], vec[n - 1]);
    mrUnrank1(vec, q, n - 1);
}

template <typename T1, typename T2, typename T3> auto mrRank1(T1 &vec, T2 &inv, const T3 &n)
{
    if (n < 2)
        return 0;
    auto s = vec[n - 1];
    swap(vec[n - 1], vec[inv[n - 1]]);
    swap(inv[s], inv[n - 1]);
    return s + n * mrRank1(vec, inv, n - 1);
}

template <typename T1, typename T2> auto getPermutation(T1 &vec, const T2 &rank)
{
    for (auto i : range_el(0, vec.len()))
        vec.set(i, i);
    mrUnrank1(vec, rank, vec.len());
}

template <typename T1> auto getRank(const T1 &vec)
{
    auto v = create_array({0}) * vec.len();
    auto inv = create_array({0}) * vec.len();
    {int Lindex = 0;
    for (auto &&val : vec) {
        auto i = Lindex;
        v.set(i, val);
        inv.set(val, i);
        Lindex++;
    }}
    return mrRank1(v, inv, vec.len());
}

auto tv3 = create_array({0}) * 3;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (int r = 0; r < 6; r++) {
            getPermutation(tv3, r);
            print(u"#2 -> #. -> #."_S.format(r, tv3, getRank(tv3)));
        }

        print();
    }
} code_block_1;

auto tv4 = create_array({0}) * 4;

struct CodeBlock2
{
    CodeBlock2()
    {
        for (int r = 0; r < 24; r++) {
            getPermutation(tv4, r);
            print(u"#2 -> #. -> #."_S.format(r, tv4, getRank(tv4)));
        }

        print();
    }
} code_block_2;

auto tv12 = create_array({0}) * 12;

struct CodeBlock3
{
    CodeBlock3()
    {
        for (int i = 0; i < 4; i++) {
            auto r = to_int(nonrandom() * factorial(12));
            getPermutation(tv12, r);
            print(u"#9 -> #. -> #."_S.format(r, tv12, getRank(tv12)));
        }
    }
} code_block_3;


# https://www.rosettacode.org/wiki/Pig_the_dice_game#Python
import random

playercount = 2
maxscore = 100
safescore = [0] * playercount
player = 0
score=0

while max(safescore) < maxscore:
    rolling = input("Player %i: (%i, %i) Rolling? (Y) "
                    % (player, safescore[player], score)).strip(' ').lower() in {'yes', 'y', ''}
    if rolling:
        rolled = random.randint(1, 6)
        print('  Rolled %i' % rolled)
        if rolled == 1:
            print('  Bust! you lose %i but still keep your previous %i'
                  % (score, safescore[player]))
            (score, player) = (0, (player + 1) % playercount)
        else:
            score += rolled
    else:
        safescore[player] += score
        if safescore[player] >= maxscore:
            break
        print('  Sticking with %i' % safescore[player])
        (score, player) = (0, (player + 1) % playercount)

print('\nPlayer %i wins with a score of %i' %(player, safescore[player]))
===
V playercount = 2
V maxscore = 100
V safescore = [0] * playercount
V player = 0
V score = 0

L max(safescore) < maxscore
   V rolling = input(‘Player #.: (#., #.) Rolling? (Y) ’.format(player, safescore[player], score)).trim(‘ ’).lowercase() C Set([‘yes’, ‘y’, ‘’])
   I rolling
      V rolled = random:(1 .. 6)
      print(‘  Rolled #.’.format(rolled))
      I rolled == 1
         print(‘  Bust! you lose #. but still keep your previous #.’.format(score, safescore[player]))
         (score, player) = (0, (player + 1) % playercount)
      E
         score += rolled
   E
      safescore[player] += score
      I safescore[player] >= maxscore
         L.break
      print(‘  Sticking with #.’.format(safescore[player]))
      (score, player) = (0, (player + 1) % playercount)

print("\nPlayer #. wins with a score of #.".format(player, safescore[player]))
===
auto playercount = 2;
auto maxscore = 100;
auto safescore = create_array({0}) * playercount;
auto player = 0;
auto score = 0;

struct CodeBlock1
{
    CodeBlock1()
    {
        while (max(safescore) < maxscore) {
            auto rolling = in(input(u"Player #.: (#., #.) Rolling? (Y) "_S.format(player, safescore[player], score)).trim(u" "_S).lowercase(), create_set({u"yes"_S, u"y"_S, u""_S}));
            if (rolling) {
                auto rolled = randomns::_(range_ee(1, 6));
                print(u"  Rolled #."_S.format(rolled));
                if (rolled == 1) {
                    print(u"  Bust! you lose #. but still keep your previous #."_S.format(score, safescore[player]));
                    assign_from_tuple(score, player, make_tuple(0, mod((player + 1), playercount)));
                }
                else
                    score += rolled;
            }
            else {
                safescore[player] += score;
                if (safescore[player] >= maxscore)
                    break;
                print(u"  Sticking with #."_S.format(safescore[player]));
                assign_from_tuple(score, player, make_tuple(0, mod((player + 1), playercount)));
            }
        }

        print(u"\nPlayer #. wins with a score of #."_S.format(player, safescore[player]));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Pisano_period#Nim
import math, collections

def lcm(m, n):
    return m // math.gcd(m, n) * n

def get_primes(n):
    r : List[int] = []
    for d in range(2, n + 1):
        q = n // d
        m = n % d
        while m == 0:
            r.append(d)
            n = q
            q = n // d
            m = n % d
    return r

def is_prime(a):
    if a == 2: return True
    if a < 2 or a % 2 == 0: return False
    for i in range(3, int(math.sqrt(a)) + 1, 2):
        if a % i == 0:
            return False
    return True

def pisano_period(m):
    p = 0
    c = 1
    for i in range(m*m):
        p = (p + c) % m
        (p, c) = (c, p)
        if p == 0 and c == 1: return i + 1
    return 1

def pisano_prime(p, k):
    return p**(k-1) * pisano_period(p) if is_prime(p) else 0

def pisano(m):
    primes = get_primes(m)
    prime_powers = collections.defaultdict(int) # int
    for p in primes:
        prime_powers[p] += 1
    pps : List[int] = []
    for k, v in prime_powers.items():
        pps.append(pisano_prime(k, v))
    if len(pps) == 0: return 1
    result = pps[0]
    for i in range(1, len(pps)):
        result = lcm(result, pps[i])
    return result

for p in range(2, 15):
    pp = pisano_prime(p, 2)
    if pp > 0:
        print('pisano_prime({:2}, 2) = {}'.format(p, pp))

print()
for p in range(2, 180):
    pp = pisano_prime(p, 1)
    if pp > 0:
        print('pisano_prime({:3}, 1) = {}'.format(p, pp))

print()
print("pisano(n) for integers 'n' from 1 to 180 are:")
for n in range(1, 181):
    print('%3d' % pisano(n), end = "\n" if n % 15 == 0 else ' ')
===
F lcm(m, n)
   R m I/ gcd(m, n) * n

F get_primes(=n)
   [Int] r
   L(d) 2 .. n
      V q = n I/ d
      V m = n % d
      L m == 0
         r.append(d)
         n = q
         q = n I/ d
         m = n % d
   R r

F is_prime(a)
   I a == 2
      R 1B
   I a < 2 | a % 2 == 0
      R 0B
   L(i) (3 .. Int(sqrt(a))).step(2)
      I a % i == 0
         R 0B
   R 1B

F pisano_period(m)
   V p = 0
   V c = 1
   L(i) 0 .< m * m
      p = (p + c) % m
      swap(&p, &c)
      I p == 0 & c == 1
         R i + 1
   R 1

F pisano_prime(p, k)
   R I is_prime(p) {p ^ (k - 1) * pisano_period(p)} E 0

F pisano(m)
   V primes = get_primes(m)
   V prime_powers = DefaultDict[Int, Int]()
   L(p) primes
      prime_powers[p]++
   [Int] pps
   L(k, v) prime_powers
      pps.append(pisano_prime(k, v))
   I pps.empty
      R 1
   V result = pps[0]
   L(i) 1 .< pps.len
      result = lcm(result, pps[i])
   R result

L(p) 2..14
   V pp = pisano_prime(p, 2)
   I pp > 0
      print(‘pisano_prime(#2, 2) = #.’.format(p, pp))

print()
L(p) 2..179
   V pp = pisano_prime(p, 1)
   I pp > 0
      print(‘pisano_prime(#3, 1) = #.’.format(p, pp))

print()
print(‘pisano(n) for integers 'n' from 1 to 180 are:’)
L(n) 1..180
   print(‘#3’.format(pisano(n)), end' I n % 15 == 0 {"\n"} E ‘ ’)
===
template <typename T1, typename T2> auto lcm(const T1 &m, const T2 &n)
{
    return idiv(m, gcd(m, n)) * n;
}

template <typename T1> auto get_primes(T1 n)
{
    Array<int> r;
    for (auto d : range_ee(2, n)) {
        auto q = idiv(n, d);
        auto m = mod(n, d);
        while (m == 0) {
            r.append(d);
            n = q;
            q = idiv(n, d);
            m = mod(n, d);
        }
    }
    return r;
}

template <typename T1> auto is_prime(const T1 &a)
{
    if (a == 2)
        return true;
    if (a < 2 || mod(a, 2) == 0)
        return false;
    for (auto i : range_ee(3, to_int(sqrt(a))).step(2))
        if (mod(a, i) == 0)
            return false;
    return true;
}

template <typename T1> auto pisano_period(const T1 &m)
{
    auto p = 0;
    auto c = 1;
    for (auto i : range_el(0, m * m)) {
        p = mod((p + c), m);
        swap(p, c);
        if (p == 0 && c == 1)
            return i + 1;
    }
    return 1;
}

template <typename T1, typename T2> auto pisano_prime(const T1 &p, const T2 &k)
{
    return is_prime(p) ? pow(p, (k - 1)) * pisano_period(p) : 0;
}

template <typename T1> auto pisano(const T1 &m)
{
    auto primes = get_primes(m);
    auto prime_powers = DefaultDict<int, int>();
    for (auto &&p : primes)
        prime_powers[p]++;
    Array<int> pps;
    for (auto &&[k, v] : prime_powers)
        pps.append(pisano_prime(k, v));
    if (pps.empty())
        return 1;
    auto result = _get<0>(pps);
    for (auto i : range_el(1, pps.len()))
        result = lcm(result, pps[i]);
    return result;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto p : range_ee(2, 14)) {
            auto pp = pisano_prime(p, 2);
            if (pp > 0)
                print(u"pisano_prime(#2, 2) = #."_S.format(p, pp));
        }

        print();
        for (auto p : range_ee(2, 179)) {
            auto pp = pisano_prime(p, 1);
            if (pp > 0)
                print(u"pisano_prime(#3, 1) = #."_S.format(p, pp));
        }

        print();
        print(u"pisano(n) for integers 'n' from 1 to 180 are:"_S);
        for (auto n : range_ee(1, 180))
            print(u"#3"_S.format(pisano(n)), mod(n, 15) == 0 ? u"\n"_S : u" "_S);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Practical_numbers#Nim
import math
from copy import copy

def properDivisors(n):
    result = [1]
    for i in range(2, int(math.sqrt(n)) + 1):
        if n % i == 0:
            j = n // i
            result.append(i)
            if i != j: result.append(j)
    return result

def allSums(n):
    divs = properDivisors(n)
    currSet = set() # int
    result = set() # int
    for d in divs:
        currSet = copy(result)
        for sum in currSet:
            result.add(sum + d)
        result.add(d)
    return result

def isPractical(n):
    return set(list(range(1, n))) <= allSums(n)

count = 0
for n in range(1, 334):
    if isPractical(n):
        count += 1
        print('%3d' % n, end = "\n" if count % 11 == 0 else ' ')
print('Found', count, 'practical numbers between 1 and 333.')
print()
print('666 is ', '' if isPractical(666) else 'not ', 'a practical number.', sep = '')
===
F properDivisors(n)
   V result = [1]
   L(i) 2 .. Int(sqrt(n))
      I n % i == 0
         V j = n I/ i
         result.append(i)
         I i != j
            result.append(j)
   R result

F allSums(n)
   V divs = properDivisors(n)
   V currSet = Set[Int]()
   V result = Set[Int]()
   L(d) divs
      currSet = copy(result)
      L(sum) currSet
         result.add(sum + d)
      result.add(d)
   R result

F isPractical(n)
   R Set(Array(1 .< n)) <= allSums(n)

V count = 0
L(n) 1..333
   I isPractical(n)
      count++
      print(‘#3’.format(n), end' I count % 11 == 0 {"\n"} E ‘ ’)
print(‘Found ’count‘ practical numbers between 1 and 333.’)
print()
print(‘666 is ’(I isPractical(666) {‘’} E ‘not ’)‘a practical number.’)
===
template <typename T1> auto properDivisors(const T1 &n)
{
    auto result = create_array({1});
    for (auto i : range_ee(2, to_int(sqrt(n))))
        if (mod(n, i) == 0) {
            auto j = idiv(n, i);
            result.append(i);
            if (i != j)
                result.append(j);
        }
    return result;
}

template <typename T1> auto allSums(const T1 &n)
{
    auto divs = properDivisors(n);
    auto currSet = Set<int>();
    auto result = Set<int>();
    for (auto &&d : divs) {
        currSet = copy(result);
        for (auto &&sum : currSet)
            result.add(sum + d);
        result.add(d);
    }
    return result;
}

template <typename T1> auto isPractical(const T1 &n)
{
    return create_set(create_array(range_el(1, n))) <= allSums(n);
}

auto count = 0;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto n : range_ee(1, 333))
            if (isPractical(n)) {
                count++;
                print(u"#3"_S.format(n), mod(count, 11) == 0 ? u"\n"_S : u" "_S);
            }
        print(u"Found "_S & count & u" practical numbers between 1 and 333."_S);
        print();
        print(u"666 is "_S & (isPractical(666) ? u""_S : u"not "_S) & u"a practical number."_S);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Price_list_behind_API#Python
import random

#%%Sample price generation
price_list_size = random.randrange(99_000, 101_000)
price_list = [random.randrange(100_000) for i in range(price_list_size)]

delta_price = 1     # Minimum difference between any two different prices.

#%% API
def get_prange_count(startp, endp):
    return len([r for r in price_list if startp <= float(r) <= endp])

def get_max_price():
    return max(price_list)

#%% Solution
def get_5k(mn : float, mx : float, num=5_000):
    "Binary search for num items between mn and mx, adjusting mx"
    count = get_prange_count(mn, mx)
    delta_mx = (mx - mn) / 2
    while count != num and delta_mx >= delta_price / 2:
        mx += -delta_mx if count > num else +delta_mx
        mx = float(mx // 1)    # Floor
        (count, delta_mx) = (get_prange_count(mn, mx), delta_mx / 2)
    return (mx, count)

def get_all_5k(mn=0.0, mx : float=get_max_price(), num=5_000):
    "Get all non-overlapping ranges"
    (partmax, partcount) = get_5k(mn, mx, num)
    result = [(mn, partmax, partcount)]
    while partmax < mx:
        partmin = partmax + delta_price
        (partmax, partcount) = get_5k(partmin, mx, num)
        assert partcount > 0, \
            f"price_list from {partmin} with too many of the same price"
        result.append((partmin, partmax, partcount))
    return result

print(f"Using {price_list_size} random prices from 0 to {get_max_price()}")
result = get_all_5k()
print(f"Splits into {len(result)} bins of approx 5000 elements")
for mn, mx, count in result:
    print(f"  From {mn:8.1f} ... {mx:8.1f} with {count} items.")

if len(price_list) != sum(count for mn, mx, count in result):
    print("\nWhoops! Some items missing:")
===
V price_list_size = random:(99'000 .< 101'000)
V price_list = (0 .< price_list_size).map(i -> random:(100'000))

V delta_price = 1

F get_prange_count(startp, endp)
   R :price_list.filter(r -> Float(r) C @startp .. @endp).len

F get_max_price()
   R max(:price_list)

F get_5k(Float mn, Float =mx; num = 5'000)
   ‘Binary search for num items between mn and mx, adjusting mx’
   V count = get_prange_count(mn, mx)
   V delta_mx = (mx - mn) / 2
   L count != num & delta_mx >= :delta_price / 2
      mx += I count > num {-delta_mx} E +delta_mx
      mx = Float(mx I/ 1)
      (count, delta_mx) = (get_prange_count(mn, mx), delta_mx / 2)
   R (mx, count)

F get_all_5k(mn = 0.0, Float mx = get_max_price(); num = 5'000)
   ‘Get all non-overlapping ranges’
   V (partmax, partcount) = get_5k(mn, mx, num)
   V result = [(mn, partmax, partcount)]
   L partmax < mx
      V partmin = partmax + :delta_price
      (partmax, partcount) = get_5k(partmin, mx, num)
      assert(partcount > 0, ‘price_list from ’partmin‘ with too many of the same price’)
      result.append((partmin, partmax, partcount))
   R result

print(‘Using ’price_list_size‘ random prices from 0 to ’get_max_price())
V result = get_all_5k()
print(‘Splits into ’result.len‘ bins of approx 5000 elements’)
L(mn, mx, count) result
   print(f:‘  From {mn:8.1} ... {mx:8.1} with {count} items.’)

I price_list.len != sum(result.map((mn, mx, count) -> count))
   print("\nWhoops! Some items missing:")
===
auto price_list_size = randomns::_(range_el(99'000, 101'000));
auto price_list = range_el(0, price_list_size).map([](const auto &i){return randomns::_(100'000);});

auto delta_price = 1;

template <typename T1, typename T2> auto get_prange_count(const T1 &startp, const T2 &endp)
{
    return ::price_list.filter([&endp, &startp](const auto &r){return in(to_float(r), range_ee(startp, endp));}).len();
}

auto get_max_price()
{
    return max(::price_list);
}

template <typename T3 = decltype(5'000)> auto get_5k(const double mn, double mx, const T3 &num = 5'000)
{
    u"Binary search for num items between mn and mx, adjusting mx"_S;
    auto count = get_prange_count(mn, mx);
    auto delta_mx = (mx - mn) / 2.0;
    while (count != num && delta_mx >= ::delta_price / 2.0) {
        mx += count > num ? -delta_mx : +delta_mx;
        mx = to_float(idiv(mx, 1));
        assign_from_tuple(count, delta_mx, make_tuple(get_prange_count(mn, mx), delta_mx / 2.0));
    }
    return make_tuple(mx, count);
}

template <typename T1 = decltype(0.0), typename T3 = decltype(5'000)> auto get_all_5k(const T1 &mn = 0.0, const double mx = get_max_price(), const T3 &num = 5'000)
{
    u"Get all non-overlapping ranges"_S;
    auto [partmax, partcount] = get_5k(mn, mx, num);
    auto result = create_array({make_tuple(mn, partmax, partcount)});
    while (partmax < mx) {
        auto partmin = partmax + ::delta_price;
        assign_from_tuple(partmax, partcount, get_5k(partmin, mx, num));
        assert(partcount > 0, u"price_list from "_S & partmin & u" with too many of the same price"_S);
        result.append(make_tuple(partmin, partmax, partcount));
    }
    return result;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"Using "_S & price_list_size & u" random prices from 0 to "_S & get_max_price());
    }
} code_block_1;

auto result = get_all_5k();

struct CodeBlock2
{
    CodeBlock2()
    {
        print(u"Splits into "_S & result.len() & u" bins of approx 5000 elements"_S);
        for (auto &&[mn, mx, count] : result)
            print(u"  From #6.1 ... #6.1 with #. items."_S.format(mn, mx, count));

        if (price_list.len() != sum_map(result, [](const auto &mn, const auto &mx, const auto &count){return count;}))
            print(u"\nWhoops! Some items missing:"_S);
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Prime_numbers_which_contain_123
import math

def is_prime(a):
    if a == 2: return True
    if a < 2 or a % 2 == 0: return False
    for i in range(3, int(math.sqrt(a)) + 1, 2):
        if a % i == 0:
            return False
    return True

def is_prime123(n):
    return '123' in str(n) and is_prime(n)

c = 0
for n in range(100_000):
    if is_prime123(n):
        c += 1
        print('%5d' % n, end = "\n" if c % 8 == 0 else ' ')
print()
print('Found', c, '"123" primes less than 100000')
c = 0
for n in range(1_000_000):
    if is_prime123(n):
        c += 1
print()
print('Found', c, '"123" primes less than 1000000')
===
F is_prime(a)
   I a == 2
      R 1B
   I a < 2 | a % 2 == 0
      R 0B
   L(i) (3 .. Int(sqrt(a))).step(2)
      I a % i == 0
         R 0B
   R 1B

F is_prime123(n)
   R ‘123’ C String(n) & is_prime(n)

V c = 0
L(n) 100'000
   I is_prime123(n)
      c++
      print(‘#5’.format(n), end' I c % 8 == 0 {"\n"} E ‘ ’)
print()
print(‘Found ’c‘ "123" primes less than 100000’)
c = 0
L(n) 1'000'000
   I is_prime123(n)
      c++
print()
print(‘Found ’c‘ "123" primes less than 1000000’)
===
template <typename T1> auto is_prime(const T1 &a)
{
    if (a == 2)
        return true;
    if (a < 2 || mod(a, 2) == 0)
        return false;
    for (auto i : range_ee(3, to_int(sqrt(a))).step(2))
        if (mod(a, i) == 0)
            return false;
    return true;
}

template <typename T1> auto is_prime123(const T1 &n)
{
    return in(u"123"_S, String(n)) && is_prime(n);
}

auto c = 0;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (int n = 0; n < 100'000; n++)
            if (is_prime123(n)) {
                c++;
                print(u"#5"_S.format(n), mod(c, 8) == 0 ? u"\n"_S : u" "_S);
            }
        print();
        print(u"Found "_S & c & u" \"123\" primes less than 100000"_S);
        c = 0;
        for (int n = 0; n < 1'000'000; n++)
            if (is_prime123(n))
                c++;
        print();
        print(u"Found "_S & c & u" \"123\" primes less than 1000000"_S);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Primes_whose_sum_of_digits_is_25#Nim
import math

def is_prime(a):
    if a == 2: return True
    if a < 2 or a % 2 == 0: return False
    for i in range(3, int(math.sqrt(a)) + 1, 2):
        if a % i == 0:
            return False
    return True

def digit_sum(n):
    result = 0
    while n != 0:
        result += n % 10
        n //= 10
    return result

c = 0
for n in range(5000):
    if digit_sum(n) == 25 and is_prime(n):
        c += 1
        print('%4d' % n, end = "\n" if c % 6 == 0 else ' ')
print()
print('Found', c, 'primes whose sum of digits is 25')
===
F is_prime(a)
   I a == 2
      R 1B
   I a < 2 | a % 2 == 0
      R 0B
   L(i) (3 .. Int(sqrt(a))).step(2)
      I a % i == 0
         R 0B
   R 1B

F digit_sum(=n)
   V result = 0
   L n != 0
      result += n % 10
      n I/= 10
   R result

V c = 0
L(n) 5000
   I digit_sum(n) == 25 & is_prime(n)
      c++
      print(‘#4’.format(n), end' I c % 6 == 0 {"\n"} E ‘ ’)
print()
print(‘Found ’c‘ primes whose sum of digits is 25’)
===
template <typename T1> auto is_prime(const T1 &a)
{
    if (a == 2)
        return true;
    if (a < 2 || mod(a, 2) == 0)
        return false;
    for (auto i : range_ee(3, to_int(sqrt(a))).step(2))
        if (mod(a, i) == 0)
            return false;
    return true;
}

template <typename T1> auto digit_sum(T1 n)
{
    auto result = 0;
    while (n != 0) {
        result += mod(n, 10);
        n = idiv(n, 10);
    }
    return result;
}

auto c = 0;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (int n = 0; n < 5000; n++)
            if (digit_sum(n) == 25 && is_prime(n)) {
                c++;
                print(u"#4"_S.format(n), mod(c, 6) == 0 ? u"\n"_S : u" "_S);
            }
        print();
        print(u"Found "_S & c & u" primes whose sum of digits is 25"_S);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Primes_with_digits_in_nondecreasing_order#Nim
import math

def is_prime(a):
    if a == 2: return True
    if a < 2 or a % 2 == 0: return False
    for i in range(3, int(math.sqrt(a)) + 1, 2):
        if a % i == 0:
            return False
    return True

def is_non_decreasing(n):
    prev = 10
    while n != 0:
        d = n % 10
        if d > prev: return False
        prev = d
        n //= 10
    return True

c = 0
for n in range(1000):
    if is_non_decreasing(n) and is_prime(n):
        c += 1
        print('%3d' % n, end = "\n" if c % 10 == 0 else ' ')
print()
print('Found', c, 'primes with digits in nondecreasing order')
===
F is_prime(a)
   I a == 2
      R 1B
   I a < 2 | a % 2 == 0
      R 0B
   L(i) (3 .. Int(sqrt(a))).step(2)
      I a % i == 0
         R 0B
   R 1B

F is_non_decreasing(=n)
   V prev = 10
   L n != 0
      V d = n % 10
      I d > prev
         R 0B
      prev = d
      n I/= 10
   R 1B

V c = 0
L(n) 1000
   I is_non_decreasing(n) & is_prime(n)
      c++
      print(‘#3’.format(n), end' I c % 10 == 0 {"\n"} E ‘ ’)
print()
print(‘Found ’c‘ primes with digits in nondecreasing order’)
===
template <typename T1> auto is_prime(const T1 &a)
{
    if (a == 2)
        return true;
    if (a < 2 || mod(a, 2) == 0)
        return false;
    for (auto i : range_ee(3, to_int(sqrt(a))).step(2))
        if (mod(a, i) == 0)
            return false;
    return true;
}

template <typename T1> auto is_non_decreasing(T1 n)
{
    auto prev = 10;
    while (n != 0) {
        auto d = mod(n, 10);
        if (d > prev)
            return false;
        prev = d;
        n = idiv(n, 10);
    }
    return true;
}

auto c = 0;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (int n = 0; n < 1000; n++)
            if (is_non_decreasing(n) && is_prime(n)) {
                c++;
                print(u"#3"_S.format(n), mod(c, 10) == 0 ? u"\n"_S : u" "_S);
            }
        print();
        print(u"Found "_S & c & u" primes with digits in nondecreasing order"_S);
    }
} code_block_1;