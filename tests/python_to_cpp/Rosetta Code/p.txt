# https://www.rosettacode.org/wiki/Pangram_checker
def is_pangram(sentence):
    return len(set(ch for ch in sentence.lower() if 'a' <= ch <= 'z')) == 26

for sentence in ['The quick brown fox jumps over the lazy dog.',
                 'The quick brown fox jumped over the lazy dog.']:
    print("'%s' is %sa pangram" % (sentence, 'not ' * (not is_pangram(sentence))))
===
F is_pangram(sentence)
   R Set(sentence.lowercase().filter(ch -> ch C ‘a’..‘z’)).len == 26

L(sentence) [‘The quick brown fox jumps over the lazy dog.’, ‘The quick brown fox jumped over the lazy dog.’]
   print(‘'#.' is #.a pangram’.format(sentence, ‘not ’ * (!is_pangram(sentence))))
===
template <typename T1> auto is_pangram(const T1 &sentence)
{
    return create_set(sentence.lowercase().filter([](const auto &ch){return in(ch, range_ee(u'a'_C, u'z'_C));})).len() == 26;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&sentence : create_array({u"The quick brown fox jumps over the lazy dog."_S, u"The quick brown fox jumped over the lazy dog."_S}))
            print(u"'#.' is #.a pangram"_S.format(sentence, u"not "_S * (!is_pangram(sentence))));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Parsing/Shunting-yard_algorithm#Java
import re

def infix_to_postfix(infix):
    ops = '-+/*^'
    sb = ''
    s : List[int] = []

    for token in re.split(r'\s', infix):
        if len(token) == 0:
            continue

        c = token[0]
        idx = ops.find(c)
        if idx != -1:
            if len(s) == 0:
                s.append(idx)
            else:
                while len(s) != 0:
                    prec2 = s[-1] // 2
                    prec1 = idx // 2
                    if prec2 > prec1 or (prec2 == prec1 and c != '^'):
                        sb += ops[s.pop()] + ' '
                    else:
                        break
                s.append(idx)

        elif c == '(': # )
            s.append(-2) # -2 stands for '('

        elif c == ')':
            while s[-1] != -2:
                sb += ops[s.pop()] + ' '
            s.pop()

        else:
            sb += token + ' '

    while len(s) != 0:
        sb += ops[s.pop()] + ' '

    return sb

infix = '3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3'
print('infix:   ' + infix)
print('postfix: ' + infix_to_postfix(infix))
===
F infix_to_postfix(infix)
   V ops = ‘-+/*^’
   V sb = ‘’
   [Int] s

   L(token) infix.split(re:‘\s’)
      I token.empty
         L.continue

      V c = token[0]
      V idx = ops.findi(c)
      I idx != -1
         I s.empty
            s.append(idx)
         E
            L !s.empty
               V prec2 = s.last I/ 2
               V prec1 = idx I/ 2
               I prec2 > prec1 | (prec2 == prec1 & c != ‘^’)
                  sb ‘’= ops[s.pop()]‘ ’
               E
                  L.break
            s.append(idx)

      E I c == ‘(’
         s.append(-2)

      E I c == ‘)’
         L s.last != -2
            sb ‘’= ops[s.pop()]‘ ’
         s.pop()

      E
         sb ‘’= token‘ ’

   L !s.empty
      sb ‘’= ops[s.pop()]‘ ’

   R sb

V infix = ‘3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3’
print(‘infix:   ’infix)
print(‘postfix: ’infix_to_postfix(infix))
===
template <typename T1> auto infix_to_postfix(const T1 &infix)
{
    auto ops = u"-+/*^"_S;
    auto sb = u""_S;
    Array<int> s;

    for (auto &&token : infix.split(re::_(uR"(\s)"_S))) {
        if (token.empty())
            continue;

        auto c = _get<0>(token);
        auto idx = ops.findi(c);
        if (idx != -1) {
            if (s.empty())
                s.append(idx);
            else {
                while (!s.empty()) {
                    auto prec2 = idiv(s.last(), 2);
                    auto prec1 = idiv(idx, 2);
                    if (prec2 > prec1 || (prec2 == prec1 && c != u'^'))
                        sb &= ops[s.pop()] & u" "_S;
                    else
                        break;
                }
                s.append(idx);
            }
        }

        else if (c == u'(')
            s.append(-2);

        else if (c == u')') {
            while (s.last() != -2)
                sb &= ops[s.pop()] & u" "_S;
            s.pop();
        }

        else
            sb &= token & u" "_S;
    }

    while (!s.empty())
        sb &= ops[s.pop()] & u" "_S;

    return sb;
}

auto infix = u"3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3"_S;

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"infix:   "_S & infix);
        print(u"postfix: "_S & infix_to_postfix(infix));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Parsing/RPN_to_infix_conversion#Java
import re

ops = '-+/*^'

def postfix_to_infix(postfix):
    class Expression:
        op : str
        ex : str
        prec = 3

        def __init__(self, e1 : str, e2 : str = '', o : str = ''):
            if o == '':
                self.ex = e1
            else:
                self.ex = e1 + ' ' + o + ' ' + e2
                self.op = o
                self.prec = ops.index(o) // 2

        def __str__(self):
            return self.ex

        def __repr__(self):
            return self.ex

    expr : List[Expression] = []

    for token in re.split(r'\s+', postfix):
        c = token[0]
        idx = ops.find(c)
        if idx != -1:# and len(token) == 1:
            r = expr.pop()
            l = expr.pop()
            opPrec = idx // 2

            if l.prec < opPrec or (l.prec == opPrec and c == '^'):
                l.ex = '(' + l.ex + ')'

            if r.prec < opPrec or (r.prec == opPrec and c != '^'):
                r.ex = '(' + r.ex + ')'

            expr.append(Expression(l.ex, r.ex, token))

        else:
            expr.append(Expression(token))

        print(token + ' -> ' + str(expr))

    assert(len(expr) == 1)
    return expr[0].ex

for e in ['3 4 2 * 1 5 - 2 3 ^ ^ / +',
          '1 2 + 3 4 + ^ 5 6 + ^']:
    print('Postfix : ' + e)
    print('Infix : ' + postfix_to_infix(e))
    print()
===
V ops = ‘-+/*^’

F postfix_to_infix(postfix)
   T Expression
      String op
      String ex
      prec = 3

      F (String e1, String e2 = ‘’, String o = ‘’)
         I o == ‘’
            .ex = e1
         E
            .ex = e1‘ ’o‘ ’e2
            .op = o
            .prec = :ops.index(o) I/ 2

      F String()
         R .ex

      F __repr__()
         R .ex

   [Expression] expr

   L(token) postfix.split(re:‘\s+’)
      V c = token[0]
      V idx = :ops.findi(c)
      I idx != -1
         V r = expr.pop()
         V l = expr.pop()
         V opPrec = idx I/ 2

         I l.prec < opPrec | (l.prec == opPrec & c == ‘^’)
            l.ex = ‘(’l.ex‘)’

         I r.prec < opPrec | (r.prec == opPrec & c != ‘^’)
            r.ex = ‘(’r.ex‘)’

         expr.append(Expression(l.ex, r.ex, token))

      E
         expr.append(Expression(token))

      print(token‘ -> ’String(expr))

   assert(expr.len == 1)
   R expr[0].ex

L(e) [‘3 4 2 * 1 5 - 2 3 ^ ^ / +’, ‘1 2 + 3 4 + ^ 5 6 + ^’]
   print(‘Postfix : ’e)
   print(‘Infix : ’postfix_to_infix(e))
   print()
===
auto ops = u"-+/*^"_S;

template <typename T1> auto postfix_to_infix(const T1 &postfix)
{
    class Expression
    {
    public:
        String op;
        String ex;
        decltype(3) prec = 3;

        Expression(const String &e1, const String &e2 = u""_S, const String &o = u""_S)
        {
            if (o == u"")
                ex = e1;
            else {
                ex = e1 & u" "_S & o & u" "_S & e2;
                op = o;
                prec = idiv(::ops.index(o), 2);
            }
        }

        operator String() const
        {
            return ex;
        }

        auto __repr__()
        {
            return ex;
        }
    };

    Array<Expression> expr;

    for (auto &&token : postfix.split(re::_(uR"(\s+)"_S))) {
        auto c = _get<0>(token);
        auto idx = ::ops.findi(c);
        if (idx != -1) {
            auto r = expr.pop();
            auto l = expr.pop();
            auto opPrec = idiv(idx, 2);

            if (l.prec < opPrec || (l.prec == opPrec && c == u'^'))
                l.ex = u"("_S & l.ex & u")"_S;

            if (r.prec < opPrec || (r.prec == opPrec && c != u'^'))
                r.ex = u"("_S & r.ex & u")"_S;

            expr.append(Expression(l.ex, r.ex, token));
        }

        else
            expr.append(Expression(token));

        print(token & u" -> "_S & String(expr));
    }

    assert(expr.len() == 1);
    return _get<0>(expr).ex;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&e : create_array({u"3 4 2 * 1 5 - 2 3 ^ ^ / +"_S, u"1 2 + 3 4 + ^ 5 6 + ^"_S})) {
            print(u"Postfix : "_S & e);
            print(u"Infix : "_S & postfix_to_infix(e));
            print();
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Pascal_matrix_generation#Python
def pascal_upp(n):
    s = [[0] * n for _ in range(n)]
    s[0] = [1] * n
    for i in range(1, n):
        for j in range(i, n):
            s[i][j] = s[i-1][j-1] + s[i][j-1]
    return s

def pascal_low(n):
    # transpose of pascal_upp(n)
    upp = pascal_upp(n)
    s = [[0] * n for _ in range(n)]
    for x in range(n):
        for y in range(n):
            s[y][x] = upp[x][y]
    return s

def pascal_sym(n):
    s = [[1] * n for _ in range(n)]
    for i in range(1, n):
        for j in range(1, n):
            s[i][j] = s[i-1][j] + s[i][j-1]
    return s

def pp(mat):
    print('[' + ",\n ".join(map(str, mat)) + ']')

n = 5
print("Upper:")
pp(pascal_upp(n))
print("\nLower:")
pp(pascal_low(n))
print("\nSymmetric:")
pp(pascal_sym(n))
===
F pascal_upp(n)
   V s = [[0] * n] * n
   s[0] = [1] * n
   L(i) 1 .< n
      L(j) i .< n
         s[i][j] = s[i - 1][j - 1] + s[i][j - 1]
   R s

F pascal_low(n)
   V upp = pascal_upp(n)
   V s = [[0] * n] * n
   L(x) 0 .< n
      L(y) 0 .< n
         s[y][x] = upp[x][y]
   R s

F pascal_sym(n)
   V s = [[1] * n] * n
   L(i) 1 .< n
      L(j) 1 .< n
         s[i][j] = s[i - 1][j] + s[i][j - 1]
   R s

F pp(mat)
   print(‘[’mat.map(String).join(",\n ")‘]’)

V n = 5
print(‘Upper:’)
pp(pascal_upp(n))
print("\nLower:")
pp(pascal_low(n))
print("\nSymmetric:")
pp(pascal_sym(n))
===
template <typename T1> auto pascal_upp(const T1 &n)
{
    auto s = create_array({create_array({0}) * n}) * n;
    _set<0>(s, create_array({1}) * n);
    for (auto i : range_el(1, n))
        for (auto j : range_el(i, n))
            s[i].set(j, s[i - 1][j - 1] + s[i][j - 1]);
    return s;
}

template <typename T1> auto pascal_low(const T1 &n)
{
    auto upp = pascal_upp(n);
    auto s = create_array({create_array({0}) * n}) * n;
    for (auto x : range_el(0, n))
        for (auto y : range_el(0, n))
            s[y].set(x, upp[x][y]);
    return s;
}

template <typename T1> auto pascal_sym(const T1 &n)
{
    auto s = create_array({create_array({1}) * n}) * n;
    for (auto i : range_el(1, n))
        for (auto j : range_el(1, n))
            s[i].set(j, s[i - 1][j] + s[i][j - 1]);
    return s;
}

template <typename T1> auto pp(const T1 &mat)
{
    print(u"["_S & mat.map([](const auto &x){return String(x);}).join(u",\n "_S) & u"]"_S);
}

auto n = 5;

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"Upper:"_S);
        pp(pascal_upp(n));
        print(u"\nLower:"_S);
        pp(pascal_low(n));
        print(u"\nSymmetric:"_S);
        pp(pascal_sym(n));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Perfect_numbers#Python
def perf(n):
    sum = 0
    for i in range(1, n):
        if n % i == 0:
            sum += i
    return sum == n

for i in range(1, 10001):
    if perf(i):
        print(i, end = ' ')
===
F perf(n)
   V sum = 0
   L(i) 1 .< n
      I n % i == 0
         sum += i
   R sum == n

L(i) 1..10000
   I perf(i)
      print(i, end' ‘ ’)
===
template <typename T1> auto perf(const T1 &n)
{
    auto sum = 0;
    for (auto i : range_el(1, n))
        if (mod(n, i) == 0)
            sum += i;
    return sum == n;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto i : range_ee(1, 10000))
            if (perf(i))
                print(i, u" "_S);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Perfect_shuffle#Python
def flatten(lst):
    r : List[int] = []
    for sublst in lst:
        for i in sublst:
            r += [i]
    return r

def magic_shuffle(deck):
    half = len(deck) // 2
    return flatten(zip(deck[:half], deck[half:]))

def after_how_many_is_equal(start, end):
    deck = magic_shuffle(start)
    counter = 1
    while deck != end:
        deck = magic_shuffle(deck)
        counter += 1
    return counter

print("Length of the deck of cards | Perfect shuffles needed to obtain the same deck back")
for length in (8, 24, 52, 100, 1020, 1024, 10000):
    deck = list(range(length))
    shuffles_needed = after_how_many_is_equal(deck,deck)
    print("%-5d | %d" % (length,shuffles_needed))
===
F flatten(lst)
   [Int] r
   L(sublst) lst
      L(i) sublst
         r [+]= i
   R r

F magic_shuffle(deck)
   V half = deck.len I/ 2
   R flatten(zip(deck[0 .< half], deck[half ..]))

F after_how_many_is_equal(start, end)
   V deck = magic_shuffle(start)
   V counter = 1
   L deck != end
      deck = magic_shuffle(deck)
      counter++
   R counter

print(‘Length of the deck of cards | Perfect shuffles needed to obtain the same deck back’)
L(length) (8, 24, 52, 100, 1020, 1024, 10000)
   V deck = Array(0 .< length)
   V shuffles_needed = after_how_many_is_equal(deck, deck)
   print(‘#<5 | #.’.format(length, shuffles_needed))
===
template <typename T1> auto flatten(const T1 &lst)
{
    Array<int> r;
    for (auto &&sublst : lst)
        for (auto &&i : sublst)
            r.append(i);
    return r;
}

template <typename T1> auto magic_shuffle(const T1 &deck)
{
    auto half = idiv(deck.len(), 2);
    return flatten(zip(deck[range_el(0, half)], deck[range_ei(half)]));
}

template <typename T1, typename T2> auto after_how_many_is_equal(const T1 &start, const T2 &end)
{
    auto deck = magic_shuffle(start);
    auto counter = 1;
    while (deck != end) {
        deck = magic_shuffle(deck);
        counter++;
    }
    return counter;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"Length of the deck of cards | Perfect shuffles needed to obtain the same deck back"_S);
        for (auto &&length : make_tuple(8, 24, 52, 100, 1020, 1024, 10000)) {
            auto deck = create_array(range_el(0, length));
            auto shuffles_needed = after_how_many_is_equal(deck, deck);
            print(u"#<5 | #."_S.format(length, shuffles_needed));
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Perfect_totient_numbers#Python
import math, itertools

def φ(n):
    return sum(1 for k in range(1, n + 1) if math.gcd(n, k) == 1)

def perfect_totient(cnt):
    r : List[int] = []

    for n0 in itertools.count(1):
        parts = 0
        n = n0
        while n != 1:
            n = φ(n)
            parts += n
        if parts == n0:
            r += [n0]
            if len(r) == cnt:
                return r

print(perfect_totient(20))
===
F φ(n)
   R sum((1 .. n).filter(k -> gcd(@n, k) == 1).map(k -> 1))

F perfect_totient(cnt)
   [Int] r

   L(n0) 1..
      V parts = 0
      V n = n0
      L n != 1
         n = φ(n)
         parts += n
      I parts == n0
         r [+]= n0
         I r.len == cnt
            R r

print(perfect_totient(20))
===
template <typename T1> auto φ(const T1 &n)
{
    return sum_map(range_ee(1, n).filter([&n](const auto &k){return gcd(n, k) == 1;}), [](const auto &k){return 1;});
}

template <typename T1> auto perfect_totient(const T1 &cnt)
{
    Array<int> r;

    for (auto n0 : range_ei(1)) {
        auto parts = 0;
        auto n = n0;
        while (n != 1) {
            n = φ(n);
            parts += n;
        }
        if (parts == n0) {
            r.append(n0);
            if (r.len() == cnt)
                return r;
        }
    }
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(perfect_totient(20));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Permutation_test#Kotlin
data = [85, 88, 75, 66, 25, 29, 83, 39, 97,
    68, 41, 10, 49, 16, 65, 32, 92, 28, 98]

def pick(at, remain, accu, treat):
    if remain == 0:
        return 1 if accu > treat else 0
    return pick(at - 1, remain - 1, accu + data[at - 1], treat) + \
          (pick(at - 1, remain, accu, treat) if at > remain else 0)

treat = 0
total = 1.0
for i in range(0, 9):
    treat += data[i]
for i in range(19, 10, -1):
    total *= i
for i in range(9, 0, -1):
    total /= i

gt = pick(19, 9, 0, treat)
le = int(total - gt)

print('<= : %f%%  %d' % (100 * le / total, le))
print(' > : %f%%  %d' % (100 * gt / total, gt))
===
V data = [85, 88, 75, 66, 25, 29, 83, 39, 97, 68, 41, 10, 49, 16, 65, 32, 92, 28, 98]

F pick(at, remain, accu, treat)
   I remain == 0
      R I accu > treat {1} E 0
   R pick(at - 1, remain - 1, accu + :data[at - 1], treat) + (I at > remain {pick(at - 1, remain, accu, treat)} E 0)

V treat = 0
V total = 1.0
L(i) 0..8
   treat += data[i]
L(i) (19.<10).step(-1)
   total *= i
L(i) (9.<0).step(-1)
   total /= i

V gt = pick(19, 9, 0, treat)
V le = Int(total - gt)

print(‘<= : #.6%  #.’.format(100 * le / total, le))
print(‘ > : #.6%  #.’.format(100 * gt / total, gt))
===
auto data = create_array({85, 88, 75, 66, 25, 29, 83, 39, 97, 68, 41, 10, 49, 16, 65, 32, 92, 28, 98});

template <typename T1, typename T2, typename T3, typename T4> auto pick(const T1 &at, const T2 &remain, const T3 &accu, const T4 &treat)
{
    if (remain == 0)
        return accu > treat ? 1 : 0;
    return pick(at - 1, remain - 1, accu + ::data[at - 1], treat) + (at > remain ? pick(at - 1, remain, accu, treat) : 0);
}

auto treat = 0;
auto total = 1.0;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto i : range_ee(0, 8))
            treat += data[i];
        for (auto i : range_el(19, 10).step(-1))
            total *= i;
        for (auto i : range_el(9, 0).step(-1))
            total /= i;
    }
} code_block_1;

auto gt = pick(19, 9, 0, treat);
auto le = to_int(total - gt);

struct CodeBlock2
{
    CodeBlock2()
    {
        print(u"<= : #.6%  #."_S.format(100 * le / total, le));
        print(u" > : #.6%  #."_S.format(100 * gt / total, gt));
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Permutations_with_repetitions#Kotlin
import sys

n = 3
values = ['A', 'B', 'C', 'D']
k = len(values)
decide = lambda pc: pc[0] == 'B' and pc[1] == 'C'
pn = [0] * n
pc = ["\0"] * n
while True:
    for i, x in enumerate(pn):
        pc[i] = values[x]
    print(pc)

    if decide(pc):
        break

    i = 0
    while True:
        pn[i] += 1
        if pn[i] < k: break
        pn[i] = 0
        i += 1
        if i == n:
            sys.exit(0) # ^L.break
===
V n = 3
V values = [‘A’, ‘B’, ‘C’, ‘D’]
V k = values.len
V decide = pc -> pc[0] == ‘B’ & pc[1] == ‘C’
V pn = [0] * n
V pc = ["\0"] * n
L
   L(x) pn
      V i = L.index
      pc[i] = values[x]
   print(pc)

   I decide(pc)
      L.break

   V i = 0
   L
      pn[i]++
      I pn[i] < k
         L.break
      pn[i] = 0
      i++
      I i == n
         exit(0)
===
auto n = 3;
auto values = create_array({u'A'_C, u'B'_C, u'C'_C, u'D'_C});
auto k = values.len();
auto decide = [](const auto &pc){return _get<0>(pc) == u'B' && _get<1>(pc) == u'C';};
auto pn = create_array({0}) * n;
auto pc = create_array({u'\0'_C}) * n;

struct CodeBlock1
{
    CodeBlock1()
    {
        while (true) {
            {int Lindex = 0;
            for (auto &&x : pn) {
                auto i = Lindex;
                pc.set(i, values[x]);
                Lindex++;
            }}
            print(pc);

            if (decide(pc))
                break;

            auto i = 0;
            while (true) {
                pn[i]++;
                if (pn[i] < k)
                    break;
                pn.set(i, 0);
                i++;
                if (i == n)
                    exit(0);
            }
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Pernicious_numbers#Python
import math

def popcount(n):
    return bin(n).count('1')

def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(math.sqrt(n)) + 1):
        if n % i == 0:
            return False
    return True

i = 0
cnt = 0
while True:
    if is_prime(popcount(i)):
        print(i, end = ' ')
        cnt += 1
        if cnt == 25:
            break
    i += 1

print()
for i in range(888888877, 888888888 + 1):
    if is_prime(popcount(i)):
        print(i, end = ' ')
===
F popcount(n)
   R bin(n).count(‘1’)

F is_prime(n)
   I n < 2
      R 0B
   L(i) 2 .. Int(sqrt(n))
      I n % i == 0
         R 0B
   R 1B

V i = 0
V cnt = 0
L
   I is_prime(popcount(i))
      print(i, end' ‘ ’)
      cnt++
      I cnt == 25
         L.break
   i++

print()
L(i) 888888877 .. 888888888
   I is_prime(popcount(i))
      print(i, end' ‘ ’)
===
template <typename T1> auto popcount(const T1 &n)
{
    return bin(n).count(u"1"_S);
}

template <typename T1> auto is_prime(const T1 &n)
{
    if (n < 2)
        return false;
    for (auto i : range_ee(2, to_int(sqrt(n))))
        if (mod(n, i) == 0)
            return false;
    return true;
}

auto i = 0;
auto cnt = 0;

struct CodeBlock1
{
    CodeBlock1()
    {
        while (true) {
            if (is_prime(popcount(i))) {
                print(i, u" "_S);
                cnt++;
                if (cnt == 25)
                    break;
            }
            i++;
        }

        print();
        for (auto i : range_ee(888888877, 888888888))
            if (is_prime(popcount(i)))
                print(i, u" "_S);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Phrase_reversals#Python
phrase = 'rosetta code phrase reversal'
print(phrase[::-1])
print(' '.join(word[::-1] for word in phrase.split(' ')))
print(' '.join(phrase.split(' ')[::-1]))
===
V phrase = ‘rosetta code phrase reversal’
print(reversed(phrase))
print(phrase.split(‘ ’).map(word -> reversed(word)).join(‘ ’))
print((reversed(phrase.split(‘ ’))).join(‘ ’))
===
auto phrase = u"rosetta code phrase reversal"_S;

struct CodeBlock1
{
    CodeBlock1()
    {
        print(reversed(phrase));
        print(phrase.split(u" "_S).map([](const auto &word){return reversed(word);}).join(u" "_S));
        print((reversed(phrase.split(u" "_S))).join(u" "_S));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Polynomial_regression#Swift
def average(arr):
    return sum(arr) / float(len(arr))

def poly_regression(x, y):
    xm = average(x)
    ym = average(y)
    x2m = average(list(map(lambda i: i * i,  x)))
    x3m = average(list(map(lambda i: i ** 3, x)))
    x4m = average(list(map(lambda i: i ** 4, x)))
    xym = average(list(map(lambda ij: ij[0] * ij[1], zip(x,y))))
    x2ym = average(list(map(lambda ij: ij[0] * ij[0] * ij[1], zip(x,y))))

    sxx = x2m - xm * xm
    sxy = xym - xm * ym
    sxx2 = x3m - xm * x2m
    sx2x2 = x4m - x2m * x2m
    sx2y = x2ym - x2m * ym

    b = (sxy * sx2x2 - sx2y * sxx2) / (sxx * sx2x2 - sxx2 * sxx2)
    c = (sx2y * sxx - sxy * sxx2) / (sxx * sx2x2 - sxx2 * sxx2)
    a = ym - b * xm - c * x2m

    def abc(xx):
        return (a + b * xx) + (c * xx * xx)

    print("y = %g + %gx + %gx^2\n" % (a, b, c))
    print(' Input  Approximation')
    print(' x   y     y1')

    for i in range(len(x)):
        print('%2d %3d  %5.1f' % (x[i], y[i], abc(i)))

x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
y = [1, 6, 17, 34, 57, 86, 121, 162, 209, 262, 321]
poly_regression(x, y)
===
F average(arr)
   R sum(arr) / Float(arr.len)

F poly_regression(x, y)
   V xm = average(x)
   V ym = average(y)
   V x2m = average(x.map(i -> i * i))
   V x3m = average(x.map(i -> i ^ 3))
   V x4m = average(x.map(i -> i ^ 4))
   V xym = average(zip(x, y).map(ij -> ij[0] * ij[1]))
   V x2ym = average(zip(x, y).map(ij -> ij[0] * ij[0] * ij[1]))

   V sxx = x2m - xm * xm
   V sxy = xym - xm * ym
   V sxx2 = x3m - xm * x2m
   V sx2x2 = x4m - x2m * x2m
   V sx2y = x2ym - x2m * ym

   V b = (sxy * sx2x2 - sx2y * sxx2) / (sxx * sx2x2 - sxx2 * sxx2)
   V c = (sx2y * sxx - sxy * sxx2) / (sxx * sx2x2 - sxx2 * sxx2)
   V a = ym - b * xm - c * x2m

   F abc(xx)
      R (@a + @b * xx) + (@c * xx * xx)

   print("y = #. + #.x + #.x^2\n".format(a, b, c))
   print(‘ Input  Approximation’)
   print(‘ x   y     y1’)

   L(i) 0 .< x.len
      print(‘#2 #3  #3.1’.format(x[i], y[i], abc(i)))

V x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
V y = [1, 6, 17, 34, 57, 86, 121, 162, 209, 262, 321]
poly_regression(x, y)
===
template <typename T1> auto average(const T1 &arr)
{
    return sum(arr) / to_float(arr.len());
}

template <typename T1, typename T2> auto poly_regression(const T1 &x, const T2 &y)
{
    auto xm = average(x);
    auto ym = average(y);
    auto x2m = average(x.map([](const auto &i){return i * i;}));
    auto x3m = average(x.map([](const auto &i){return cube(i);}));
    auto x4m = average(x.map([](const auto &i){return pow(i, 4);}));
    auto xym = average(zip(x, y).map([](const auto &ij){return _get<0>(ij) * _get<1>(ij);}));
    auto x2ym = average(zip(x, y).map([](const auto &ij){return _get<0>(ij) * _get<0>(ij) * _get<1>(ij);}));

    auto sxx = x2m - xm * xm;
    auto sxy = xym - xm * ym;
    auto sxx2 = x3m - xm * x2m;
    auto sx2x2 = x4m - x2m * x2m;
    auto sx2y = x2ym - x2m * ym;

    auto b = (sxy * sx2x2 - sx2y * sxx2) / (sxx * sx2x2 - sxx2 * sxx2);
    auto c = (sx2y * sxx - sxy * sxx2) / (sxx * sx2x2 - sxx2 * sxx2);
    auto a = ym - b * xm - c * x2m;

    auto abc = [&a, &b, &c](const auto &xx)
    {
        return (a + b * xx) + (c * xx * xx);
    };

    print(u"y = #. + #.x + #.x^2\n"_S.format(a, b, c));
    print(u" Input  Approximation"_S);
    print(u" x   y     y1"_S);

    for (auto i : range_el(0, x.len()))
        print(u"#2 #3  #3.1"_S.format(x[i], y[i], abc(i)));
}

auto x = create_array({0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10});
auto y = create_array({1, 6, 17, 34, 57, 86, 121, 162, 209, 262, 321});

struct CodeBlock1
{
    CodeBlock1()
    {
        poly_regression(x, y);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Polynomial_synthetic_division#Python
def extended_synthetic_division(dividend, divisor):
    '''Fast polynomial division by using Extended Synthetic Division. Also works with non-monic polynomials.'''
    # dividend and divisor are both polynomials, which are here simply lists of coefficients. Eg: x^2 + 3x + 5 will be represented as [1, 3, 5]

    out = dividend[:] # Copy the dividend
    normalizer = divisor[0]
    for i in range(len(dividend)-(len(divisor)-1)):
        out[i] /= normalizer # for general polynomial division (when polynomials are non-monic),
                                 # we need to normalize by dividing the coefficient with the divisor's first coefficient
        coef = out[i]
        if coef != 0: # useless to multiply if coef is 0
            for j in range(1, len(divisor)): # in synthetic division, we always skip the first coefficient of the divisor,
                                              # because it's only used to normalize the dividend coefficients
                out[i + j] += -divisor[j] * coef

    # The resulting out contains both the quotient and the remainder, the remainder being the size of the divisor (the remainder
    # has necessarily the same degree as the divisor since it's what we couldn't divide from the dividend), so we compute the index
    # where this separation is, and return the quotient and remainder.
    separator = len(divisor)-1
    return (out[:-separator], out[-separator:]) # return quotient, remainder.

print("POLYNOMIAL SYNTHETIC DIVISION")
n = [1, -12, 0, -42]
D = [1, -3]
print("  %s / %s =" % (n,D), end = ' ')
(a, b) = extended_synthetic_division(n, D)
print("%s remainder %s" % (a, b))
===
F extended_synthetic_division(dividend, divisor)
   ‘Fast polynomial division by using Extended Synthetic Division. Also works with non-monic polynomials.’

   V out = copy(dividend)
   V normalizer = divisor[0]
   L(i) 0 .< dividend.len - (divisor.len - 1)
      out[i] /= normalizer
      V coef = out[i]
      I coef != 0
         L(j) 1 .< divisor.len
            out[i + j] += -divisor[j] * coef

   V separator = divisor.len - 1
   R (out[0 .< (len)-separator], out[(len)-separator ..])

print(‘POLYNOMIAL SYNTHETIC DIVISION’)
V n = [1, -12, 0, -42]
V D = [1, -3]
print(‘  #. / #. =’.format(n, D), end' ‘ ’)
V (a, b) = extended_synthetic_division(n, D)
print(‘#. remainder #.’.format(a, b))
===
template <typename T1, typename T2> auto extended_synthetic_division(const T1 &dividend, const T2 &divisor)
{
    u"Fast polynomial division by using Extended Synthetic Division. Also works with non-monic polynomials."_S;

    auto out = copy(dividend);
    auto normalizer = _get<0>(divisor);
    for (auto i : range_el(0, dividend.len() - (divisor.len() - 1))) {
        out[i] /= normalizer;
        auto coef = out[i];
        if (coef != 0)
            for (auto j : range_el(1, divisor.len()))
                out[i + j] += -divisor[j] * coef;
    }

    auto separator = divisor.len() - 1;
    return make_tuple(out[range_e_llen(0,  - separator)], out[range_elen_i( - separator)]);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"POLYNOMIAL SYNTHETIC DIVISION"_S);
    }
} code_block_1;

auto n = create_array({1, -12, 0, -42});
auto D = create_array({1, -3});

struct CodeBlock2
{
    CodeBlock2()
    {
        print(u"  #. / #. ="_S.format(n, D), u" "_S);
    }
} code_block_2;

auto [a, b] = extended_synthetic_division(n, D);

struct CodeBlock3
{
    CodeBlock3()
    {
        print(u"#. remainder #."_S.format(a, b));
    }
} code_block_3;


# https://www.rosettacode.org/wiki/Population_count#Python
from typing import List
Int64 = int

def popcount(n):
    return bin(n).count('1')

print([popcount(Int64(3)**i) for i in range(30)])

evil : List[int] = []
odious : List[int] = []
i = 0
while len(evil) < 30 or len(odious) < 30:
    p = popcount(i)
    if (p % 2) != 0: odious.append(i)
    else: evil.append(i)
    i += 1

print(evil[:30])
print(odious[:30])
===
F popcount(n)
   R bin(n).count(‘1’)

print((0.<30).map(i -> popcount(Int64(3) ^ i)))

[Int] evil
[Int] odious
V i = 0
L evil.len < 30 | odious.len < 30
   V p = popcount(i)
   I (p % 2) != 0
      odious.append(i)
   E
      evil.append(i)
   i++

print(evil[0.<30])
print(odious[0.<30])
===
template <typename T1> auto popcount(const T1 &n)
{
    return bin(n).count(u"1"_S);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(range_el(0, 30).map([](const auto &i){return popcount(pow(to_int64(3), i));}));
    }
} code_block_1;

Array<int> evil;
Array<int> odious;
auto i = 0;

struct CodeBlock2
{
    CodeBlock2()
    {
        while (evil.len() < 30 || odious.len() < 30) {
            auto p = popcount(i);
            if ((mod(p, 2)) != 0)
                odious.append(i);
            else
                evil.append(i);
            i++;
        }

        print(evil[range_el(0, 30)]);
        print(odious[range_el(0, 30)]);
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Power_set#Python
def list_powerset(lst):
    # the power set of the empty set has one element, the empty set
    empty_list : List[int] = []
    result = [empty_list]
    for x in lst:
        # for every additional element in our set
        # the power set consists of the subsets that don't
        # contain this element (just take the previous power set)
        # plus the subsets that do contain the element (use list
        # comprehension to add [x] onto everything in the
        # previous power set)
        result.extend([subset + [x] for subset in result])
    return result

print(list_powerset([1,2,3]))
===
F list_powerset(lst)
   [Int] empty_list
   V result = [empty_list]
   L(x) lst
      result.extend(result.map(subset -> subset [+] [@x]))
   R result

print(list_powerset([1, 2, 3]))
===
template <typename T1> auto list_powerset(const T1 &lst)
{
    Array<int> empty_list;
    auto result = create_array({empty_list});
    for (auto &&x : lst)
        result.extend(result.map([&x](const auto &subset){return subset + create_array({x});}));
    return result;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(list_powerset(create_array({1, 2, 3})));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Primality_by_Wilson%27s_theorem#Python
import math
Int64 = int

def is_wprime(n : Int64):
    return n > 1 and (n == 2 or
                      (n % 2 and (math.factorial(n - 1) + 1) % n == 0))

c = 20
print("Primes under %d:" % c, end="\n  ")
print([n for n in range(c) if is_wprime(n)])
===
F is_wprime(Int64 n)
   R n > 1 & (n == 2 | (n % 2 & (factorial(n - 1) + 1) % n == 0))

V c = 20
print(‘Primes under #.:’.format(c), end' "\n  ")
print((0 .< c).filter(n -> is_wprime(n)))
===
auto is_wprime(const Int64 &n)
{
    return n > 1 && (n == 2 || (mod(n, 2) && mod((factorial(n - 1) + 1), n) == 0));
}

auto c = 20;

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"Primes under #.:"_S.format(c), u"\n  "_S);
        print(range_el(0, c).filter([](const auto &n){return is_wprime(n);}));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Prime_conspiracy#Python
import math, collections

limit = 1000000
k = limit
n = k * 17
primes = [True] * n
primes[0] = primes[1] = False

for i in range(2, int(math.sqrt(n)) + 1):
    if not primes[i]:
        continue
    for j in range(i * i, n, i):
        primes[j] = False

trans_map = collections.defaultdict(int) # Tuple[int, int]
prev = -1

for i in range(n):
    if primes[i]:
        if prev != -1:
            trans_map[(prev, i % 10)] += 1
        prev = i % 10

        if k == 1:
            break
        k -= 1

print("First %d primes. Transitions prime %% 10 > next-prime %% 10." % limit)
for trans in sorted(trans_map.keys()):
    print('%d -> %d count %5d frequency: %.4f%%' % (trans[0], trans[1], trans_map[trans], 100.0 * trans_map[trans] / limit))
===
V limit = 1000000
V k = limit
V n = k * 17
V primes = [1B] * n
primes[0] = primes[1] = 0B

L(i) 2 .. Int(sqrt(n))
   I !primes[i]
      L.continue
   L(j) (i * i .< n).step(i)
      primes[j] = 0B

V trans_map = DefaultDict[(Int, Int), Int]()
V prev = -1

L(i) 0 .< n
   I primes[i]
      I prev != -1
         trans_map[(prev, i % 10)]++
      prev = i % 10

      I k == 1
         L.break
      k--

print(‘First #. primes. Transitions prime % 10 > next-prime % 10.’.format(limit))
L(trans) sorted(trans_map.keys())
   print(‘#. -> #. count #5 frequency: #.4%’.format(trans[0], trans[1], trans_map[trans], 100.0 * trans_map[trans] / limit))
===
auto limit = 1000000;
auto k = limit;
auto n = k * 17;
auto primes = create_array({true}) * n;

struct CodeBlock1
{
    CodeBlock1()
    {
        _set<0>(primes, _set<1>(primes, false));

        for (auto i : range_ee(2, to_int(sqrt(n)))) {
            if (!primes[i])
                continue;
            for (auto j : range_el(i * i, n).step(i))
                primes.set(j, false);
        }
    }
} code_block_1;

auto trans_map = DefaultDict<ivec2, int>();
auto prev = -1;

struct CodeBlock2
{
    CodeBlock2()
    {
        for (auto i : range_el(0, n))
            if (primes[i]) {
                if (prev != -1)
                    trans_map[make_tuple(prev, mod(i, 10))]++;
                prev = mod(i, 10);

                if (k == 1)
                    break;
                k--;
            }

        print(u"First #. primes. Transitions prime % 10 > next-prime % 10."_S.format(limit));
        for (auto &&trans : sorted(trans_map.keys()))
            print(u"#. -> #. count #5 frequency: #.4%"_S.format(_get<0>(trans), _get<1>(trans), trans_map[trans], 100.0 * trans_map[trans] / limit));
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Priority_queue#Python
import heapq
items = [(3, "Clear drains"), (4, "Feed cat"), (5, "Make tea"), (1, "Solve RC tasks"), (2, "Tax return")]
heapq.heapify(items)
while len(items):
    print(heapq.heappop(items))
===
V items = [(3, ‘Clear drains’), (4, ‘Feed cat’), (5, ‘Make tea’), (1, ‘Solve RC tasks’), (2, ‘Tax return’)]
minheap:heapify(&items)
L !items.empty
   print(minheap:pop(&items))
===
auto items = create_array({make_tuple(3, u"Clear drains"_S), make_tuple(4, u"Feed cat"_S), make_tuple(5, u"Make tea"_S), make_tuple(1, u"Solve RC tasks"_S), make_tuple(2, u"Tax return"_S)});

struct CodeBlock1
{
    CodeBlock1()
    {
        minheap::heapify(items);
        while (!items.empty())
            print(minheap::pop(items));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Product_of_divisors#Python
def product_of_divisors(n):
    ans = 1
    i = 1
    j = 1
    while i*i <= n:
        if 0 == n%i:
            ans *= i
            j = n//i
            if j != i:
                ans *= j
        i += 1
    return ans

print([product_of_divisors(n) for n in range(1,51)])
===
F product_of_divisors(n)
   V ans = 1
   V i = 1
   V j = 1
   L i * i <= n
      I 0 == n % i
         ans *= i
         j = n I/ i
         I j != i
            ans *= j
      i++
   R ans

print((1..50).map(n -> product_of_divisors(n)))
===
template <typename T1> auto product_of_divisors(const T1 &n)
{
    auto ans = 1;
    auto i = 1;
    auto j = 1;
    while (i * i <= n) {
        if (0 == mod(n, i)) {
            ans *= i;
            j = idiv(n, i);
            if (j != i)
                ans *= j;
        }
        i++;
    }
    return ans;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(range_ee(1, 50).map([](const auto &n){return product_of_divisors(n);}));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Proper_divisors#Python
def proper_divs(n):
    return list({x for x in range(1, (n + 1) // 2 + 1) if n % x == 0 and n != x})

print([proper_divs(n) for n in range(1, 11)])

(n, leng) = max(((n, len(proper_divs(n))) for n in range(1, 20001)), key=lambda pd: pd[1])
print(n, leng)
===
F proper_divs(n)
   R Array(Set((1 .. (n + 1) I/ 2).filter(x -> @n % x == 0 & @n != x)))

print((1..10).map(n -> proper_divs(n)))

V (n, leng) = max(((1..20000).map(n -> (n, proper_divs(n).len))), key' pd -> pd[1])
print(n‘ ’leng)
===
template <typename T1> auto proper_divs(const T1 &n)
{
    return create_array(create_set(range_ee(1, idiv((n + 1), 2)).filter([&n](const auto &x){return mod(n, x) == 0 && n != x;})));
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(range_ee(1, 10).map([](const auto &n){return proper_divs(n);}));
    }
} code_block_1;

auto [n, leng] = max_with_key((range_ee(1, 20000).map([](const auto &n){return make_tuple(n, proper_divs(n).len());})), [](const auto &pd){return _get<1>(pd);});

struct CodeBlock2
{
    CodeBlock2()
    {
        print(n & u" "_S & leng);
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Pythagorean_quadruples#Python
def quad(top = 2200):
    r = [False] * top
    ab = [False] * (top * 2)**2
    for a in range(1, top):
        for b in range(a, top):
            ab[a * a + b * b] = True
    s = 3
    for c in range(1, top):
        (s1, s, s2) = (s, s + 2, s + 2)
        for d in range(c + 1, top):
            if ab[s1]:
                r[d] = True
            s1 += s2
            s2 += 2
    return [i for i, val in enumerate(r) if not val and i]

print(quad())
===
F quad(top = 2200)
   V r = [0B] * top
   V ab = [0B] * (top * 2) ^ 2
   L(a) 1 .< top
      L(b) a .< top
         ab[a * a + b * b] = 1B
   V s = 3
   L(c) 1 .< top
      (V s1, s, V s2) = (s, s + 2, s + 2)
      L(d) c + 1 .< top
         I ab[s1]
            r[d] = 1B
         s1 += s2
         s2 += 2
   R enumerate(r).filter((i, val) -> !val & i).map((i, val) -> i)

print(quad())
===
template <typename T1 = decltype(2200)> auto quad(const T1 &top = 2200)
{
    auto r = create_array({false}) * top;
    auto ab = create_array({false}) * square((top * 2));
    for (auto a : range_el(1, top))
        for (auto b : range_el(a, top))
            ab.set(a * a + b * b, true);
    auto s = 3;
    for (auto c : range_el(1, top)) {
        TUPLE_ELEMENT_T(0, make_tuple(s, s + 2, s + 2)) s1;
        TUPLE_ELEMENT_T(2, make_tuple(s, s + 2, s + 2)) s2;
        assign_from_tuple(s1, s, s2, make_tuple(s, s + 2, s + 2));
        for (auto d : range_el(c + 1, top)) {
            if (ab[s1])
                r.set(d, true);
            s1 += s2;
            s2 += 2;
        }
    }
    return enumerate(r).filter([](const auto &i, const auto &val){return !val && i;}).map([](const auto &i, const auto &val){return i;});
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(quad());
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Partition_function_P#Python
import time
BigInt = int

def partitions(n):
    """Count partitions."""
    p = [BigInt(1)] + [BigInt(0)] * n
    for i in range(1, n + 1):
        k = 0
        while True:
            k += 1
            j = (k * (3*k - 1)) // 2
            if j > i:
                break
            if k & 1:
                p[i] += p[i - j]
            else:
                p[i] -= p[i - j]
            j = (k * (3*k + 1)) // 2
            if j > i:
                break
            if k & 1:
                p[i] += p[i - j]
            else:
                p[i] -= p[i - j]

    return p[n]

print("Partitions:", [partitions(x) for x in range(15)])

start = time.perf_counter()
print(partitions(6666))
print(time.perf_counter() - start)
===
F partitions(n)
   ‘Count partitions.’
   V p = [BigInt(1)] [+] [BigInt(0)] * n
   L(i) 1 .. n
      V k = 0
      L
         k++
         V j = (k * (3 * k - 1)) I/ 2
         I j > i
            L.break
         I k [&] 1
            p[i] += p[i - j]
         E
            p[i] -= p[i - j]
         j = (k * (3 * k + 1)) I/ 2
         I j > i
            L.break
         I k [&] 1
            p[i] += p[i - j]
         E
            p[i] -= p[i - j]

   R p[n]

print(‘Partitions: ’(0.<15).map(x -> partitions(x)))

V start = time:perf_counter()
print(partitions(6666))
print(time:perf_counter() - start)
===
template <typename T1> auto partitions(const T1 &n)
{
    u"Count partitions."_S;
    auto p = create_array({BigInt(1)}) + create_array({BigInt(0)}) * n;
    for (auto i : range_ee(1, n)) {
        auto k = 0;
        while (true) {
            k++;
            auto j = idiv((k * (3 * k - 1)), 2);
            if (j > i)
                break;
            if (k & 1)
                p[i] += p[i - j];
            else
                p[i] -= p[i - j];
            j = idiv((k * (3 * k + 1)), 2);
            if (j > i)
                break;
            if (k & 1)
                p[i] += p[i - j];
            else
                p[i] -= p[i - j];
        }
    }

    return p[n];
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"Partitions: "_S & range_el(0, 15).map([](const auto &x){return partitions(x);}));
    }
} code_block_1;

auto start = timens::perf_counter();

struct CodeBlock2
{
    CodeBlock2()
    {
        print(partitions(6666));
        print(timens::perf_counter() - start);
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Prime_decomposition#D
# Slow BigInt
BigInt = int

def decompose(number : BigInt):
    result : List[BigInt] = []
    n = number
    i : BigInt = 2
    while n % i == 0:
        result.append(i)
        n //= i
    i = 3
    while n >= i * i:
        while n % i == 0:
            result.append(i)
            n //= i
        i += 2
    if n != 1:
        result.append(n)
    return result

for i in range(2, 10):
    print(decompose(i))
print(decompose(1023 * 1024))
print(decompose(2 * 3 * 5 * 7 * 11 * 11 * 13 * 17))
print(decompose(BigInt(16860167264933) * 179951))
===
F decompose(BigInt number)
   [BigInt] result
   V n = number
   BigInt i = 2
   L n % i == 0
      result.append(i)
      n I/= i
   i = 3
   L n >= i * i
      L n % i == 0
         result.append(i)
         n I/= i
      i += 2
   I n != 1
      result.append(n)
   R result

L(i) 2..9
   print(decompose(i))
print(decompose(1023 * 1024))
print(decompose(2 * 3 * 5 * 7 * 11 * 11 * 13 * 17))
print(decompose(BigInt(16860167264933) * 179951))
===
auto decompose(const BigInt &number)
{
    Array<BigInt> result;
    auto n = number;
    BigInt i = 2;
    while (mod(n, i) == 0) {
        result.append(i);
        n = idiv(n, i);
    }
    i = 3;
    while (n >= i * i) {
        while (mod(n, i) == 0) {
            result.append(i);
            n = idiv(n, i);
        }
        i += 2;
    }
    if (n != 1)
        result.append(n);
    return result;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto i : range_ee(2, 9))
            print(decompose(i));
        print(decompose(1023 * 1024));
        print(decompose(2 * 3 * 5 * 7 * 11 * 11 * 13 * 17));
        print(decompose(BigInt(16860167264933) * 179951));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Primorial_numbers#Python
BigInt = int

def get_primes(primes_count):
    limit = 17 * primes_count
    is_prime = [False] * 2 + [True] * (limit - 1)
    for n in range(int(limit**0.5 + 1.5)): # stop at ``sqrt(limit)``
        if is_prime[n]:
            for i in range(n*n, limit+1, n):
                is_prime[i] = False

    primes : List[int] = []
    for i, prime in enumerate(is_prime):
        if prime:
            primes.append(i)
            if len(primes) == primes_count:
                break
    return primes

primes = get_primes(100000)

def primorial(n):
    r : BigInt = 1
    for i in range(n):
        r *= primes[i]
    return r

print('First ten primorials:', [primorial(n) for n in range(10)])
for e in range(6):
    n = 10**e
    print('primorial(%i) has %i digits' % (n, len(str(primorial(n)))))
===
F get_primes(primes_count)
   V limit = 17 * primes_count
   V is_prime = [0B] * 2 [+] [1B] * (limit - 1)
   L(n) 0 .< Int(limit ^ 0.5 + 1.5)
      I is_prime[n]
         L(i) (n * n .< limit + 1).step(n)
            is_prime[i] = 0B

   [Int] primes
   L(prime) is_prime
      V i = L.index
      I prime
         primes.append(i)
         I primes.len == primes_count
            L.break
   R primes

V primes = get_primes(100000)

F primorial(n)
   BigInt r = 1
   L(i) 0 .< n
      r *= :primes[i]
   R r

print(‘First ten primorials: ’(0.<10).map(n -> primorial(n)))
L(e) 6
   V n = 10 ^ e
   print(‘primorial(#.) has #. digits’.format(n, String(primorial(n)).len))
===
template <typename T1> auto get_primes(const T1 &primes_count)
{
    auto limit = 17 * primes_count;
    auto is_prime = create_array({false}) * 2 + create_array({true}) * (limit - 1);
    for (auto n : range_el(0, to_int(pow(limit, 0.5) + 1.5)))
        if (is_prime[n])
            for (auto i : range_el(n * n, limit + 1).step(n))
                is_prime.set(i, false);

    Array<int> primes;
    {int Lindex = 0;
    for (auto &&prime : is_prime) {
        auto i = Lindex;
        if (prime) {
            primes.append(i);
            if (primes.len() == primes_count)
                break;
        }
        Lindex++;
    }}
    return primes;
}

auto primes = get_primes(100000);

template <typename T1> auto primorial(const T1 &n)
{
    BigInt r = 1;
    for (auto i : range_el(0, n))
        r *= ::primes[i];
    return r;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"First ten primorials: "_S & range_el(0, 10).map([](const auto &n){return primorial(n);}));
        for (int e = 0; e < 6; e++) {
            auto n = pow(10, e);
            print(u"primorial(#.) has #. digits"_S.format(n, String(primorial(n)).len()));
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Partition_an_integer_x_into_n_primes#D
def is_prime(a):
    return not (a < 2 or any(a % x == 0 for x in range(2, int(a**0.5) + 1)))

def generate_primes(n):
    r = [2]
    i = 3
    while True:
        if is_prime(i):
            r.append(i)
            if len(r) == n:
                break
        i += 2
    return r

primes = generate_primes(50_000)

def find_combo(k, x, m, n, combo : list):
    if k >= m:
        if sum(primes[idx] for idx in combo) == x:
            print('Partitioned %5d with %2d %s: ' % (x, m, 'primes' if m > 1 else 'prime '), end = '')
            for i in range(m):
                print(primes[combo[i]], end = '+' if i < m - 1 else "\n") # L.last_iteration
            return True
    else:
        for j in range(n):
            if k == 0 or j > combo[k-1]:
                combo[k] = j
                if find_combo(k+1, x, m, n, combo):
                    return True
    return False

def partition(x, m):
    n = len([a for a in primes if a <= x])
    combo = [0] * m
    if not find_combo(0, x, m, n, combo):
        print('Partitioned %5d with %2d %s: (not possible)' % (x, m, 'primes' if m > 1 else 'prime '))

data = [(99809, 1), (18, 2), (19, 3), (20, 4), (2017, 24),
        (22699, 1), (22699, 2), (22699, 3), (22699, 4), (40355, 3)]

for n, cnt in data:
    partition(n, cnt)
===
F is_prime(a)
   R !(a < 2 | any((2 .. Int(a ^ 0.5)).map(x -> @a % x == 0)))

F generate_primes(n)
   V r = [2]
   V i = 3
   L
      I is_prime(i)
         r.append(i)
         I r.len == n
            L.break
      i += 2
   R r

V primes = generate_primes(50'000)

F find_combo(k, x, m, n, &combo)
   I k >= m
      I sum(combo.map(idx -> :primes[idx])) == x
         print(‘Partitioned #5 with #2 #.: ’.format(x, m, I m > 1 {‘primes’} E ‘prime ’), end' ‘’)
         L(i) 0 .< m
            print(:primes[combo[i]], end' I i < m - 1 {‘+’} E "\n")
         R 1B
   E
      L(j) 0 .< n
         I k == 0 | j > combo[k - 1]
            combo[k] = j
            I find_combo(k + 1, x, m, n, &combo)
               R 1B
   R 0B

F partition(x, m)
   V n = :primes.filter(a -> a <= @x).len
   V combo = [0] * m
   I !find_combo(0, x, m, n, &combo)
      print(‘Partitioned #5 with #2 #.: (not possible)’.format(x, m, I m > 1 {‘primes’} E ‘prime ’))

V data = [(99809, 1), (18, 2), (19, 3), (20, 4), (2017, 24), (22699, 1), (22699, 2), (22699, 3), (22699, 4), (40355, 3)]

L(n, cnt) data
   partition(n, cnt)
===
template <typename T1> auto is_prime(const T1 &a)
{
    return !(a < 2 || any_map(range_ee(2, to_int(pow(a, 0.5))), [&a](const auto &x){return mod(a, x) == 0;}));
}

template <typename T1> auto generate_primes(const T1 &n)
{
    auto r = create_array({2});
    auto i = 3;
    while (true) {
        if (is_prime(i)) {
            r.append(i);
            if (r.len() == n)
                break;
        }
        i += 2;
    }
    return r;
}

auto primes = generate_primes(50'000);

template <typename T1, typename T2, typename T3, typename T4, typename T5> auto find_combo(const T1 &k, const T2 &x, const T3 &m, const T4 &n, T5 &combo)
{
    if (k >= m) {
        if (sum_map(combo, [](const auto &idx){return ::primes[idx];}) == x) {
            print(u"Partitioned #5 with #2 #.: "_S.format(x, m, m > 1 ? u"primes"_S : u"prime "_S), u""_S);
            for (auto i : range_el(0, m))
                print(::primes[combo[i]], i < m - 1 ? u"+"_S : u"\n"_S);
            return true;
        }
    }
    else
        for (auto j : range_el(0, n))
            if (k == 0 || j > combo[k - 1]) {
                combo.set(k, j);
                if (find_combo(k + 1, x, m, n, combo))
                    return true;
            }
    return false;
}

template <typename T1, typename T2> auto partition(const T1 &x, const T2 &m)
{
    auto n = ::primes.filter([&x](const auto &a){return a <= x;}).len();
    auto combo = create_array({0}) * m;
    if (!find_combo(0, x, m, n, combo))
        print(u"Partitioned #5 with #2 #.: (not possible)"_S.format(x, m, m > 1 ? u"primes"_S : u"prime "_S));
}

auto data = create_array({make_tuple(99809, 1), make_tuple(18, 2), make_tuple(19, 3), make_tuple(20, 4), make_tuple(2017, 24), make_tuple(22699, 1), make_tuple(22699, 2), make_tuple(22699, 3), make_tuple(22699, 4), make_tuple(40355, 3)});

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&[n, cnt] : data)
            partition(n, cnt);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Pascal%27s_triangle/Puzzle#D
def e(x : list, row, col): # -> &
    return x[row * (row + 1) // 2 + col]

def iterate(v : list, diff : list, do_print = True):
    tot = 0.0
    while True:
        e(v, 0, 0) = 151
        e(v, 2, 0) = 40
        e(v, 4, 1) = 11
        e(v, 4, 3) = 4

        for i in range(1, 5):
            for j in range(i + 1):
                e(diff, i, j) = 0
                if j < i:
                    e(diff, i, j) += e(v, i - 1, j) - e(v, i, j + 1) - e(v, i, j)
                if j != 0:
                    e(diff, i, j) += e(v, i - 1, j - 1) - e(v, i, j - 1) - e(v, i, j)

        for i in range(1, 4):
            for j in range(0, i):
                e(diff, i, j) += e(v, i + 1, j) + e(v, i + 1, j + 1) - e(v, i, j)

        e(diff, 4, 2) += e(v, 4, 0) + e(v, 4, 4) - e(v, 4, 2)

        for i in range(len(v)):
            v[i] += diff[i] / 4

        tot = sum(a * a for a in diff)
        if do_print:
            print('dev:', tot)
        if tot < 0.1:
            break

v = [0.0] * 15
diff = [0.0] * 15
iterate(v, diff)

idx = 0
for i in range(5):
    for j in range(i + 1):
        print('%4d' % int(0.5 + v[idx]), end = ' ' if j < i else "\n")
        idx += 1
===
F e(&x, row, col) -> &
   R x[row * (row + 1) I/ 2 + col]

F iterate(&v, &diff, do_print = 1B)
   V tot = 0.0
   L
      e(&v, 0, 0) = 151
      e(&v, 2, 0) = 40
      e(&v, 4, 1) = 11
      e(&v, 4, 3) = 4

      L(i) 1..4
         L(j) 0 .. i
            e(&diff, i, j) = 0
            I j < i
               e(&diff, i, j) += e(&v, i - 1, j) - e(&v, i, j + 1) - e(&v, i, j)
            I j != 0
               e(&diff, i, j) += e(&v, i - 1, j - 1) - e(&v, i, j - 1) - e(&v, i, j)

      L(i) 1..3
         L(j) 0 .< i
            e(&diff, i, j) += e(&v, i + 1, j) + e(&v, i + 1, j + 1) - e(&v, i, j)

      e(&diff, 4, 2) += e(&v, 4, 0) + e(&v, 4, 4) - e(&v, 4, 2)

      L(i) 0 .< v.len
         v[i] += diff[i] / 4

      tot = sum(diff.map(a -> a * a))
      I do_print
         print(‘dev: ’tot)
      I tot < 0.1
         L.break

V v = [0.0] * 15
V diff = [0.0] * 15
iterate(&v, &diff)

V idx = 0
L(i) 5
   L(j) 0 .. i
      print(‘#4’.format(Int(0.5 + v[idx])), end' I j < i {‘ ’} E "\n")
      idx++
===
template <typename T1, typename T2, typename T3> auto& e(T1 &x, const T2 &row, const T3 &col)
{
    return x[idiv(row * (row + 1), 2) + col];
}

template <typename T1, typename T2, typename T3 = decltype(true)> auto iterate(T1 &v, T2 &diff, const T3 &do_print = true)
{
    auto tot = 0.0;
    while (true) {
        e(v, 0, 0) = 151;
        e(v, 2, 0) = 40;
        e(v, 4, 1) = 11;
        e(v, 4, 3) = 4;

        for (auto i : range_ee(1, 4))
            for (auto j : range_ee(0, i)) {
                e(diff, i, j) = 0;
                if (j < i)
                    e(diff, i, j) += e(v, i - 1, j) - e(v, i, j + 1) - e(v, i, j);
                if (j != 0)
                    e(diff, i, j) += e(v, i - 1, j - 1) - e(v, i, j - 1) - e(v, i, j);
            }

        for (auto i : range_ee(1, 3))
            for (auto j : range_el(0, i))
                e(diff, i, j) += e(v, i + 1, j) + e(v, i + 1, j + 1) - e(v, i, j);

        e(diff, 4, 2) += e(v, 4, 0) + e(v, 4, 4) - e(v, 4, 2);

        for (auto i : range_el(0, v.len()))
            v[i] += diff[i] / 4.0;

        tot = sum_map(diff, [](const auto &a){return a * a;});
        if (do_print)
            print(u"dev: "_S & tot);
        if (tot < 0.1)
            break;
    }
}

auto v = create_array({0.0}) * 15;
auto diff = create_array({0.0}) * 15;

struct CodeBlock1
{
    CodeBlock1()
    {
        iterate(v, diff);
    }
} code_block_1;

auto idx = 0;

struct CodeBlock2
{
    CodeBlock2()
    {
        for (int i = 0; i < 5; i++)
            for (auto j : range_ee(0, i)) {
                print(u"#4"_S.format(to_int(0.5 + v[idx])), j < i ? u" "_S : u"\n"_S);
                idx++;
            }
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Peaceful_chess_queen_armies#D
from enum import IntEnum
from typing import List, Tuple

class Piece(IntEnum):
    EMPTY = 0
    BLACK = 1
    WHITE = 2

def isAttacking(queen, pos):
    return queen[0] == pos[0] \
        or queen[1] == pos[1] \
        or abs(queen[0] - pos[0]) == abs(queen[1] - pos[1])

def place(m, n, pBlackQueens : list, pWhiteQueens : list):
    if m == 0:
        return True

    placingBlack = True
    for i in range(n):
        for j in range(n):
            pos = (i, j)
            for queen in pBlackQueens:
                if queen == pos or ((not placingBlack) and isAttacking(queen, pos)):
                    break # `L(j).continue`
            else:
                for queen in pWhiteQueens:
                    if queen == pos or (placingBlack and isAttacking(queen, pos)):
                        break
                else:
                    if placingBlack:
                        pBlackQueens += [pos]
                        placingBlack = False
                    else:
                        pWhiteQueens += [pos]
                        if place(m - 1, n, pBlackQueens, pWhiteQueens):
                            return True
                        pBlackQueens.pop()
                        pWhiteQueens.pop()
                        placingBlack = True

    if not placingBlack:
        pBlackQueens.pop()
    return False

def printBoard(n, blackQueens, whiteQueens):
    board = [Piece.EMPTY] * (n * n)

    for queen in blackQueens:
        board[queen[0] * n + queen[1]] = Piece.BLACK

    for queen in whiteQueens:
        board[queen[0] * n + queen[1]] = Piece.WHITE

    for i, b in enumerate(board):
        if i != 0 and i % n == 0:
            print()
        if b == Piece.BLACK:
            print('B ', end = '')
        elif b == Piece.WHITE:
            print('W ', end = '')
        else:
            j = i // n
            k = i - j * n
            if j % 2 == k % 2:
                print('x ', end = '')
            else:
                print('o ', end = '')
    print("\n")

nms = [
        (2, 1), (3, 1), (3, 2), (4, 1), (4, 2), (4, 3),
        (5, 1), (5, 2), (5, 3), (5, 4), (5, 5),
        (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6),
        (7, 1), (7, 2), (7, 3), (7, 4), (7, 5), (7, 6), (7, 7),
      ]

for nm in nms:
    print("%d black and %d white queens on a %d x %d board:" % (nm[1], nm[1], nm[0], nm[0]))
    blackQueens : List[Tuple[int, int]] = []
    whiteQueens : List[Tuple[int, int]] = []
    if place(nm[1], nm[0], blackQueens, whiteQueens):
        printBoard(nm[0], blackQueens, whiteQueens)
    else:
        print("No solution exists.\n")
===
T.enum Piece
   EMPTY
   BLACK
   WHITE

F isAttacking(queen, pos)
   R queen[0] == pos[0] | queen[1] == pos[1] | abs(queen[0] - pos[0]) == abs(queen[1] - pos[1])

F place(m, n, &pBlackQueens, &pWhiteQueens)
   I m == 0
      R 1B

   V placingBlack = 1B
   L(i) 0 .< n
      L(j) 0 .< n
         V pos = (i, j)
         L(queen) pBlackQueens
            I queen == pos | ((!placingBlack) & isAttacking(queen, pos))
               L.break
         L.was_no_break
            L(queen) pWhiteQueens
               I queen == pos | (placingBlack & isAttacking(queen, pos))
                  L.break
            L.was_no_break
               I placingBlack
                  pBlackQueens [+]= pos
                  placingBlack = 0B
               E
                  pWhiteQueens [+]= pos
                  I place(m - 1, n, &pBlackQueens, &pWhiteQueens)
                     R 1B
                  pBlackQueens.pop()
                  pWhiteQueens.pop()
                  placingBlack = 1B

   I !placingBlack
      pBlackQueens.pop()
   R 0B

F printBoard(n, blackQueens, whiteQueens)
   V board = [Piece.EMPTY] * (n * n)

   L(queen) blackQueens
      board[queen[0] * n + queen[1]] = Piece.BLACK

   L(queen) whiteQueens
      board[queen[0] * n + queen[1]] = Piece.WHITE

   L(b) board
      V i = L.index
      I i != 0 & i % n == 0
         print()
      I b == BLACK
         print(‘B ’, end' ‘’)
      E I b == WHITE
         print(‘W ’, end' ‘’)
      E
         V j = i I/ n
         V k = i - j * n
         I j % 2 == k % 2
            print(‘x ’, end' ‘’)
         E
            print(‘o ’, end' ‘’)
   print("\n")

V nms = [(2, 1), (3, 1), (3, 2), (4, 1), (4, 2), (4, 3), (5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6), (7, 1), (7, 2), (7, 3), (7, 4), (7, 5), (7, 6), (7, 7)]

L(nm) nms
   print(‘#. black and #. white queens on a #. x #. board:’.format(nm[1], nm[1], nm[0], nm[0]))
   [(Int, Int)] blackQueens
   [(Int, Int)] whiteQueens
   I place(nm[1], nm[0], &blackQueens, &whiteQueens)
      printBoard(nm[0], blackQueens, whiteQueens)
   E
      print("No solution exists.\n")
===
enum class Piece {
    EMPTY,
    BLACK,
    WHITE
};

template <typename T1, typename T2> auto isAttacking(const T1 &queen, const T2 &pos)
{
    return _get<0>(queen) == _get<0>(pos) || _get<1>(queen) == _get<1>(pos) || abs(_get<0>(queen) - _get<0>(pos)) == abs(_get<1>(queen) - _get<1>(pos));
}

template <typename T1, typename T2, typename T3, typename T4> auto place(const T1 &m, const T2 &n, T3 &pBlackQueens, T4 &pWhiteQueens)
{
    if (m == 0)
        return true;

    auto placingBlack = true;
    for (auto i : range_el(0, n))
        for (auto j : range_el(0, n)) {
            auto pos = make_tuple(i, j);
            for (auto &&queen : pBlackQueens)
                if (queen == pos || ((!placingBlack) && isAttacking(queen, pos)))
                    goto break_;
            for (auto &&queen : pWhiteQueens)
                if (queen == pos || (placingBlack && isAttacking(queen, pos)))
                    goto break_1;
            if (placingBlack) {
                pBlackQueens.append(pos);
                placingBlack = false;
            }
            else {
                pWhiteQueens.append(pos);
                if (place(m - 1, n, pBlackQueens, pWhiteQueens))
                    return true;
                pBlackQueens.pop();
                pWhiteQueens.pop();
                placingBlack = true;
            }
            break_1:;
            break_:;
        }

    if (!placingBlack)
        pBlackQueens.pop();
    return false;
}

template <typename T1, typename T2, typename T3> auto printBoard(const T1 &n, const T2 &blackQueens, const T3 &whiteQueens)
{
    auto board = create_array({Piece::EMPTY}) * (n * n);

    for (auto &&queen : blackQueens)
        board.set(_get<0>(queen) * n + _get<1>(queen), Piece::BLACK);

    for (auto &&queen : whiteQueens)
        board.set(_get<0>(queen) * n + _get<1>(queen), Piece::WHITE);
    {int Lindex = 0;

    for (auto &&b : board) {
        auto i = Lindex;
        if (i != 0 && mod(i, n) == 0)
            print();
        if (b == TYPE_RM_REF(b)::BLACK)
            print(u"B "_S, u""_S);
        else if (b == TYPE_RM_REF(b)::WHITE)
            print(u"W "_S, u""_S);
        else {
            auto j = idiv(i, n);
            auto k = i - j * n;
            if (mod(j, 2) == mod(k, 2))
                print(u"x "_S, u""_S);
            else
                print(u"o "_S, u""_S);
        }
        Lindex++;
    }}
    print(u"\n"_S);
}

auto nms = create_array({make_tuple(2, 1), make_tuple(3, 1), make_tuple(3, 2), make_tuple(4, 1), make_tuple(4, 2), make_tuple(4, 3), make_tuple(5, 1), make_tuple(5, 2), make_tuple(5, 3), make_tuple(5, 4), make_tuple(5, 5), make_tuple(6, 1), make_tuple(6, 2), make_tuple(6, 3), make_tuple(6, 4), make_tuple(6, 5), make_tuple(6, 6), make_tuple(7, 1), make_tuple(7, 2), make_tuple(7, 3), make_tuple(7, 4), make_tuple(7, 5), make_tuple(7, 6), make_tuple(7, 7)});

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&nm : nms) {
            print(u"#. black and #. white queens on a #. x #. board:"_S.format(_get<1>(nm), _get<1>(nm), _get<0>(nm), _get<0>(nm)));
            Array<ivec2> blackQueens;
            Array<ivec2> whiteQueens;
            if (place(_get<1>(nm), _get<0>(nm), blackQueens, whiteQueens))
                printBoard(_get<0>(nm), blackQueens, whiteQueens);
            else
                print(u"No solution exists.\n"_S);
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Pi#D
# Slow BigInt
BigInt = int

ndigits = 0
q = BigInt(1)
r = BigInt(0)
t = q
k = q
n = BigInt(3)
l = n

first = True
while ndigits < 1_000:
    if 4 * q + r - t < n * t:
        print(n, end = '')
        ndigits += 1
        if ndigits % 70 == 0:
            print()
        if first:
            first = False
            print('.', end = '')
        nr = 10 * (r - n * t)
        n = ((10 * (3 * q + r)) // t) - 10 * n
        q *= 10
        r = nr
    else:
        nr = (2 * q + r) * l
        nn = (q * (7 * k + 2) + r * l) // (t * l)
        q *= k
        t *= l
        l += 2
        k += 1
        n = nn
        r = nr
===
V ndigits = 0
V q = BigInt(1)
V r = BigInt(0)
V t = q
V k = q
V n = BigInt(3)
V l = n

V first = 1B
L ndigits < 1'000
   I 4 * q + r - t < n * t
      print(n, end' ‘’)
      ndigits++
      I ndigits % 70 == 0
         print()
      I first
         first = 0B
         print(‘.’, end' ‘’)
      V nr = 10 * (r - n * t)
      n = ((10 * (3 * q + r)) I/ t) - 10 * n
      q *= 10
      r = nr
   E
      V nr = (2 * q + r) * l
      V nn = (q * (7 * k + 2) + r * l) I/ (t * l)
      q *= k
      t *= l
      l += 2
      k++
      n = nn
      r = nr
===
auto ndigits = 0;
auto q = BigInt(1);
auto r = BigInt(0);
auto t = q;
auto k = q;
auto n = BigInt(3);
auto l = n;

auto first = true;

struct CodeBlock1
{
    CodeBlock1()
    {
        while (ndigits < 1'000)
            if (4 * q + r - t < n * t) {
                print(n, u""_S);
                ndigits++;
                if (mod(ndigits, 70) == 0)
                    print();
                if (first) {
                    first = false;
                    print(u"."_S, u""_S);
                }
                auto nr = 10 * (r - n * t);
                n = (idiv((10 * (3 * q + r)), t)) - 10 * n;
                q *= 10;
                r = nr;
            }
            else {
                auto nr = (2 * q + r) * l;
                auto nn = idiv((q * (7 * k + 2) + r * l), (t * l));
                q *= k;
                t *= l;
                l += 2;
                k++;
                n = nn;
                r = nr;
            }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Poker_hand_analyser#D
def analyzeHandHelper(faceCount, suitCount):
    p1 = False
    p2 = False
    t = False
    f = False
    fl = False
    st = False

    for fc in faceCount:
        fc = fc
        if fc == 2:
            if p1:
                p2 = True
            else:
                p1 = True
        elif fc == 3:
            t = True
        elif fc == 4:
            f = True

    for sc in suitCount:
        if sc == 5:
            fl = True

    if (not p1) and (not p2) and (not t) and (not f):
        s = 0
        for fc in faceCount:
            if fc != 0:
                s += 1
            else:
                s = 0
            if s == 5:
                break

        st = (s == 5) or (s == 4 and faceCount[0] != 0 and faceCount[1] == 0)

    if st and fl:   return "straight-flush"
    elif f:         return "four-of-a-kind"
    elif p1 and t:  return "full-house"
    elif fl:        return "flush"
    elif st:        return "straight"
    elif t:         return "three-of-a-kind"
    elif p1 and p2: return "two-pair"
    elif p1:        return "one-pair"
    else:           return "high-card"

def analyzeHand(inHand):
    handLen = 5
    face = "A23456789TJQK"
    suit = "SHCD"
    errorMessage = "invalid hand."

    hand = sorted(inHand.split(' '))
    if len(hand) != handLen:
        return errorMessage
    if len(set(hand)) != handLen:
        return errorMessage + " Duplicated cards."

    faceCount = [0] * len(face)
    suitCount = [0] * len(suit)
    for card in hand:
        if len(card) != 2:
            return errorMessage
        n = face.find(card[0])
        l = suit.find(card[1])
        if n < 0 or l < 0:
            return errorMessage
        faceCount[n] += 1
        suitCount[l] += 1

    return analyzeHandHelper(faceCount, suitCount)

for hand in ["2H 2D 2S KS QD",
             "2H 5H 7D 8S 9D",
             "AH 2D 3S 4S 5S",
             "2H 3H 2D 3S 3D",
             "2H 7H 2D 3S 3D",
             "2H 7H 7D 7S 7C",
             "TH JH QH KH AH",
             "4H 4C KC 5D TC",
             "QC TC 7C 6C 4C"]:
    print(hand + ":", analyzeHand(hand))
===
F analyzeHandHelper(faceCount, suitCount)
   V p1 = 0B
   V p2 = 0B
   V t = 0B
   V f = 0B
   V fl = 0B
   V st = 0B

   L(=fc) faceCount
      S fc
         2
            I p1
               p2 = 1B
            E
               p1 = 1B
         3
            t = 1B
         4
            f = 1B

   L(sc) suitCount
      I sc == 5
         fl = 1B

   I (!p1) & (!p2) & (!t) & (!f)
      V s = 0
      L(fc) faceCount
         I fc != 0
            s++
         E
            s = 0
         I s == 5
            L.break

      st = (s == 5) | (s == 4 & faceCount[0] != 0 & faceCount[1] == 0)

   I st & fl
      R ‘straight-flush’
   E I f
      R ‘four-of-a-kind’
   E I p1 & t
      R ‘full-house’
   E I fl
      R ‘flush’
   E I st
      R ‘straight’
   E I t
      R ‘three-of-a-kind’
   E I p1 & p2
      R ‘two-pair’
   E I p1
      R ‘one-pair’
   E
      R ‘high-card’

F analyzeHand(inHand)
   V handLen = 5
   V face = ‘A23456789TJQK’
   V suit = ‘SHCD’
   V errorMessage = ‘invalid hand.’

   V hand = sorted(inHand.split(‘ ’))
   I hand.len != handLen
      R errorMessage
   I Set(hand).len != handLen
      R errorMessage‘ Duplicated cards.’

   V faceCount = [0] * face.len
   V suitCount = [0] * suit.len
   L(card) hand
      I card.len != 2
         R errorMessage
      V n = face.findi(card[0])
      V l = suit.findi(card[1])
      I n < 0 | l < 0
         R errorMessage
      faceCount[n]++
      suitCount[l]++

   R analyzeHandHelper(faceCount, suitCount)

L(hand) [‘2H 2D 2S KS QD’, ‘2H 5H 7D 8S 9D’, ‘AH 2D 3S 4S 5S’, ‘2H 3H 2D 3S 3D’, ‘2H 7H 2D 3S 3D’, ‘2H 7H 7D 7S 7C’, ‘TH JH QH KH AH’, ‘4H 4C KC 5D TC’, ‘QC TC 7C 6C 4C’]
   print((hand‘:’)‘ ’analyzeHand(hand))
===
template <typename T1, typename T2> auto analyzeHandHelper(const T1 &faceCount, const T2 &suitCount)
{
    auto p1 = false;
    auto p2 = false;
    auto t = false;
    auto f = false;
    auto fl = false;
    auto st = false;

    for (auto fc : faceCount)
        switch (fc)
        {
        case 2:
            if (p1)
                p2 = true;
            else
                p1 = true;
            break;
        case 3:
            t = true;
            break;
        case 4:
            f = true;
            break;
        }

    for (auto &&sc : suitCount)
        if (sc == 5)
            fl = true;

    if ((!p1) && (!p2) && (!t) && (!f)) {
        auto s = 0;
        for (auto &&fc : faceCount) {
            if (fc != 0)
                s++;
            else
                s = 0;
            if (s == 5)
                break;
        }

        st = (s == 5) || (s == 4 && _get<0>(faceCount) != 0 && _get<1>(faceCount) == 0);
    }

    if (st && fl)
        return u"straight-flush"_S;
    else if (f)
        return u"four-of-a-kind"_S;
    else if (p1 && t)
        return u"full-house"_S;
    else if (fl)
        return u"flush"_S;
    else if (st)
        return u"straight"_S;
    else if (t)
        return u"three-of-a-kind"_S;
    else if (p1 && p2)
        return u"two-pair"_S;
    else if (p1)
        return u"one-pair"_S;
    else
        return u"high-card"_S;
}

template <typename T1> auto analyzeHand(const T1 &inHand)
{
    auto handLen = 5;
    auto face = u"A23456789TJQK"_S;
    auto suit = u"SHCD"_S;
    auto errorMessage = u"invalid hand."_S;

    auto hand = sorted(inHand.split(u" "_S));
    if (hand.len() != handLen)
        return errorMessage;
    if (create_set(hand).len() != handLen)
        return errorMessage & u" Duplicated cards."_S;

    auto faceCount = create_array({0}) * face.len();
    auto suitCount = create_array({0}) * suit.len();
    for (auto &&card : hand) {
        if (card.len() != 2)
            return errorMessage;
        auto n = face.findi(_get<0>(card));
        auto l = suit.findi(_get<1>(card));
        if (n < 0 || l < 0)
            return errorMessage;
        faceCount[n]++;
        suitCount[l]++;
    }

    return analyzeHandHelper(faceCount, suitCount);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&hand : create_array({u"2H 2D 2S KS QD"_S, u"2H 5H 7D 8S 9D"_S, u"AH 2D 3S 4S 5S"_S, u"2H 3H 2D 3S 3D"_S, u"2H 7H 2D 3S 3D"_S, u"2H 7H 7D 7S 7C"_S, u"TH JH QH KH AH"_S, u"4H 4C KC 5D TC"_S, u"QC TC 7C 6C 4C"_S}))
            print((hand & u":"_S) & u" "_S & analyzeHand(hand));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Price_fraction#Python
def bisect_right(a, x):
    lo = 0
    hi = len(a)
    while lo < hi:
        mid = (lo+hi)//2
        if x < a[mid]: hi = mid
        else: lo = mid+1
    return lo

_cin  = [0.06, 0.11, 0.16, 0.21, 0.26, 0.31, 0.36, 0.41, 0.46, 0.51, 0.56, 0.61, 0.66, 0.71, 0.76, 0.81, 0.86, 0.91, 0.96, 1.01]
_cout = [0.10, 0.18, 0.26, 0.32, 0.38, 0.44, 0.50, 0.54, 0.58, 0.62, 0.66, 0.70, 0.74, 0.78, 0.82, 0.86, 0.90, 0.94, 0.98, 1.00]
def pricerounder(pricein):
    return _cout[ bisect_right(_cin, pricein) ]

for i in range(11):
    print('%.2f %.2f' % (i / 10, pricerounder(i / 10)))
===
F bisect_right(a, x)
   V lo = 0
   V hi = a.len
   L lo < hi
      V mid = (lo + hi) I/ 2
      I x < a[mid]
         hi = mid
      E
         lo = mid + 1
   R lo

V _cin = [0.06, 0.11, 0.16, 0.21, 0.26, 0.31, 0.36, 0.41, 0.46, 0.51, 0.56, 0.61, 0.66, 0.71, 0.76, 0.81, 0.86, 0.91, 0.96, 1.01]
V _cout = [0.10, 0.18, 0.26, 0.32, 0.38, 0.44, 0.50, 0.54, 0.58, 0.62, 0.66, 0.70, 0.74, 0.78, 0.82, 0.86, 0.90, 0.94, 0.98, 1.00]
F pricerounder(pricein)
   R :_cout[bisect_right(:_cin, pricein)]

L(i) 11
   print(‘#.2 #.2’.format(i / 10, pricerounder(i / 10)))
===
template <typename T1, typename T2> auto bisect_right(const T1 &a, const T2 &x)
{
    auto lo = 0;
    auto hi = a.len();
    while (lo < hi) {
        auto mid = idiv((lo + hi), 2);
        if (x < a[mid])
            hi = mid;
        else
            lo = mid + 1;
    }
    return lo;
}

auto _cin = create_array({0.06, 0.11, 0.16, 0.21, 0.26, 0.31, 0.36, 0.41, 0.46, 0.51, 0.56, 0.61, 0.66, 0.71, 0.76, 0.81, 0.86, 0.91, 0.96, 1.01});
auto _cout = create_array({0.10, 0.18, 0.26, 0.32, 0.38, 0.44, 0.50, 0.54, 0.58, 0.62, 0.66, 0.70, 0.74, 0.78, 0.82, 0.86, 0.90, 0.94, 0.98, 1.00});
template <typename T1> auto pricerounder(const T1 &pricein)
{
    return ::_cout[bisect_right(::_cin, pricein)];
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (int i = 0; i < 11; i++)
            print(u"#.2 #.2"_S.format(i / 10.0, pricerounder(i / 10.0)));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Primes_-_allocate_descendants_to_their_ancestors#Python
Int64 = int

maxsum = 99

def get_primes(max):
    # if max < 2:
    #     return []
    lprimes = [2]
    for x in range(3, max + 1, 2):
        for p in lprimes:
            if x % p == 0:
                break
        else:
            lprimes.append(x)
    return lprimes

descendants = [[Int64(0)]*0 for _ in range(maxsum + 1)]
ancestors = [[Int64(0)]*0 for _ in range(maxsum + 1)]

primes = get_primes(maxsum)

for p in primes:
    descendants[p].append(p)
    for s in range(1, len(descendants) - p):
        descendants[s + p] += [p * pr for pr in descendants[s]]

for p in primes + [4]:
    descendants[p].pop()

total = 0
for s in range(1, maxsum + 1):
    descendants[s].sort()
    for d in descendants[s]:
        if d > maxsum:
            break
        ancestors[int(d)] = ancestors[s] + [Int64(s)]
    print([s], "Level:", len(ancestors[s]))
    print("Ancestors:", str(ancestors[s]) if len(ancestors[s]) else "None")
    print("Descendants:", str(len(descendants[s])) if len(descendants[s]) else "None")
    if len(descendants[s]):
        print(descendants[s])
    print()
    total += len(descendants[s])

print("Total descendants", total)
===
V maxsum = 99

F get_primes(max)
   V lprimes = [2]
   L(x) (3 .< max + 1).step(2)
      L(p) lprimes
         I x % p == 0
            L.break
      L.was_no_break
         lprimes.append(x)
   R lprimes

V descendants = [[Int64(0)] * 0] * (maxsum + 1)
V ancestors = [[Int64(0)] * 0] * (maxsum + 1)

V primes = get_primes(maxsum)

L(p) primes
   descendants[p].append(p)
   L(s) 1 .< descendants.len - p
      descendants[s + p] [+]= descendants[s].map(pr -> @p * pr)

L(p) primes [+] [4]
   descendants[p].pop()

V total = 0
L(s) 1 .. maxsum
   descendants[s].sort()
   L(d) descendants[s]
      I d > maxsum
         L.break
      ancestors[Int(d)] = ancestors[s] [+] [Int64(s)]
   print([s]‘ Level: ’ancestors[s].len)
   print(‘Ancestors: ’(I !ancestors[s].empty {String(ancestors[s])} E ‘None’))
   print(‘Descendants: ’(I !descendants[s].empty {String(descendants[s].len)} E ‘None’))
   I !descendants[s].empty
      print(descendants[s])
   print()
   total += descendants[s].len

print(‘Total descendants ’total)
===
auto maxsum = 99;

template <typename T1> auto get_primes(const T1 &max)
{
    auto lprimes = create_array({2});
    for (auto x : range_el(3, max + 1).step(2)) {
        for (auto &&p : lprimes)
            if (mod(x, p) == 0)
                goto break_;
        lprimes.append(x);
        break_:;
    }
    return lprimes;
}

auto descendants = create_array({create_array({to_int64(0)}) * 0}) * (maxsum + 1);
auto ancestors = create_array({create_array({to_int64(0)}) * 0}) * (maxsum + 1);

auto primes = get_primes(maxsum);

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&p : primes) {
            descendants[p].append(p);
            for (auto s : range_el(1, descendants.len() - p))
                descendants[s + p].append(descendants[s].map([&p](const auto &pr){return p * pr;}));
        }

        for (auto &&p : primes + create_array({4}))
            descendants[p].pop();
    }
} code_block_1;

auto total = 0;

struct CodeBlock2
{
    CodeBlock2()
    {
        for (auto s : range_ee(1, maxsum)) {
            descendants[s].sort();
            for (auto &&d : descendants[s]) {
                if (d > maxsum)
                    break;
                ancestors.set(to_int(d), ancestors[s] + create_array({to_int64(s)}));
            }
            print(create_array({s}) & u" Level: "_S & ancestors[s].len());
            print(u"Ancestors: "_S & (!ancestors[s].empty() ? String(ancestors[s]) : u"None"_S));
            print(u"Descendants: "_S & (!descendants[s].empty() ? String(descendants[s].len()) : u"None"_S));
            if (!descendants[s].empty())
                print(descendants[s]);
            print();
            total += descendants[s].len();
        }

        print(u"Total descendants "_S & total);
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Problem_of_Apollonius#Python
from typing import NamedTuple
import math

class Circle(NamedTuple):
    x : float
    y : float
    r : float
    def __str__(self):
        return 'Circle(x=%s, y=%s, r=%s)' % (self.x, self.y, self.r)

def solveApollonius(c1, c2, c3, s1, s2, s3):
    (x1, y1, r1) = c1
    (x2, y2, r2) = c2
    (x3, y3, r3) = c3

    v11 = 2*x2 - 2*x1
    v12 = 2*y2 - 2*y1
    v13 = x1*x1 - x2*x2 + y1*y1 - y2*y2 - r1*r1 + r2*r2
    v14 = 2*s2*r2 - 2*s1*r1

    v21 = 2*x3 - 2*x2
    v22 = 2*y3 - 2*y2
    v23 = x2*x2 - x3*x3 + y2*y2 - y3*y3 - r2*r2 + r3*r3
    v24 = 2*s3*r3 - 2*s2*r2

    w12 = v12/v11
    w13 = v13/v11
    w14 = v14/v11

    w22 = v22/v21-w12
    w23 = v23/v21-w13
    w24 = v24/v21-w14

    P = -w23/w22
    Q = w24/w22
    M = -w12*P-w13
    n = w14 - w12*Q

    a = n*n + Q*Q - 1
    b = 2*M*n - 2*n*x1 + 2*P*Q - 2*Q*y1 + 2*s1*r1
    c = x1*x1 + M*M - 2*M*x1 + P*P + y1*y1 - 2*P*y1 - r1*r1

    # Find a root of a quadratic equation. This requires the circle centers not to be e.g. colinear
    D = b*b-4*a*c
    rs = (-b-math.sqrt(D))/(2*a)

    xs = M+n*rs
    ys = P+Q*rs

    return Circle(xs, ys, rs)

(c1, c2, c3) = (Circle(0, 0, 1), Circle(4, 0, 1), Circle(2, 4, 2))
print(solveApollonius(c1, c2, c3, 1, 1, 1))    #Expects "Circle[x=2.00,y=2.10,r=3.90]" (green circle in image)
print(solveApollonius(c1, c2, c3, -1, -1, -1)) #Expects "Circle[x=2.00,y=0.83,r=1.17]" (red circle in image)
===
T Circle
   Float x
   Float y
   Float r
   F String()
      R ‘Circle(x=#., y=#., r=#.)’.format(.x, .y, .r)
   F (x, y, r)
      .x = x
      .y = y
      .r = r

F solveApollonius(c1, c2, c3, s1, s2, s3)
   V (x1, y1, r1) = c1
   V (x2, y2, r2) = c2
   V (x3, y3, r3) = c3

   V v11 = 2 * x2 - 2 * x1
   V v12 = 2 * y2 - 2 * y1
   V v13 = x1 * x1 - x2 * x2 + y1 * y1 - y2 * y2 - r1 * r1 + r2 * r2
   V v14 = 2 * s2 * r2 - 2 * s1 * r1

   V v21 = 2 * x3 - 2 * x2
   V v22 = 2 * y3 - 2 * y2
   V v23 = x2 * x2 - x3 * x3 + y2 * y2 - y3 * y3 - r2 * r2 + r3 * r3
   V v24 = 2 * s3 * r3 - 2 * s2 * r2

   V w12 = v12 / v11
   V w13 = v13 / v11
   V w14 = v14 / v11

   V w22 = v22 / v21 - w12
   V w23 = v23 / v21 - w13
   V w24 = v24 / v21 - w14

   V P = -w23 / w22
   V Q = w24 / w22
   V M = -w12 * P - w13
   V n = w14 - w12 * Q

   V a = n * n + Q * Q - 1
   V b = 2 * M * n - 2 * n * x1 + 2 * P * Q - 2 * Q * y1 + 2 * s1 * r1
   V c = x1 * x1 + M * M - 2 * M * x1 + P * P + y1 * y1 - 2 * P * y1 - r1 * r1

   V D = b * b - 4 * a * c
   V rs = (-b - sqrt(D)) / (2 * a)

   V xs = M + n * rs
   V ys = P + Q * rs

   R Circle(xs, ys, rs)

V (c1, c2, c3) = (Circle(0, 0, 1), Circle(4, 0, 1), Circle(2, 4, 2))
print(solveApollonius(c1, c2, c3, 1, 1, 1))
print(solveApollonius(c1, c2, c3, -1, -1, -1))
===
class Circle
{
public:
    double x;
    double y;
    double r;
    operator String() const
    {
        return u"Circle(x=#., y=#., r=#.)"_S.format(x, y, r);
    }
    template <typename T1, typename T2, typename T3> Circle(const T1 &x, const T2 &y, const T3 &r) :
        x(x),
        y(y),
        r(r)
    {
    }
};

template <typename T1, typename T2, typename T3, typename T4, typename T5, typename T6> auto solveApollonius(const T1 &c1, const T2 &c2, const T3 &c3, const T4 &s1, const T5 &s2, const T6 &s3)
{
    auto [x1, _y1_, r1] = c1;
    auto [x2, y2, r2] = c2;
    auto [x3, y3, r3] = c3;

    auto v11 = 2 * x2 - 2 * x1;
    auto v12 = 2 * y2 - 2 * _y1_;
    auto v13 = x1 * x1 - x2 * x2 + _y1_ * _y1_ - y2 * y2 - r1 * r1 + r2 * r2;
    auto v14 = 2 * s2 * r2 - 2 * s1 * r1;

    auto v21 = 2 * x3 - 2 * x2;
    auto v22 = 2 * y3 - 2 * y2;
    auto v23 = x2 * x2 - x3 * x3 + y2 * y2 - y3 * y3 - r2 * r2 + r3 * r3;
    auto v24 = 2 * s3 * r3 - 2 * s2 * r2;

    auto w12 = v12 / v11;
    auto w13 = v13 / v11;
    auto w14 = v14 / v11;

    auto w22 = v22 / v21 - w12;
    auto w23 = v23 / v21 - w13;
    auto w24 = v24 / v21 - w14;

    auto P = -w23 / w22;
    auto Q = w24 / w22;
    auto M = -w12 * P - w13;
    auto n = w14 - w12 * Q;

    auto a = n * n + Q * Q - 1;
    auto b = 2 * M * n - 2 * n * x1 + 2 * P * Q - 2 * Q * _y1_ + 2 * s1 * r1;
    auto c = x1 * x1 + M * M - 2 * M * x1 + P * P + _y1_ * _y1_ - 2 * P * _y1_ - r1 * r1;

    auto D = b * b - 4 * a * c;
    auto rs = (-b - sqrt(D)) / (2 * a);

    auto xs = M + n * rs;
    auto ys = P + Q * rs;

    return Circle(xs, ys, rs);
}

auto [c1, c2, c3] = make_tuple(Circle(0, 0, 1), Circle(4, 0, 1), Circle(2, 4, 2));

struct CodeBlock1
{
    CodeBlock1()
    {
        print(solveApollonius(c1, c2, c3, 1, 1, 1));
        print(solveApollonius(c1, c2, c3, -1, -1, -1));
    }
} code_block_1;