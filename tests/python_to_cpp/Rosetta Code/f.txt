# https://www.rosettacode.org/wiki/Fraction_reduction#Python
def indexOf(haystack, needle):
    idx = 0
    for straw in haystack:
        if straw == needle:
            return idx
        else:
            idx += 1
    return -1

def getDigits(n, le, digits : list):
    while n > 0:
        r = n % 10
        if r == 0 or indexOf(digits, r) >= 0:
            return False
        le -= 1
        digits[le] = r
        n = int(n / 10)
    return True

def removeDigit(digits, le, idx):
    pows = [1, 10, 100, 1000, 10000]
    sum = 0
    pow = pows[le - 2]
    i = 0
    while i < le:
        if i == idx:
            i += 1
            continue
        sum = sum + digits[i] * pow
        pow = int(pow / 10)
        i += 1
    return sum

lims = [ [ 12, 97 ], [ 123, 986 ], [ 1234, 9875 ], [ 12345, 98764 ] ]
count = [0] * 5
omitted = [[0] * 10 for j in range(5)]

i = 0
while i < len(lims):
    n = lims[i][0]
    while n < lims[i][1]:
        nDigits = [0] * (i + 2)
        nOk = getDigits(n, i + 2, nDigits)
        if not nOk:
            n += 1
            continue
        d = n + 1
        while d <= lims[i][1] + 1:
            dDigits = [0] * (i + 2)
            dOk = getDigits(d, i + 2, dDigits)
            if not dOk:
                d += 1
                continue
            nix = 0
            while nix < len(nDigits):
                digit = nDigits[nix]
                dix = indexOf(dDigits, digit)
                if dix >= 0:
                    rn = removeDigit(nDigits, i + 2, nix)
                    rd = removeDigit(dDigits, i + 2, dix)
                    if (1.0 * n / d) == (1.0 * rn / rd):
                        count[i] += 1
                        omitted[i][digit] += 1
                        if count[i] <= 12:
                            print("%d/%d = %d/%d by omitting %d's" % (n, d, rn, rd, digit))
                nix += 1
            d += 1
        n += 1
    print()
    i += 1

i = 2
while i <= 5:
    print("There are %d %d-digit fractions of which:" % (count[i - 2], i))
    j = 1
    while j <= 9:
        if omitted[i - 2][j] == 0:
            j += 1
            continue
        print("%6s have %d's omitted" % (omitted[i - 2][j], j))
        j += 1
    print()
    i += 1
===
F indexOf(haystack, needle)
   V idx = 0
   L(straw) haystack
      I straw == needle
         R idx
      E
         idx++
   R -1

F getDigits(=n, =le, &digits)
   L n > 0
      V r = n % 10
      I r == 0 | indexOf(digits, r) >= 0
         R 0B
      le--
      digits[le] = r
      n = Int(n / 10)
   R 1B

F removeDigit(digits, le, idx)
   V pows = [1, 10, 100, 1000, 10000]
   V sum = 0
   V pow = pows[le - 2]
   V i = 0
   L i < le
      I i == idx
         i++
         L.continue
      sum = sum + digits[i] * pow
      pow = Int(pow / 10)
      i++
   R sum

V lims = [[12, 97], [123, 986], [1234, 9875], [12345, 98764]]
V count = [0] * 5
V omitted = [[0] * 10] * 5

V i = 0
L i < lims.len
   V n = lims[i][0]
   L n < lims[i][1]
      V nDigits = [0] * (i + 2)
      V nOk = getDigits(n, i + 2, &nDigits)
      I !nOk
         n++
         L.continue
      V d = n + 1
      L d <= lims[i][1] + 1
         V dDigits = [0] * (i + 2)
         V dOk = getDigits(d, i + 2, &dDigits)
         I !dOk
            d++
            L.continue
         V nix = 0
         L nix < nDigits.len
            V digit = nDigits[nix]
            V dix = indexOf(dDigits, digit)
            I dix >= 0
               V rn = removeDigit(nDigits, i + 2, nix)
               V rd = removeDigit(dDigits, i + 2, dix)
               I (1.0 * n / d) == (1.0 * rn / rd)
                  count[i]++
                  omitted[i][digit]++
                  I count[i] <= 12
                     print(‘#./#. = #./#. by omitting #.'s’.format(n, d, rn, rd, digit))
            nix++
         d++
      n++
   print()
   i++

i = 2
L i <= 5
   print(‘There are #. #.-digit fractions of which:’.format(count[i - 2], i))
   V j = 1
   L j <= 9
      I omitted[i - 2][j] == 0
         j++
         L.continue
      print(‘#6 have #.'s omitted’.format(omitted[i - 2][j], j))
      j++
   print()
   i++
===
template <typename T1, typename T2> auto indexOf(const T1 &haystack, const T2 &needle)
{
    auto idx = 0;
    for (auto &&straw : haystack)
        if (straw == needle)
            return idx;
        else
            idx++;
    return -1;
}

template <typename T1, typename T2, typename T3> auto getDigits(T1 n, T2 le, T3 &digits)
{
    while (n > 0) {
        auto r = mod(n, 10);
        if (r == 0 || indexOf(digits, r) >= 0)
            return false;
        le--;
        digits.set(le, r);
        n = to_int(n / 10.0);
    }
    return true;
}

template <typename T1, typename T2, typename T3> auto removeDigit(const T1 &digits, const T2 &le, const T3 &idx)
{
    auto pows = create_array({1, 10, 100, 1000, 10000});
    auto sum = 0;
    auto pow = pows[le - 2];
    auto i = 0;
    while (i < le) {
        if (i == idx) {
            i++;
            continue;
        }
        sum = sum + digits[i] * pow;
        pow = to_int(pow / 10.0);
        i++;
    }
    return sum;
}

auto lims = create_array({create_array({12, 97}), create_array({123, 986}), create_array({1234, 9875}), create_array({12345, 98764})});
auto count = create_array({0}) * 5;
auto omitted = create_array({create_array({0}) * 10}) * 5;

auto i = 0;

struct CodeBlock1
{
    CodeBlock1()
    {
        while (i < lims.len()) {
            auto n = _get<0>(lims[i]);
            while (n < _get<1>(lims[i])) {
                auto nDigits = create_array({0}) * (i + 2);
                auto nOk = getDigits(n, i + 2, nDigits);
                if (!nOk) {
                    n++;
                    continue;
                }
                auto d = n + 1;
                while (d <= _get<1>(lims[i]) + 1) {
                    auto dDigits = create_array({0}) * (i + 2);
                    auto dOk = getDigits(d, i + 2, dDigits);
                    if (!dOk) {
                        d++;
                        continue;
                    }
                    auto nix = 0;
                    while (nix < nDigits.len()) {
                        auto digit = nDigits[nix];
                        auto dix = indexOf(dDigits, digit);
                        if (dix >= 0) {
                            auto rn = removeDigit(nDigits, i + 2, nix);
                            auto rd = removeDigit(dDigits, i + 2, dix);
                            if ((1.0 * n / d) == (1.0 * rn / rd)) {
                                count[i]++;
                                omitted[i][digit]++;
                                if (count[i] <= 12)
                                    print(u"#./#. = #./#. by omitting #.'s"_S.format(n, d, rn, rd, digit));
                            }
                        }
                        nix++;
                    }
                    d++;
                }
                n++;
            }
            print();
            i++;
        }

        i = 2;
        while (i <= 5) {
            print(u"There are #. #.-digit fractions of which:"_S.format(count[i - 2], i));
            auto j = 1;
            while (j <= 9) {
                if (omitted[i - 2][j] == 0) {
                    j++;
                    continue;
                }
                print(u"#6 have #.'s omitted"_S.format(omitted[i - 2][j], j));
                j++;
            }
            print();
            i++;
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Faces_from_a_mesh#Python
def perim_equal(p1, p2):
    # Cheap tests first
    if len(p1) != len(p2) or set(p1) != set(p2):
        return False
    if any(p2 == (p1[n:] + p1[:n]) for n in range(len(p1))):
        return True
    p2 = p2[::-1] # not inplace
    return any(p2 == (p1[n:] + p1[:n]) for n in range(len(p1)))

def edge_to_periphery(e):
    edges = sorted(e)
    p : List[int] = []
    if len(edges):
        p = [edges[0][0], edges[0][1]]
        edges.pop(0)
    last = p[-1] if len(p) else -1
    while len(edges):
        for n, ij in enumerate(edges):
            (i, j) = ij
            if i == last:
                p.append(j)
                last = j
                edges.pop(n)
                break
            elif j == last:
                p.append(i)
                last = i
                edges.pop(n)
                break
        else:
            #raise ValueError(f'Invalid edge format: {e}')
            return ">>>Error! Invalid edge format<<<"
    return str(p[:-1])

print('Perimeter format equality checks:')
for eq_check in [
        ( 'Q', [8, 1, 3],
          'R', [1, 3, 8]),
        ( 'U', [18, 8, 14, 10, 12, 17, 19],
          'V', [8, 14, 10, 12, 17, 19, 18]) ]:
    (n1, p1, n2, p2) = eq_check
    eq = '==' if perim_equal(p1, p2) else '!='
    print(' ', n1, eq, n2)

print("\nEdge to perimeter format translations:")
edge_d = {
 'E': [(1, 11), (7, 11), (1, 7)],
 'F': [(11, 23), (1, 17), (17, 23), (1, 11)],
 'G': [(8, 14), (17, 19), (10, 12), (10, 14), (12, 17), (8, 18), (18, 19)],
 'H': [(1, 3), (9, 11), (3, 11), (1, 11)]
        }
for name, edges in edge_d.items():
    print('  ' + name + ': ' + str(edges) + "\n     -> " + edge_to_periphery(edges))
===
F perim_equal(p1, =p2)
   I p1.len != p2.len | Set(p1) != Set(p2)
      R 0B
   I any((0 .< p1.len).map(n -> @p2 == (@p1[n ..] + @p1[0 .< n])))
      R 1B
   p2 = reversed(p2)
   R any((0 .< p1.len).map(n -> @p2 == (@p1[n ..] + @p1[0 .< n])))

F edge_to_periphery(e)
   V edges = sorted(e)
   [Int] p
   I !edges.empty
      p = [edges[0][0], edges[0][1]]
      edges.pop(0)
   V last = I !p.empty {p.last} E -1
   L !edges.empty
      L(ij) edges
         V n = L.index
         V (i, j) = ij
         I i == last
            p.append(j)
            last = j
            edges.pop(n)
            L.break
         E I j == last
            p.append(i)
            last = i
            edges.pop(n)
            L.break
      L.was_no_break
         R ‘>>>Error! Invalid edge format<<<’
   R String(p[0 .< (len)-1])

print(‘Perimeter format equality checks:’)
L(eq_check) [(‘Q’, [8, 1, 3], ‘R’, [1, 3, 8]), (‘U’, [18, 8, 14, 10, 12, 17, 19], ‘V’, [8, 14, 10, 12, 17, 19, 18])]
   V (n1, p1, n2, p2) = eq_check
   V eq = I perim_equal(p1, p2) {‘==’} E ‘!=’
   print(‘  ’n1‘ ’eq‘ ’n2)

print("\nEdge to perimeter format translations:")
V edge_d = [‘E’ = [(1, 11), (7, 11), (1, 7)], ‘F’ = [(11, 23), (1, 17), (17, 23), (1, 11)], ‘G’ = [(8, 14), (17, 19), (10, 12), (10, 14), (12, 17), (8, 18), (18, 19)], ‘H’ = [(1, 3), (9, 11), (3, 11), (1, 11)]]
L(name, edges) edge_d
   print(‘  ’name‘: ’String(edges)"\n     -> "edge_to_periphery(edges))
===
template <typename T1, typename T2> auto perim_equal(const T1 &p1, T2 p2)
{
    if (p1.len() != p2.len() || create_set(p1) != create_set(p2))
        return false;
    if (any_map(range_el(0, p1.len()), [&p1, &p2](const auto &n){return p2 == (p1[range_ei(n)] + p1[range_el(0, n)]);}))
        return true;
    p2 = reversed(p2);
    return any_map(range_el(0, p1.len()), [&p1, &p2](const auto &n){return p2 == (p1[range_ei(n)] + p1[range_el(0, n)]);});
}

template <typename T1> auto edge_to_periphery(const T1 &e)
{
    auto edges = sorted(e);
    Array<int> p;
    if (!edges.empty()) {
        p = create_array({_get<0>(_get<0>(edges)), _get<1>(_get<0>(edges))});
        edges.pop(0);
    }
    auto last = !p.empty() ? p.last() : -1;
    while (!edges.empty()) {
        {int Lindex = 0;
        for (auto &&ij : edges) {
            auto n = Lindex;
            auto [i, j] = ij;
            if (i == last) {
                p.append(j);
                last = j;
                edges.pop(n);
                goto break_;
            }
            else if (j == last) {
                p.append(i);
                last = i;
                edges.pop(n);
                goto break_;
            }
            Lindex++;
        }}
        return u">>>Error! Invalid edge format<<<"_S;
        break_:;
    }
    return String(p[range_e_llen(0,  - 1)]);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"Perimeter format equality checks:"_S);
        for (auto &&eq_check : create_array({make_tuple(u"Q"_S, create_array({8, 1, 3}), u"R"_S, create_array({1, 3, 8})), make_tuple(u"U"_S, create_array({18, 8, 14, 10, 12, 17, 19}), u"V"_S, create_array({8, 14, 10, 12, 17, 19, 18}))})) {
            auto [n1, p1, n2, p2] = eq_check;
            auto eq = perim_equal(p1, p2) ? u"=="_S : u"!="_S;
            print(u"  "_S & n1 & u" "_S & eq & u" "_S & n2);
        }

        print(u"\nEdge to perimeter format translations:"_S);
    }
} code_block_1;

auto edge_d = create_dict(dict_of(u'E'_C, create_array({make_tuple(1, 11), make_tuple(7, 11), make_tuple(1, 7)}))(u'F'_C, create_array({make_tuple(11, 23), make_tuple(1, 17), make_tuple(17, 23), make_tuple(1, 11)}))(u'G'_C, create_array({make_tuple(8, 14), make_tuple(17, 19), make_tuple(10, 12), make_tuple(10, 14), make_tuple(12, 17), make_tuple(8, 18), make_tuple(18, 19)}))(u'H'_C, create_array({make_tuple(1, 3), make_tuple(9, 11), make_tuple(3, 11), make_tuple(1, 11)})));

struct CodeBlock2
{
    CodeBlock2()
    {
        for (auto &&[name, edges] : edge_d)
            print(u"  "_S & name & u": "_S & String(edges) & u"\n     -> "_S & edge_to_periphery(edges));
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Factorions#Python
fact = [1] # cache factorials from 0 to 11
for n in range(1, 12):
    fact.append(fact[n-1] * n)

for b in range(9, 12+1):
    print('The factorions for base', b, 'are:')
    for i in range(1, 1_500_000):
        fact_sum = 0
        j = i
        while j > 0:
            d = j % b
            fact_sum += fact[d]
            j = j//b
        if fact_sum == i:
            print(i, end=" ")
    print()
===
V fact = [1]
L(n) 1..11
   fact.append(fact[n - 1] * n)

L(b) 9 .. 12
   print(‘The factorions for base ’b‘ are:’)
   L(i) 1..1499999
      V fact_sum = 0
      V j = i
      L j > 0
         V d = j % b
         fact_sum += fact[d]
         j = j I/ b
      I fact_sum == i
         print(i, end' ‘ ’)
   print()
===
auto fact = create_array({1});

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto n : range_ee(1, 11))
            fact.append(fact[n - 1] * n);

        for (auto b : range_ee(9, 12)) {
            print(u"The factorions for base "_S & b & u" are:"_S);
            for (auto i : range_ee(1, 1499999)) {
                auto fact_sum = 0;
                auto j = i;
                while (j > 0) {
                    auto d = mod(j, b);
                    fact_sum += fact[d];
                    j = idiv(j, b);
                }
                if (fact_sum == i)
                    print(i, u" "_S);
            }
            print();
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Factors_of_a_Mersenne_number#Python
import math

def is_prime(a):
    if a == 2: return True
    if a < 2 or a % 2 == 0: return False
    for i in range(3, int(math.sqrt(a)) + 1, 2):
        if a % i == 0:
            return False
    return True

def m_factor(p):
    max_k = 16384 // p # arbitrary limit; since Python automatically uses long's, it doesn't overflow
    for k in range(max_k):
        q = 2*p*k + 1
        if not is_prime(q):
            continue
        elif q % 8 != 1 and q % 8 != 7:
            continue
        elif pow(2, p, q) == 1:
            return q
    return 0

exponent = int(input("Enter exponent of Mersenne number: "))
if not is_prime(exponent):
    print("Exponent is not prime: %d" % exponent)
else:
    factor = m_factor(exponent)
    if factor == 0:
        print("No factor found for M%d" % exponent)
    else:
        print("M%d has a factor: %d" % (exponent, factor))
===
F is_prime(a)
   I a == 2
      R 1B
   I a < 2 | a % 2 == 0
      R 0B
   L(i) (3 .. Int(sqrt(a))).step(2)
      I a % i == 0
         R 0B
   R 1B

F m_factor(p)
   V max_k = 16384 I/ p
   L(k) 0 .< max_k
      V q = 2 * p * k + 1
      I !is_prime(q)
         L.continue
      E I q % 8 != 1 & q % 8 != 7
         L.continue
      E I pow(2, p, q) == 1
         R q
   R 0

V exponent = Int(input(‘Enter exponent of Mersenne number: ’))
I !is_prime(exponent)
   print(‘Exponent is not prime: #.’.format(exponent))
E
   V factor = m_factor(exponent)
   I factor == 0
      print(‘No factor found for M#.’.format(exponent))
   E
      print(‘M#. has a factor: #.’.format(exponent, factor))
===
template <typename T1> auto is_prime(const T1 &a)
{
    if (a == 2)
        return true;
    if (a < 2 || mod(a, 2) == 0)
        return false;
    for (auto i : range_ee(3, to_int(sqrt(a))).step(2))
        if (mod(a, i) == 0)
            return false;
    return true;
}

template <typename T1> auto m_factor(const T1 &p)
{
    auto max_k = idiv(16384, p);
    for (auto k : range_el(0, max_k)) {
        auto q = 2 * p * k + 1;
        if (!is_prime(q))
            continue;
        else if (mod(q, 8) != 1 && mod(q, 8) != 7)
            continue;
        else if (pow(2, p, q) == 1)
            return q;
    }
    return 0;
}

auto exponent = to_int(input(u"Enter exponent of Mersenne number: "_S));

struct CodeBlock1
{
    CodeBlock1()
    {
        if (!is_prime(exponent))
            print(u"Exponent is not prime: #."_S.format(exponent));
        else {
            auto factor = m_factor(exponent);
            if (factor == 0)
                print(u"No factor found for M#."_S.format(exponent));
            else
                print(u"M#. has a factor: #."_S.format(exponent, factor));
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Fairshare_between_two_and_more#Python
import itertools

def _basechange_int(num, b):
    """
    Return list of ints representing positive num in base b
    """
    if num == 0:
        return [0]
    result : List[int] = []
    while num != 0:
        (num, d) = divmod(num, b)
        result.append(d)
    return result[::-1]

def fairshare(b, n):
    r : List[int] = []
    for i in itertools.count(0):
        r += [sum(_basechange_int(i, b)) % b]
        if len(r) == n:
            break
    return r

for b in (2, 3, 5, 11):
    print('{:>2}'.format(b) + ': ' + str(fairshare(b, 25))[1:-1])
===
F _basechange_int(=num, b)
   ‘
    Return list of ints representing positive num in base b
    ’
   I num == 0
      R [0]
   [Int] result
   L num != 0
      (num, V d) = divmod(num, b)
      result.append(d)
   R reversed(result)

F fairshare(b, n)
   [Int] r
   L(i) 0..
      r [+]= sum(_basechange_int(i, b)) % b
      I r.len == n
         L.break
   R r

L(b) (2, 3, 5, 11)
   print(‘#2’.format(b)‘: ’String(fairshare(b, 25))[1 .< (len)-1])
===
template <typename T1, typename T2> auto _basechange_int(T1 num, const T2 &b)
{
    uR"(
    Return list of ints representing positive num in base b
    )"_S;
    if (num == 0)
        return create_array({0});
    Array<int> result;
    while (num != 0) {
        TUPLE_ELEMENT_T(1, divmod(num, b)) d;
        assign_from_tuple(num, d, divmod(num, b));
        result.append(d);
    }
    return reversed(result);
}

template <typename T1, typename T2> auto fairshare(const T1 &b, const T2 &n)
{
    Array<int> r;
    for (auto i : range_ei(0)) {
        r.append(mod(sum(_basechange_int(i, b)), b));
        if (r.len() == n)
            break;
    }
    return r;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&b : make_tuple(2, 3, 5, 11))
            print(u"#2"_S.format(b) & u": "_S & String(fairshare(b, 25))[range_e_llen(1,  - 1)]);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/FASTA_format#Python
FASTA=\
'''>Rosetta_Example_1
THERECANBENOSPACE
>Rosetta_Example_2
THERECANBESEVERAL
LINESBUTTHEYALLMUST
BECONCATENATED'''

def fasta_parse(infile_str):
    key = ''
    val = ''
    r : List[Tuple[str, str]] = []
    for line in infile_str.split("\n"):
        if line.startswith('>'):
            if key != '':
                r += [(key, val)]
            key = line[1:].split()[0]
            val = ''
        elif key != '':
            val += line
    if key != '':
        r += [(key, val)]
    return r

print("\n".join('%s: %s' % (key, val) for key, val in fasta_parse(FASTA)))
===
V FASTA = ‘>Rosetta_Example_1
THERECANBENOSPACE
>Rosetta_Example_2
THERECANBESEVERAL
LINESBUTTHEYALLMUST
BECONCATENATED’

F fasta_parse(infile_str)
   V key = ‘’
   V val = ‘’
   [(String, String)] r
   L(line) infile_str.split("\n")
      I line.starts_with(‘>’)
         I key != ‘’
            r [+]= (key, val)
         key = line[1..].split_py()[0]
         val = ‘’
      E I key != ‘’
         val ‘’= line
   I key != ‘’
      r [+]= (key, val)
   R r

print(fasta_parse(FASTA).map((key, val) -> ‘#.: #.’.format(key, val)).join("\n"))
===
auto FASTA = uR"(>Rosetta_Example_1
THERECANBENOSPACE
>Rosetta_Example_2
THERECANBESEVERAL
LINESBUTTHEYALLMUST
BECONCATENATED)"_S;

template <typename T1> auto fasta_parse(const T1 &infile_str)
{
    auto key = u""_S;
    auto val = u""_S;
    Array<Tuple<String, String>> r;
    for (auto &&line : infile_str.split(u"\n"_S))
        if (line.starts_with(u">"_S)) {
            if (key != u"")
                r.append(make_tuple(key, val));
            key = _get<0>(line[range_ei(1)].split_py());
            val = u""_S;
        }
        else if (key != u"")
            val &= line;
    if (key != u"")
        r.append(make_tuple(key, val));
    return r;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(fasta_parse(FASTA).map([](const auto &key, const auto &val){return u"#.: #."_S.format(key, val);}).join(u"\n"_S));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Find_if_a_point_is_within_a_triangle#Kotlin
from typing import NamedTuple

EPS = 0.001
EPS_SQUARE = EPS * EPS

class Point(NamedTuple):
    x : float
    y : float

    def __str__(self):
        return '(' + str(self.x) + ', ' + str(self.y) + ')'

def side(p1, p2, p):
    return (p2.y - p1.y) * (p.x - p1.x) + (-p2.x + p1.x) * (p.y - p1.y)

def distanceSquarePointToSegment(p1, p2, p):
    p1P2SquareLength = (p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y)
    dotProduct = ((p.x - p1.x) * (p2.x - p1.x) + (p.y - p1.y) * (p2.y - p1.y)) / p1P2SquareLength
    if dotProduct < 0:
        return (p.x - p1.x) * (p.x - p1.x) + (p.y - p1.y) * (p.y - p1.y)
    if dotProduct <= 1:
        pP1SquareLength = (p1.x - p.x) * (p1.x - p.x) + (p1.y - p.y) * (p1.y - p.y)
        return pP1SquareLength - dotProduct * dotProduct * p1P2SquareLength
    return (p.x - p2.x) * (p.x - p2.x) + (p.y - p2.y) * (p.y - p2.y)

class Triangle(NamedTuple):
    p1 : Point
    p2 : Point
    p3 : Point

    def __str__(self):
        return 'Triangle[' + str(self.p1) + ', ' + str(self.p2) + ', ' + str(self.p3) +']'

    def pointInTriangleBoundingBox(self, p): # const
        xMin = min(self.p1.x, min(self.p2.x, self.p3.x)) - EPS
        xMax = max(self.p1.x, max(self.p2.x, self.p3.x)) + EPS
        yMin = min(self.p1.y, min(self.p2.y, self.p3.y)) - EPS
        yMax = max(self.p1.y, max(self.p2.y, self.p3.y)) + EPS
        return not (p.x < xMin or xMax < p.x or p.y < yMin or yMax < p.y)

    def nativePointInTriangle(self, p): # const
        checkSide1 = side(self.p1, self.p2, p) >= 0
        checkSide2 = side(self.p2, self.p3, p) >= 0
        checkSide3 = side(self.p3, self.p1, p) >= 0
        return checkSide1 and checkSide2 and checkSide3

    def accuratePointInTriangle(self, p): # const
        if not self.pointInTriangleBoundingBox(p):
            return False
        if self.nativePointInTriangle(p):
            return True
        if distanceSquarePointToSegment(self.p1, self.p2, p) <= EPS_SQUARE:
            return True
        if distanceSquarePointToSegment(self.p2, self.p3, p) <= EPS_SQUARE:
            return True
        return distanceSquarePointToSegment(self.p3, self.p1, p) <= EPS_SQUARE

def test(t, p):
    print(t)
    print('Point', p, 'is within triangle ?', 'true' if t.accuratePointInTriangle(p) else 'false')

p1 = Point(1.5, 2.4)
p2 = Point(5.1, -3.1)
p3 = Point(-3.8, 1.2)
tri = Triangle(p1, p2, p3)
test(tri, Point(0.0, 0.0))
test(tri, Point(0.0, 1.0))
test(tri, Point(3.0, 1.0))
print()
p1 = Point(1.0 / 10, 1.0 / 9)
p2 = Point(100.0 / 8, 100.0 / 3)
p3 = Point(100.0 / 4, 100.0 / 9)
tri = Triangle(p1, p2, p3)
pt = Point(p1.x + 3.0 / 7 * (p2.x - p1.x), p1.y + 3.0 / 7 * (p2.y - p1.y))
test(tri, pt)
print()
p3 = Point(-100.0 / 8, 100.0 / 6)
tri = Triangle(p1, p2, p3)
test(tri, pt)
===
V EPS = 0.001
V EPS_SQUARE = EPS * EPS

T Point((Float x, Float y))
   F String()
      R ‘(’String(.x)‘, ’String(.y)‘)’

F side(p1, p2, p)
   R (p2.y - p1.y) * (p.x - p1.x) + (-p2.x + p1.x) * (p.y - p1.y)

F distanceSquarePointToSegment(p1, p2, p)
   V p1P2SquareLength = (p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y)
   V dotProduct = ((p.x - p1.x) * (p2.x - p1.x) + (p.y - p1.y) * (p2.y - p1.y)) / p1P2SquareLength
   I dotProduct < 0
      R (p.x - p1.x) * (p.x - p1.x) + (p.y - p1.y) * (p.y - p1.y)
   I dotProduct <= 1
      V pP1SquareLength = (p1.x - p.x) * (p1.x - p.x) + (p1.y - p.y) * (p1.y - p.y)
      R pP1SquareLength - dotProduct * dotProduct * p1P2SquareLength
   R (p.x - p2.x) * (p.x - p2.x) + (p.y - p2.y) * (p.y - p2.y)

T Triangle((Point p1, Point p2, Point p3))
   F String()
      R ‘Triangle[’String(.p1)‘, ’String(.p2)‘, ’String(.p3)‘]’

   F.const pointInTriangleBoundingBox(p)
      V xMin = min(.p1.x, min(.p2.x, .p3.x)) - :EPS
      V xMax = max(.p1.x, max(.p2.x, .p3.x)) + :EPS
      V yMin = min(.p1.y, min(.p2.y, .p3.y)) - :EPS
      V yMax = max(.p1.y, max(.p2.y, .p3.y)) + :EPS
      R !(p.x < xMin | xMax < p.x | p.y < yMin | yMax < p.y)

   F.const nativePointInTriangle(p)
      V checkSide1 = side(.p1, .p2, p) >= 0
      V checkSide2 = side(.p2, .p3, p) >= 0
      V checkSide3 = side(.p3, .p1, p) >= 0
      R checkSide1 & checkSide2 & checkSide3

   F.const accuratePointInTriangle(p)
      I !.pointInTriangleBoundingBox(p)
         R 0B
      I .nativePointInTriangle(p)
         R 1B
      I distanceSquarePointToSegment(.p1, .p2, p) <= :EPS_SQUARE
         R 1B
      I distanceSquarePointToSegment(.p2, .p3, p) <= :EPS_SQUARE
         R 1B
      R distanceSquarePointToSegment(.p3, .p1, p) <= :EPS_SQUARE

F test(t, p)
   print(t)
   print(‘Point ’p‘ is within triangle ? ’(I t.accuratePointInTriangle(p) {‘true’} E ‘false’))

V p1 = Point(1.5, 2.4)
V p2 = Point(5.1, -3.1)
V p3 = Point(-3.8, 1.2)
V tri = Triangle(p1, p2, p3)
test(tri, Point(0.0, 0.0))
test(tri, Point(0.0, 1.0))
test(tri, Point(3.0, 1.0))
print()
p1 = Point(1.0 / 10, 1.0 / 9)
p2 = Point(100.0 / 8, 100.0 / 3)
p3 = Point(100.0 / 4, 100.0 / 9)
tri = Triangle(p1, p2, p3)
V pt = Point(p1.x + 3.0 / 7 * (p2.x - p1.x), p1.y + 3.0 / 7 * (p2.y - p1.y))
test(tri, pt)
print()
p3 = Point(-100.0 / 8, 100.0 / 6)
tri = Triangle(p1, p2, p3)
test(tri, pt)
===
auto EPS = 0.001;
auto EPS_SQUARE = EPS * EPS;

class Point
{
public:
    double x;
    double y;

    Point(const double &x, const double &y) :
        x(x), y(y) {}

    operator String() const
    {
        return u"("_S & String(x) & u", "_S & String(y) & u")"_S;
    }
};

template <typename T1, typename T2, typename T3> auto side(const T1 &p1, const T2 &p2, const T3 &p)
{
    return (p2.y - p1.y) * (p.x - p1.x) + (-p2.x + p1.x) * (p.y - p1.y);
}

template <typename T1, typename T2, typename T3> auto distanceSquarePointToSegment(const T1 &p1, const T2 &p2, const T3 &p)
{
    auto p1P2SquareLength = (p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y);
    auto dotProduct = ((p.x - p1.x) * (p2.x - p1.x) + (p.y - p1.y) * (p2.y - p1.y)) / p1P2SquareLength;
    if (dotProduct < 0)
        return (p.x - p1.x) * (p.x - p1.x) + (p.y - p1.y) * (p.y - p1.y);
    if (dotProduct <= 1) {
        auto pP1SquareLength = (p1.x - p.x) * (p1.x - p.x) + (p1.y - p.y) * (p1.y - p.y);
        return pP1SquareLength - dotProduct * dotProduct * p1P2SquareLength;
    }
    return (p.x - p2.x) * (p.x - p2.x) + (p.y - p2.y) * (p.y - p2.y);
}

class Triangle
{
public:
    Point p1;
    Point p2;
    Point p3;

    Triangle(const Point &p1, const Point &p2, const Point &p3) :
        p1(p1), p2(p2), p3(p3) {}

    operator String() const
    {
        return u"Triangle["_S & String(p1) & u", "_S & String(p2) & u", "_S & String(p3) & u"]"_S;
    }

    template <typename T1> auto pointInTriangleBoundingBox(const T1 &p) const
    {
        auto xMin = min(p1.x, min(p2.x, p3.x)) - ::EPS;
        auto xMax = max(p1.x, max(p2.x, p3.x)) + ::EPS;
        auto yMin = min(p1.y, min(p2.y, p3.y)) - ::EPS;
        auto yMax = max(p1.y, max(p2.y, p3.y)) + ::EPS;
        return !(p.x < xMin || xMax < p.x || p.y < yMin || yMax < p.y);
    }

    template <typename T1> auto nativePointInTriangle(const T1 &p) const
    {
        auto checkSide1 = side(p1, p2, p) >= 0;
        auto checkSide2 = side(p2, p3, p) >= 0;
        auto checkSide3 = side(p3, p1, p) >= 0;
        return checkSide1 && checkSide2 && checkSide3;
    }

    template <typename T1> auto accuratePointInTriangle(const T1 &p) const
    {
        if (!pointInTriangleBoundingBox(p))
            return false;
        if (nativePointInTriangle(p))
            return true;
        if (distanceSquarePointToSegment(p1, p2, p) <= ::EPS_SQUARE)
            return true;
        if (distanceSquarePointToSegment(p2, p3, p) <= ::EPS_SQUARE)
            return true;
        return distanceSquarePointToSegment(p3, p1, p) <= ::EPS_SQUARE;
    }
};

template <typename T1, typename T2> auto test(const T1 &t, const T2 &p)
{
    print(t);
    print(u"Point "_S & p & u" is within triangle ? "_S & (t.accuratePointInTriangle(p) ? u"true"_S : u"false"_S));
}

auto p1 = Point(1.5, 2.4);
auto p2 = Point(5.1, -3.1);
auto p3 = Point(-3.8, 1.2);
auto tri = Triangle(p1, p2, p3);

struct CodeBlock1
{
    CodeBlock1()
    {
        test(tri, Point(0.0, 0.0));
        test(tri, Point(0.0, 1.0));
        test(tri, Point(3.0, 1.0));
        print();
        p1 = Point(1.0 / 10.0, 1.0 / 9.0);
        p2 = Point(100.0 / 8.0, 100.0 / 3.0);
        p3 = Point(100.0 / 4.0, 100.0 / 9.0);
        tri = Triangle(p1, p2, p3);
    }
} code_block_1;

auto pt = Point(p1.x + 3.0 / 7.0 * (p2.x - p1.x), p1.y + 3.0 / 7.0 * (p2.y - p1.y));

struct CodeBlock2
{
    CodeBlock2()
    {
        test(tri, pt);
        print();
        p3 = Point(-100.0 / 8.0, 100.0 / 6.0);
        tri = Triangle(p1, p2, p3);
        test(tri, pt);
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Find_the_intersection_of_two_lines#Python
def line_intersect(Ax1, Ay1, Ax2, Ay2, Bx1, By1, Bx2, By2):
    d = (By2 - By1) * (Ax2 - Ax1) - (Bx2 - Bx1) * (Ay2 - Ay1)
    if d == 0:
        return (float('inf'), float('inf'))

    uA = ((Bx2 - Bx1) * (Ay1 - By1) - (By2 - By1) * (Ax1 - Bx1)) / d
    uB = ((Ax2 - Ax1) * (Ay1 - By1) - (Ay2 - Ay1) * (Ax1 - Bx1)) / d

    if not(0.0 <= uA <= 1.0 and 0.0 <= uB <= 1.0):
        return (float('inf'), float('inf'))
    x = Ax1 + uA * (Ax2 - Ax1)
    y = Ay1 + uA * (Ay2 - Ay1)

    return (x, y)

(a, b, c, d) = (4.0, 0.0, 6.0, 10.0)  # try (4, 0), (6, 4)
(e, f, g, h) = (0.0, 3.0, 10.0, 7.0)  # for non intersecting test
pt = line_intersect(a, b, c, d, e, f, g, h)
print(pt)
===
F line_intersect(Ax1, Ay1, Ax2, Ay2, Bx1, By1, Bx2, By2)
   V d = (By2 - By1) * (Ax2 - Ax1) - (Bx2 - Bx1) * (Ay2 - Ay1)
   I d == 0
      R (Float.infinity, Float.infinity)

   V uA = ((Bx2 - Bx1) * (Ay1 - By1) - (By2 - By1) * (Ax1 - Bx1)) / d
   V uB = ((Ax2 - Ax1) * (Ay1 - By1) - (Ay2 - Ay1) * (Ax1 - Bx1)) / d

   I !(uA C 0.0..1.0 & uB C 0.0..1.0)
      R (Float.infinity, Float.infinity)
   V x = Ax1 + uA * (Ax2 - Ax1)
   V y = Ay1 + uA * (Ay2 - Ay1)

   R (x, y)

V (a, b, c, d) = (4.0, 0.0, 6.0, 10.0)
V (e, f, g, h) = (0.0, 3.0, 10.0, 7.0)
V pt = line_intersect(a, b, c, d, e, f, g, h)
print(pt)
===
template <typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8> auto line_intersect(const T1 &Ax1, const T2 &Ay1, const T3 &Ax2, const T4 &Ay2, const T5 &Bx1, const T6 &By1, const T7 &Bx2, const T8 &By2)
{
    auto d = (By2 - By1) * (Ax2 - Ax1) - (Bx2 - Bx1) * (Ay2 - Ay1);
    if (d == 0)
        return make_tuple(std::numeric_limits<double>::infinity(), std::numeric_limits<double>::infinity());

    auto uA = ((Bx2 - Bx1) * (Ay1 - By1) - (By2 - By1) * (Ax1 - Bx1)) / d;
    auto uB = ((Ax2 - Ax1) * (Ay1 - By1) - (Ay2 - Ay1) * (Ax1 - Bx1)) / d;

    if (!(in(uA, range_ee(0.0, 1.0)) && in(uB, range_ee(0.0, 1.0))))
        return make_tuple(std::numeric_limits<double>::infinity(), std::numeric_limits<double>::infinity());
    auto x = Ax1 + uA * (Ax2 - Ax1);
    auto y = Ay1 + uA * (Ay2 - Ay1);

    return make_tuple(x, y);
}

auto [a, b, c, d] = make_tuple(4.0, 0.0, 6.0, 10.0);
auto [e, f, g, h] = make_tuple(0.0, 3.0, 10.0, 7.0);
auto pt = line_intersect(a, b, c, d, e, f, g, h);

struct CodeBlock1
{
    CodeBlock1()
    {
        print(pt);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Find_words_which_contains_more_than_3_e_vowels#Python
aiou = 'aiou' # to get round ‘bug in MSVC 2017’[https://developercommunity.visualstudio.com/t/bug-with-operator-in-c/565417]

for word in open('unixdict.txt').read().split("\n"):
    if not any(c in aiou for c in word) and sum(int(c=='e') for c in word)>3:
        print(word)
===
V aiou = ‘aiou’

L(word) File(‘unixdict.txt’).read().split("\n")
   I !any(word.map(c -> c C :aiou)) & sum(word.map(c -> Int(c == ‘e’))) > 3
      print(word)
===
auto aiou = u"aiou"_S;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&word : File(u"unixdict.txt"_S).read().split(u"\n"_S))
            if (!any_map(word, [](const auto &c){return in(c, ::aiou);}) && sum_map(word, [](const auto &c){return to_int(c == u'e');}) > 3)
                print(word);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Find_words_with_alternating_vowels_and_consonants#Nim
vowels = 'aeiou'

count = 0
for word in open('unixdict.txt').read().split("\n"):
    if len(word) > 9:
        first = word[0] in vowels
        for i in range(2, len(word), 2):
            if (word[i] in vowels) != first:
                break
        else:
            for i in range(1, len(word), 2):
                if (word[i] in vowels) == first:
                    break
            else:
                count += 1
                print(word.rjust(14), end = "\n" if count % 7 == 0 else ' ')
print()
===
V vowels = ‘aeiou’

V count = 0
L(word) File(‘unixdict.txt’).read().split("\n")
   I word.len > 9
      V first = word[0] C vowels
      L(i) (2 .< word.len).step(2)
         I (word[i] C vowels) != first
            L.break
      L.was_no_break
         L(i) (1 .< word.len).step(2)
            I (word[i] C vowels) == first
               L.break
         L.was_no_break
            count++
            print(word.rjust(14), end' I count % 7 == 0 {"\n"} E ‘ ’)
print()
===
auto vowels = u"aeiou"_S;

auto count = 0;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&word : File(u"unixdict.txt"_S).read().split(u"\n"_S))
            if (word.len() > 9) {
                auto first = in(_get<0>(word), vowels);
                for (auto i : range_el(2, word.len()).step(2))
                    if ((in(word[i], vowels)) != first)
                        goto break_;
                for (auto i : range_el(1, word.len()).step(2))
                    if ((in(word[i], vowels)) == first)
                        goto break_1;
                count++;
                print(word.rjust(14), mod(count, 7) == 0 ? u'\n'_C : u' '_C);
                break_1:;
                break_:;
            }
        print();
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Finite_state_machine#Python
states = {  'ready':
                ('Machine ready: (d)eposit, or (q)uit?',
                 [str('d'),'q']),
            'waiting':
                ('Machine waiting: (s)elect, or (r)efund?',
                 [str('s'),'r']),
            'dispense' :
                ('Machine dispensing: please (r)emove product',
                 [str('r')]),
            'refunding' :
                ('Refunding money',
                 ['']*0),
          }
transitions = { 'ready': {
                    str('d'): 'waiting',
                    str('q'): 'exit'},
                'waiting' : {
                    str('s') : 'dispense',
                    str('r') : 'refunding'},
                'dispense' : {
                    str('r') : 'ready'},
                'refunding' : {
                    '' : 'ready'}}

def Acceptor(prompt, valids):
    ''' Acceptor style finite state machine to prompt for user input'''
    if len(valids) == 0:
        print(prompt)
        return ''
    else:
        while True:
            resp = input(prompt)[0].lower()
            if resp in valids:
                return str(resp)

def finite_state_machine(initial_state, exit_state):
    next_state = initial_state
    current_state = states[next_state]
    while True:
        response = Acceptor(current_state[0], current_state[1])
        if response == exit_state:
            break
        next_state = transitions[next_state][response]
        current_state = states[next_state]

finite_state_machine('ready', 'q')
===
V states = [‘ready’ = (‘Machine ready: (d)eposit, or (q)uit?’, [String(‘d’), ‘q’]), ‘waiting’ = (‘Machine waiting: (s)elect, or (r)efund?’, [String(‘s’), ‘r’]), ‘dispense’ = (‘Machine dispensing: please (r)emove product’, [String(‘r’)]), ‘refunding’ = (‘Refunding money’, [‘’] * 0)]
V transitions = [‘ready’ = [String(‘d’) = ‘waiting’, String(‘q’) = ‘exit’], ‘waiting’ = [String(‘s’) = ‘dispense’, String(‘r’) = ‘refunding’], ‘dispense’ = [String(‘r’) = ‘ready’], ‘refunding’ = [‘’ = ‘ready’]]

F Acceptor(prompt, valids)
   ‘ Acceptor style finite state machine to prompt for user input’
   I valids.empty
      print(prompt)
      R ‘’
   E
      L
         V resp = input(prompt)[0].lowercase()
         I resp C valids
            R String(resp)

F finite_state_machine(initial_state, exit_state)
   V next_state = initial_state
   V current_state = :states[next_state]
   L
      V response = Acceptor(current_state[0], current_state[1])
      I response == exit_state
         L.break
      next_state = :transitions[next_state][response]
      current_state = :states[next_state]

finite_state_machine(‘ready’, ‘q’)
===
auto states = create_dict(dict_of(u"ready"_S, make_tuple(u"Machine ready: (d)eposit, or (q)uit?"_S, create_array<String>({u"d"_S, u"q"_S})))(u"waiting"_S, make_tuple(u"Machine waiting: (s)elect, or (r)efund?"_S, create_array<String>({u"s"_S, u"r"_S})))(u"dispense"_S, make_tuple(u"Machine dispensing: please (r)emove product"_S, create_array({u"r"_S})))(u"refunding"_S, make_tuple(u"Refunding money"_S, create_array({u""_S}) * 0)));
auto transitions = create_dict(dict_of(u"ready"_S, create_dict(dict_of(u"d"_S, u"waiting"_S)(u"q"_S, u"exit"_S)))(u"waiting"_S, create_dict(dict_of(u"s"_S, u"dispense"_S)(u"r"_S, u"refunding"_S)))(u"dispense"_S, create_dict(dict_of(u"r"_S, u"ready"_S)))(u"refunding"_S, create_dict(dict_of(u""_S, u"ready"_S))));

template <typename T1, typename T2> auto Acceptor(const T1 &prompt, const T2 &valids)
{
    u" Acceptor style finite state machine to prompt for user input"_S;
    if (valids.empty()) {
        print(prompt);
        return u""_S;
    }
    else
        while (true) {
            auto resp = _get<0>(input(prompt)).lowercase();
            if (in(resp, valids))
                return String(resp);
        }
}

template <typename T1, typename T2> auto finite_state_machine(const T1 &initial_state, const T2 &exit_state)
{
    auto next_state = initial_state;
    auto current_state = ::states[next_state];
    while (true) {
        auto response = Acceptor(_get<0>(current_state), _get<1>(current_state));
        if (response == exit_state)
            break;
        next_state = ::transitions[next_state][response];
        current_state = ::states[next_state];
    }
}

struct CodeBlock1
{
    CodeBlock1()
    {
        finite_state_machine(u"ready"_S, u"q"_S);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/First-class_functions/Use_numbers_analogously#Python
(x,xi, y,yi) = (2.0,0.5, 4.0,0.25)
z  = x + y
zi = 1.0 / (x + y)
multiplier = lambda n1, n2: (lambda m: n1 * n2 * m)
numlist = [x, y, z]
numlisti = [xi, yi, zi]
print([multiplier(inversen, n)(.5) for n, inversen in zip(numlist, numlisti)])
===
V (x, xi, y, yi) = (2.0, 0.5, 4.0, 0.25)
V z = x + y
V zi = 1.0 / (x + y)
V multiplier = (n1, n2) -> (m -> @n1 * @n2 * m)
V numlist = [x, y, z]
V numlisti = [xi, yi, zi]
print(zip(numlist, numlisti).map((n, inversen) -> multiplier(inversen, n)(.5)))
===
auto [x, xi, y, yi] = make_tuple(2.0, 0.5, 4.0, 0.25);
auto z = x + y;
auto zi = 1.0 / (x + y);
auto multiplier = [](const auto &n1, const auto &n2){return ([&n1, &n2](const auto &m){return n1 * n2 * m;});};
auto numlist = create_array({x, y, z});
auto numlisti = create_array({xi, yi, zi});

struct CodeBlock1
{
    CodeBlock1()
    {
        print(zip(numlist, numlisti).map([](const auto &n, const auto &inversen){return multiplier(inversen, n)(.5);}));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/First_perfect_square_in_base_n_with_n_unique_digits#Nim
from _11l import *

for base in range(2, 17):
    n = Int64(float(base) ** ((base - 1) / 2))
    while True:
        sq = n * n
        sqstr = int_to_str_with_radix(sq, base)
        if len(sqstr) >= base and len(set(list(sqstr))) == base:
            nstr = int_to_str_with_radix(n, base)
            print('Base {:2}:  {:>8}^2 = {}'.format(base, nstr, sqstr))
            break
        n += 1
===
L(base) 2..16
   V n = Int64(Float(base) ^ ((base - 1) / 2))
   L
      V sq = n * n
      V sqstr = String(sq, radix' base)
      I sqstr.len >= base & Set(Array(sqstr)).len == base
         V nstr = String(n, radix' base)
         print(‘Base #2:  #8^2 = #.’.format(base, nstr, sqstr))
         L.break
      n++
===
struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto base : range_ee(2, 16)) {
            auto n = to_int64(pow(to_float(base), ((base - 1) / 2.0)));
            while (true) {
                auto sq = n * n;
                auto sqstr = int_to_str_with_radix(sq, base);
                if (sqstr.len() >= base && create_set(create_array(sqstr)).len() == base) {
                    auto nstr = int_to_str_with_radix(n, base);
                    print(u"Base #2:  #8^2 = #."_S.format(base, nstr, sqstr));
                    break;
                }
                n++;
            }
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/First_power_of_2_that_has_leading_decimal_digits_of_12#Python
import math

def p(l, n, pwr=2):
    l = int(abs(l))
    digitcount = math.floor(math.log(l, 10))
    log10pwr = math.log(pwr, 10)
    (raised, found) = (-1, 0)
    while found < n:
        raised += 1
        firstdigits = math.floor(10**(math.modf(log10pwr * raised)[0] + digitcount))
        if firstdigits == l:
            found += 1
    return raised

for l, n in [(12, 1), (12, 2), (123, 45), (123, 12345), (123, 678910)]:
    print('p(' + str(l) + ', ' + str(n) + ') = ' + str(p(l, n)))
===
F p(=l, n, pwr = 2)
   l = Int(abs(l))
   V digitcount = floori(log(l, 10))
   V log10pwr = log(pwr, 10)
   V (raised, found) = (-1, 0)
   L found < n
      raised++
      V firstdigits = floori(10 ^ (modf(log10pwr * raised)[0] + digitcount))
      I firstdigits == l
         found++
   R raised

L(l, n) [(12, 1), (12, 2), (123, 45), (123, 12345), (123, 678910)]
   print(‘p(’String(l)‘, ’String(n)‘) = ’String(p(l, n)))
===
template <typename T1, typename T2, typename T3 = decltype(2)> auto p(T1 l, const T2 &n, const T3 &pwr = 2)
{
    l = to_int(abs(l));
    auto digitcount = floori(log(l, 10));
    auto log10pwr = log(pwr, 10);
    auto [raised, found] = make_tuple(-1, 0);
    while (found < n) {
        raised++;
        auto firstdigits = floori(pow(10, (_get<0>(modf(log10pwr * raised)) + digitcount)));
        if (firstdigits == l)
            found++;
    }
    return raised;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&[l, n] : create_array({make_tuple(12, 1), make_tuple(12, 2), make_tuple(123, 45), make_tuple(123, 12345), make_tuple(123, 678910)}))
            print(u"p("_S & String(l) & u", "_S & String(n) & u") = "_S & String(p(l, n)));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Flipping_bits_game#Python
import random
from copy import deepcopy
ascii_lowercase = 'abcdefghij'
digits = '0123456789' # to get round ‘bug in MSVC 2017’[https://developercommunity.visualstudio.com/t/bug-with-operator-in-c/565417]

n = 3   # n x n Square arrray

board  = [[0]* n for i in range(n)]

def setbits(board : list, count=1):
    for i in range(count):
        board[random.randrange(n)][random.randrange(n)] ^= 1

def fliprow(i):
    #board[i-1][:] = [x ^ 1 for x in board[i-1] ]
    for j in range(n):
        board[i-1][j] ^= 1

def flipcol(i):
    for row in board: # &
        row[i] ^= 1

def shuffle(board, count=1):
    for i in range(count):
        if random.randrange(0, 2) != 0:
            fliprow(random.randrange(n)+1)
        else:
            flipcol(random.randrange(n))

def pr(board, comment=''):
    print(comment)
    print('     ' + ' '.join(ascii_lowercase[i] for i in range(n)))
    print('  ' + '\n  '.join(' '.join(['%2s' % j] + [str(i) for i in line])
                             for j, line in enumerate(board, 1)))

def init(board : list):
    setbits(board, count=random.randrange(n)+1)
    target = deepcopy(board)
    while board == target:
        shuffle(board, count=2 * n)
    prompt = '  X, T, or 1-%i / %s-%s to flip: ' % (n, ascii_lowercase[0],
                                                    ascii_lowercase[n-1])
    return (target, prompt)

(target, prompt) = init(board)
pr(target, 'Target configuration is:')
print('')
turns = 0
while board != target:
    turns += 1
    pr(board, '%i:' % turns)
    ans = input(prompt).strip(' ')
    if (len(ans) == 1
        and ans in ascii_lowercase and ascii_lowercase.index(ans) < n):
        flipcol(ascii_lowercase.index(ans))
    elif ans != '' and all(ch in digits for ch in ans) and 1 <= int(ans) <= n:
        fliprow(int(ans))
    elif ans == 'T':
        pr(target, 'Target configuration is:')
        turns -= 1
    elif ans == 'X':
        break
    else:
        print("  I don't understand '%s'... Try again. (X to exit or T to show target)\n" % ans[:9])
        turns -= 1
else:
    print('\nWell done!\nBye.')
===
V ascii_lowercase = ‘abcdefghij’
V digits = ‘0123456789’

V n = 3

V board = [[0] * :n] * n

F setbits(&board, count = 1)
   L(i) 0 .< count
      board[random:(:n)][random:(:n)] (+)= 1

F fliprow(i)
   L(j) 0 .< :n
      :board[i - 1][j] (+)= 1

F flipcol(i)
   L(&row) :board
      row[i] (+)= 1

F shuffle(board, count = 1)
   L(i) 0 .< count
      I random:(0 .< 2) != 0
         fliprow(random:(:n) + 1)
      E
         flipcol(random:(:n))

F pr(board, comment = ‘’)
   print(comment)
   print(‘     ’(0 .< :n).map(i -> :ascii_lowercase[i]).join(‘ ’))
   print(‘  ’enumerate(board, 1).map((j, line) -> ([‘#2’.format(j)] [+] line.map(i -> String(i))).join(‘ ’)).join("\n  "))

F init(&board)
   setbits(&board, count' random:(:n) + 1)
   V target = copy(board)
   L board == target
      shuffle(board, count' 2 * :n)
   V prompt = ‘  X, T, or 1-#. / #.-#. to flip: ’.format(:n, :ascii_lowercase[0], :ascii_lowercase[:n - 1])
   R (target, prompt)

V (target, prompt) = init(&board)
pr(target, ‘Target configuration is:’)
print(‘’)
V turns = 0
L board != target
   turns++
   pr(board, ‘#.:’.format(turns))
   V ans = input(prompt).trim(‘ ’)
   I (ans.len == 1 & ans C ascii_lowercase & ascii_lowercase.index(ans) < n)
      flipcol(ascii_lowercase.index(ans))
   E I ans != ‘’ & all(ans.map(ch -> ch C :digits)) & Int(ans) C 1 .. n
      fliprow(Int(ans))
   E I ans == ‘T’
      pr(target, ‘Target configuration is:’)
      turns--
   E I ans == ‘X’
      L.break
   E
      print("  I don't understand '#.'... Try again. (X to exit or T to show target)\n".format(ans[0.<9]))
      turns--
L.was_no_break
   print("\nWell done!\nBye.")
===
auto ascii_lowercase = u"abcdefghij"_S;
auto digits = u"0123456789"_S;

auto n = 3;

auto board = create_array({create_array({0}) * ::n}) * n;

template <typename T1, typename T2 = decltype(1)> auto setbits(T1 &board, const T2 &count = 1)
{
    for (auto i : range_el(0, count))
        board[randomns::_(::n)][randomns::_(::n)] ^= 1;
}

template <typename T1> auto fliprow(const T1 &i)
{
    for (auto j : range_el(0, ::n))
        ::board[i - 1][j] ^= 1;
}

template <typename T1> auto flipcol(const T1 &i)
{
    for (auto &row : ::board)
        row[i] ^= 1;
}

template <typename T1, typename T2 = decltype(1)> auto shuffle(const T1 &board, const T2 &count = 1)
{
    for (auto i : range_el(0, count))
        if (randomns::_(range_el(0, 2)) != 0)
            fliprow(randomns::_(::n) + 1);
        else
            flipcol(randomns::_(::n));
}

template <typename T1, typename T2 = decltype(u""_S)> auto pr(const T1 &board, const T2 &comment = u""_S)
{
    print(comment);
    print(u"     "_S & range_el(0, ::n).map([](const auto &i){return ::ascii_lowercase[i];}).join(u" "_S));
    print(u"  "_S & enumerate(board, 1).map([](const auto &j, const auto &line){return (create_array({u"#2"_S.format(j)}) + line.map([](const auto &i){return String(i);})).join(u" "_S);}).join(u"\n  "_S));
}

template <typename T1> auto init(T1 &board)
{
    setbits(board, randomns::_(::n) + 1);
    auto target = copy(board);
    while (board == target)
        shuffle(board, 2 * ::n);
    auto prompt = u"  X, T, or 1-#. / #.-#. to flip: "_S.format(::n, _get<0>(::ascii_lowercase), ::ascii_lowercase[::n - 1]);
    return make_tuple(target, prompt);
}

auto [target, prompt] = init(board);

struct CodeBlock1
{
    CodeBlock1()
    {
        pr(target, u"Target configuration is:"_S);
        print(u""_S);
    }
} code_block_1;

auto turns = 0;

struct CodeBlock2
{
    CodeBlock2()
    {
        while (board != target) {
            turns++;
            pr(board, u"#.:"_S.format(turns));
            auto ans = input(prompt).trim(u" "_S);
            if ((ans.len() == 1 && in(ans, ascii_lowercase) && ascii_lowercase.index(ans) < n))
                flipcol(ascii_lowercase.index(ans));
            else if (ans != u"" && all_map(ans, [](const auto &ch){return in(ch, ::digits);}) && in(to_int(ans), range_ee(1, n)))
                fliprow(to_int(ans));
            else if (ans == u'T') {
                pr(target, u"Target configuration is:"_S);
                turns--;
            }
            else if (ans == u'X')
                goto break_;
            else {
                print(u"  I don't understand '#.'... Try again. (X to exit or T to show target)\n"_S.format(ans[range_el(0, 9)]));
                turns--;
            }
        }
        print(u"\nWell done!\nBye."_S);
        break_:;
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Four_is_magic#Nim
Int64 = int

Small = ["zero",    "one",     "two",       "three",    "four",
         "five",    "six",     "seven",     "eight",    "nine",
         "ten",     "eleven",  "twelve",    "thirteen", "fourteen",
         "fifteen", "sixteen", "seventeen", "eighteen", "nineteen"]

Tens = ["", "", "twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety"]

Illions = ["", " thousand", " million", " billion", " trillion", " quadrillion", " quintillion"]

def say(n : Int64) -> str:
    result = ''
    if n < 0:
        result = "negative "
        n = -n

    if n < 20:
        result += Small[int(n)]

    elif n < 100:
        result += Tens[int(n // 10)]
        m = n % 10
        if m != 0: result += '-' + Small[int(m)]

    elif n < 1000:
        result += Small[int(n // 100)] + " hundred"
        m = n % 100
        if m != 0: result += ' ' + say(m)

    else:
        # Work from right to left.
        sx = ""
        i = 0
        while n > 0:
            m = n % 1000
            n //= 1000
            if m != 0:
                ix = say(m) + '' + Illions[i]
                if len(sx) > 0: ix += " " + sx
                sx = ix
            i += 1
        result += sx

    return result

def fourIsMagic(n):
    s = say(n).capitalize()
    result = s
    while n != 4:
        n = len(s)
        s = say(n)
        result += " is " + s + ", " + s
    return result + " is magic."

for n in [Int64(0), 4, 6, 11, 13, 75, 100, 337, -164, 0x7FFF_FFFF_FFFF_FFFF]:
    print(fourIsMagic(n))
===
V Small = [‘zero’, ‘one’, ‘two’, ‘three’, ‘four’, ‘five’, ‘six’, ‘seven’, ‘eight’, ‘nine’, ‘ten’, ‘eleven’, ‘twelve’, ‘thirteen’, ‘fourteen’, ‘fifteen’, ‘sixteen’, ‘seventeen’, ‘eighteen’, ‘nineteen’]

V Tens = [‘’, ‘’, ‘twenty’, ‘thirty’, ‘forty’, ‘fifty’, ‘sixty’, ‘seventy’, ‘eighty’, ‘ninety’]

V Illions = [‘’, ‘ thousand’, ‘ million’, ‘ billion’, ‘ trillion’, ‘ quadrillion’, ‘ quintillion’]

F say(Int64 =n) -> String
   V result = ‘’
   I n < 0
      result = ‘negative ’
      n = -n

   I n < 20
      result ‘’= Small[Int(n)]

   E I n < 100
      result ‘’= Tens[Int(n I/ 10)]
      V m = n % 10
      I m != 0
         result ‘’= ‘-’Small[Int(m)]

   E I n < 1000
      result ‘’= Small[Int(n I/ 100)]‘ hundred’
      V m = n % 100
      I m != 0
         result ‘’= ‘ ’say(m)

   E
      V sx = ‘’
      V i = 0
      L n > 0
         V m = n % 1000
         n I/= 1000
         I m != 0
            V ix = say(m)‘’Illions[i]
            I sx.len > 0
               ix ‘’= ‘ ’sx
            sx = ix
         i++
      result ‘’= sx

   R result

F fourIsMagic(=n)
   V s = say(n).capitalize()
   V result = s
   L n != 4
      n = s.len
      s = say(n)
      result ‘’= ‘ is ’s‘, ’s
   R result‘ is magic.’

L(n) [Int64(0), 4, 6, 11, 13, 75, 100, 337, -164, 7FFF'FFFF'FFFF'FFFF]
   print(fourIsMagic(n))
===
auto Small = create_array({u"zero"_S, u"one"_S, u"two"_S, u"three"_S, u"four"_S, u"five"_S, u"six"_S, u"seven"_S, u"eight"_S, u"nine"_S, u"ten"_S, u"eleven"_S, u"twelve"_S, u"thirteen"_S, u"fourteen"_S, u"fifteen"_S, u"sixteen"_S, u"seventeen"_S, u"eighteen"_S, u"nineteen"_S});

auto Tens = create_array({u""_S, u""_S, u"twenty"_S, u"thirty"_S, u"forty"_S, u"fifty"_S, u"sixty"_S, u"seventy"_S, u"eighty"_S, u"ninety"_S});

auto Illions = create_array({u""_S, u" thousand"_S, u" million"_S, u" billion"_S, u" trillion"_S, u" quadrillion"_S, u" quintillion"_S});

String say(Int64 n)
{
    auto result = u""_S;
    if (n < 0) {
        result = u"negative "_S;
        n = -n;
    }

    if (n < 20)
        result &= Small[to_int(n)];

    else if (n < 100) {
        result &= Tens[to_int(idiv(n, 10))];
        auto m = mod(n, 10);
        if (m != 0)
            result &= u"-"_S & Small[to_int(m)];
    }

    else if (n < 1000) {
        result &= Small[to_int(idiv(n, 100))] & u" hundred"_S;
        auto m = mod(n, 100);
        if (m != 0)
            result &= u" "_S & say(m);
    }

    else {
        auto sx = u""_S;
        auto i = 0;
        while (n > 0) {
            auto m = mod(n, 1000);
            n = idiv(n, 1000);
            if (m != 0) {
                auto ix = say(m) & Illions[i];
                if (sx.len() > 0)
                    ix &= u" "_S & sx;
                sx = ix;
            }
            i++;
        }
        result &= sx;
    }

    return result;
}

template <typename T1> auto fourIsMagic(T1 n)
{
    auto s = say(n).capitalize();
    auto result = s;
    while (n != 4) {
        n = s.len();
        s = say(n);
        result &= u" is "_S & s & u", "_S & s;
    }
    return result & u" is magic."_S;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&n : create_array<Int64>({to_int64(0), 4, 6, 11, 13, 75, 100, 337, -164, 0x7FFF'FFFF'FFFF'FFFF}))
            print(fourIsMagic(n));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Fractal_tree#Nim
import math

Width = 1000
Height = 1000
TrunkLength = 400
ScaleFactor = 0.6
StartingAngle = 1.5 * math.pi
DeltaAngle = 0.2 * math.pi

def drawTree(outfile, x : float, y : float, len, theta) -> None:
    if len >= 1:
        x2 = x + len * math.cos(theta)
        y2 = y + len * math.sin(theta)
        outfile.write("<line x1='%f' y1='%f' x2='%f' y2='%f' style='stroke:white;stroke-width:1'/>\n" % (x, y, x2, y2))
        drawTree(outfile, x2, y2, len * ScaleFactor, theta + DeltaAngle)
        drawTree(outfile, x2, y2, len * ScaleFactor, theta - DeltaAngle)

outsvg = open("tree.svg", 'w', newline = "\n")
outsvg.write(
"""<?xml version='1.0' encoding='utf-8' standalone='no'?>
<!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN' 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'>
<svg width='100%%' height='100%%' version='1.1' xmlns='http://www.w3.org/2000/svg'>
<rect width="100%" height="100%" fill="black"/>
""")
drawTree(outsvg, 0.5 * Width, Height, TrunkLength, StartingAngle)
outsvg.write("</svg>\n")
===
V Width = 1000
V Height = 1000
V TrunkLength = 400
V ScaleFactor = 0.6
V StartingAngle = 1.5 * math:pi
V DeltaAngle = 0.2 * math:pi

F drawTree(outfile, Float x, Float y; len, theta) -> Void
   I len >= 1
      V x2 = x + len * cos(theta)
      V y2 = y + len * sin(theta)
      outfile.write("<line x1='#.6' y1='#.6' x2='#.6' y2='#.6' style='stroke:white;stroke-width:1'/>\n".format(x, y, x2, y2))
      drawTree(outfile, x2, y2, len * ScaleFactor, theta + DeltaAngle)
      drawTree(outfile, x2, y2, len * ScaleFactor, theta - DeltaAngle)

V outsvg = File(‘tree.svg’, WRITE)
outsvg.write(‘<?xml version='1.0' encoding='utf-8' standalone='no'?>
<!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN' 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'>
<svg width='100%%' height='100%%' version='1.1' xmlns='http://www.w3.org/2000/svg'>
<rect width="100%" height="100%" fill="black"/>
’)
drawTree(outsvg, 0.5 * Width, Height, TrunkLength, StartingAngle)
outsvg.write("</svg>\n")
===
auto Width = 1000;
auto Height = 1000;
auto TrunkLength = 400;
auto ScaleFactor = 0.6;
auto StartingAngle = 1.5 * math::pi;
auto DeltaAngle = 0.2 * math::pi;

template <typename T1, typename T4, typename T5> void drawTree(const T1 &outfile, const double x, const double y, const T4 &len, const T5 &theta)
{
    if (len >= 1) {
        auto x2 = x + len * cos(theta);
        auto y2 = y + len * sin(theta);
        outfile.write(u"<line x1='#.6' y1='#.6' x2='#.6' y2='#.6' style='stroke:white;stroke-width:1'/>\n"_S.format(x, y, x2, y2));
        drawTree(outfile, x2, y2, len * ScaleFactor, theta + DeltaAngle);
        drawTree(outfile, x2, y2, len * ScaleFactor, theta - DeltaAngle);
    }
}

auto outsvg = FileWr(u"tree.svg"_S);

struct CodeBlock1
{
    CodeBlock1()
    {
        outsvg.write(uR"(<?xml version='1.0' encoding='utf-8' standalone='no'?>
<!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN' 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'>
<svg width='100%%' height='100%%' version='1.1' xmlns='http://www.w3.org/2000/svg'>
<rect width="100%" height="100%" fill="black"/>
)"_S);
        drawTree(outsvg, 0.5 * Width, Height, TrunkLength, StartingAngle);
        outsvg.write(u"</svg>\n"_S);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Frobenius_numbers#Python
import itertools

def isPrime(v):
  if v <= 1:
    return False
  if v < 4:
    return True
  if v % 2 == 0:
    return False
  if v < 9:
    return True
  if v % 3 == 0:
    return False
  else:
    r = round(pow(v,0.5))
    f = 5
    while f <= r:
      if v % f == 0 or v % (f + 2) == 0:
        return False
      f += 6
    return True

pn = 2
n = 0
for i in itertools.count(3, 2):
  if isPrime(i):
    n += 1
    f = (pn * i) - pn - i
    if f > 10000:
      break
    print (n, ' => ', f)
    pn = i
===
F isPrime(v)
   I v <= 1
      R 0B
   I v < 4
      R 1B
   I v % 2 == 0
      R 0B
   I v < 9
      R 1B
   I v % 3 == 0
      R 0B
   E
      V r = round(pow(v, 0.5))
      V f = 5
      L f <= r
         I v % f == 0 | v % (f + 2) == 0
            R 0B
         f += 6
      R 1B

V pn = 2
V n = 0
L(i) (3..).step(2)
   I isPrime(i)
      n++
      V f = (pn * i) - pn - i
      I f > 10000
         L.break
      print(n‘  =>  ’f)
      pn = i
===
template <typename T1> auto isPrime(const T1 &v)
{
    if (v <= 1)
        return false;
    if (v < 4)
        return true;
    if (mod(v, 2) == 0)
        return false;
    if (v < 9)
        return true;
    if (mod(v, 3) == 0)
        return false;
    else {
        auto r = round(pow(v, 0.5));
        auto f = 5;
        while (f <= r) {
            if (mod(v, f) == 0 || mod(v, (f + 2)) == 0)
                return false;
            f += 6;
        }
        return true;
    }
}

auto pn = 2;
auto n = 0;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto i : range_ei(3).step(2))
            if (isPrime(i)) {
                n++;
                auto f = (pn * i) - pn - i;
                if (f > 10000)
                    break;
                print(n & u"  =>  "_S & f);
                pn = i;
            }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Find_adjacent_primes_which_differ_by_a_square_integer#Python
import math

def primes_upto(limit):
    is_prime = [False] * 2 + [True] * (limit - 1)
    for n in range(int(limit**0.5 + 1.5)): # stop at ``sqrt(limit)``
        if is_prime[n]:
            for i in range(n*n, limit+1, n):
                is_prime[i] = False
    return [i for i, prime in enumerate(is_prime) if prime]

primes = primes_upto(1_000_000)

def is_square(x):
    return int(math.sqrt(x)) ** 2 == x

for n in range(2, len(primes)):
    pr1 = primes[n]
    pr2 = primes[n-1]
    diff = pr1 - pr2
    if (is_square(diff) and diff > 36):
       print(pr1, pr2, "diff =", diff)
===
F primes_upto(limit)
   V is_prime = [0B] * 2 [+] [1B] * (limit - 1)
   L(n) 0 .< Int(limit ^ 0.5 + 1.5)
      I is_prime[n]
         L(i) (n * n .. limit).step(n)
            is_prime[i] = 0B
   R enumerate(is_prime).filter((i, prime) -> prime).map((i, prime) -> i)

V primes = primes_upto(1'000'000)

F is_square(x)
   R Int(sqrt(x)) ^ 2 == x

L(n) 2 .< primes.len
   V pr1 = primes[n]
   V pr2 = primes[n - 1]
   V diff = pr1 - pr2
   I (is_square(diff) & diff > 36)
      print(pr1‘ ’pr2‘ diff = ’diff)
===
template <typename T1> auto primes_upto(const T1 &limit)
{
    auto is_prime = create_array({false}) * 2 + create_array({true}) * (limit - 1);
    for (auto n : range_el(0, to_int(pow(limit, 0.5) + 1.5)))
        if (is_prime[n])
            for (auto i : range_ee(n * n, limit).step(n))
                is_prime.set(i, false);
    return enumerate(is_prime).filter([](const auto &i, const auto &prime){return prime;}).map([](const auto &i, const auto &prime){return i;});
}

auto primes = primes_upto(1'000'000);

template <typename T1> auto is_square(const T1 &x)
{
    return square(to_int(sqrt(x))) == x;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto n : range_el(2, primes.len())) {
            auto pr1 = primes[n];
            auto pr2 = primes[n - 1];
            auto diff = pr1 - pr2;
            if ((is_square(diff) && diff > 36))
                print(pr1 & u" "_S & pr2 & u" diff = "_S & diff);
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Find_first_missing_positive
import itertools

nums = [[1,2,0], [3,4,-1,1], [7,8,9,11,12]]

for l in nums:
    for n in itertools.count(1):
        if n not in l:
            print(l, '->', n)
            break
===
V nums = [[1, 2, 0], [3, 4, -1, 1], [7, 8, 9, 11, 12]]

L(l) nums
   L(n) 1..
      I n !C l
         print(l‘ -> ’n)
         L.break
===
auto nums = create_array({create_array({1, 2, 0}), create_array({3, 4, -1, 1}), create_array({7, 8, 9, 11, 12})});

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&l : nums)
            for (auto n : range_ei(1))
                if (!in(n, l)) {
                    print(l & u" -> "_S & n);
                    break;
                }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Find_minimum_number_of_coins_that_make_a_given_value#Python_::_Procedural
denominations = [1,2,5,10,20,50,100,200]
total = 988
print(f"Available denominations: {denominations}. Total is to be: {total}.")
(coins, remaining) = (sorted(denominations, reverse=True), total)
for n in range(len(coins)):
    (coinsused, remaining) = divmod(remaining, coins[n])
    if coinsused > 0:
        print("   ", coinsused, "*", coins[n])
===
V denominations = [1, 2, 5, 10, 20, 50, 100, 200]
V total = 988
print(‘Available denominations: ’denominations‘. Total is to be: ’total‘.’)
V (coins, remaining) = (sorted(denominations, reverse' 1B), total)
L(n) 0 .< coins.len
   (V coinsused, remaining) = divmod(remaining, coins[n])
   I coinsused > 0
      print(‘    ’coinsused‘ * ’coins[n])
===
auto denominations = create_array({1, 2, 5, 10, 20, 50, 100, 200});
auto total = 988;

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"Available denominations: "_S & denominations & u". Total is to be: "_S & total & u"."_S);
    }
} code_block_1;

auto [coins, remaining] = make_tuple(sorted(denominations, nullptr, true), total);

struct CodeBlock2
{
    CodeBlock2()
    {
        for (auto n : range_el(0, coins.len())) {
            TUPLE_ELEMENT_T(0, divmod(remaining, coins[n])) coinsused;
            assign_from_tuple(coinsused, remaining, divmod(remaining, coins[n]));
            if (coinsused > 0)
                print(u"    "_S & coinsused & u" * "_S & coins[n]);
        }
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Find_square_difference
import itertools

for n in itertools.count(1):
    if n ** 2 - (n - 1) ** 2 > 1000:
        print(n)
        break
===
L(n) 1..
   I n ^ 2 - (n - 1) ^ 2 > 1000
      print(n)
      L.break
===
struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto n : range_ei(1))
            if (square(n) - square((n - 1)) > 1000) {
                print(n);
                break;
            }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Find_words_which_contains_all_the_vowels#Nim
for word in open('unixdict.txt').read().split("\n"):
    if len(word) > 10:
        for vowel in ('a', 'e', 'i', 'o', 'u'):
            if word.count(vowel) != 1:
                break
        else:
            print(word)
===
L(word) File(‘unixdict.txt’).read().split("\n")
   I word.len > 10
      L(vowel) (‘a’, ‘e’, ‘i’, ‘o’, ‘u’)
         I word.count(vowel) != 1
            L.break
      L.was_no_break
         print(word)
===
struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&word : File(u"unixdict.txt"_S).read().split(u"\n"_S))
            if (word.len() > 10) {
                for (auto &&vowel : make_tuple(u"a"_S, u"e"_S, u"i"_S, u"o"_S, u"u"_S))
                    if (word.count(vowel) != 1)
                        goto break_;
                print(word);
                break_:;
            }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Find_words_whose_first_and_last_three_letters_are_equal
for word in open('unixdict.txt').read().split("\n"):
    if len(word) > 5 and word[:3] == word[-3:]:
        print(word)
===
L(word) File(‘unixdict.txt’).read().split("\n")
   I word.len > 5 & word[0.<3] == word[(len)-3 ..]
      print(word)
===
struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&word : File(u"unixdict.txt"_S).read().split(u"\n"_S))
            if (word.len() > 5 && word[range_el(0, 3)] == word[range_elen_i( - 3)])
                print(word);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Fortunate_numbers#Nim
# Slow BigInt
import random, math, itertools
BigInt = int

def isProbablePrime(n, k = 10):
    if n < 2 or n % 2 == 0:
        return n == 2

    d = n - 1
    s = 0
    while d % 2 == 0:
        d //= 2
        s += 1

    assert(2 ** s * d == n - 1)

    nn : int
    if n < 0x7FFF_FFFF:
        nn = int(n)
    else:
        nn = 0x7FFF_FFFF

    for _ in range(k):
        a = random.randrange(2, nn)
        x = pow(a, d, n)
        if x == 1 or x == n - 1:
            continue
        for _ in range(s - 1):
            x = pow(x, 2, n)
            if x == 1:
                return False
            if x == n - 1:
                break # `^L.continue`
        else:
            return False

    return True

def is_prime(a):
    if a == 2: return True
    if a < 2 or a % 2 == 0: return False
    for i in range(3, int(math.sqrt(a)) + 1, 2):
        if a % i == 0:
            return False
    return True

primorial = BigInt(1)

nn = 50
lim = 75
s = set() # int
for n in itertools.count(1):
    if is_prime(n):
        primorial *= n
        m = 3
        while True:
            if isProbablePrime(primorial + m, 25):
                s.add(m)
                break
            m += 2
        lim -= 1
        if lim == 0:
            break

print('First', nn, 'fortunate numbers:')
for i, m in enumerate(sorted(list(s))[:nn]):
    print('%3d' % m, end = "\n" if (i + 1) % 10 == 0 else ' ')
===
F isProbablePrime(n, k = 10)
   I n < 2 | n % 2 == 0
      R n == 2

   V d = n - 1
   V s = 0
   L d % 2 == 0
      d I/= 2
      s++

   assert(2 ^ s * d == n - 1)

   Int nn
   I n < 7FFF'FFFF
      nn = Int(n)
   E
      nn = 7FFF'FFFF

   L(_) 0 .< k
      V a = random:(2 .< nn)
      V x = pow(a, d, n)
      I x == 1 | x == n - 1
         L.continue
      L(_) 0 .< s - 1
         x = pow(x, 2, n)
         I x == 1
            R 0B
         I x == n - 1
            L.break
      L.was_no_break
         R 0B

   R 1B

F is_prime(a)
   I a == 2
      R 1B
   I a < 2 | a % 2 == 0
      R 0B
   L(i) (3 .. Int(sqrt(a))).step(2)
      I a % i == 0
         R 0B
   R 1B

V primorial = BigInt(1)

V nn = 50
V lim = 75
V s = Set[Int]()
L(n) 1..
   I is_prime(n)
      primorial *= n
      V m = 3
      L
         I isProbablePrime(primorial + m, 25)
            s.add(m)
            L.break
         m += 2
      I --lim == 0
         L.break

print(‘First ’nn‘ fortunate numbers:’)
L(m) sorted(Array(s))[0 .< nn]
   V i = L.index
   print(‘#3’.format(m), end' I (i + 1) % 10 == 0 {"\n"} E ‘ ’)
===
template <typename T1, typename T2 = decltype(10)> auto isProbablePrime(const T1 &n, const T2 &k = 10)
{
    if (n < 2 || mod(n, 2) == 0)
        return n == 2;

    auto d = n - 1;
    auto s = 0;
    while (mod(d, 2) == 0) {
        d = idiv(d, 2);
        s++;
    }

    assert(pow(2, s) * d == n - 1);

    int nn;
    if (n < 0x7FFF'FFFF)
        nn = to_int(n);
    else
        nn = 0x7FFF'FFFF;

    for (auto _ : range_el(0, k)) {
        auto a = randomns::_(range_el(2, nn));
        auto x = pow(a, d, n);
        if (x == 1 || x == n - 1)
            continue;
        for (auto _ : range_el(0, s - 1)) {
            x = pow(x, 2, n);
            if (x == 1)
                return false;
            if (x == n - 1)
                goto break_;
        }
        return false;
        break_:;
    }

    return true;
}

template <typename T1> auto is_prime(const T1 &a)
{
    if (a == 2)
        return true;
    if (a < 2 || mod(a, 2) == 0)
        return false;
    for (auto i : range_ee(3, to_int(sqrt(a))).step(2))
        if (mod(a, i) == 0)
            return false;
    return true;
}

auto primorial = BigInt(1);

auto nn = 50;
auto lim = 75;
auto s = Set<int>();

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto n : range_ei(1))
            if (is_prime(n)) {
                primorial *= n;
                auto m = 3;
                while (true) {
                    if (isProbablePrime(primorial + m, 25)) {
                        s.add(m);
                        break;
                    }
                    m += 2;
                }
                if (--lim == 0)
                    break;
            }

        print(u"First "_S & nn & u" fortunate numbers:"_S);
        {int Lindex = 0;
        for (auto &&m : sorted(create_array(s))[range_el(0, nn)]) {
            auto i = Lindex;
            print(u"#3"_S.format(m), mod((i + 1), 10) == 0 ? u'\n'_C : u' '_C);
            Lindex++;
        }}
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Find_prime_n_such_that_reversed_n_is_also_prime
import math

def is_prime(a):
    if a == 2: return True
    if a < 2 or a % 2 == 0: return False
    for i in range(3, int(math.sqrt(a)) + 1, 2):
        if a % i == 0:
            return False
    return True

for n in range(1, 500):
    if is_prime(n) and is_prime(int(str(n)[::-1])):
        print(n, end = ' ')
===
F is_prime(a)
   I a == 2
      R 1B
   I a < 2 | a % 2 == 0
      R 0B
   L(i) (3 .. Int(sqrt(a))).step(2)
      I a % i == 0
         R 0B
   R 1B

L(n) 1..499
   I is_prime(n) & is_prime(Int(reversed(String(n))))
      print(n, end' ‘ ’)
===
template <typename T1> auto is_prime(const T1 &a)
{
    if (a == 2)
        return true;
    if (a < 2 || mod(a, 2) == 0)
        return false;
    for (auto i : range_ee(3, to_int(sqrt(a))).step(2))
        if (mod(a, i) == 0)
            return false;
    return true;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto n : range_ee(1, 499))
            if (is_prime(n) && is_prime(to_int(reversed(String(n)))))
                print(n, u" "_S);
    }
} code_block_1;


# https://rosettacode.org/wiki/Find_Chess960_starting_position_identifier#Python
# optional, but task function depends on it as written
def validate_position(candidate: str):
    assert (
        len(candidate) == 8
    ), f"candidate position has invalid len = {len(candidate)}"

    valid_pieces = {"R": 2, "N": 2, "B": 2, "Q": 1, "K": 1}
    assert set(list(candidate)) == set(valid_pieces.keys()), f"candidate position contains invalid pieces"
    for piece_type in valid_pieces.keys():
        assert (
            candidate.count(piece_type) == valid_pieces[piece_type]
        ), f"piece type '{piece_type}' has invalid count"

    bishops_pos = [index for index,
                   value in enumerate(list(candidate)) if value == "B"]
    assert (
        bishops_pos[0] % 2 != bishops_pos[1] % 2
    ), f"candidate position has both bishops in the same color"

    assert [piece for piece in candidate if piece in "RK"] == [
        "R",
        "K",
        "R",
    ], "candidate position has K outside of RR"

def calc_position(start_pos: str):
    validate_position(start_pos)
    # step 1
    subset_step1 = [piece for piece in start_pos if piece not in "QB"]
    nights_positions = [
        index for index, value in enumerate(subset_step1) if value == "N"
    ]
    nights_table = {
        (0, 1): 0,
        (0, 2): 1,
        (0, 3): 2,
        (0, 4): 3,
        (1, 2): 4,
        (1, 3): 5,
        (1, 4): 6,
        (2, 3): 7,
        (2, 4): 8,
        (3, 4): 9,
    }
    n = nights_table[(nights_positions[0], nights_positions[1])]

    # step 2
    subset_step2 = [piece for piece in start_pos if piece != "B"]
    q = subset_step2.index("Q")

    # step 3
    dark_squares = [
        piece for index, piece in enumerate(list(start_pos)) if index in list(range(0, 9, 2))
    ]
    light_squares = [
        piece for index, piece in enumerate(list(start_pos)) if index in list(range(1, 9, 2))
    ]
    d = dark_squares.index("B")
    l = light_squares.index("B")

    return 4 * (4 * (6*n + q) + d) + l

for example in ["QNRBBNKR", "RNBQKBNR", "RQNBBKRN", "RNQBBKRN"]:
    print(f'Position: {example}; Chess960 PID= {calc_position(example)}')
===
F validate_position(String candidate)
   assert(candidate.len == 8, ‘candidate position has invalid len = ’candidate.len)

   V valid_pieces = [‘R’ = 2, ‘N’ = 2, ‘B’ = 2, ‘Q’ = 1, ‘K’ = 1]
   assert(Set(Array(candidate)) == Set(valid_pieces.keys()), ‘candidate position contains invalid pieces’)
   L(piece_type) valid_pieces.keys()
      assert(candidate.count(piece_type) == valid_pieces[piece_type], ‘piece type '’piece_type‘' has invalid count’)

   V bishops_pos = enumerate(Array(candidate)).filter((index, value) -> value == ‘B’).map((index, value) -> index)
   assert(bishops_pos[0] % 2 != bishops_pos[1] % 2, ‘candidate position has both bishops in the same color’)

   assert(candidate.filter(piece -> piece C ‘RK’) == [‘R’, ‘K’, ‘R’], ‘candidate position has K outside of RR’)

F calc_position(String start_pos)
   validate_position(start_pos)
   V subset_step1 = start_pos.filter(piece -> piece !C ‘QB’)
   V nights_positions = enumerate(subset_step1).filter((index, value) -> value == ‘N’).map((index, value) -> index)
   V nights_table = [(0, 1) = 0, (0, 2) = 1, (0, 3) = 2, (0, 4) = 3, (1, 2) = 4, (1, 3) = 5, (1, 4) = 6, (2, 3) = 7, (2, 4) = 8, (3, 4) = 9]
   V n = nights_table[(nights_positions[0], nights_positions[1])]

   V subset_step2 = start_pos.filter(piece -> piece != ‘B’)
   V q = subset_step2.index(‘Q’)

   V dark_squares = enumerate(Array(start_pos)).filter((index, piece) -> index C Array((0.<9).step(2))).map((index, piece) -> piece)
   V light_squares = enumerate(Array(start_pos)).filter((index, piece) -> index C Array((1.<9).step(2))).map((index, piece) -> piece)
   V d = dark_squares.index(‘B’)
   V l = light_squares.index(‘B’)

   R 4 * (4 * (6 * n + q) + d) + l

L(example) [‘QNRBBNKR’, ‘RNBQKBNR’, ‘RQNBBKRN’, ‘RNQBBKRN’]
   print(‘Position: ’example‘; Chess960 PID= ’calc_position(example))
===
auto validate_position(const String &candidate)
{
    assert(candidate.len() == 8, u"candidate position has invalid len = "_S & candidate.len());

    auto valid_pieces = create_dict(dict_of(u'R'_C, 2)(u'N'_C, 2)(u'B'_C, 2)(u'Q'_C, 1)(u'K'_C, 1));
    assert(create_set(create_array(candidate)) == create_set(valid_pieces.keys()), u"candidate position contains invalid pieces"_S);
    for (auto &&piece_type : valid_pieces.keys())
        assert(candidate.count(piece_type) == valid_pieces[piece_type], u"piece type '"_S & piece_type & u"' has invalid count"_S);

    auto bishops_pos = enumerate(create_array(candidate)).filter([](const auto &index, const auto &value){return value == u'B';}).map([](const auto &index, const auto &value){return index;});
    assert(mod(_get<0>(bishops_pos), 2) != mod(_get<1>(bishops_pos), 2), u"candidate position has both bishops in the same color"_S);

    assert(candidate.filter([](const auto &piece){return in(piece, u"RK"_S);}) == create_array({u'R'_C, u'K'_C, u'R'_C}), u"candidate position has K outside of RR"_S);
}

auto calc_position(const String &start_pos)
{
    validate_position(start_pos);
    auto subset_step1 = start_pos.filter([](const auto &piece){return !in(piece, u"QB"_S);});
    auto nights_positions = enumerate(subset_step1).filter([](const auto &index, const auto &value){return value == u'N';}).map([](const auto &index, const auto &value){return index;});
    auto nights_table = create_dict(dict_of(make_tuple(0, 1), 0)(make_tuple(0, 2), 1)(make_tuple(0, 3), 2)(make_tuple(0, 4), 3)(make_tuple(1, 2), 4)(make_tuple(1, 3), 5)(make_tuple(1, 4), 6)(make_tuple(2, 3), 7)(make_tuple(2, 4), 8)(make_tuple(3, 4), 9));
    auto n = nights_table[make_tuple(_get<0>(nights_positions), _get<1>(nights_positions))];

    auto subset_step2 = start_pos.filter([](const auto &piece){return piece != u'B';});
    auto q = subset_step2.index(u'Q'_C);

    auto dark_squares = enumerate(create_array(start_pos)).filter([](const auto &index, const auto &piece){return in(index, create_array(range_el(0, 9).step(2)));}).map([](const auto &index, const auto &piece){return piece;});
    auto light_squares = enumerate(create_array(start_pos)).filter([](const auto &index, const auto &piece){return in(index, create_array(range_el(1, 9).step(2)));}).map([](const auto &index, const auto &piece){return piece;});
    auto d = dark_squares.index(u'B'_C);
    auto l = light_squares.index(u'B'_C);

    return 4 * (4 * (6 * n + q) + d) + l;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&example : create_array({u"QNRBBNKR"_S, u"RNBQKBNR"_S, u"RQNBBKRN"_S, u"RNQBBKRN"_S}))
            print(u"Position: "_S & example & u"; Chess960 PID= "_S & calc_position(example));
    }
} code_block_1;


# https://rosettacode.org/wiki/Find_prime_numbers_of_the_form_n*n*n%2B2#Python
def isPrime(n):
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

for n in range(1, 200):
    if isPrime(n**3+2):
        print(f'{n}\t{n**3+2}');
===
F isPrime(n)
   L(i) 2 .. Int(n ^ 0.5)
      I n % i == 0
         R 0B
   R 1B

L(n) 1..199
   I isPrime(n ^ 3 + 2)
      print(n"\t"(n ^ 3 + 2))
===
template <typename T1> auto isPrime(const T1 &n)
{
    for (auto i : range_ee(2, to_int(pow(n, 0.5))))
        if (mod(n, i) == 0)
            return false;
    return true;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto n : range_ee(1, 199))
            if (isPrime(cube(n) + 2))
                print(n & u"\t"_S & (cube(n) + 2));
    }
} code_block_1;


# https://rosettacode.org/wiki/Find_words_which_contain_the_most_consonants#Python
import re, collections
from typing import DefaultDict, List

lines = open('unixdict.txt').read().split("\n")

# keep only lines that's long enough and has no non-letters
words = [w for w in lines if len(w) > 10 and not re.match(r'[^a-z]', w)]

good : DefaultDict[int, List[str]] = collections.defaultdict(list)
for word in words:
    # take all consonants in word
    c = re.sub(r'[aeiou]', '', word)

    # check if there are duplicates
    if sorted(list(c)) == sorted(list(set(list(c)))):
        good[len(c)].append(word)

for k, v in sorted(good.items(), reverse=True):
    if len(v) > 30:
        print(f'{k}: {len(v)} words')
    else:
        print(f'{k}:', ' '.join(sorted(v)))
===
V lines = File(‘unixdict.txt’).read().split("\n")

V words = lines.filter(w -> w.len > 10 & !re:‘^[^a-z]’.search(w))

DefaultDict[Int, [String]] good
L(word) words
   V c = word.replace(re:‘[aeiou]’, ‘’)

   I sorted(Array(c)) == sorted(Array(Set(Array(c))))
      good[c.len].append(word)

L(k, v) sorted(good.items(), reverse' 1B)
   I v.len > 30
      print(k‘: ’v.len‘ words’)
   E
      print((k‘:’)‘ ’sorted(v).join(‘ ’))
===
auto lines = File(u"unixdict.txt"_S).read().split(u"\n"_S);

auto words = lines.filter([](const auto &w){return w.len() > 10 && !re::_(u"^[^a-z]"_S).search(w);});

DefaultDict<int, Array<String>> good;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&word : words) {
            auto c = word.replace(re::_(u"[aeiou]"_S), u""_S);

            if (sorted(create_array(c)) == sorted(create_array(create_set(create_array(c)))))
                good[c.len()].append(word);
        }

        for (auto &&[k, v] : sorted(good.items(), nullptr, true))
            if (v.len() > 30)
                print(k & u": "_S & v.len() & u" words"_S);
            else
                print((k & u":"_S) & u" "_S & sorted(v).join(u" "_S));
    }
} code_block_1;


# https://rosettacode.org/wiki/First_9_prime_Fibonacci_number#Python
import math
Int64 = int

def prime(x):
    if x < 2:
        return False
    if x == 2 or x == 3:
        return True
    if x % 2 == 0:
        return False
    for i in range(3, int(math.sqrt(x)) + 1, 2):
        if x % i == 0:
            return False
    return True

n = 11
fibn = 3
a, b = Int64(1), Int64(1)
while n > 0:
    a, b = b, a + b
    if prime(b):
        print("fib(%d): %d" % (fibn, b))
        n -= 1
    fibn += 1
===
F prime(x)
   I x < 2
      R 0B
   I x == 2 | x == 3
      R 1B
   I x % 2 == 0
      R 0B
   L(i) (3 .. Int(sqrt(x))).step(2)
      I x % i == 0
         R 0B
   R 1B

V n = 11
V fibn = 3
V (a, b) = (Int64(1), Int64(1))
L n > 0
   (a, b) = (b, a + b)
   I prime(b)
      print(‘fib(#.): #.’.format(fibn, b))
      n--
   fibn++
===
template <typename T1> auto prime(const T1 &x)
{
    if (x < 2)
        return false;
    if (x == 2 || x == 3)
        return true;
    if (mod(x, 2) == 0)
        return false;
    for (auto i : range_ee(3, to_int(sqrt(x))).step(2))
        if (mod(x, i) == 0)
            return false;
    return true;
}

auto n = 11;
auto fibn = 3;
auto [a, b] = make_tuple(to_int64(1), to_int64(1));

struct CodeBlock1
{
    CodeBlock1()
    {
        while (n > 0) {
            assign_from_tuple(a, b, make_tuple(b, a + b));
            if (prime(b)) {
                print(u"fib(#.): #."_S.format(fibn, b));
                n--;
            }
            fibn++;
        }
    }
} code_block_1;


# https://rosettacode.org/wiki/Four_sides_of_square#Python
size = 9
for row in range(size):
    for col in range(size):
        if row == 0 or row == size-1 or col == 0 or col == size-1:
            print("1", end=" ")
        else:
            print("0", end=" ")
    print()
===
V size = 9
L(row) 0 .< size
   L(col) 0 .< size
      I row == 0 | row == size - 1 | col == 0 | col == size - 1
         print(‘1’, end' ‘ ’)
      E
         print(‘0’, end' ‘ ’)
   print()
===
auto size = 9;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto row : range_el(0, size)) {
            for (auto col : range_el(0, size))
                if (row == 0 || row == size - 1 || col == 0 || col == size - 1)
                    print(u"1"_S, u" "_S);
                else
                    print(u"0"_S, u" "_S);
            print();
        }
    }
} code_block_1;