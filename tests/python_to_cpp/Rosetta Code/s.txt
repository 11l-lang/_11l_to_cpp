# https://www.rosettacode.org/wiki/Sailors,_coconuts_and_a_monkey_problem#Python
def monkey_coconuts(sailors = 5):
    nuts = sailors
    while True:
        n0 = nuts
        wakes : List[Tuple[int, int, int]] = []
        for sailor in range(sailors + 1):
            (portion, remainder) = divmod(n0, sailors)
            wakes.append((n0, portion, remainder))
            if portion <= 0 or remainder != (1 if sailor != sailors else 0):
                nuts += 1
                break
            n0 = n0 - portion - remainder
        else:
            return (nuts, wakes)

for sailors in [5, 6]:
    (nuts, wake_stats) = monkey_coconuts(sailors)
    print("\nFor %i sailors the initial nut count is %i" % (sailors, nuts))
    print("On each waking, the nut count, portion taken, and monkeys share are:\n ",
              ",\n  ".join(str(ws) for ws in wake_stats))
===
F monkey_coconuts(sailors = 5)
   V nuts = sailors
   L
      V n0 = nuts
      [(Int, Int, Int)] wakes
      L(sailor) 0 .. sailors
         V (portion, remainder) = divmod(n0, sailors)
         wakes.append((n0, portion, remainder))
         I portion <= 0 | remainder != (I sailor != sailors {1} E 0)
            nuts++
            L.break
         n0 = n0 - portion - remainder
      L.was_no_break
         R (nuts, wakes)

L(sailors) [5, 6]
   V (nuts, wake_stats) = monkey_coconuts(sailors)
   print("\nFor #. sailors the initial nut count is #.".format(sailors, nuts))
   print("On each waking, the nut count, portion taken, and monkeys share are:\n  "wake_stats.map(ws -> String(ws)).join(",\n  "))
===
template <typename T1 = decltype(5)> auto monkey_coconuts(const T1 &sailors = 5)
{
    auto nuts = sailors;
    while (true) {
        auto n0 = nuts;
        Array<ivec3> wakes;
        for (auto sailor : range_ee(0, sailors)) {
            auto [portion, remainder] = divmod(n0, sailors);
            wakes.append(make_tuple(n0, portion, remainder));
            if (portion <= 0 || remainder != (sailor != sailors ? 1 : 0)) {
                nuts++;
                goto break_;
            }
            n0 = n0 - portion - remainder;
        }
        return make_tuple(nuts, wakes);
        break_:;
    }
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&sailors : create_array({5, 6})) {
            auto [nuts, wake_stats] = monkey_coconuts(sailors);
            print(u"\nFor #. sailors the initial nut count is #."_S.format(sailors, nuts));
            print(u"On each waking, the nut count, portion taken, and monkeys share are:\n  "_S & wake_stats.map([](const auto &ws){return String(ws);}).join(u",\n  "_S));
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Sattolo_cycle#Python
import random

def sattolo_cycle(items : list):
    for i in range(len(items) - 1, 0, -1):
        j = random.randrange(i)
        (items[j], items[i]) = (items[i], items[j])

for _ in range(3):
    lst = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    sattolo_cycle(lst)
    print(lst)
===
F sattolo_cycle(&items)
   L(i) (items.len - 1 .< 0).step(-1)
      V j = random:(i)
      swap(&items[j], &items[i])

L(_) 3
   V lst = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
   sattolo_cycle(&lst)
   print(lst)
===
template <typename T1> auto sattolo_cycle(T1 &items)
{
    for (auto i : range_el(items.len() - 1, 0).step(-1)) {
        auto j = randomns::_(i);
        swap(items[j], items[i]);
    }
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (int _ = 0; _ < 3; _++) {
            auto lst = create_array({1, 2, 3, 4, 5, 6, 7, 8, 9, 10});
            sattolo_cycle(lst);
            print(lst);
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Scope_modifiers#Python
x = "From global scope"

def outerfunc():
    x = "From scope at outerfunc"

    def scoped_local():
        x = "scope local"
        return "scoped_local scope gives x = " + x
    print(scoped_local())

    def scoped_nonlocal():
        nonlocal x
        return "scoped_nonlocal scope gives x = " + x
    print(scoped_nonlocal())

    def scoped_global():
        global x
        return "scoped_global scope gives x = " + x
    print(scoped_global())

outerfunc()
===
V x = ‘From global scope’

F outerfunc()
   V x = ‘From scope at outerfunc’

   F scoped_local()
      V x = ‘scope local’
      R ‘scoped_local scope gives x = ’x
   print(scoped_local())

   F scoped_nonlocal()
      R ‘scoped_nonlocal scope gives x = ’@x
   print(scoped_nonlocal())

   F scoped_global()
      R ‘scoped_global scope gives x = ’:x
   print(scoped_global())

outerfunc()
===
auto x = u"From global scope"_S;

auto outerfunc()
{
    auto x = u"From scope at outerfunc"_S;

    auto scoped_local = []()
    {
        auto x = u"scope local"_S;
        return u"scoped_local scope gives x = "_S & x;
    };
    print(scoped_local());

    auto scoped_nonlocal = [&x]()
    {
        return u"scoped_nonlocal scope gives x = "_S & x;
    };
    print(scoped_nonlocal());

    auto scoped_global = []()
    {
        return u"scoped_global scope gives x = "_S & ::x;
    };
    print(scoped_global());
}

struct CodeBlock1
{
    CodeBlock1()
    {
        outerfunc();
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Search_a_list#Python
haystack=["Zig","Zag","Wally","Ronald","Bush","Krusty","Charlie","Bush","Bozo"]

for needle in ("Washington","Bush"):
  try:
    print(haystack.index(needle), needle)
  except ValueError:
    print (needle,"is not in haystack")
===
V haystack = [‘Zig’, ‘Zag’, ‘Wally’, ‘Ronald’, ‘Bush’, ‘Krusty’, ‘Charlie’, ‘Bush’, ‘Bozo’]

L(needle) (‘Washington’, ‘Bush’)
   X.try
      print(haystack.index(needle)‘ ’needle)
   X.catch ValueError
      print(needle‘ is not in haystack’)
===
auto haystack = create_array({u"Zig"_S, u"Zag"_S, u"Wally"_S, u"Ronald"_S, u"Bush"_S, u"Krusty"_S, u"Charlie"_S, u"Bush"_S, u"Bozo"_S});

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&needle : make_tuple(u"Washington"_S, u"Bush"_S)) {
            try
            {
                print(haystack.index(needle) & u" "_S & needle);
            }
            catch (const ValueError&)
            {
                print(needle & u" is not in haystack"_S);
            }
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Search_a_list_of_records
class City:
    name : str
    population : float

    def __init__(self, name, population):
        self.name = name
        self.population = population

cities = [
        City("Lagos", 21),
        City("Cairo", 15.2),
        City("Kinshasa-Brazzaville", 11.3),
        City("Greater Johannesburg", 7.55),
        City("Mogadishu", 5.85),
        City("Khartoum-Omdurman", 4.98),
        City("Dar Es Salaam", 4.7),
        City("Alexandria", 4.58),
        City("Abidjan", 4.4),
        City("Casablanca", 3.98)
    ]

def first_index(cities, condition):
    for index, city in enumerate(cities):
        if condition(city):
            return index

def first(cities, condition):
    for city in cities:
        if condition(city):
            return city

print(first_index(cities, lambda city: city.name == "Dar Es Salaam"))
print(first(cities, lambda city: city.population < 5.0).name)
print(first(cities, lambda city: city.name[0] == 'A').population)
===
T City
   String name
   Float population

   F (name, population)
      .name = name
      .population = population

V cities = [City(‘Lagos’, 21), City(‘Cairo’, 15.2), City(‘Kinshasa-Brazzaville’, 11.3), City(‘Greater Johannesburg’, 7.55), City(‘Mogadishu’, 5.85), City(‘Khartoum-Omdurman’, 4.98), City(‘Dar Es Salaam’, 4.7), City(‘Alexandria’, 4.58), City(‘Abidjan’, 4.4), City(‘Casablanca’, 3.98)]

F first_index(cities, condition)
   L(city) cities
      V index = L.index
      I condition(city)
         R index

F first(cities, condition)
   L(city) cities
      I condition(city)
         R city

print(first_index(cities, city -> city.name == ‘Dar Es Salaam’))
print(first(cities, city -> city.population < 5.0).name)
print(first(cities, city -> city.name[0] == ‘A’).population)
===
class City
{
public:
    String name;
    double population;

    template <typename T1, typename T2> City(const T1 &name, const T2 &population) :
        name(name),
        population(population)
    {
    }
};

auto cities = create_array<City>({City(u"Lagos"_S, 21), City(u"Cairo"_S, 15.2), City(u"Kinshasa-Brazzaville"_S, 11.3), City(u"Greater Johannesburg"_S, 7.55), City(u"Mogadishu"_S, 5.85), City(u"Khartoum-Omdurman"_S, 4.98), City(u"Dar Es Salaam"_S, 4.7), City(u"Alexandria"_S, 4.58), City(u"Abidjan"_S, 4.4), City(u"Casablanca"_S, 3.98)});

template <typename T1, typename T2> auto first_index(const T1 &cities, const T2 &condition)
{
    {int Lindex = 0;
    for (auto &&city : cities) {
        auto index = Lindex;
        if (condition(city))
            return index;
        Lindex++;
    }}
}

template <typename T1, typename T2> auto first(const T1 &cities, const T2 &condition)
{
    for (auto &&city : cities)
        if (condition(city))
            return city;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(first_index(cities, [](const auto &city){return city.name == u"Dar Es Salaam";}));
        print(first(cities, [](const auto &city){return city.population < 5.0;}).name);
        print(first(cities, [](const auto &city){return _get<0>(city.name) == u'A';}).population);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/SEDOLs#Python
def char2value(c):
  assert c not in 'AEIOU', "No vowels"
  return int(c, 36)

sedolweight = [1,3,1,7,3,9]

def checksum(sedol):
    tmp = sum(char2value(ch) * weight for ch, weight in
                  zip(sedol, sedolweight)
               )
    return str((10 - (tmp % 10)) % 10)

sedols = \
'''710889
B0YBKJ
406566
B0YBLH
228276
B0YBKL
557910
B0YBKR
585284
B0YBKT'''

for sedol in sedols.split("\n"):
    print(sedol + '' + checksum(sedol))
===
F char2value(c)
   assert(c !C ‘AEIOU’, ‘No vowels’)
   R Int(c, radix' 36)

V sedolweight = [1, 3, 1, 7, 3, 9]

F checksum(sedol)
   V tmp = sum(zip(sedol, :sedolweight).map((ch, weight) -> char2value(ch) * weight))
   R String((10 - (tmp % 10)) % 10)

V sedols = ‘710889
B0YBKJ
406566
B0YBLH
228276
B0YBKL
557910
B0YBKR
585284
B0YBKT’

L(sedol) sedols.split("\n")
   print(sedol‘’checksum(sedol))
===
template <typename T1> auto char2value(const T1 &c)
{
    assert(!in(c, u"AEIOU"_S), u"No vowels"_S);
    return to_int(c, 36);
}

auto sedolweight = create_array({1, 3, 1, 7, 3, 9});

template <typename T1> auto checksum(const T1 &sedol)
{
    auto tmp = sum_map(zip(sedol, ::sedolweight), [](const auto &ch, const auto &weight){return char2value(ch) * weight;});
    return String(mod((10 - (mod(tmp, 10))), 10));
}

auto sedols = uR"(710889
B0YBKJ
406566
B0YBLH
228276
B0YBKL
557910
B0YBKR
585284
B0YBKT)"_S;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&sedol : sedols.split(u"\n"_S))
            print(sedol & checksum(sedol));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Self-describing_numbers#Python
def is_self_describing(n):
    s = str(n)
    return all(s.count(str(i)) == int(ch) for i, ch in enumerate(list(s)))

print([x for x in range(4000000) if is_self_describing(x)])
===
F is_self_describing(n)
   V s = String(n)
   R all(enumerate(Array(s)).map((i, ch) -> @s.count(String(i)) == Int(ch)))

print((0.<4000000).filter(x -> is_self_describing(x)))
===
template <typename T1> auto is_self_describing(const T1 &n)
{
    auto s = String(n);
    return all_map(enumerate(create_array(s)), [&s](const auto &i, const auto &ch){return s.count(String(i)) == to_int(ch);});
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(range_el(0, 4000000).filter([](const auto &x){return is_self_describing(x);}));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Semiprime#C.2B.2B
def is_semiprime(c):
    a = 2
    b = 0
    while b < 3 and c != 1:
        if c % a == 0:
            c /= a
            b += 1
        else:
            a += 1
    return b == 2

print([n for n in range(1, 101) if is_semiprime(n)])
===
F is_semiprime(=c)
   V a = 2
   V b = 0
   L b < 3 & c != 1
      I c % a == 0
         c /= a
         b++
      E
         a++
   R b == 2

print((1..100).filter(n -> is_semiprime(n)))
===
template <typename T1> auto is_semiprime(T1 c)
{
    auto a = 2;
    auto b = 0;
    while (b < 3 && c != 1)
        if (mod(c, a) == 0) {
            c /= a;
            b++;
        }
        else
            a++;
    return b == 2;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(range_ee(1, 100).filter([](const auto &n){return is_semiprime(n);}));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Sequence_of_non-squares#Python
import math

def non_square(n : int):
    return n + int(math.floor(1/2 + math.sqrt(n)))

print(*map(non_square, range(1, 23)))

def is_square(n):
    return math.sqrt(n).is_integer()

for i in range(1, 10 ** 6):
    if is_square(non_square(i)):
        print('Square found', i)
        break
else:
    print('No squares found')
===
F non_square(Int n)
   R n + Int(floor(1 / 2 + sqrt(n)))

print_elements((1..22).map(non_square))

F is_square(n)
   R fract(sqrt(n)) == 0

L(i) 1 .< 10 ^ 6
   I is_square(non_square(i))
      print(‘Square found ’i)
      L.break
L.was_no_break
   print(‘No squares found’)
===
auto non_square(const int n)
{
    return n + to_int(floor(1.0 / 2 + sqrt(n)));
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print_elements(range_ee(1, 22).map(non_square));
    }
} code_block_1;

template <typename T1> auto is_square(const T1 &n)
{
    return fract(sqrt(n)) == 0;
}

struct CodeBlock2
{
    CodeBlock2()
    {
        for (auto i : range_el(1, pow(10, 6)))
            if (is_square(non_square(i))) {
                print(u"Square found "_S & i);
                goto break_;
            }
        print(u"No squares found"_S);
        break_:;
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Sequence_of_primes_by_trial_division#Python
def prime(a):
    return not (a < 2 or any(a % x == 0 for x in range(2, int(a**0.5) + 1)))

def primes_below(n):
    return [i for i in range(n) if prime(i)]

print(primes_below(100))
===
F prime(a)
   R !(a < 2 | any((2 .. Int(a ^ 0.5)).map(x -> @a % x == 0)))

F primes_below(n)
   R (0 .< n).filter(i -> prime(i))

print(primes_below(100))
===
template <typename T1> auto prime(const T1 &a)
{
    return !(a < 2 || any_map(range_ee(2, to_int(pow(a, 0.5))), [&a](const auto &x){return mod(a, x) == 0;}));
}

template <typename T1> auto primes_below(const T1 &n)
{
    return range_el(0, n).filter([](const auto &i){return prime(i);});
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(primes_below(100));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Sequence:_smallest_number_greater_than_previous_term_with_exactly_n_divisors#Python
def divisors(n):
    divs = [1]
    for ii in range(2, int(n ** 0.5) + 3):
        if n % ii == 0:
            divs.append(ii)
            divs.append(int(n / ii))
    divs.append(n)
    return list(set(divs))

def sequence(max_n):
    previous = 0
    n = 0
    r : List[int] = []
    while True:
        n += 1
        ii = previous
        if n > max_n:
            break
        while True:
            ii += 1
            if len(divisors(ii)) == n:
                r.append(ii)
                previous = ii
                break
    return r

for item in sequence(15):
    print(item)
===
F divisors(n)
   V divs = [1]
   L(ii) 2 .< Int(n ^ 0.5) + 3
      I n % ii == 0
         divs.append(ii)
         divs.append(Int(n / ii))
   divs.append(n)
   R Array(Set(divs))

F sequence(max_n)
   V previous = 0
   V n = 0
   [Int] r
   L
      n++
      V ii = previous
      I n > max_n
         L.break
      L
         ii++
         I divisors(ii).len == n
            r.append(ii)
            previous = ii
            L.break
   R r

L(item) sequence(15)
   print(item)
===
template <typename T1> auto divisors(const T1 &n)
{
    auto divs = create_array({1});
    for (auto ii : range_el(2, to_int(pow(n, 0.5)) + 3))
        if (mod(n, ii) == 0) {
            divs.append(ii);
            divs.append(to_int(n / ii));
        }
    divs.append(n);
    return create_array(create_set(divs));
}

template <typename T1> auto sequence(const T1 &max_n)
{
    auto previous = 0;
    auto n = 0;
    Array<int> r;
    while (true) {
        n++;
        auto ii = previous;
        if (n > max_n)
            break;
        while (true) {
            ii++;
            if (divisors(ii).len() == n) {
                r.append(ii);
                previous = ii;
                break;
            }
        }
    }
    return r;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&item : sequence(15))
            print(item);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Sequence:_smallest_number_with_exactly_n_divisors#Python
def divisors(n):
    divs = [1]
    for ii in range(2, int(n ** 0.5) + 3):
        if n % ii == 0:
            divs.append(ii)
            divs.append(int(n / ii))
    divs.append(n)
    return list(set(divs))

def sequence(max_n):
    n = 0
    r : List[int] = []
    while True:
        n += 1
        ii = 0
        if n > max_n:
            break
        while True:
            ii += 1
            if len(divisors(ii)) == n:
                r.append(ii)
                break
    return r

for item in sequence(15):
    print(item)
===
F divisors(n)
   V divs = [1]
   L(ii) 2 .< Int(n ^ 0.5) + 3
      I n % ii == 0
         divs.append(ii)
         divs.append(Int(n / ii))
   divs.append(n)
   R Array(Set(divs))

F sequence(max_n)
   V n = 0
   [Int] r
   L
      n++
      V ii = 0
      I n > max_n
         L.break
      L
         ii++
         I divisors(ii).len == n
            r.append(ii)
            L.break
   R r

L(item) sequence(15)
   print(item)
===
template <typename T1> auto divisors(const T1 &n)
{
    auto divs = create_array({1});
    for (auto ii : range_el(2, to_int(pow(n, 0.5)) + 3))
        if (mod(n, ii) == 0) {
            divs.append(ii);
            divs.append(to_int(n / ii));
        }
    divs.append(n);
    return create_array(create_set(divs));
}

template <typename T1> auto sequence(const T1 &max_n)
{
    auto n = 0;
    Array<int> r;
    while (true) {
        n++;
        auto ii = 0;
        if (n > max_n)
            break;
        while (true) {
            ii++;
            if (divisors(ii).len() == n) {
                r.append(ii);
                break;
            }
        }
    }
    return r;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&item : sequence(15))
            print(item);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Shoelace_formula_for_polygonal_area#Python
def area_by_shoelace(x, y):
    return abs( sum(i * j for i, j in zip(x,             y[1:] + y[:1]))
               -sum(i * j for i, j in zip(x[1:] + x[:1], y            ))) / 2

points = [(3,4), (5,11), (12,8), (9,5), (5,6)]
x = [p[0] for p in points]
y = [p[1] for p in points]

print(area_by_shoelace(x, y))
===
F area_by_shoelace(x, y)
   R abs(sum(zip(x, y[1..] + y[0.<1]).map((i, j) -> i * j)) - sum(zip(x[1..] + x[0.<1], y).map((i, j) -> i * j))) / 2

V points = [(3, 4), (5, 11), (12, 8), (9, 5), (5, 6)]
V x = points.map(p -> p[0])
V y = points.map(p -> p[1])

print(area_by_shoelace(x, y))
===
template <typename T1, typename T2> auto area_by_shoelace(const T1 &x, const T2 &y)
{
    return abs(sum_map(zip(x, y[range_ei(1)] + y[range_el(0, 1)]), [](const auto &i, const auto &j){return i * j;}) - sum_map(zip(x[range_ei(1)] + x[range_el(0, 1)], y), [](const auto &i, const auto &j){return i * j;})) / 2.0;
}

auto points = create_array({make_tuple(3, 4), make_tuple(5, 11), make_tuple(12, 8), make_tuple(9, 5), make_tuple(5, 6)});
auto x = points.map([](const auto &p){return _get<0>(p);});
auto y = points.map([](const auto &p){return _get<1>(p);});

struct CodeBlock1
{
    CodeBlock1()
    {
        print(area_by_shoelace(x, y));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Short-circuit_evaluation#Python
def a(v):
    print("  # Called function a(%s)" % v)
    return v

def b(v):
    print("  # Called function b(%s)" % v)
    return v

for i in (False, True):
    for j in (False, True):
        print("\nCalculating: x = a(i) and b(j)")
        x = a(i) and b(j)
        print("Calculating: y = a(i) or  b(j)")
        y = a(i) or  b(j)
===
F a(v)
   print(‘  # Called function a(#.)’.format(v))
   R v

F b(v)
   print(‘  # Called function b(#.)’.format(v))
   R v

L(i) (0B, 1B)
   L(j) (0B, 1B)
      print("\nCalculating: x = a(i) and b(j)")
      V x = a(i) & b(j)
      print(‘Calculating: y = a(i) or  b(j)’)
      V y = a(i) | b(j)
===
template <typename T1> auto a(const T1 &v)
{
    print(u"  # Called function a(#.)"_S.format(v));
    return v;
}

template <typename T1> auto b(const T1 &v)
{
    print(u"  # Called function b(#.)"_S.format(v));
    return v;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&i : make_tuple(false, true))
            for (auto &&j : make_tuple(false, true)) {
                print(u"\nCalculating: x = a(i) and b(j)"_S);
                auto x = a(i) && b(j);
                print(u"Calculating: y = a(i) or  b(j)"_S);
                auto y = a(i) || b(j);
            }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Shortest_common_supersequence#C.2B.2B
def scs(x : str, y : str):
    if len(x) == 0:
        return y
    if len(y) == 0:
        return x
    if x[0] == y[0]:
        return x[0] + scs(x[1:], y[1:])
    if len(scs(x, y[1:])) <= len(scs(x[1:], y)):
        return y[0] + scs(x, y[1:])
    else:
        return x[0] + scs(x[1:], y)

print(scs('abcbdab', 'bdcaba'))
===
F scs(String x, String y)
   I x.empty
      R y
   I y.empty
      R x
   I x[0] == y[0]
      R x[0]‘’scs(x[1..], y[1..])
   I scs(x, y[1..]).len <= scs(x[1..], y).len
      R y[0]‘’scs(x, y[1..])
   E
      R x[0]‘’scs(x[1..], y)

print(scs(‘abcbdab’, ‘bdcaba’))
===
auto scs(const String &x, const String &y)
{
    if (x.empty())
        return y;
    if (y.empty())
        return x;
    if (_get<0>(x) == _get<0>(y))
        return _get<0>(x) & scs(x[range_ei(1)], y[range_ei(1)]);
    if (scs(x, y[range_ei(1)]).len() <= scs(x[range_ei(1)], y).len())
        return _get<0>(y) & scs(x, y[range_ei(1)]);
    else
        return _get<0>(x) & scs(x[range_ei(1)], y);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(scs(u"abcbdab"_S, u"bdcaba"_S));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Show_ASCII_table#Python
for i in range(16):
    for j in range(32+i, 127+1, 16):
        k : str
        if j == 32:
            k = 'Spc'
        elif j == 127:
            k = 'Del'
        else:
            k = chr(j)
        print("%3d : %-3s" % (j,k), end="")
    print()
===
L(i) 16
   L(j) (32 + i .. 127).step(16)
      String k
      I j == 32
         k = ‘Spc’
      E I j == 127
         k = ‘Del’
      E
         k = Char(code' j)
      print(‘#3 : #<3’.format(j, k), end' ‘’)
   print()
===
struct CodeBlock1
{
    CodeBlock1()
    {
        for (int i = 0; i < 16; i++) {
            for (auto j : range_ee(32 + i, 127).step(16)) {
                String k;
                if (j == 32)
                    k = u"Spc"_S;
                else if (j == 127)
                    k = u"Del"_S;
                else
                    k = Char(j);
                print(u"#3 : #<3"_S.format(j, k), u""_S);
            }
            print();
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Sierpinski_carpet#Python
def sierpinski_carpet(n):
  carpet = [str("#")]
  for i in range(n):
    carpet = [x + '' + x + '' + x for x in carpet] + \
             [x + '' + x.replace("#"," ") + '' + x for x in carpet] + \
             [x + '' + x + '' + x for x in carpet]
  return "\n".join(carpet)

print(sierpinski_carpet(3))
===
F sierpinski_carpet(n)
   V carpet = [String(‘#’)]
   L(i) 0 .< n
      carpet = carpet.map(x -> x‘’x‘’x) [+] carpet.map(x -> x‘’x.replace(‘#’, ‘ ’)‘’x) [+] carpet.map(x -> x‘’x‘’x)
   R carpet.join("\n")

print(sierpinski_carpet(3))
===
template <typename T1> auto sierpinski_carpet(const T1 &n)
{
    auto carpet = create_array({String(u"#"_S)});
    for (auto i : range_el(0, n))
        carpet = carpet.map([](const auto &x){return x & x & x;}) + carpet.map([](const auto &x){return x & x.replace(u"#"_S, u" "_S) & x;}) + carpet.map([](const auto &x){return x & x & x;});
    return carpet.join(u"\n"_S);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(sierpinski_carpet(3));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Sierpinski_triangle#Python
def sierpinski(n):
    d = [str("*")]
    for i in range(n):
        sp = " " * (2 ** i)
        d = [sp+''+x+''+sp for x in d] + [x+" "+x for x in d]
    return d

print("\n".join(sierpinski(4)))
===
F sierpinski(n)
   V d = [String(‘*’)]
   L(i) 0 .< n
      V sp = ‘ ’ * (2 ^ i)
      d = d.map(x -> @sp‘’x‘’@sp) [+] d.map(x -> x‘ ’x)
   R d

print(sierpinski(4).join("\n"))
===
template <typename T1> auto sierpinski(const T1 &n)
{
    auto d = create_array({String(u"*"_S)});
    for (auto i : range_el(0, n)) {
        auto sp = u" "_S * (pow(2, i));
        d = d.map([&sp](const auto &x){return sp & x & sp;}) + d.map([](const auto &x){return x & u" "_S & x;});
    }
    return d;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(sierpinski(4).join(u"\n"_S));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Sieve_of_Eratosthenes#Python
def primes_upto(limit):
    is_prime = [False] * 2 + [True] * (limit - 1)
    for n in range(int(limit**0.5 + 1.5)): # stop at ``sqrt(limit)``
        if is_prime[n]:
            for i in range(n*n, limit+1, n):
                is_prime[i] = False
    return [i for i, prime in enumerate(is_prime) if prime]

print(primes_upto(100))
===
F primes_upto(limit)
   V is_prime = [0B] * 2 [+] [1B] * (limit - 1)
   L(n) 0 .< Int(limit ^ 0.5 + 1.5)
      I is_prime[n]
         L(i) (n * n .. limit).step(n)
            is_prime[i] = 0B
   R enumerate(is_prime).filter((i, prime) -> prime).map((i, prime) -> i)

print(primes_upto(100))
===
template <typename T1> auto primes_upto(const T1 &limit)
{
    auto is_prime = create_array({false}) * 2 + create_array({true}) * (limit - 1);
    for (auto n : range_el(0, to_int(pow(limit, 0.5) + 1.5)))
        if (is_prime[n])
            for (auto i : range_ee(n * n, limit).step(n))
                is_prime.set(i, false);
    return enumerate(is_prime).filter([](const auto &i, const auto &prime){return prime;}).map([](const auto &i, const auto &prime){return i;});
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(primes_upto(100));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Sleep#Python
import time

seconds = float(input())
print("Sleeping...")
time.sleep(seconds) # number is in seconds ... but accepts fractions
print("Awake!")
===
V seconds = Float(input())
print(‘Sleeping...’)
sleep(seconds)
print(‘Awake!’)
===
auto seconds = to_float(input());

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"Sleeping..."_S);
        sleep(seconds);
        print(u"Awake!"_S);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Smarandache_prime-digital_sequence#Python
def divisors(n):
    divs = [1]
    for ii in range(2, int(n ** 0.5) + 3):
        if n % ii == 0:
            divs.append(ii)
            divs.append(int(n / ii))
    divs.append(n)
    return list(set(divs))

def is_prime(n):
    return len(divisors(n)) == 2

def digit_check(n):
    if len(str(n))<2:
        return True
    else:
        for digit in str(n):
            if not is_prime(int(digit)):
                return False
        return True

def sequence(max_n):
    ii = 0
    n = 0
    r : List[int] = []
    while True:
        ii += 1
        if is_prime(ii):
            if n>max_n:
                break
            if digit_check(ii):
                n += 1
                r.append(ii)
    return r

seq = sequence(100)
print('First 25 SPDS primes:')
for item in seq[:25]:
    print(item, end = ' ')
print()
print('Hundredth SPDS prime:', seq[99])
===
F divisors(n)
   V divs = [1]
   L(ii) 2 .< Int(n ^ 0.5) + 3
      I n % ii == 0
         divs.append(ii)
         divs.append(Int(n / ii))
   divs.append(n)
   R Array(Set(divs))

F is_prime(n)
   R divisors(n).len == 2

F digit_check(n)
   I String(n).len < 2
      R 1B
   E
      L(digit) String(n)
         I !is_prime(Int(digit))
            R 0B
      R 1B

F sequence(max_n)
   V ii = 0
   V n = 0
   [Int] r
   L
      ii++
      I is_prime(ii)
         I n > max_n
            L.break
         I digit_check(ii)
            n++
            r.append(ii)
   R r

V seq = sequence(100)
print(‘First 25 SPDS primes:’)
L(item) seq[0.<25]
   print(item, end' ‘ ’)
print()
print(‘Hundredth SPDS prime: ’seq[99])
===
template <typename T1> auto divisors(const T1 &n)
{
    auto divs = create_array({1});
    for (auto ii : range_el(2, to_int(pow(n, 0.5)) + 3))
        if (mod(n, ii) == 0) {
            divs.append(ii);
            divs.append(to_int(n / ii));
        }
    divs.append(n);
    return create_array(create_set(divs));
}

template <typename T1> auto is_prime(const T1 &n)
{
    return divisors(n).len() == 2;
}

template <typename T1> auto digit_check(const T1 &n)
{
    if (String(n).len() < 2)
        return true;
    else {
        for (auto &&digit : String(n))
            if (!is_prime(to_int(digit)))
                return false;
        return true;
    }
}

template <typename T1> auto sequence(const T1 &max_n)
{
    auto ii = 0;
    auto n = 0;
    Array<int> r;
    while (true) {
        ii++;
        if (is_prime(ii)) {
            if (n > max_n)
                break;
            if (digit_check(ii)) {
                n++;
                r.append(ii);
            }
        }
    }
    return r;
}

auto seq = sequence(100);

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"First 25 SPDS primes:"_S);
        for (auto &&item : seq[range_el(0, 25)])
            print(item, u" "_S);
        print();
        print(u"Hundredth SPDS prime: "_S & _get<99>(seq));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Smith_numbers#Python
def factors(n):
    rt : List[int] = []
    f = 2
    if n == 1:
        rt.append(1);
    else:
        while True:
            if 0 == ( n % f ):
                rt.append(f)
                n //= f
                if n == 1:
                    return rt
            else:
                f += 1
    return rt

def sum_digits(n):
    sum = 0
    while n > 0:
        m = n % 10
        sum += m
        n -= m
        n //= 10

    return sum

def add_all_digits(lst):
    sum = 0
    for i in range (len(lst)):
        sum += sum_digits(lst[i])

    return sum

def list_smith_numbers(cnt):
    r : List[int] = []
    for i in range(4, cnt):
        fac = factors(i)
        if len(fac) > 1:
            if sum_digits(i) == add_all_digits(fac):
                r.append(i)
    return r

sn = list_smith_numbers(10_000)
print('Count of Smith Numbers below 10k:', len(sn))
print()
print('First 15 Smith Numbers:')
print(*sn[:15])
print()
print('Last 12 Smith Numbers below 10000:')
print(*sn[-12:])
===
F factors(=n)
   [Int] rt
   V f = 2
   I n == 1
      rt.append(1)
   E
      L
         I 0 == (n % f)
            rt.append(f)
            n I/= f
            I n == 1
               R rt
         E
            f++
   R rt

F sum_digits(=n)
   V sum = 0
   L n > 0
      V m = n % 10
      sum += m
      n -= m
      n I/= 10

   R sum

F add_all_digits(lst)
   V sum = 0
   L(i) 0 .< lst.len
      sum += sum_digits(lst[i])

   R sum

F list_smith_numbers(cnt)
   [Int] r
   L(i) 4 .< cnt
      V fac = factors(i)
      I fac.len > 1
         I sum_digits(i) == add_all_digits(fac)
            r.append(i)
   R r

V sn = list_smith_numbers(10'000)
print(‘Count of Smith Numbers below 10k: ’sn.len)
print()
print(‘First 15 Smith Numbers:’)
print_elements(sn[0.<15])
print()
print(‘Last 12 Smith Numbers below 10000:’)
print_elements(sn[(len)-12 ..])
===
template <typename T1> auto factors(T1 n)
{
    Array<int> rt;
    auto f = 2;
    if (n == 1)
        rt.append(1);
    else
        while (true)
            if (0 == (mod(n, f))) {
                rt.append(f);
                n = idiv(n, f);
                if (n == 1)
                    return rt;
            }
            else
                f++;
    return rt;
}

template <typename T1> auto sum_digits(T1 n)
{
    auto sum = 0;
    while (n > 0) {
        auto m = mod(n, 10);
        sum += m;
        n -= m;
        n = idiv(n, 10);
    }

    return sum;
}

template <typename T1> auto add_all_digits(const T1 &lst)
{
    auto sum = 0;
    for (auto i : range_el(0, lst.len()))
        sum += sum_digits(lst[i]);

    return sum;
}

template <typename T1> auto list_smith_numbers(const T1 &cnt)
{
    Array<int> r;
    for (auto i : range_el(4, cnt)) {
        auto fac = factors(i);
        if (fac.len() > 1) {
            if (sum_digits(i) == add_all_digits(fac))
                r.append(i);
        }
    }
    return r;
}

auto sn = list_smith_numbers(10'000);

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"Count of Smith Numbers below 10k: "_S & sn.len());
        print();
        print(u"First 15 Smith Numbers:"_S);
        print_elements(sn[range_el(0, 15)]);
        print();
        print(u"Last 12 Smith Numbers below 10000:"_S);
        print_elements(sn[range_elen_i( - 12)]);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Solve_a_Holy_Knight%27s_tour#Python
moves = [
    [-1, -2], [1, -2], [-1, 2], [1, 2],
    [-2, -1], [-2, 1], [2, -1], [2, 1]
]

def solve(pz : list, sz, sx, sy, idx, cnt):
    if idx > cnt:
        return 1

    for i in range(len(moves)):
        x = sx + moves[i][0]
        y = sy + moves[i][1]
        if sz > x and x > -1 and sz > y and y > -1 and pz[x][y] == 0:
            pz[x][y] = idx
            if 1 == solve(pz, sz, x, y, idx + 1, cnt):
                return 1
            pz[x][y] = 0

    return 0

def find_solution(pz, sz):
    p = [[-1] * sz for i in range(sz)]
    idx = 0
    x = 0
    y = 0
    cnt = 0
    for j in range(sz):
        for i in range(sz):
            if pz[idx] == "x":
                p[i][j] = 0
                cnt += 1
            elif pz[idx] == "s":
                p[i][j] = 1
                cnt += 1
                x = i
                y = j
            idx += 1

    if 1 == solve(p, sz, x, y, 2, cnt):
        for j in range(sz):
            for i in range(sz):
                if p[i][j] != -1:
                    print(" %02d" % p[i][j], end = '')
                else:
                    print("   ", end = '')
            print()
    else:
        print("Cannot solve this puzzle!")

# entry point
find_solution(".xxx.....x.xx....xxxxxxxxxx..x.xx.x..xxxsxxxxxx...xx.x.....xxx..", 8)
print()
find_solution(".....s.x..........x.x.........xxxxx.........xxx.......x..x.x..x..xxxxx...xxxxx..xx.....xx..xxxxx...xxxxx..x..x.x..x.......xxx.........xxxxx.........x.x..........x.x.....", 13)
===
V moves = [[-1, -2], [1, -2], [-1, 2], [1, 2], [-2, -1], [-2, 1], [2, -1], [2, 1]]

F solve(&pz, sz, sx, sy, idx, cnt)
   I idx > cnt
      R 1

   L(i) 0 .< :moves.len
      V x = sx + :moves[i][0]
      V y = sy + :moves[i][1]
      I sz > x & x > -1 & sz > y & y > -1 & pz[x][y] == 0
         pz[x][y] = idx
         I 1 == solve(&pz, sz, x, y, idx + 1, cnt)
            R 1
         pz[x][y] = 0

   R 0

F find_solution(pz, sz)
   V p = [[-1] * sz] * sz
   V idx = 0
   V x = 0
   V y = 0
   V cnt = 0
   L(j) 0 .< sz
      L(i) 0 .< sz
         I pz[idx] == ‘x’
            p[i][j] = 0
            cnt++
         E I pz[idx] == ‘s’
            p[i][j] = 1
            cnt++
            x = i
            y = j
         idx++

   I 1 == solve(&p, sz, x, y, 2, cnt)
      L(j) 0 .< sz
         L(i) 0 .< sz
            I p[i][j] != -1
               print(‘ #02’.format(p[i][j]), end' ‘’)
            E
               print(‘   ’, end' ‘’)
         print()
   E
      print(‘Cannot solve this puzzle!’)

find_solution(‘.xxx.....x.xx....xxxxxxxxxx..x.xx.x..xxxsxxxxxx...xx.x.....xxx..’, 8)
print()
find_solution(‘.....s.x..........x.x.........xxxxx.........xxx.......x..x.x..x..xxxxx...xxxxx..xx.....xx..xxxxx...xxxxx..x..x.x..x.......xxx.........xxxxx.........x.x..........x.x.....’, 13)
===
auto moves = create_array({create_array({-1, -2}), create_array({1, -2}), create_array({-1, 2}), create_array({1, 2}), create_array({-2, -1}), create_array({-2, 1}), create_array({2, -1}), create_array({2, 1})});

template <typename T1, typename T2, typename T3, typename T4, typename T5, typename T6> auto solve(T1 &pz, const T2 &sz, const T3 &sx, const T4 &sy, const T5 &idx, const T6 &cnt)
{
    if (idx > cnt)
        return 1;

    for (auto i : range_el(0, ::moves.len())) {
        auto x = sx + _get<0>(::moves[i]);
        auto y = sy + _get<1>(::moves[i]);
        if (sz > x && x > -1 && sz > y && y > -1 && pz[x][y] == 0) {
            pz[x].set(y, idx);
            if (1 == solve(pz, sz, x, y, idx + 1, cnt))
                return 1;
            pz[x].set(y, 0);
        }
    }

    return 0;
}

template <typename T1, typename T2> auto find_solution(const T1 &pz, const T2 &sz)
{
    auto p = create_array({create_array({-1}) * sz}) * sz;
    auto idx = 0;
    auto x = 0;
    auto y = 0;
    auto cnt = 0;
    for (auto j : range_el(0, sz))
        for (auto i : range_el(0, sz)) {
            if (pz[idx] == u'x') {
                p[i].set(j, 0);
                cnt++;
            }
            else if (pz[idx] == u's') {
                p[i].set(j, 1);
                cnt++;
                x = i;
                y = j;
            }
            idx++;
        }

    if (1 == solve(p, sz, x, y, 2, cnt))
        for (auto j : range_el(0, sz)) {
            for (auto i : range_el(0, sz))
                if (p[i][j] != -1)
                    print(u" #02"_S.format(p[i][j]), u""_S);
                else
                    print(u"   "_S, u""_S);
            print();
        }
    else
        print(u"Cannot solve this puzzle!"_S);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        find_solution(u".xxx.....x.xx....xxxxxxxxxx..x.xx.x..xxxsxxxxxx...xx.x.....xxx.."_S, 8);
        print();
        find_solution(u".....s.x..........x.x.........xxxxx.........xxx.......x..x.x..x..xxxxx...xxxxx..xx.....xx..xxxxx...xxxxx..x..x.x..x.......xxx.........xxxxx.........x.x..........x.x....."_S, 13);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Solve_a_Hopido_puzzle#Python
neighbours = [[2, 2], [-2, 2], [2, -2], [-2, -2], [3, 0], [0, 3], [-3, 0], [0, -3]]
cnt = 0
pWid = 0
pHei = 0

def is_valid(a, b):
    return -1 < a and a < pWid and -1 < b and b < pHei

def iterate(pa : list, x, y, v):
    if v > cnt:
        return 1

    for i in range(len(neighbours)):
        a = x + neighbours[i][0]
        b = y + neighbours[i][1]
        if is_valid(a, b) and pa[a][b] == 0:
            pa[a][b] = v
            r = iterate(pa, a, b, v + 1)
            if r == 1:
                return r
            pa[a][b] = 0
    return 0

def solve(pz, w, h):
    global cnt, pWid, pHei

    pa = [[-1] * h for i in range(w)]
    f = 0
    pWid = w
    pHei = h
    for j in range(h):
        for i in range(w):
            if pz[f] == "1":
                pa[i][j] = 0
                cnt += 1
            f += 1

    for y in range(h):
        for x in range(w):
            if pa[x][y] == 0:
                pa[x][y] = 1
                if 1 == iterate(pa, x, y, 2):
                    return (1, pa)
                pa[x][y] = 0

    return (0, pa)

r = solve("011011011111111111111011111000111000001000", 7, 6)
if r[0] == 1:
    for j in range(6):
        for i in range(7):
            if r[1][i][j] == -1:
                print("   ", end = '')
            else:
                print(" %02d" % r[1][i][j], end = '')
        print()
else:
    print("No solution!", end = '')
===
V neighbours = [[2, 2], [-2, 2], [2, -2], [-2, -2], [3, 0], [0, 3], [-3, 0], [0, -3]]
V cnt = 0
V pWid = 0
V pHei = 0

F is_valid(a, b)
   R -1 < a & a < :pWid & -1 < b & b < :pHei

F iterate(&pa, x, y, v)
   I v > :cnt
      R 1

   L(i) 0 .< :neighbours.len
      V a = x + :neighbours[i][0]
      V b = y + :neighbours[i][1]
      I is_valid(a, b) & pa[a][b] == 0
         pa[a][b] = v
         V r = iterate(&pa, a, b, v + 1)
         I r == 1
            R r
         pa[a][b] = 0
   R 0

F solve(pz, w, h)

   V pa = [[-1] * h] * w
   V f = 0
   :pWid = w
   :pHei = h
   L(j) 0 .< h
      L(i) 0 .< w
         I pz[f] == ‘1’
            pa[i][j] = 0
            :cnt++
         f++

   L(y) 0 .< h
      L(x) 0 .< w
         I pa[x][y] == 0
            pa[x][y] = 1
            I 1 == iterate(&pa, x, y, 2)
               R (1, pa)
            pa[x][y] = 0

   R (0, pa)

V r = solve(‘011011011111111111111011111000111000001000’, 7, 6)
I r[0] == 1
   L(j) 6
      L(i) 7
         I r[1][i][j] == -1
            print(‘   ’, end' ‘’)
         E
            print(‘ #02’.format(r[1][i][j]), end' ‘’)
      print()
E
   print(‘No solution!’, end' ‘’)
===
auto neighbours = create_array({create_array({2, 2}), create_array({-2, 2}), create_array({2, -2}), create_array({-2, -2}), create_array({3, 0}), create_array({0, 3}), create_array({-3, 0}), create_array({0, -3})});
auto cnt = 0;
auto pWid = 0;
auto pHei = 0;

template <typename T1, typename T2> auto is_valid(const T1 &a, const T2 &b)
{
    return -1 < a && a < ::pWid && -1 < b && b < ::pHei;
}

template <typename T1, typename T2, typename T3, typename T4> auto iterate(T1 &pa, const T2 &x, const T3 &y, const T4 &v)
{
    if (v > ::cnt)
        return 1;

    for (auto i : range_el(0, ::neighbours.len())) {
        auto a = x + _get<0>(::neighbours[i]);
        auto b = y + _get<1>(::neighbours[i]);
        if (is_valid(a, b) && pa[a][b] == 0) {
            pa[a].set(b, v);
            auto r = iterate(pa, a, b, v + 1);
            if (r == 1)
                return r;
            pa[a].set(b, 0);
        }
    }
    return 0;
}

template <typename T1, typename T2, typename T3> auto solve(const T1 &pz, const T2 &w, const T3 &h)
{

    auto pa = create_array({create_array({-1}) * h}) * w;
    auto f = 0;
    ::pWid = w;
    ::pHei = h;
    for (auto j : range_el(0, h))
        for (auto i : range_el(0, w)) {
            if (pz[f] == u'1') {
                pa[i].set(j, 0);
                ::cnt++;
            }
            f++;
        }

    for (auto y : range_el(0, h))
        for (auto x : range_el(0, w))
            if (pa[x][y] == 0) {
                pa[x].set(y, 1);
                if (1 == iterate(pa, x, y, 2))
                    return make_tuple(1, pa);
                pa[x].set(y, 0);
            }

    return make_tuple(0, pa);
}

auto r = solve(u"011011011111111111111011111000111000001000"_S, 7, 6);

struct CodeBlock1
{
    CodeBlock1()
    {
        if (_get<0>(r) == 1)
            for (int j = 0; j < 6; j++) {
                for (int i = 0; i < 7; i++)
                    if (_get<1>(r)[i][j] == -1)
                        print(u"   "_S, u""_S);
                    else
                        print(u" #02"_S.format(_get<1>(r)[i][j]), u""_S);
                print();
            }
        else
            print(u"No solution!"_S, u""_S);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Sort_a_list_of_object_identifiers#Python
data = [
    '1.3.6.1.4.1.11.2.17.19.3.4.0.10',
    '1.3.6.1.4.1.11.2.17.5.2.0.79',
    '1.3.6.1.4.1.11.2.17.19.3.4.0.4',
    '1.3.6.1.4.1.11150.3.4.0.1',
    '1.3.6.1.4.1.11.2.17.19.3.4.0.1',
    '1.3.6.1.4.1.11150.3.4.0'
]

delim = '.' # to get round ‘bug in MSVC 2017’[https://developercommunity.visualstudio.com/t/bug-with-operator-in-c/565417]

for s in sorted(data, key=lambda x: list(map(int, x.split(delim)))):
    print(s)
===
V data = [‘1.3.6.1.4.1.11.2.17.19.3.4.0.10’, ‘1.3.6.1.4.1.11.2.17.5.2.0.79’, ‘1.3.6.1.4.1.11.2.17.19.3.4.0.4’, ‘1.3.6.1.4.1.11150.3.4.0.1’, ‘1.3.6.1.4.1.11.2.17.19.3.4.0.1’, ‘1.3.6.1.4.1.11150.3.4.0’]

V delim = ‘.’

L(s) sorted(data, key' x -> x.split(:delim).map(Int))
   print(s)
===
auto data = create_array({u"1.3.6.1.4.1.11.2.17.19.3.4.0.10"_S, u"1.3.6.1.4.1.11.2.17.5.2.0.79"_S, u"1.3.6.1.4.1.11.2.17.19.3.4.0.4"_S, u"1.3.6.1.4.1.11150.3.4.0.1"_S, u"1.3.6.1.4.1.11.2.17.19.3.4.0.1"_S, u"1.3.6.1.4.1.11150.3.4.0"_S});

auto delim = u"."_S;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&s : sorted(data, [](const auto &x){return x.split(::delim).map([](const auto &x){return to_int(x);});}))
            print(s);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Sort_disjoint_sublist#Python
def sort_disjoint_sublist(data : list, indices):
    sindices = sorted(indices)
    values  = sorted(data[i] for i in sindices)
    for index, value in zip(sindices, values):
        data[index] = value

d = [7, 6, 5, 4, 3, 2, 1, 0]
i = [6, 1, 7]
sort_disjoint_sublist(d, i)
print(d)
===
F sort_disjoint_sublist(&data, indices)
   V sindices = sorted(indices)
   V values = sorted(sindices.map(i -> @data[i]))
   L(index, value) zip(sindices, values)
      data[index] = value

V d = [7, 6, 5, 4, 3, 2, 1, 0]
V i = [6, 1, 7]
sort_disjoint_sublist(&d, i)
print(d)
===
template <typename T1, typename T2> auto sort_disjoint_sublist(T1 &data, const T2 &indices)
{
    auto sindices = sorted(indices);
    auto values = sorted(sindices.map([&data](const auto &i){return data[i];}));
    for (auto &&[index, value] : zip(sindices, values))
        data.set(index, value);
}

auto d = create_array({7, 6, 5, 4, 3, 2, 1, 0});
auto i = create_array({6, 1, 7});

struct CodeBlock1
{
    CodeBlock1()
    {
        sort_disjoint_sublist(d, i);
        print(d);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Sort_numbers_lexicographically#Python
n=13
print(sorted(list(range(1,n+1)), key=lambda i: str(i)))
===
V n = 13
print(sorted(Array(1 .. n), key' i -> String(i)))
===
auto n = 13;

struct CodeBlock1
{
    CodeBlock1()
    {
        print(sorted(create_array(range_ee(1, n)), [](const auto &i){return String(i);}));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Sort_three_variables
x = 77444
y =   -12
z =     0
(x, y, z) = tuple(sorted((x, y, z)))
print(x, y, z)

xs = 'lions, tigers, and'
ys = 'bears, oh my!'
zs = '(from the "Wizard of OZ")'
(xs, ys, zs) = sorted([xs, ys, zs])
print(xs, ys, zs, sep = "\n")
===
V x = 77444
V y = -12
V z = 0
(x, y, z) = tuple_sorted((x, y, z))
print(x‘ ’y‘ ’z)

V xs = ‘lions, tigers, and’
V ys = ‘bears, oh my!’
V zs = ‘(from the "Wizard of OZ")’
(xs, ys, zs) = sorted([xs, ys, zs])
print(xs"\n"ys"\n"zs)
===
auto x = 77444;
auto y = -12;
auto z = 0;

struct CodeBlock1
{
    CodeBlock1()
    {
        assign_from_tuple(x, y, z, tuple_sorted(make_tuple(x, y, z)));
        print(x & u" "_S & y & u" "_S & z);
    }
} code_block_1;

auto xs = u"lions, tigers, and"_S;
auto ys = u"bears, oh my!"_S;
auto zs = u"(from the \"Wizard of OZ\")"_S;

struct CodeBlock2
{
    CodeBlock2()
    {
        assign_from_tuple(xs, ys, zs, sorted(create_array({xs, ys, zs})));
        print(xs & u"\n"_S & ys & u"\n"_S & zs);
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Sort_using_a_custom_comparator#Python
strings = "here are Some sample strings to be sorted".split(' ')

print(sorted(strings, key = lambda x: (-len(x), x.upper())))
===
V strings = ‘here are Some sample strings to be sorted’.split(‘ ’)

print(sorted(strings, key' x -> (-x.len, x.uppercase())))
===
auto strings = u"here are Some sample strings to be sorted"_S.split(u" "_S);

struct CodeBlock1
{
    CodeBlock1()
    {
        print(sorted(strings, [](const auto &x){return make_tuple(-x.len(), x.uppercase());}));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Sorting_algorithms/Bogosort
import random
from _11l import *

#def is_sorted(data):
#    return all(data[i] <= data[i + 1] for i in range(len(data) - 1))

def bogosort(data : list):
    while not is_sorted(data):
        random.shuffle(data)

arr = [2, 1, 3]
bogosort(arr)
print(arr)
===
F bogosort(&data)
   L !data.is_sorted()
      random:shuffle(&data)

V arr = [2, 1, 3]
bogosort(&arr)
print(arr)
===
template <typename T1> auto bogosort(T1 &data)
{
    while (!data.is_sorted())
        randomns::shuffle(data);
}

auto arr = create_array({2, 1, 3});

struct CodeBlock1
{
    CodeBlock1()
    {
        bogosort(arr);
        print(arr);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Sorting_Algorithms/Circle_Sort#Python
def circle_sort_backend(A:list, l:int, r:int):
    n = r-l
    if n < 2:
        return 0
    swaps = 0
    m = n//2
    for i in range(m):
        if A[r-(i+1)] < A[l+i]:
            (A[r-(i+1)], A[l+i],) = (A[l+i], A[r-(i+1)],)
            swaps += 1
    if (n & 1) != 0 and (A[l+m] < A[l+m-1]):
        (A[l+m-1], A[l+m],) = (A[l+m], A[l+m-1],)
        swaps += 1
    return swaps + circle_sort_backend(A, l, l+m) + circle_sort_backend(A, l+m, r)

def circle_sort(l:list):
    swaps = 0
    s = 1
    while s != 0:
        s = circle_sort_backend(l, 0, len(l))
        swaps += s
    return swaps

import random
for i in range(309):
    l = list(range(i))
    m = l[:]
    random.shuffle(l)
    n = l[:]
    circle_sort(l)
    if l != m:
        print(len(l))
        print(n)
        print(l)
===
F circle_sort_backend(&A, Int l, Int r)
   V n = r - l
   I n < 2
      R 0
   V swaps = 0
   V m = n I/ 2
   L(i) 0 .< m
      I A[r - (i + 1)] < A[l + i]
         swap(&A[r - (i + 1)], &A[l + i])
         swaps++
   I (n [&] 1) != 0 & (A[l + m] < A[l + m - 1])
      swap(&A[l + m - 1], &A[l + m])
      swaps++
   R swaps + circle_sort_backend(&A, l, l + m) + circle_sort_backend(&A, l + m, r)

F circle_sort(&l)
   V swaps = 0
   V s = 1
   L s != 0
      s = circle_sort_backend(&l, 0, l.len)
      swaps += s
   R swaps
L(i) 309
   V l = Array(0 .< i)
   V m = copy(l)
   random:shuffle(&l)
   V n = copy(l)
   circle_sort(&l)
   I l != m
      print(l.len)
      print(n)
      print(l)
===
template <typename T1> auto circle_sort_backend(T1 &A, const int l, const int r)
{
    auto n = r - l;
    if (n < 2)
        return 0;
    auto swaps = 0;
    auto m = idiv(n, 2);
    for (auto i : range_el(0, m))
        if (A[r - (i + 1)] < A[l + i]) {
            swap(A[r - (i + 1)], A[l + i]);
            swaps++;
        }
    if ((n & 1) != 0 && (A[l + m] < A[l + m - 1])) {
        swap(A[l + m - 1], A[l + m]);
        swaps++;
    }
    return swaps + circle_sort_backend(A, l, l + m) + circle_sort_backend(A, l + m, r);
}

template <typename T1> auto circle_sort(T1 &l)
{
    auto swaps = 0;
    auto s = 1;
    while (s != 0) {
        s = circle_sort_backend(l, 0, l.len());
        swaps += s;
    }
    return swaps;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (int i = 0; i < 309; i++) {
            auto l = create_array(range_el(0, i));
            auto m = copy(l);
            randomns::shuffle(l);
            auto n = copy(l);
            circle_sort(l);
            if (l != m) {
                print(l.len());
                print(n);
                print(l);
            }
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Sorting_algorithms/Cocktail_sort#Python
def cocktailSort(A : list):
    while True:
        for indices in (range(0, len(A)-1, 1), range(len(A)-2, -1, -1)):
            swapped = False
            for i in indices:
                if A[i] > A[i+1]:
                    (A[i], A[i+1]) = (A[i+1], A[i])
                    swapped = True
            if not swapped:
                return

test1 = [7, 6, 5, 9, 8, 4, 3, 1, 2, 0]
cocktailSort(test1)
print(test1)
===
F cocktailSort(&A)
   L
      L(indices) ((0 .< A.len - 1).step(1), (A.len - 2 .< -1).step(-1))
         V swapped = 0B
         L(i) indices
            I A[i] > A[i + 1]
               swap(&A[i], &A[i + 1])
               swapped = 1B
         I !swapped
            R

V test1 = [7, 6, 5, 9, 8, 4, 3, 1, 2, 0]
cocktailSort(&test1)
print(test1)
===
template <typename T1> auto cocktailSort(T1 &A)
{
    while (true)
        for (auto &&indices : make_tuple(range_el(0, A.len() - 1).step(1), range_el(A.len() - 2, -1).step(-1))) {
            auto swapped = false;
            for (auto &&i : indices)
                if (A[i] > A[i + 1]) {
                    swap(A[i], A[i + 1]);
                    swapped = true;
                }
            if (!swapped)
                return;
        }
}

auto test1 = create_array({7, 6, 5, 9, 8, 4, 3, 1, 2, 0});

struct CodeBlock1
{
    CodeBlock1()
    {
        cocktailSort(test1);
        print(test1);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Sorting_algorithms/Cocktail_sort_with_shifting_bounds#Python
def cocktailshiftingbounds(A : list):
    beginIdx = 0
    endIdx = len(A) - 1

    while beginIdx <= endIdx:
        newBeginIdx = endIdx
        newEndIdx = beginIdx
        for ii in range(beginIdx,endIdx):
            if A[ii] > A[ii + 1]:
                (A[ii+1], A[ii]) = (A[ii], A[ii+1])
                newEndIdx = ii

        endIdx = newEndIdx

        for ii in range(endIdx,beginIdx-1,-1):
            if A[ii] > A[ii + 1]:
                (A[ii+1], A[ii]) = (A[ii], A[ii+1])
                newBeginIdx = ii

        beginIdx = newBeginIdx + 1

test1 = [7, 6, 5, 9, 8, 4, 3, 1, 2, 0]
cocktailshiftingbounds(test1)
print(test1)
===
F cocktailshiftingbounds(&A)
   V beginIdx = 0
   V endIdx = A.len - 1

   L beginIdx <= endIdx
      V newBeginIdx = endIdx
      V newEndIdx = beginIdx
      L(ii) beginIdx .< endIdx
         I A[ii] > A[ii + 1]
            swap(&A[ii + 1], &A[ii])
            newEndIdx = ii

      endIdx = newEndIdx

      L(ii) (endIdx .< beginIdx - 1).step(-1)
         I A[ii] > A[ii + 1]
            swap(&A[ii + 1], &A[ii])
            newBeginIdx = ii

      beginIdx = newBeginIdx + 1

V test1 = [7, 6, 5, 9, 8, 4, 3, 1, 2, 0]
cocktailshiftingbounds(&test1)
print(test1)
===
template <typename T1> auto cocktailshiftingbounds(T1 &A)
{
    auto beginIdx = 0;
    auto endIdx = A.len() - 1;

    while (beginIdx <= endIdx) {
        auto newBeginIdx = endIdx;
        auto newEndIdx = beginIdx;
        for (auto ii : range_el(beginIdx, endIdx))
            if (A[ii] > A[ii + 1]) {
                swap(A[ii + 1], A[ii]);
                newEndIdx = ii;
            }

        endIdx = newEndIdx;

        for (auto ii : range_el(endIdx, beginIdx - 1).step(-1))
            if (A[ii] > A[ii + 1]) {
                swap(A[ii + 1], A[ii]);
                newBeginIdx = ii;
            }

        beginIdx = newBeginIdx + 1;
    }
}

auto test1 = create_array({7, 6, 5, 9, 8, 4, 3, 1, 2, 0});

struct CodeBlock1
{
    CodeBlock1()
    {
        cocktailshiftingbounds(test1);
        print(test1);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Sorting_algorithms/Comb_sort#Python
def combsort(input : list):
    gap = len(input)
    swaps = True
    while gap > 1 or swaps:
        gap = max(1, int(gap / 1.25))  # minimum gap is 1
        swaps = False
        for i in range(len(input) - gap):
            j = i+gap
            if input[i] > input[j]:
                (input[i], input[j]) = (input[j], input[i])
                swaps = True

y = [88, 18, 31, 44, 4, 0, 8, 81, 14, 78, 20, 76, 84, 33, 73, 75, 82, 5, 62, 70]
combsort(y)
assert y == sorted(y)
print(y)
===
F combsort(&input)
   V gap = input.len
   V swaps = 1B
   L gap > 1 | swaps
      gap = max(1, Int(gap / 1.25))
      swaps = 0B
      L(i) 0 .< input.len - gap
         V j = i + gap
         I input[i] > input[j]
            swap(&input[i], &input[j])
            swaps = 1B

V y = [88, 18, 31, 44, 4, 0, 8, 81, 14, 78, 20, 76, 84, 33, 73, 75, 82, 5, 62, 70]
combsort(&y)
assert(y == sorted(y))
print(y)
===
template <typename T1> auto combsort(T1 &input)
{
    auto gap = input.len();
    auto swaps = true;
    while (gap > 1 || swaps) {
        gap = max(1, to_int(gap / 1.25));
        swaps = false;
        for (auto i : range_el(0, input.len() - gap)) {
            auto j = i + gap;
            if (input[i] > input[j]) {
                swap(input[i], input[j]);
                swaps = true;
            }
        }
    }
}

auto y = create_array({88, 18, 31, 44, 4, 0, 8, 81, 14, 78, 20, 76, 84, 33, 73, 75, 82, 5, 62, 70});

struct CodeBlock1
{
    CodeBlock1()
    {
        combsort(y);
        assert(y == sorted(y));
        print(y);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Sorting_algorithms/Counting_sort#Python
def countingSort(a, min, max):
    cnt = [0] * (max - min + 1)
    for x in a:
        cnt[x - min] += 1

    result : List[int] = []
    for x, n in enumerate(cnt, start=min):
        result += [x] * n
    return result

data = [9, 7, 10, 2, 9, 7, 4, 3, 10, 2, 7, 10, 2, 1, 3, 8, 7, 3, 9, 5, 8, 5, 1, 6, 3, 7, 5, 4, 6, 9, 9, 6, 6, 10, 2, 4, 5, 2, 8, 2, 2, 5, 2, 9, 3, 3, 5, 7, 8, 4]
print(countingSort(data, min(data), max(data)) == sorted(data))
===
F countingSort(a, min, max)
   V cnt = [0] * (max - min + 1)
   L(x) a
      cnt[x - min]++

   [Int] result
   L(n) cnt
      V x = L.index + min
      result [+]= [x] * n
   R result

V data = [9, 7, 10, 2, 9, 7, 4, 3, 10, 2, 7, 10, 2, 1, 3, 8, 7, 3, 9, 5, 8, 5, 1, 6, 3, 7, 5, 4, 6, 9, 9, 6, 6, 10, 2, 4, 5, 2, 8, 2, 2, 5, 2, 9, 3, 3, 5, 7, 8, 4]
print(countingSort(data, min(data), max(data)) == sorted(data))
===
template <typename T1, typename T2, typename T3> auto countingSort(const T1 &a, const T2 &min, const T3 &max)
{
    auto cnt = create_array({0}) * (max - min + 1);
    for (auto &&x : a)
        cnt[x - min]++;

    Array<int> result;
    {int Lindex = 0;
    for (auto &&n : cnt) {
        auto x = Lindex + min;
        result.append(create_array({x}) * n);
        Lindex++;
    }}
    return result;
}

auto data = create_array({9, 7, 10, 2, 9, 7, 4, 3, 10, 2, 7, 10, 2, 1, 3, 8, 7, 3, 9, 5, 8, 5, 1, 6, 3, 7, 5, 4, 6, 9, 9, 6, 6, 10, 2, 4, 5, 2, 8, 2, 2, 5, 2, 9, 3, 3, 5, 7, 8, 4});

struct CodeBlock1
{
    CodeBlock1()
    {
        print(countingSort(data, min(data), max(data)) == sorted(data));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Sorting_algorithms/Cycle_sort#Python
def cycleSort(vector : list):
    writes = 0

    # Loop through the vector to find cycles to rotate.
    for cycleStart, item in enumerate(vector):

        # Find where to put the item.
        pos = cycleStart
        for item2 in vector[cycleStart + 1:]:
            if item2 < item:
                pos += 1

        # If the item is already there, this is not a cycle.
        if pos == cycleStart:
            continue

        # Otherwise, put the item there or right after any duplicates.
        while item == vector[pos]:
            pos += 1
        (vector[pos], item) = (item, vector[pos])
        writes += 1

        # Rotate the rest of the cycle.
        while pos != cycleStart:

            # Find where to put the item.
            pos = cycleStart
            for item2 in vector[cycleStart + 1:]:
                if item2 < item:
                    pos += 1

            # Put the item there or right after any duplicates.
            while item == vector[pos]:
                pos += 1
            (vector[pos], item) = (item, vector[pos])
            writes += 1

    return writes

x = [float(0), 1, 2, 2, 2, 2, 1, 9, 3.5, 5, 8, 4, 7, 0, 6]
xcopy = x[:]
writes = cycleSort(xcopy)
if xcopy != sorted(x):
    print('Wrong order!')
else:
    print('%s\nIs correctly sorted using cycleSort to' % x)
    print('%s\nUsing %i writes.' % (xcopy, writes))
===
F cycleSort(&vector)
   V writes = 0

   L(=item) vector
      V cycleStart = L.index

      V pos = cycleStart
      L(item2) vector[cycleStart + 1 ..]
         I item2 < item
            pos++

      I pos == cycleStart
         L.continue

      L item == vector[pos]
         pos++
      swap(&vector[pos], &item)
      writes++

      L pos != cycleStart

         pos = cycleStart
         L(item2) vector[cycleStart + 1 ..]
            I item2 < item
               pos++

         L item == vector[pos]
            pos++
         swap(&vector[pos], &item)
         writes++

   R writes

V x = [Float(0), 1, 2, 2, 2, 2, 1, 9, 3.5, 5, 8, 4, 7, 0, 6]
V xcopy = copy(x)
V writes = cycleSort(&xcopy)
I xcopy != sorted(x)
   print(‘Wrong order!’)
E
   print("#.\nIs correctly sorted using cycleSort to".format(x))
   print("#.\nUsing #. writes.".format(xcopy, writes))
===
template <typename T1> auto cycleSort(T1 &vector)
{
    auto writes = 0;
    {int Lindex = 0;

    for (auto item : vector) {{
        auto cycleStart = Lindex;

        auto pos = cycleStart;
        for (auto &&item2 : vector[range_ei(cycleStart + 1)])
            if (item2 < item)
                pos++;

        if (pos == cycleStart)
            goto on_continue;

        while (item == vector[pos])
            pos++;
        swap(vector[pos], item);
        writes++;

        while (pos != cycleStart) {

            pos = cycleStart;
            for (auto &&item2 : vector[range_ei(cycleStart + 1)])
                if (item2 < item)
                    pos++;

            while (item == vector[pos])
                pos++;
            swap(vector[pos], item);
            writes++;
        }
} on_continue:
        Lindex++;
    }}

    return writes;
}

auto x = create_array<double>({to_float(0), 1, 2, 2, 2, 2, 1, 9, 3.5, 5, 8, 4, 7, 0, 6});
auto xcopy = copy(x);
auto writes = cycleSort(xcopy);

struct CodeBlock1
{
    CodeBlock1()
    {
        if (xcopy != sorted(x))
            print(u"Wrong order!"_S);
        else {
            print(u"#.\nIs correctly sorted using cycleSort to"_S.format(x));
            print(u"#.\nUsing #. writes."_S.format(xcopy, writes));
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Sorting_algorithms/Gnome_sort#Python
def gnomesort(a : list):
    i = 1
    j = 2
    while i < len(a):
        if a[i-1] <= a[i]:
            i = j
            j += 1
        else:
            (a[i-1],a[i]) = (a[i],a[i-1])
            i -= 1
            if i == 0:
                i = j
                j += 1
    return a

print(gnomesort([3,4,2,5,1,6]))
===
F gnomesort(&a)
   V i = 1
   V j = 2
   L i < a.len
      I a[i - 1] <= a[i]
         i = j
         j++
      E
         swap(&a[i - 1], &a[i])
         i--
         I i == 0
            i = j
            j++
   R a

print(gnomesort(&[3, 4, 2, 5, 1, 6]))
===
template <typename T1> auto gnomesort(T1 &a)
{
    auto i = 1;
    auto j = 2;
    while (i < a.len())
        if (a[i - 1] <= a[i]) {
            i = j;
            j++;
        }
        else {
            swap(a[i - 1], a[i]);
            i--;
            if (i == 0) {
                i = j;
                j++;
            }
        }
    return a;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(gnomesort(make_ref(create_array({3, 4, 2, 5, 1, 6}))));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Sorting_algorithms/Heapsort#Python
def siftdown(lst : list, start, end):
  root = start
  while True:
    child = root * 2 + 1
    if child > end: break
    if child + 1 <= end and lst[child] < lst[child + 1]:
      child += 1
    if lst[root] < lst[child]:
      (lst[root], lst[child]) = (lst[child], lst[root])
      root = child
    else:
      break

def heapsort(lst : list):
  # in pseudo-code, heapify only called once, so inline it here
  for start in range((len(lst)-2)//2, -1, -1):
    siftdown(lst, start, len(lst)-1)

  for end in range(len(lst)-1, 0, -1):
    (lst[end], lst[0]) = (lst[0], lst[end])
    siftdown(lst, 0, end - 1)

arr = [7, 6, 5, 9, 8, 4, 3, 1, 2, 0]
heapsort(arr)
print(arr)
===
F siftdown(&lst, start, end)
   V root = start
   L
      V child = root * 2 + 1
      I child > end
         L.break
      I child + 1 <= end & lst[child] < lst[child + 1]
         child++
      I lst[root] < lst[child]
         swap(&lst[root], &lst[child])
         root = child
      E
         L.break

F heapsort(&lst)
   L(start) ((lst.len - 2) I/ 2 .< -1).step(-1)
      siftdown(&lst, start, lst.len - 1)

   L(end) (lst.len - 1 .< 0).step(-1)
      swap(&lst[end], &lst[0])
      siftdown(&lst, 0, end - 1)

V arr = [7, 6, 5, 9, 8, 4, 3, 1, 2, 0]
heapsort(&arr)
print(arr)
===
template <typename T1, typename T2, typename T3> auto siftdown(T1 &lst, const T2 &start, const T3 &end)
{
    auto root = start;
    while (true) {
        auto child = root * 2 + 1;
        if (child > end)
            break;
        if (child + 1 <= end && lst[child] < lst[child + 1])
            child++;
        if (lst[root] < lst[child]) {
            swap(lst[root], lst[child]);
            root = child;
        }
        else
            break;
    }
}

template <typename T1> auto heapsort(T1 &lst)
{
    for (auto start : range_el(idiv((lst.len() - 2), 2), -1).step(-1))
        siftdown(lst, start, lst.len() - 1);

    for (auto end : range_el(lst.len() - 1, 0).step(-1)) {
        swap(lst[end], _get<0>(lst));
        siftdown(lst, 0, end - 1);
    }
}

auto arr = create_array({7, 6, 5, 9, 8, 4, 3, 1, 2, 0});

struct CodeBlock1
{
    CodeBlock1()
    {
        heapsort(arr);
        print(arr);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Sorting_algorithms/Insertion_sort#Python
def insertion_sort(l : list):
    for i in range(1, len(l)):
        j = i-1
        key = l[i]
        while j >= 0 and l[j] > key:
           l[j+1] = l[j]
           j -= 1
        l[j+1] = key

arr = [7, 6, 5, 9, 8, 4, 3, 1, 2, 0]
insertion_sort(arr)
print(arr)
===
F insertion_sort(&l)
   L(i) 1 .< l.len
      V j = i - 1
      V key = l[i]
      L j >= 0 & l[j] > key
         l[j + 1] = l[j]
         j--
      l[j + 1] = key

V arr = [7, 6, 5, 9, 8, 4, 3, 1, 2, 0]
insertion_sort(&arr)
print(arr)
===
template <typename T1> auto insertion_sort(T1 &l)
{
    for (auto i : range_el(1, l.len())) {
        auto j = i - 1;
        auto key = l[i];
        while (j >= 0 && l[j] > key) {
            l.set(j + 1, l[j]);
            j--;
        }
        l.set(j + 1, key);
    }
}

auto arr = create_array({7, 6, 5, 9, 8, 4, 3, 1, 2, 0});

struct CodeBlock1
{
    CodeBlock1()
    {
        insertion_sort(arr);
        print(arr);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Sorting_algorithms/Merge_sort#Python
def merge(left, right):
    result : List[int] = []
    left_idx = 0
    right_idx = 0
    while left_idx < len(left) and right_idx < len(right):
        # change the direction of this comparison to change the direction of the sort
        if left[left_idx] <= right[right_idx]:
            result.append(left[left_idx])
            left_idx += 1
        else:
            result.append(right[right_idx])
            right_idx += 1

    if left_idx < len(left):
        result.extend(left[left_idx:])
    if right_idx < len(right):
        result.extend(right[right_idx:])
    return result

def merge_sort(m):
    if len(m) <= 1:
        return m

    middle = len(m) // 2
    left = m[:middle]
    right = m[middle:]

    left = merge_sort(left)
    right = merge_sort(right)
    return list(merge(left, right))

arr = [7, 6, 5, 9, 8, 4, 3, 1, 2, 0]
print(merge_sort(arr))
===
F merge(left, right)
   [Int] result
   V left_idx = 0
   V right_idx = 0
   L left_idx < left.len & right_idx < right.len
      I left[left_idx] <= right[right_idx]
         result.append(left[left_idx])
         left_idx++
      E
         result.append(right[right_idx])
         right_idx++

   I left_idx < left.len
      result.extend(left[left_idx ..])
   I right_idx < right.len
      result.extend(right[right_idx ..])
   R result

F merge_sort(m)
   I m.len <= 1
      R m

   V middle = m.len I/ 2
   V left = m[0 .< middle]
   V right = m[middle ..]

   left = merge_sort(left)
   right = merge_sort(right)
   R Array(merge(left, right))

V arr = [7, 6, 5, 9, 8, 4, 3, 1, 2, 0]
print(merge_sort(arr))
===
template <typename T1, typename T2> auto merge(const T1 &left, const T2 &right)
{
    Array<int> result;
    auto left_idx = 0;
    auto right_idx = 0;
    while (left_idx < left.len() && right_idx < right.len())
        if (left[left_idx] <= right[right_idx]) {
            result.append(left[left_idx]);
            left_idx++;
        }
        else {
            result.append(right[right_idx]);
            right_idx++;
        }

    if (left_idx < left.len())
        result.extend(left[range_ei(left_idx)]);
    if (right_idx < right.len())
        result.extend(right[range_ei(right_idx)]);
    return result;
}

template <typename T1> auto merge_sort(const T1 &m)
{
    if (m.len() <= 1)
        return m;

    auto middle = idiv(m.len(), 2);
    auto left = m[range_el(0, middle)];
    auto right = m[range_ei(middle)];

    left = merge_sort(left);
    right = merge_sort(right);
    return create_array(merge(left, right));
}

auto arr = create_array({7, 6, 5, 9, 8, 4, 3, 1, 2, 0});

struct CodeBlock1
{
    CodeBlock1()
    {
        print(merge_sort(arr));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Sorting_algorithms/Pancake_sort#Python
tutor = True

def pancakesort(data : list):
    if len(data) <= 1:
        return
    if tutor: print()
    for size in range(len(data), 1, -1):
        maxindex = max(range(size), key=lambda x: data[x])
        if maxindex+1 != size:
            # This indexed max needs moving
            if maxindex != 0:
                # Flip the max item to the left
                if tutor: print('With: %s doflip  %i'
                                % ( ' '.join(str(x) for x in data), maxindex+1 ))
                data[:maxindex+1] = reversed(data[:maxindex+1])
            # Flip it into its final position
            if tutor: print('With: %s  doflip %i'
                                % ( ' '.join(str(x) for x in data), size ))
            data[:size] = reversed(data[:size])
    if tutor: print()

data = '6 7 2 1 8 9 5 3 4'.split(' ')
print('Original List: ' + ' '.join(data))
pancakesort(data)
print('Pancake Sorted List: ' + ' '.join(data))
===
V tutor = 1B

F pancakesort(&data)
   I data.len <= 1
      R
   I :tutor
      print()
   L(size) (data.len .< 1).step(-1)
      V maxindex = max(0 .< size, key' x -> @data[x])
      I maxindex + 1 != size
         I maxindex != 0
            I :tutor
               print(‘With: #. doflip  #.’.format(data.map(x -> String(x)).join(‘ ’), maxindex + 1))
            data.reverse_range(0 .< maxindex + 1)
         I :tutor
            print(‘With: #.  doflip #.’.format(data.map(x -> String(x)).join(‘ ’), size))
         data.reverse_range(0 .< size)
   I :tutor
      print()

V data = ‘6 7 2 1 8 9 5 3 4’.split(‘ ’)
print(‘Original List: ’data.join(‘ ’))
pancakesort(&data)
print(‘Pancake Sorted List: ’data.join(‘ ’))
===
auto tutor = true;

template <typename T1> auto pancakesort(T1 &data)
{
    if (data.len() <= 1)
        return;
    if (::tutor)
        print();
    for (auto size : range_el(data.len(), 1).step(-1)) {
        auto maxindex = max_with_key(range_el(0, size), [&data](const auto &x){return data[x];});
        if (maxindex + 1 != size) {
            if (maxindex != 0) {
                if (::tutor)
                    print(u"With: #. doflip  #."_S.format(data.map([](const auto &x){return String(x);}).join(u" "_S), maxindex + 1));
                data.reverse_range(range_el(0, maxindex + 1));
            }
            if (::tutor)
                print(u"With: #.  doflip #."_S.format(data.map([](const auto &x){return String(x);}).join(u" "_S), size));
            data.reverse_range(range_el(0, size));
        }
    }
    if (::tutor)
        print();
}

auto data = u"6 7 2 1 8 9 5 3 4"_S.split(u" "_S);

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"Original List: "_S & data.join(u" "_S));
        pancakesort(data);
        print(u"Pancake Sorted List: "_S & data.join(u" "_S));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Sorting_algorithms/Quicksort#Python
def _quicksort(array : list, start, stop) -> None:
    if stop - start > 0:
        pivot = array[start]
        left = start
        right = stop
        while left <= right:
            while array[left] < pivot:
                left += 1
            while array[right] > pivot:
                right -= 1
            if left <= right:
                (array[left], array[right]) = (array[right], array[left])
                left += 1
                right -= 1
        _quicksort(array, start, right)
        _quicksort(array, left, stop)

def quicksort(array : list):
    _quicksort(array, 0, len(array) - 1)

arr = [7, 6, 5, 9, 8, 4, 3, 1, 2, 0]
quicksort(arr)
print(arr)
===
F _quicksort(&array, start, stop) -> N
   I stop - start > 0
      V pivot = array[start]
      V left = start
      V right = stop
      L left <= right
         L array[left] < pivot
            left++
         L array[right] > pivot
            right--
         I left <= right
            swap(&array[left], &array[right])
            left++
            right--
      _quicksort(&array, start, right)
      _quicksort(&array, left, stop)

F quicksort(&array)
   _quicksort(&array, 0, array.len - 1)

V arr = [7, 6, 5, 9, 8, 4, 3, 1, 2, 0]
quicksort(&arr)
print(arr)
===
template <typename T1, typename T2, typename T3> void _quicksort(T1 &array, const T2 &start, const T3 &stop)
{
    if (stop - start > 0) {
        auto pivot = array[start];
        auto left = start;
        auto right = stop;
        while (left <= right) {
            while (array[left] < pivot)
                left++;
            while (array[right] > pivot)
                right--;
            if (left <= right) {
                swap(array[left], array[right]);
                left++;
                right--;
            }
        }
        _quicksort(array, start, right);
        _quicksort(array, left, stop);
    }
}

template <typename T1> auto quicksort(T1 &array)
{
    _quicksort(array, 0, array.len() - 1);
}

auto arr = create_array({7, 6, 5, 9, 8, 4, 3, 1, 2, 0});

struct CodeBlock1
{
    CodeBlock1()
    {
        quicksort(arr);
        print(arr);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Sorting_algorithms/Radix_sort#Python
def flatten(some_list):
    new_list : List[int] = []
    for sub_list in some_list:
        new_list += sub_list
    return new_list

def radix_sort(l, p=-1, s=-1):
    if s == -1:
        s = len(str(max(l)))
    if p == -1:
        p = s

    i = s - p

    if i >= s:
        return l

    bins = [[0]*0 for _ in range(10)]

    for e in l:
        bins[int(str(e).zfill(s)[i])] += [e]

    return flatten([radix_sort(b, p-1, s) for b in bins])

arr = [7, 6, 5, 9, 8, 4, 3, 1, 2, 0]
print(radix_sort(arr))
===
F flatten(some_list)
   [Int] new_list
   L(sub_list) some_list
      new_list [+]= sub_list
   R new_list

F radix_sort(l, =p = -1, =s = -1)
   I s == -1
      s = String(max(l)).len
   I p == -1
      p = s

   V i = s - p

   I i >= s
      R l

   V bins = [[Int]()] * 10

   L(e) l
      bins[Int(String(e).zfill(s)[i])] [+]= e

   R flatten(bins.map(b -> radix_sort(b, @p - 1, @s)))

V arr = [7, 6, 5, 9, 8, 4, 3, 1, 2, 0]
print(radix_sort(arr))
===
template <typename T1> auto flatten(const T1 &some_list)
{
    Array<int> new_list;
    for (auto &&sub_list : some_list)
        new_list.append(sub_list);
    return new_list;
}

template <typename T1, typename T2 = decltype(-1), typename T3 = decltype(-1)> auto radix_sort(const T1 &l, T2 p = -1, T3 s = -1)
{
    if (s == -1)
        s = String(max(l)).len();
    if (p == -1)
        p = s;

    auto i = s - p;

    if (i >= s)
        return l;

    auto bins = create_array({Array<int>()}) * 10;

    for (auto &&e : l)
        bins[to_int(String(e).zfill(s)[i])].append(e);

    return flatten(bins.map([&p, &s](const auto &b){return radix_sort(b, p - 1, s);}));
}

auto arr = create_array({7, 6, 5, 9, 8, 4, 3, 1, 2, 0});

struct CodeBlock1
{
    CodeBlock1()
    {
        print(radix_sort(arr));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Sorting_algorithms/Selection_sort#Python
def selection_sort(lst : list):
    for i, e in enumerate(lst):
        mn = min(range(i,len(lst)), key = lambda x: lst[x])
        (lst[i], lst[mn]) = (lst[mn], e)

arr = [7, 6, 5, 9, 8, 4, 3, 1, 2, 0]
selection_sort(arr)
print(arr)
===
F selection_sort(&lst)
   L(e) lst
      V i = L.index
      V mn = min(i .< lst.len, key' x -> @lst[x])
      (lst[i], lst[mn]) = (lst[mn], e)

V arr = [7, 6, 5, 9, 8, 4, 3, 1, 2, 0]
selection_sort(&arr)
print(arr)
===
template <typename T1> auto selection_sort(T1 &lst)
{
    {int Lindex = 0;
    for (auto &&e : lst) {
        auto i = Lindex;
        auto mn = min_with_key(range_el(i, lst.len()), [&lst](const auto &x){return lst[x];});
        assign_from_tuple(lst[i], lst[mn], make_tuple(lst[mn], e));
        Lindex++;
    }}
}

auto arr = create_array({7, 6, 5, 9, 8, 4, 3, 1, 2, 0});

struct CodeBlock1
{
    CodeBlock1()
    {
        selection_sort(arr);
        print(arr);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Sorting_algorithms/Shell_sort#Python
def shell_sort(seq : list):
    inc = len(seq) // 2
    while inc != 0:
        for i, el in enumerate(seq[inc:], inc):
            while i >= inc and seq[i - inc] > el:
                seq[i] = seq[i - inc]
                i -= inc
            seq[i] = el
        inc = 1 if inc == 2 else inc * 5 // 11

data = [22, 7, 2, -5, 8, 4]
shell_sort(data)
print(data)
===
F shell_sort(&seq)
   V inc = seq.len I/ 2
   L inc != 0
      L(el) seq[inc ..]
         V i = L.index + inc
         L i >= inc & seq[i - inc] > el
            seq[i] = seq[i - inc]
            i -= inc
         seq[i] = el
      inc = I inc == 2 {1} E inc * 5 I/ 11

V data = [22, 7, 2, -5, 8, 4]
shell_sort(&data)
print(data)
===
template <typename T1> auto shell_sort(T1 &seq)
{
    auto inc = idiv(seq.len(), 2);
    while (inc != 0) {
        {int Lindex = 0;
        for (auto &&el : seq[range_ei(inc)]) {
            auto i = Lindex + inc;
            while (i >= inc && seq[i - inc] > el) {
                seq.set(i, seq[i - inc]);
                i -= inc;
            }
            seq.set(i, el);
            Lindex++;
        }}
        inc = inc == 2 ? 1 : idiv(inc * 5, 11);
    }
}

auto data = create_array({22, 7, 2, -5, 8, 4});

struct CodeBlock1
{
    CodeBlock1()
    {
        shell_sort(data);
        print(data);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Sorting_algorithms/Stooge_sort#Python
def stoogesort(l : list, i, j) -> None:
    if l[j] < l[i]:
        (l[i], l[j]) = (l[j], l[i])
    if j - i > 1:
        t = (j - i + 1) // 3
        stoogesort(l, i  , j-t)
        stoogesort(l, i+t, j  )
        stoogesort(l, i  , j-t)

def stooge(l : list):
    return stoogesort(l, 0, len(l) - 1)

data = [1, 4, 5, 3, -6, 3, 7, 10, -2, -5, 7, 5, 9, -3, 7]
stooge(data)
print(data)
===
F stoogesort(&l, i, j) -> N
   I l[j] < l[i]
      swap(&l[i], &l[j])
   I j - i > 1
      V t = (j - i + 1) I/ 3
      stoogesort(&l, i, j - t)
      stoogesort(&l, i + t, j)
      stoogesort(&l, i, j - t)

F stooge(&l)
   R stoogesort(&l, 0, l.len - 1)

V data = [1, 4, 5, 3, -6, 3, 7, 10, -2, -5, 7, 5, 9, -3, 7]
stooge(&data)
print(data)
===
template <typename T1, typename T2, typename T3> void stoogesort(T1 &l, const T2 &i, const T3 &j)
{
    if (l[j] < l[i])
        swap(l[i], l[j]);
    if (j - i > 1) {
        auto t = idiv((j - i + 1), 3);
        stoogesort(l, i, j - t);
        stoogesort(l, i + t, j);
        stoogesort(l, i, j - t);
    }
}

template <typename T1> auto stooge(T1 &l)
{
    return stoogesort(l, 0, l.len() - 1);
}

auto data = create_array({1, 4, 5, 3, -6, 3, 7, 10, -2, -5, 7, 5, 9, -3, 7});

struct CodeBlock1
{
    CodeBlock1()
    {
        stooge(data);
        print(data);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Sorting_algorithms/Strand_sort#Python
def merge_list(a : list, b : list):
    out : List[int] = []
    while len(a) != 0 and len(b) != 0:
        if a[0] < b[0]:
            out.append(a.pop(0))
        else:
            out.append(b.pop(0))
    out += a
    out += b
    return out

def strand(a : list):
    i = 0
    s = [a.pop(0)]
    while i < len(a):
        if a[i] > s[-1]:
            s.append(a.pop(i))
        else:
            i += 1
    return s

def strand_sort(a : list):
    out = strand(a)
    while len(a):
        out = merge_list(out, strand(a))
    return out

print(strand_sort([1, 6, 3, 2, 1, 7, 5, 3]))
===
F merge_list(&a, &b)
   [Int] out
   L !a.empty & !b.empty
      I a[0] < b[0]
         out.append(a.pop(0))
      E
         out.append(b.pop(0))
   out [+]= a
   out [+]= b
   R out

F strand(&a)
   V i = 0
   V s = [a.pop(0)]
   L i < a.len
      I a[i] > s.last
         s.append(a.pop(i))
      E
         i++
   R s

F strand_sort(&a)
   V out = strand(&a)
   L !a.empty
      out = merge_list(&out, &strand(&a))
   R out

print(strand_sort(&[1, 6, 3, 2, 1, 7, 5, 3]))
===
template <typename T1, typename T2> auto merge_list(T1 &a, T2 &b)
{
    Array<int> out;
    while (!a.empty() && !b.empty())
        if (_get<0>(a) < _get<0>(b))
            out.append(a.pop(0));
        else
            out.append(b.pop(0));
    out.append(a);
    out.append(b);
    return out;
}

template <typename T1> auto strand(T1 &a)
{
    auto i = 0;
    auto s = create_array({a.pop(0)});
    while (i < a.len())
        if (a[i] > s.last())
            s.append(a.pop(i));
        else
            i++;
    return s;
}

template <typename T1> auto strand_sort(T1 &a)
{
    auto out = strand(a);
    while (!a.empty())
        out = merge_list(out, make_ref(strand(a)));
    return out;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(strand_sort(make_ref(create_array({1, 6, 3, 2, 1, 7, 5, 3}))));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Spinning_rod_animation/Text#Python
import time
while True:
    for rod in r'\|/-':
        print(rod, end='\r')
        time.sleep(0.25)
===
L
   L(rod) ‘\|/-’
      print(rod, end' "\r")
      sleep(0.25)
===
struct CodeBlock1
{
    CodeBlock1()
    {
        while (true)
            for (auto &&rod : uR"(\|/-)"_S) {
                print(rod, u"\r"_S);
                sleep(0.25);
            }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Spiral_matrix#Python
def spiral_matrix(n):
    m = [[0] * n for i in range(n)]
    dx = [0, 1, 0, -1]
    dy = [1, 0, -1, 0]
    x = 0
    y = -1
    c = 0
    for i in range(n + n - 1):
        for j in range((n + n - i) // 2):
            x += dx[i % 4]
            y += dy[i % 4]
            m[x][y] = c
            c += 1
    return m

def printspiral(myarray):
    n = range(len(myarray))
    for y in n:
        for x in n:
            print("%2i" % myarray[y][x], end = ' ')
        print()

printspiral(spiral_matrix(5))
===
F spiral_matrix(n)
   V m = [[0] * n] * n
   V dx = [0, 1, 0, -1]
   V dy = [1, 0, -1, 0]
   V x = 0
   V y = -1
   V c = 0
   L(i) 0 .< n + n - 1
      L(j) 0 .< (n + n - i) I/ 2
         x += dx[i % 4]
         y += dy[i % 4]
         m[x][y] = c
         c++
   R m

F printspiral(myarray)
   V n = 0 .< myarray.len
   L(y) n
      L(x) n
         print(‘#2’.format(myarray[y][x]), end' ‘ ’)
      print()

printspiral(spiral_matrix(5))
===
template <typename T1> auto spiral_matrix(const T1 &n)
{
    auto m = create_array({create_array({0}) * n}) * n;
    auto dx = create_array({0, 1, 0, -1});
    auto dy = create_array({1, 0, -1, 0});
    auto x = 0;
    auto y = -1;
    auto c = 0;
    for (auto i : range_el(0, n + n - 1))
        for (auto j : range_el(0, idiv((n + n - i), 2))) {
            x += dx[mod(i, 4)];
            y += dy[mod(i, 4)];
            m[x].set(y, c);
            c++;
        }
    return m;
}

template <typename T1> auto printspiral(const T1 &myarray)
{
    auto n = range_el(0, myarray.len());
    for (auto &&y : n) {
        for (auto &&x : n)
            print(u"#2"_S.format(myarray[y][x]), u" "_S);
        print();
    }
}

struct CodeBlock1
{
    CodeBlock1()
    {
        printspiral(spiral_matrix(5));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Split_a_character_string_based_on_change_of_character#C.2B.2B
def split(input, delim):
    res = ''
    for ch in input:
        if len(res) != 0 and ch != res[-1]:
            res += delim
        res += ch
    return res

print(split("gHHH5YY++///\\", ', '))
===
F split(input, delim)
   V res = ‘’
   L(ch) input
      I !res.empty & ch != res.last
         res ‘’= delim
      res ‘’= ch
   R res

print(split("gHHH5YY++///\\", ‘, ’))
===
template <typename T1, typename T2> auto split(const T1 &input, const T2 &delim)
{
    auto res = u""_S;
    for (auto &&ch : input) {
        if (!res.empty() && ch != res.last())
            res &= delim;
        res &= ch;
    }
    return res;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(split(u"gHHH5YY++///\\"_S, u", "_S));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Square_but_not_cube#C
n = 1
count = 0

while count < 30:
    sq = n * n
    cr = int(sq ** (1/3) + 1e-6)
    if cr * cr * cr != sq:
        count += 1
        print(sq)
    else:
        print(sq, 'is square and cube')
    n += 1
===
V n = 1
V count = 0

L count < 30
   V sq = n * n
   V cr = Int(sq ^ (1 / 3) + 1e-6)
   I cr * cr * cr != sq
      count++
      print(sq)
   E
      print(sq‘ is square and cube’)
   n++
===
auto n = 1;
auto count = 0;

struct CodeBlock1
{
    CodeBlock1()
    {
        while (count < 30) {
            auto sq = n * n;
            auto cr = to_int(pow(sq, (1.0 / 3)) + 1e-6);
            if (cr * cr * cr != sq) {
                count++;
                print(sq);
            }
            else
                print(sq & u" is square and cube"_S);
            n++;
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Stack#Crystal
from typing import List

stack : List[int] = []

for i in range(1, 11):
    stack.append(i)

for i in range(10):
    print(stack.pop())
===
[Int] stack

L(i) 1..10
   stack.append(i)

L(i) 10
   print(stack.pop())
===
Array<int> stack;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto i : range_ee(1, 10))
            stack.append(i);

        for (int i = 0; i < 10; i++)
            print(stack.pop());
    }
} code_block_1;


# https://www.rosettacode.org/wiki/State_name_puzzle#Python
import collections
from typing import DefaultDict, List

states = ["Alabama", "Alaska", "Arizona", "Arkansas",
"California", "Colorado", "Connecticut", "Delaware", "Florida",
"Georgia", "Hawaii", "Idaho", "Illinois", "Indiana", "Iowa", "Kansas",
"Kentucky", "Louisiana", "Maine", "Maryland", "Massachusetts",
"Michigan", "Minnesota", "Mississippi", "Missouri", "Montana",
"Nebraska", "Nevada", "New Hampshire", "New Jersey", "New Mexico",
"New York", "North Carolina", "North Dakota", "Ohio", "Oklahoma",
"Oregon", "Pennsylvania", "Rhode Island", "South Carolina",
"South Dakota", "Tennessee", "Texas", "Utah", "Vermont", "Virginia",
"Washington", "West Virginia", "Wisconsin", "Wyoming",
# Uncomment the next line for the fake states.
# "New Kory", "Wen Kory", "York New", "Kory New", "New Kory"
]

states = sorted(states)

smap : DefaultDict[str, List[str]] = collections.defaultdict(list)
for i, s1 in enumerate(states[:-1]):
    for s2 in states[i + 1:]:
        smap["".join(sorted(s1 + '' + s2))].append(s1 + " + " + s2)

for pairs in sorted(smap.values()):
    if len(pairs) > 1:
        print(" = ".join(pairs))
===
V states = [‘Alabama’, ‘Alaska’, ‘Arizona’, ‘Arkansas’, ‘California’, ‘Colorado’, ‘Connecticut’, ‘Delaware’, ‘Florida’, ‘Georgia’, ‘Hawaii’, ‘Idaho’, ‘Illinois’, ‘Indiana’, ‘Iowa’, ‘Kansas’, ‘Kentucky’, ‘Louisiana’, ‘Maine’, ‘Maryland’, ‘Massachusetts’, ‘Michigan’, ‘Minnesota’, ‘Mississippi’, ‘Missouri’, ‘Montana’, ‘Nebraska’, ‘Nevada’, ‘New Hampshire’, ‘New Jersey’, ‘New Mexico’, ‘New York’, ‘North Carolina’, ‘North Dakota’, ‘Ohio’, ‘Oklahoma’, ‘Oregon’, ‘Pennsylvania’, ‘Rhode Island’, ‘South Carolina’, ‘South Dakota’, ‘Tennessee’, ‘Texas’, ‘Utah’, ‘Vermont’, ‘Virginia’, ‘Washington’, ‘West Virginia’, ‘Wisconsin’, ‘Wyoming’]

states = sorted(states)

DefaultDict[String, [String]] smap
L(s1) states[0 .< (len)-1]
   V i = L.index
   L(s2) states[i + 1 ..]
      smap[sorted(s1‘’s2).join(‘’)].append(s1‘ + ’s2)

L(pairs) sorted(smap.values())
   I pairs.len > 1
      print(pairs.join(‘ = ’))
===
auto states = create_array({u"Alabama"_S, u"Alaska"_S, u"Arizona"_S, u"Arkansas"_S, u"California"_S, u"Colorado"_S, u"Connecticut"_S, u"Delaware"_S, u"Florida"_S, u"Georgia"_S, u"Hawaii"_S, u"Idaho"_S, u"Illinois"_S, u"Indiana"_S, u"Iowa"_S, u"Kansas"_S, u"Kentucky"_S, u"Louisiana"_S, u"Maine"_S, u"Maryland"_S, u"Massachusetts"_S, u"Michigan"_S, u"Minnesota"_S, u"Mississippi"_S, u"Missouri"_S, u"Montana"_S, u"Nebraska"_S, u"Nevada"_S, u"New Hampshire"_S, u"New Jersey"_S, u"New Mexico"_S, u"New York"_S, u"North Carolina"_S, u"North Dakota"_S, u"Ohio"_S, u"Oklahoma"_S, u"Oregon"_S, u"Pennsylvania"_S, u"Rhode Island"_S, u"South Carolina"_S, u"South Dakota"_S, u"Tennessee"_S, u"Texas"_S, u"Utah"_S, u"Vermont"_S, u"Virginia"_S, u"Washington"_S, u"West Virginia"_S, u"Wisconsin"_S, u"Wyoming"_S});

struct CodeBlock1
{
    CodeBlock1()
    {
        states = sorted(states);
    }
} code_block_1;

DefaultDict<String, Array<String>> smap;

struct CodeBlock2
{
    CodeBlock2()
    {
        {int Lindex = 0;
        for (auto &&s1 : states[range_e_llen(0,  - 1)]) {
            auto i = Lindex;
            for (auto &&s2 : states[range_ei(i + 1)])
                smap[sorted(s1 & s2).join(u""_S)].append(s1 & u" + "_S & s2);
            Lindex++;
        }}

        for (auto &&pairs : sorted(smap.values()))
            if (pairs.len() > 1)
                print(pairs.join(u" = "_S));
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Statistics/Basic#Python
def sd_mean(numbers):
    mean = sum(numbers) / len(numbers)
    sd = (sum((n - mean)**2 for n in numbers) / len(numbers))**0.5
    return (sd, mean)

def histogram(numbers):
    h = [0] * 10
    maxwidth = 50 # characters
    for n in numbers:
        h[int(n*10)] += 1
    mx = max(h)
    print()
    for n, i in enumerate(h):
        print('%3.1f: %s' % (n / 10, '+' * (i * maxwidth // mx)))
    print()

import random
for i in (1, 5):
    n = [random.random() for j in range(10**i)]
    print("\n##\n## %i numbers\n##" % 10**i)
    (sd, mean) = sd_mean(n)
    print('  sd: %8.6f, mean: %8.6f' % (sd, mean))
    histogram(n)
===
F sd_mean(numbers)
   V mean = sum(numbers) / numbers.len
   V sd = (sum(numbers.map(n -> (n - @mean) ^ 2)) / numbers.len) ^ 0.5
   R (sd, mean)

F histogram(numbers)
   V h = [0] * 10
   V maxwidth = 50
   L(n) numbers
      h[Int(n * 10)]++
   V mx = max(h)
   print()
   L(i) h
      V n = L.index
      print(‘#.1: #.’.format(n / 10, ‘+’ * (i * maxwidth I/ mx)))
   print()
L(i) (1, 5)
   V n = (0 .< 10 ^ i).map(j -> random:())
   print("\n###\n### #. numbers\n###".format(10 ^ i))
   V (sd, mean) = sd_mean(n)
   print(‘  sd: #.6, mean: #.6’.format(sd, mean))
   histogram(n)
===
template <typename T1> auto sd_mean(const T1 &numbers)
{
    auto mean = sum(numbers) / numbers.len();
    auto sd = pow((sum_map(numbers, [&mean](const auto &n){return square((n - mean));}) / numbers.len()), 0.5);
    return make_tuple(sd, mean);
}

template <typename T1> auto histogram(const T1 &numbers)
{
    auto h = create_array({0}) * 10;
    auto maxwidth = 50;
    for (auto &&n : numbers)
        h[to_int(n * 10)]++;
    auto mx = max(h);
    print();
    {int Lindex = 0;
    for (auto &&i : h) {
        auto n = Lindex;
        print(u"#.1: #."_S.format(n / 10.0, u"+"_S * (idiv(i * maxwidth, mx))));
        Lindex++;
    }}
    print();
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&i : make_tuple(1, 5)) {
            auto n = range_el(0, pow(10, i)).map([](const auto &j){return randomns::_();});
            print(u"\n###\n### #. numbers\n###"_S.format(pow(10, i)));
            auto [sd, mean] = sd_mean(n);
            print(u"  sd: #.6, mean: #.6"_S.format(sd, mean));
            histogram(n);
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Stem-and-leaf_plot#Kotlin
def leaf_plot(x : list):
    x.sort()
    i = x[0] // 10 - 1
    for j in range(len(x)):
        d = x[j] // 10
        while d > i:
            i += 1
            print('%s%3d |' % ((j != 0) * "\n", i), end = '')
        print('', x[j] % 10, end = '')
    print()

data = [
     12, 127,  28,  42,  39, 113,  42,  18,  44, 118,  44,  37, 113, 124,
     37,  48, 127,  36,  29,  31, 125, 139, 131, 115, 105, 132, 104, 123,
     35, 113, 122,  42, 117, 119,  58, 109,  23, 105,  63,  27,  44, 105,
     99,  41, 128, 121, 116, 125,  32,  61,  37, 127,  29, 113, 121,  58,
    114, 126,  53, 114,  96,  25, 109,   7,  31, 141,  46,  13,  27,  43,
    117, 116,  27,   7,  68,  40,  31, 115, 124,  42, 128,  52,  71, 118,
    117,  38,  27, 106,  33, 117, 116, 111,  40, 119,  47, 105,  57, 122,
    109, 124, 115,  43, 120,  43,  27,  27,  18,  28,  48, 125, 107, 114,
     34, 133,  45, 120,  30, 127,  31, 116, 146
]

leaf_plot(data)
===
F leaf_plot(&x)
   x.sort()
   V i = x[0] I/ 10 - 1
   L(j) 0 .< x.len
      V d = x[j] I/ 10
      L d > i
         i++
         print(‘#.#3 |’.format((j != 0) * "\n", i), end' ‘’)
      print(‘ ’(x[j] % 10), end' ‘’)
   print()

V data = [12, 127, 28, 42, 39, 113, 42, 18, 44, 118, 44, 37, 113, 124, 37, 48, 127, 36, 29, 31, 125, 139, 131, 115, 105, 132, 104, 123, 35, 113, 122, 42, 117, 119, 58, 109, 23, 105, 63, 27, 44, 105, 99, 41, 128, 121, 116, 125, 32, 61, 37, 127, 29, 113, 121, 58, 114, 126, 53, 114, 96, 25, 109, 7, 31, 141, 46, 13, 27, 43, 117, 116, 27, 7, 68, 40, 31, 115, 124, 42, 128, 52, 71, 118, 117, 38, 27, 106, 33, 117, 116, 111, 40, 119, 47, 105, 57, 122, 109, 124, 115, 43, 120, 43, 27, 27, 18, 28, 48, 125, 107, 114, 34, 133, 45, 120, 30, 127, 31, 116, 146]

leaf_plot(&data)
===
template <typename T1> auto leaf_plot(T1 &x)
{
    x.sort();
    auto i = idiv(_get<0>(x), 10) - 1;
    for (auto j : range_el(0, x.len())) {
        auto d = idiv(x[j], 10);
        while (d > i) {
            i++;
            print(u"#.#3 |"_S.format((j != 0) * u"\n"_S, i), u""_S);
        }
        print(u" "_S & (mod(x[j], 10)), u""_S);
    }
    print();
}

auto data = create_array({12, 127, 28, 42, 39, 113, 42, 18, 44, 118, 44, 37, 113, 124, 37, 48, 127, 36, 29, 31, 125, 139, 131, 115, 105, 132, 104, 123, 35, 113, 122, 42, 117, 119, 58, 109, 23, 105, 63, 27, 44, 105, 99, 41, 128, 121, 116, 125, 32, 61, 37, 127, 29, 113, 121, 58, 114, 126, 53, 114, 96, 25, 109, 7, 31, 141, 46, 13, 27, 43, 117, 116, 27, 7, 68, 40, 31, 115, 124, 42, 128, 52, 71, 118, 117, 38, 27, 106, 33, 117, 116, 111, 40, 119, 47, 105, 57, 122, 109, 124, 115, 43, 120, 43, 27, 27, 18, 28, 48, 125, 107, 114, 34, 133, 45, 120, 30, 127, 31, 116, 146});

struct CodeBlock1
{
    CodeBlock1()
    {
        leaf_plot(data);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Stern-Brocot_sequence#Python
import math

def stern_brocot(predicate=lambda series: len(series) < 20):
    sb = [1, 1]
    i = 0
    while predicate(sb):
        sb += [sum(sb[i:i + 2]), sb[i + 1]]
        i += 1
    return sb

n_first = 15
print('The first %i values:\n  ' % n_first,
      stern_brocot(lambda series: len(series) < n_first)[:n_first])
print()
n_max = 10
for n_occur in list(range(1, n_max + 1)) + [100]:
    print('1-based index of the first occurrence of %3i in the series:' % n_occur,
          stern_brocot(lambda series: n_occur not in series).index(n_occur) + 1)
          # The following would be much faster. Note that new values always occur at odd indices
          # len(stern_brocot(lambda series: n_occur != series[-2])) - 1)

print()
n_gcd = 1000
s = stern_brocot(lambda series: len(series) < n_gcd)[:n_gcd]
assert all(math.gcd(prev, this) == 1
           for prev, this in zip(s, s[1:])), 'A fraction from adjacent terms is reducible'
===
F stern_brocot(predicate = series -> series.len < 20)
   V sb = [1, 1]
   V i = 0
   L predicate(sb)
      sb [+]= [sum(sb[i .< i + 2]), sb[i + 1]]
      i++
   R sb

V n_first = 15
print(("The first #. values:\n  ".format(n_first))‘ ’stern_brocot(series -> series.len < :n_first)[0 .< n_first])
print()
V n_max = 10
L(n_occur) Array(1 .. n_max) [+] [100]
   print((‘1-based index of the first occurrence of #3 in the series:’.format(n_occur))‘ ’(stern_brocot(series -> @n_occur !C series).index(n_occur) + 1))

print()
V n_gcd = 1000
V s = stern_brocot(series -> series.len < :n_gcd)[0 .< n_gcd]
assert(all(zip(s, s[1..]).map((prev, this) -> gcd(prev, this) == 1)), ‘A fraction from adjacent terms is reducible’)
===
template <typename T1 = decltype([](const auto &series){return series.len() < 20;})> auto stern_brocot(const T1 &predicate = [](const auto &series){return series.len() < 20;})
{
    auto sb = create_array({1, 1});
    auto i = 0;
    while (predicate(sb)) {
        sb.append(create_array({sum(sb[range_el(i, i + 2)]), sb[i + 1]}));
        i++;
    }
    return sb;
}

auto n_first = 15;

struct CodeBlock1
{
    CodeBlock1()
    {
        print((u"The first #. values:\n  "_S.format(n_first)) & u" "_S & stern_brocot([](const auto &series){return series.len() < ::n_first;})[range_el(0, n_first)]);
        print();
    }
} code_block_1;

auto n_max = 10;

struct CodeBlock2
{
    CodeBlock2()
    {
        for (auto &&n_occur : create_array(range_ee(1, n_max)) + create_array({100}))
            print((u"1-based index of the first occurrence of #3 in the series:"_S.format(n_occur)) & u" "_S & (stern_brocot([&n_occur](const auto &series){return !in(n_occur, series);}).index(n_occur) + 1));

        print();
    }
} code_block_2;

auto n_gcd = 1000;
auto s = stern_brocot([](const auto &series){return series.len() < ::n_gcd;})[range_el(0, n_gcd)];

struct CodeBlock3
{
    CodeBlock3()
    {
        assert(all_map(zip(s, s[range_ei(1)]), [](const auto &prev, const auto &_this_){return gcd(prev, _this_) == 1;}), u"A fraction from adjacent terms is reducible"_S);
    }
} code_block_3;


# https://www.rosettacode.org/wiki/Strange_numbers#Python
def is_strange(n):
    xs = [int(c) for c in str(n)]
    return all(abs(a - b) in (2, 3, 5, 7) for a, b in zip(xs, xs[1:]))

xs = [n for n in range(100, 501) if is_strange(n)]
print('\nStrange numbers in range [100..500]\n')
print('(Total: ' + str(len(xs)) + ')\n')
for i, el in enumerate(xs):
    print(el, end = ' ')
    if i % 10 == 9:
        print()
===
F is_strange(n)
   V xs = String(n).map(c -> Int(c))
   R all(zip(xs, xs[1..]).map((a, b) -> abs(a - b) C (2, 3, 5, 7)))

V xs = (100..500).filter(n -> is_strange(n))
print("\nStrange numbers in range [100..500]\n")
print(‘(Total: ’String(xs.len)")\n")
L(el) xs
   V i = L.index
   print(el, end' ‘ ’)
   I i % 10 == 9
      print()
===
template <typename T1> auto is_strange(const T1 &n)
{
    auto xs = String(n).map([](const auto &c){return to_int(c);});
    return all_map(zip(xs, xs[range_ei(1)]), [](const auto &a, const auto &b){return in(abs(a - b), make_tuple(2, 3, 5, 7));});
}

auto xs = range_ee(100, 500).filter([](const auto &n){return is_strange(n);});

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"\nStrange numbers in range [100..500]\n"_S);
        print(u"(Total: "_S & String(xs.len()) & u")\n"_S);
        {int Lindex = 0;
        for (auto &&el : xs) {
            auto i = Lindex;
            print(el, u" "_S);
            if (mod(i, 10) == 9)
                print();
            Lindex++;
        }}
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Strange_plus_numbers#Python
def is_strange_plus(n):
    xs = [int(c) for c in str(n)]
    return all(a + b in (2, 3, 5, 7, 11, 13, 17) for a, b in zip(xs, xs[1:]))

xs = [n for n in range(100, 501) if is_strange_plus(n)]
print('\n"Strange Plus" numbers in range [100..500]\n')
print('(Total: ' + str(len(xs)) + ')\n')
for i, el in enumerate(xs):
    print(el, end = ' ')
    if i % 10 == 9:
        print()
===
F is_strange_plus(n)
   V xs = String(n).map(c -> Int(c))
   R all(zip(xs, xs[1..]).map((a, b) -> a + b C (2, 3, 5, 7, 11, 13, 17)))

V xs = (100..500).filter(n -> is_strange_plus(n))
print("\n\"Strange Plus\" numbers in range [100..500]\n")
print(‘(Total: ’String(xs.len)")\n")
L(el) xs
   V i = L.index
   print(el, end' ‘ ’)
   I i % 10 == 9
      print()
===
template <typename T1> auto is_strange_plus(const T1 &n)
{
    auto xs = String(n).map([](const auto &c){return to_int(c);});
    return all_map(zip(xs, xs[range_ei(1)]), [](const auto &a, const auto &b){return in(a + b, make_tuple(2, 3, 5, 7, 11, 13, 17));});
}

auto xs = range_ee(100, 500).filter([](const auto &n){return is_strange_plus(n);});

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"\n\"Strange Plus\" numbers in range [100..500]\n"_S);
        print(u"(Total: "_S & String(xs.len()) & u")\n"_S);
        {int Lindex = 0;
        for (auto &&el : xs) {
            auto i = Lindex;
            print(el, u" "_S);
            if (mod(i, 10) == 9)
                print();
            Lindex++;
        }}
    }
} code_block_1;


# https://www.rosettacode.org/wiki/String_append#Python
s = "12345678"
s += "9!"
print(s)
===
V s = ‘12345678’
s ‘’= ‘9!’
print(s)
===
auto s = u"12345678"_S;

struct CodeBlock1
{
    CodeBlock1()
    {
        s &= u"9!"_S;
        print(s);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/String_case#Python
s = "alphaBETA"
print(s.upper()) # => "ALPHABETA"
print(s.lower()) # => "alphabeta"
===
V s = ‘alphaBETA’
print(s.uppercase())
print(s.lowercase())
===
auto s = u"alphaBETA"_S;

struct CodeBlock1
{
    CodeBlock1()
    {
        print(s.uppercase());
        print(s.lowercase());
    }
} code_block_1;


# https://www.rosettacode.org/wiki/String_comparison#Python
def compare(a, b):
    if a <  b: print("'%s' is strictly less than  '%s'" % (a, b))
    if a <= b: print("'%s' is less than or equal to '%s'" % (a, b))
    if a >  b: print("'%s' is strictly greater than  '%s'" % (a, b))
    if a >= b: print("'%s' is greater than or equal to '%s'" % (a, b))
    if a == b: print("'%s' is equal to '%s'" % (a, b))
    if a != b: print("'%s' is not equal to '%s'" % (a, b))

compare('YUP', 'YUP')
compare('BALL', 'BELL')
compare('24', '123')
===
F compare(a, b)
   I a < b
      print(‘'#.' is strictly less than  '#.'’.format(a, b))
   I a <= b
      print(‘'#.' is less than or equal to '#.'’.format(a, b))
   I a > b
      print(‘'#.' is strictly greater than  '#.'’.format(a, b))
   I a >= b
      print(‘'#.' is greater than or equal to '#.'’.format(a, b))
   I a == b
      print(‘'#.' is equal to '#.'’.format(a, b))
   I a != b
      print(‘'#.' is not equal to '#.'’.format(a, b))

compare(‘YUP’, ‘YUP’)
compare(‘BALL’, ‘BELL’)
compare(‘24’, ‘123’)
===
template <typename T1, typename T2> auto compare(const T1 &a, const T2 &b)
{
    if (a < b)
        print(u"'#.' is strictly less than  '#.'"_S.format(a, b));
    if (a <= b)
        print(u"'#.' is less than or equal to '#.'"_S.format(a, b));
    if (a > b)
        print(u"'#.' is strictly greater than  '#.'"_S.format(a, b));
    if (a >= b)
        print(u"'#.' is greater than or equal to '#.'"_S.format(a, b));
    if (a == b)
        print(u"'#.' is equal to '#.'"_S.format(a, b));
    if (a != b)
        print(u"'#.' is not equal to '#.'"_S.format(a, b));
}

struct CodeBlock1
{
    CodeBlock1()
    {
        compare(u"YUP"_S, u"YUP"_S);
        compare(u"BALL"_S, u"BELL"_S);
        compare(u"24"_S, u"123"_S);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/String_concatenation#Python
s1 = "hello"
print(s1 + " world")

s2 = s1 + " world"
print(s2)
===
V s1 = ‘hello’
print(s1‘ world’)

V s2 = s1‘ world’
print(s2)
===
auto s1 = u"hello"_S;

struct CodeBlock1
{
    CodeBlock1()
    {
        print(s1 & u" world"_S);
    }
} code_block_1;

auto s2 = s1 & u" world"_S;

struct CodeBlock2
{
    CodeBlock2()
    {
        print(s2);
    }
} code_block_2;


# https://www.rosettacode.org/wiki/String_interpolation_(included)
extra = 'little'
print('Mary had a ' + extra + ' lamb.')
print('Mary had a %s lamb.' % extra)
===
V extra = ‘little’
print(‘Mary had a ’extra‘ lamb.’)
print(‘Mary had a #. lamb.’.format(extra))
===
auto extra = u"little"_S;

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"Mary had a "_S & extra & u" lamb."_S);
        print(u"Mary had a #. lamb."_S.format(extra));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/String_matching#Python
print("abcd".startswith("ab")) #returns True
print("abcd".endswith("zn")) #returns False
print("bb" in "abab") #returns False
print("ab" in "abab") #returns True
print("abab".find("bb")) #returns -1
print("abab".find("ab")) #returns 0
===
print(‘abcd’.starts_with(‘ab’))
print(‘abcd’.ends_with(‘zn’))
print(‘bb’ C ‘abab’)
print(‘ab’ C ‘abab’)
print(‘abab’.findi(‘bb’))
print(‘abab’.findi(‘ab’))
===
struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"abcd"_S.starts_with(u"ab"_S));
        print(u"abcd"_S.ends_with(u"zn"_S));
        print(in(u"bb"_S, u"abab"_S));
        print(in(u"ab"_S, u"abab"_S));
        print(u"abab"_S.findi(u"bb"_S));
        print(u"abab"_S.findi(u"ab"_S));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/String_prepend#Python
s = "12345678"
s = "0" + s
print(s)
===
V s = ‘12345678’
s = ‘0’s
print(s)
===
auto s = u"12345678"_S;

struct CodeBlock1
{
    CodeBlock1()
    {
        s = u"0"_S & s;
        print(s);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Strip_a_set_of_characters_from_a_string#Python
def stripchars(s, chars):
    return "".join(c for c in s if c not in chars)

print(stripchars("She was a soul stripper. She took my heart!", "aei"))
===
F stripchars(s, chars)
   R s.filter(c -> c !C @chars).join(‘’)

print(stripchars(‘She was a soul stripper. She took my heart!’, ‘aei’))
===
template <typename T1, typename T2> auto stripchars(const T1 &s, const T2 &chars)
{
    return s.filter([&chars](const auto &c){return !in(c, chars);}).join(u""_S);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(stripchars(u"She was a soul stripper. She took my heart!"_S, u"aei"_S));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Strip_block_comments
def strip_comments(s, b_delim = '/*', e_delim = '*/'):
    r = ''
    i = 0
    while True:
        p = s.find(b_delim, i)
        if p == -1:
            break
        r += s[i:p]
        e = s.find(e_delim, p + len(b_delim))
        assert(e != -1)
        i = e + len(e_delim)
    r += s[i:]
    return r

text = '''
  /**
   * Some comments
   * longer comments here that we can parse.
   *
   * Rahoo
      */
   function subroutine() {
    a = /* inline comment */ b + c ;
   }
   /*/ <-- tricky comments */

   /**
    * Another comment.
    */
    function something() {
    }'''

print(strip_comments(text))
===
F strip_comments(s, b_delim = ‘/*’, e_delim = ‘*/’)
   V r = ‘’
   V i = 0
   L
      V p = s.findi(b_delim, i)
      I p == -1
         L.break
      r ‘’= s[i .< p]
      V e = s.findi(e_delim, p + b_delim.len)
      assert(e != -1)
      i = e + e_delim.len
   r ‘’= s[i ..]
   R r

V text = ‘
  /**
   * Some comments
   * longer comments here that we can parse.
   *
   * Rahoo
      */
   function subroutine() {
    a = /* inline comment */ b + c ;
   }
   /*/ <-- tricky comments */

   /**
    * Another comment.
    */
    function something() {
    }’

print(strip_comments(text))
===
template <typename T1, typename T2 = decltype(u"/*"_S), typename T3 = decltype(u"*/"_S)> auto strip_comments(const T1 &s, const T2 &b_delim = u"/*"_S, const T3 &e_delim = u"*/"_S)
{
    auto r = u""_S;
    auto i = 0;
    while (true) {
        auto p = s.findi(b_delim, i);
        if (p == -1)
            break;
        r &= s[range_el(i, p)];
        auto e = s.findi(e_delim, p + b_delim.len());
        assert(e != -1);
        i = e + e_delim.len();
    }
    r &= s[range_ei(i)];
    return r;
}

auto text = uR"(
  /**
   * Some comments
   * longer comments here that we can parse.
   *
   * Rahoo
      */
   function subroutine() {
    a = /* inline comment */ b + c ;
   }
   /*/ <-- tricky comments */

   /**
    * Another comment.
    */
    function something() {
    })"_S;

struct CodeBlock1
{
    CodeBlock1()
    {
        print(strip_comments(text));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Strip_control_codes_and_extended_characters_from_a_string#Python
def stripped(s):
    return ''.join(i for i in s if 32 <= int(ord(i)) <= 126)

print(stripped("\ba\u0000b\n\rc\fd\xc3"))
===
F stripped(s)
   R s.filter(i -> Int(i.code) C 32..126).join(‘’)

print(stripped("\ba\u0000b\n\rc\fd\xc3"))
===
template <typename T1> auto stripped(const T1 &s)
{
    return s.filter([](const auto &i){return in(to_int(i.code), range_ee(32, 126));}).join(u""_S);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(stripped(u"\ba\u0000b\n\rc\fd\xc3"_S));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Strip_whitespace_from_a_string/Top_and_tail#Python
s = " \t \r \n String with spaces  \t  \r  \n  "
print(len(s.lstrip()))
print(len(s.rstrip()))
print(len(s.strip()))
===
V s = " \t \r \n String with spaces  \t  \r  \n  "
print(s.ltrim((‘ ’, "\t", "\r", "\n")).len)
print(s.rtrim((‘ ’, "\t", "\r", "\n")).len)
print(s.trim((‘ ’, "\t", "\r", "\n")).len)
===
auto s = u" \t \r \n String with spaces  \t  \r  \n  "_S;

struct CodeBlock1
{
    CodeBlock1()
    {
        print(s.ltrim(make_tuple(u" "_S, u"\t"_S, u"\r"_S, u"\n"_S)).len());
        print(s.rtrim(make_tuple(u" "_S, u"\t"_S, u"\r"_S, u"\n"_S)).len());
        print(s.trim(make_tuple(u" "_S, u"\t"_S, u"\r"_S, u"\n"_S)).len());
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Subleq#Python
import sys

def subleq(a : list):
    i = 0
    while i >= 0:
        if a[i] == -1:
            a[a[i + 1]] = ord(sys.stdin.read(1))
        elif a[i + 1] == -1:
            print(chr(a[a[i]]), end="")
        else:
            a[a[i + 1]] -= a[a[i]]
            if a[a[i + 1]] <= 0:
                i = a[i + 2]
                continue
        i += 3

subleq([15, 17, -1, 17, -1, -1, 16, 1, -1, 16, 3, -1, 15, 15,
        0, 0, -1, 72, 101, 108, 108, 111, 44, 32, 119, 111,
        114, 108, 100, 33, 10, 0])
===
F subleq(&a)
   V i = 0
   L i >= 0
      I a[i] == -1
         a[a[i + 1]] = :stdin.read(1).code
      E I a[i + 1] == -1
         print(Char(code' a[a[i]]), end' ‘’)
      E
         a[a[i + 1]] -= a[a[i]]
         I a[a[i + 1]] <= 0
            i = a[i + 2]
            L.continue
      i += 3

subleq(&[15, 17, -1, 17, -1, -1, 16, 1, -1, 16, 3, -1, 15, 15, 0, 0, -1, 72, 101, 108, 108, 111, 44, 32, 119, 111, 114, 108, 100, 33, 10, 0])
===
template <typename T1> auto subleq(T1 &a)
{
    auto i = 0;
    while (i >= 0) {
        if (a[i] == -1)
            a.set(a[i + 1], _stdin.read(1).code);
        else if (a[i + 1] == -1)
            print(Char(a[a[i]]), u""_S);
        else {
            a[a[i + 1]] -= a[a[i]];
            if (a[a[i + 1]] <= 0) {
                i = a[i + 2];
                continue;
            }
        }
        i += 3;
    }
}

struct CodeBlock1
{
    CodeBlock1()
    {
        subleq(make_ref(create_array({15, 17, -1, 17, -1, -1, 16, 1, -1, 16, 3, -1, 15, 15, 0, 0, -1, 72, 101, 108, 108, 111, 44, 32, 119, 111, 114, 108, 100, 33, 10, 0})));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Subset_sum_problem#Python
words = { # some values are different from example
    "alliance": -624,   "archbishop": -925, "balm": 397,
    "bonnet": 452,      "brute": 870,       "centipede": -658,
    "cobol": 362,       "covariate": 590,   "departure": 952,
    "deploy": 44,       "diophantine": 645, "efferent": 54,
    "elysee": -326,     "eradicate": 376,   "escritoire": 856,
    "exorcism": -983,   "fiat": 170,        "filmy": -874,
    "flatworm": 503,    "gestapo": 915,     "infra": -847,
    "isis": -982,       "lindholm": 999,    "markham": 475,
    "mincemeat": -880,  "moresby": 756,     "mycenae": 183,
    "plugging": -266,   "smokescreen": 423, "speakeasy": -745,
    "vein": 813
}

neg = 0
pos = 0
for w,v in words.items():
    if v > 0: pos += v
    else:     neg += v

sums = [['']*0] * (pos - neg + 1)

for w,v in words.items():
    s = sums[:]
    if len(s[v - neg]) == 0: s[v - neg] = [w]

    for i, w2 in enumerate(sums):
        if len(w2) != 0 and len(s[i + v]) == 0:
            s[i + v] = w2 + [w]

    sums = s
    if len(s[(-neg)]):
        for x in s[(-neg)]:
            print(x, words[x])
        break
===
V words = [‘alliance’ = -624, ‘archbishop’ = -925, ‘balm’ = 397, ‘bonnet’ = 452, ‘brute’ = 870, ‘centipede’ = -658, ‘cobol’ = 362, ‘covariate’ = 590, ‘departure’ = 952, ‘deploy’ = 44, ‘diophantine’ = 645, ‘efferent’ = 54, ‘elysee’ = -326, ‘eradicate’ = 376, ‘escritoire’ = 856, ‘exorcism’ = -983, ‘fiat’ = 170, ‘filmy’ = -874, ‘flatworm’ = 503, ‘gestapo’ = 915, ‘infra’ = -847, ‘isis’ = -982, ‘lindholm’ = 999, ‘markham’ = 475, ‘mincemeat’ = -880, ‘moresby’ = 756, ‘mycenae’ = 183, ‘plugging’ = -266, ‘smokescreen’ = 423, ‘speakeasy’ = -745, ‘vein’ = 813]

V neg = 0
V pos = 0
L(w, v) words
   I v > 0
      pos += v
   E
      neg += v

V sums = [[‘’] * 0] * (pos - neg + 1)

L(w, v) words
   V s = copy(sums)
   I s[v - neg].empty
      s[v - neg] = [w]

   L(w2) sums
      V i = L.index
      I !w2.empty & s[i + v].empty
         s[i + v] = w2 [+] [w]

   sums = s
   I !s[(-neg)].empty
      L(x) s[(-neg)]
         print(x‘ ’words[x])
      L.break
===
auto words = create_dict(dict_of(u"alliance"_S, -624)(u"archbishop"_S, -925)(u"balm"_S, 397)(u"bonnet"_S, 452)(u"brute"_S, 870)(u"centipede"_S, -658)(u"cobol"_S, 362)(u"covariate"_S, 590)(u"departure"_S, 952)(u"deploy"_S, 44)(u"diophantine"_S, 645)(u"efferent"_S, 54)(u"elysee"_S, -326)(u"eradicate"_S, 376)(u"escritoire"_S, 856)(u"exorcism"_S, -983)(u"fiat"_S, 170)(u"filmy"_S, -874)(u"flatworm"_S, 503)(u"gestapo"_S, 915)(u"infra"_S, -847)(u"isis"_S, -982)(u"lindholm"_S, 999)(u"markham"_S, 475)(u"mincemeat"_S, -880)(u"moresby"_S, 756)(u"mycenae"_S, 183)(u"plugging"_S, -266)(u"smokescreen"_S, 423)(u"speakeasy"_S, -745)(u"vein"_S, 813));

auto neg = 0;
auto pos = 0;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&[w, v] : words)
            if (v > 0)
                pos += v;
            else
                neg += v;
    }
} code_block_1;

auto sums = create_array({create_array({u""_S}) * 0}) * (pos - neg + 1);

struct CodeBlock2
{
    CodeBlock2()
    {
        for (auto &&[w, v] : words) {
            auto s = copy(sums);
            if (s[v - neg].empty())
                s.set(v - neg, create_array({w}));
            {int Lindex = 0;

            for (auto &&w2 : sums) {
                auto i = Lindex;
                if (!w2.empty() && s[i + v].empty())
                    s.set(i + v, w2 + create_array({w}));
                Lindex++;
            }}

            sums = s;
            if (!s[(-neg)].empty()) {
                for (auto &&x : s[(-neg)])
                    print(x & u" "_S & words[x]);
                break;
            }
        }
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Substitution_cipher#Kotlin
key = R''']kYV}(!7P$n5_0i R:?jOWtF/=-pe'AD&@r6%ZXs"v*N[#wSl9zq2^+g;LoB`aGh{3.HIu4fbK)mU8|dMET><,Qc\C1yxJ'''

def encode(s):
    r = ''
    for c in s:
        r += key[ord(c) - 32]
    return r

def decode(s):
    r = ''
    for c in s:
        r += chr(key.index(c) + 32)
    return r

s = "The quick brown fox jumps over the lazy dog, who barks VERY loudly!"
enc = encode(s)
print("Encoded:  " + enc)
print("Decoded:  " + decode(enc))
===
V key = ‘]kYV}(!7P$n5_0i R:?jOWtF/=-pe'AD&@r6%ZXs"v*N[#wSl9zq2^+g;LoB`aGh{3.HIu4fbK)mU8|dMET><,Qc\C1yxJ’

F encode(s)
   V r = ‘’
   L(c) s
      r ‘’= :key[c.code - 32]
   R r

F decode(s)
   V r = ‘’
   L(c) s
      r ‘’= Char(code' :key.index(c) + 32)
   R r

V s = ‘The quick brown fox jumps over the lazy dog, who barks VERY loudly!’
V enc = encode(s)
print(‘Encoded:  ’enc)
print(‘Decoded:  ’decode(enc))
===
auto key = uR"(]kYV}(!7P$n5_0i R:?jOWtF/=-pe'AD&@r6%ZXs"v*N[#wSl9zq2^+g;LoB`aGh{3.HIu4fbK)mU8|dMET><,Qc\C1yxJ)"_S;

template <typename T1> auto encode(const T1 &s)
{
    auto r = u""_S;
    for (auto &&c : s)
        r &= ::key[c.code - 32];
    return r;
}

template <typename T1> auto decode(const T1 &s)
{
    auto r = u""_S;
    for (auto &&c : s)
        r &= Char(::key.index(c) + 32);
    return r;
}

auto s = u"The quick brown fox jumps over the lazy dog, who barks VERY loudly!"_S;
auto enc = encode(s);

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"Encoded:  "_S & enc);
        print(u"Decoded:  "_S & decode(enc));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Substring#Python
s = 'abcdefgh'
n = 2
m = 3
char = 'd'
chars = 'cd'

print(s[n-1:n+m-1])
print(s[n-1:])
print(s[:-1])
indx = s.index(char)
print(s[indx:indx+m])
indx = s.index(chars)
print(s[indx:indx+m])
===
V s = ‘abcdefgh’
V n = 2
V m = 3
V char = ‘d’
V chars = ‘cd’

print(s[n - 1 .< n + m - 1])
print(s[n - 1 ..])
print(s[0 .< (len)-1])
V indx = s.index(char)
print(s[indx .< indx + m])
indx = s.index(chars)
print(s[indx .< indx + m])
===
auto s = u"abcdefgh"_S;
auto n = 2;
auto m = 3;
auto _char_ = u"d"_S;
auto chars = u"cd"_S;

struct CodeBlock1
{
    CodeBlock1()
    {
        print(s[range_el(n - 1, n + m - 1)]);
        print(s[range_ei(n - 1)]);
        print(s[range_e_llen(0,  - 1)]);
    }
} code_block_1;

auto indx = s.index(_char_);

struct CodeBlock2
{
    CodeBlock2()
    {
        print(s[range_el(indx, indx + m)]);
        indx = s.index(chars);
        print(s[range_el(indx, indx + m)]);
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Substring/Top_and_tail#Python
print("knight"[1:])     # strip first character
print("socks"[:-1])     # strip last character
print("brooms"[1:-1])   # strip both first and last characters
===
print(‘knight’[1..])
print(‘socks’[0 .< (len)-1])
print(‘brooms’[1 .< (len)-1])
===
struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"knight"_S[range_ei(1)]);
        print(u"socks"_S[range_e_llen(0,  - 1)]);
        print(u"brooms"_S[range_e_llen(1,  - 1)]);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Subtractive_generator#Python
import collections
s = collections.deque() # int
seed = 292929

s.append(seed)
s.append(1)

for n in range(2, 55):
    s.append((s[n-2] - s[n-1]) % 10**9)

r = collections.deque() # int
for n in range(55):
    i = (34 * (n+1)) % 55
    r.append(s[i])

def py_mod(a, b):
    return ((a % b) + b) % b

def getnextr():
    r.append(py_mod((r[0]-r[31]), 10**9))
    r.popleft()
    return r[54]

for n in range(219 - 54):
    getnextr()

for i in range(5):
    print("result =", getnextr())
===
V s = Deque[Int]()
V seed = 292929

s.append(seed)
s.append(1)

L(n) 2..54
   s.append((s[n - 2] - s[n - 1]) % 10 ^ 9)

V r = Deque[Int]()
L(n) 55
   V i = (34 * (n + 1)) % 55
   r.append(s[i])

F py_mod(a, b)
   R ((a % b) + b) % b

F getnextr()
   :r.append(py_mod((:r[0] - :r[31]), 10 ^ 9))
   :r.pop_left()
   R :r[54]

L(n) 0 .< 219 - 54
   getnextr()

L(i) 5
   print(‘result = ’getnextr())
===
auto s = Deque<int>();
auto seed = 292929;

struct CodeBlock1
{
    CodeBlock1()
    {
        s.append(seed);
        s.append(1);

        for (auto n : range_ee(2, 54))
            s.append(mod((s[n - 2] - s[n - 1]), pow(10, 9)));
    }
} code_block_1;

auto r = Deque<int>();

struct CodeBlock2
{
    CodeBlock2()
    {
        for (int n = 0; n < 55; n++) {
            auto i = mod((34 * (n + 1)), 55);
            r.append(s[i]);
        }
    }
} code_block_2;

template <typename T1, typename T2> auto py_mod(const T1 &a, const T2 &b)
{
    return mod(((mod(a, b)) + b), b);
}

auto getnextr()
{
    ::r.append(py_mod((_get<0>(::r) - _get<31>(::r)), pow(10, 9)));
    ::r.pop_left();
    return _get<54>(::r);
}

struct CodeBlock3
{
    CodeBlock3()
    {
        for (auto n : range_el(0, 219 - 54))
            getnextr();

        for (int i = 0; i < 5; i++)
            print(u"result = "_S & getnextr());
    }
} code_block_3;


# https://www.rosettacode.org/wiki/Suffix_tree#Python
from typing import List

class Node:
    sub : str
    ch : List[int]
    def __init__(self, sub, children):
        self.sub = sub
        self.ch = children

class SuffixTree:
    def __init__(self, str):
        self.nodes = [Node('', [0]*0)]
        for i in range(len(str)):
            self.addSuffix(str[i:])

    def addSuffix(self, suf):
        n = 0
        i = 0
        while i < len(suf):
            b = suf[i]
            x2 = 0
            n2 : int
            while True:
                children = self.nodes[n].ch
                if x2 == len(children):
                    # no matching child, remainder of suf becomes new node
                    n2 = len(self.nodes)
                    self.nodes.append(Node(suf[i:], [0]*0))
                    self.nodes[n].ch.append(n2)
                    return
                n2 = children[x2]
                if self.nodes[n2].sub[0] == b:
                    break
                x2 = x2 + 1

            # find prefix of remaining suffix in common with child
            sub2 = self.nodes[n2].sub
            j = 0
            while j < len(sub2):
                if suf[i + j] != sub2[j]:
                    # split n2
                    n3 = n2
                    # new node for the part in common
                    n2 = len(self.nodes)
                    self.nodes.append(Node(sub2[:j], [n3]))
                    self.nodes[n3].sub = sub2[j:] # old node loses the part in common
                    self.nodes[n].ch[x2] = n2
                    break # continue down the tree
                j = j + 1
            i = i + j   # advance past part in common
            n = n2      # continue down the tree

    def visualize(self):
        if len(self.nodes) == 0:
            print("<empty>")
            return

        def f(n : int, pre : str) -> None:
            children = self.nodes[n].ch
            if len(children) == 0:
                print("--", self.nodes[n].sub)
                return
            print("+-", self.nodes[n].sub)
            for c in children[:-1]:
                print(pre, "+-", end=' ')
                f(c, pre + " | ")
            print(pre, "+-", end=' ')
            f(children[-1], pre + "  ")

        f(0, "")

SuffixTree("banana$").visualize()
===
T Node
   String sub
   [Int] ch
   F (sub, children)
      .sub = sub
      .ch = children

T SuffixTree
   nodes = [Node(‘’, [Int]())]
   F (str)
      L(i) 0 .< str.len
         .addSuffix(str[i ..])

   F addSuffix(suf)
      V n = 0
      V i = 0
      L i < suf.len
         V b = suf[i]
         V x2 = 0
         Int n2
         L
            V children = .nodes[n].ch
            I x2 == children.len
               n2 = .nodes.len
               .nodes.append(Node(suf[i ..], [Int]()))
               .nodes[n].ch.append(n2)
               R
            n2 = children[x2]
            I .nodes[n2].sub[0] == b
               L.break
            x2 = x2 + 1

         V sub2 = .nodes[n2].sub
         V j = 0
         L j < sub2.len
            I suf[i + j] != sub2[j]
               V n3 = n2
               n2 = .nodes.len
               .nodes.append(Node(sub2[0 .< j], [n3]))
               .nodes[n3].sub = sub2[j ..]
               .nodes[n].ch[x2] = n2
               L.break
            j = j + 1
         i = i + j
         n = n2

   F visualize()
      I .nodes.empty
         print(‘<empty>’)
         R

      F f(Int n, String pre) -> N
         V children = @.nodes[n].ch
         I children.empty
            print(‘-- ’(@.nodes[n].sub))
            R
         print(‘+- ’(@.nodes[n].sub))
         L(c) children[0 .< (len)-1]
            print(pre‘ +-’, end' ‘ ’)
            @f(c, pre‘ | ’)
         print(pre‘ +-’, end' ‘ ’)
         @f(children.last, pre‘  ’)

      f(0, ‘’)

SuffixTree(‘banana$’).visualize()
===
class Node
{
public:
    String sub;
    Array<int> ch;
    template <typename T1, typename T2> Node(const T1 &sub, const T2 &children) :
        sub(sub),
        ch(children)
    {
    }
};

class SuffixTree
{
public:
    decltype(create_array({Node(u""_S, Array<int>())})) nodes = create_array({Node(u""_S, Array<int>())});
    template <typename T1> SuffixTree(const T1 &str)
    {
        for (auto i : range_el(0, str.len()))
            addSuffix(str[range_ei(i)]);
    }

    template <typename T1> auto addSuffix(const T1 &suf)
    {
        auto n = 0;
        auto i = 0;
        while (i < suf.len()) {
            auto b = suf[i];
            auto x2 = 0;
            int n2;
            while (true) {
                auto children = nodes[n].ch;
                if (x2 == children.len()) {
                    n2 = nodes.len();
                    nodes.append(Node(suf[range_ei(i)], Array<int>()));
                    nodes[n].ch.append(n2);
                    return;
                }
                n2 = children[x2];
                if (_get<0>(nodes[n2].sub) == b)
                    break;
                x2 = x2 + 1;
            }

            auto sub2 = nodes[n2].sub;
            auto j = 0;
            while (j < sub2.len()) {
                if (suf[i + j] != sub2[j]) {
                    auto n3 = n2;
                    n2 = nodes.len();
                    nodes.append(Node(sub2[range_el(0, j)], create_array({n3})));
                    nodes[n3].sub = sub2[range_ei(j)];
                    nodes[n].ch.set(x2, n2);
                    break;
                }
                j = j + 1;
            }
            i = i + j;
            n = n2;
        }
    }

    auto visualize()
    {
        if (nodes.empty()) {
            print(u"<empty>"_S);
            return;
        }

        std::function<void(int, String)> f = [&f, this](const int n, const String &pre)
        {
            auto children = nodes[n].ch;
            if (children.empty()) {
                print(u"-- "_S & (nodes[n].sub));
                return;
            }
            print(u"+- "_S & (nodes[n].sub));
            for (auto &&c : children[range_e_llen(0,  - 1)]) {
                print(pre & u" +-"_S, u" "_S);
                f(c, pre & u" | "_S);
            }
            print(pre & u" +-"_S, u" "_S);
            f(children.last(), pre & u"  "_S);
        };

        f(0, u""_S);
    }
};

struct CodeBlock1
{
    CodeBlock1()
    {
        SuffixTree(u"banana$"_S).visualize();
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Sum_digits_of_an_integer#Nim
def sum_digits(n, base):
    r = 0
    while n > 0:
        r += n % base
        n //= base
    return r

print(sum_digits(1, 10))
print(sum_digits(1234, 10))
print(sum_digits(0xFE, 16))
print(sum_digits(0xF0E, 16))
===
F sum_digits(=n, base)
   V r = 0
   L n > 0
      r += n % base
      n I/= base
   R r

print(sum_digits(1, 10))
print(sum_digits(1234, 10))
print(sum_digits(F'E, 16))
print(sum_digits(0F'0E, 16))
===
template <typename T1, typename T2> auto sum_digits(T1 n, const T2 &base)
{
    auto r = 0;
    while (n > 0) {
        r += mod(n, base);
        n = idiv(n, base);
    }
    return r;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(sum_digits(1, 10));
        print(sum_digits(1234, 10));
        print(sum_digits(0xFE, 16));
        print(sum_digits(0x0F'0E, 16));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Sum_multiples_of_3_and_5#C
def sum35(limit):
    sum = 0
    for i in range(1, limit):
        if i % 3 == 0 or i % 5 == 0:
            sum += i
    return sum

print(sum35(1000))
===
F sum35(limit)
   V sum = 0
   L(i) 1 .< limit
      I i % 3 == 0 | i % 5 == 0
         sum += i
   R sum

print(sum35(1000))
===
template <typename T1> auto sum35(const T1 &limit)
{
    auto sum = 0;
    for (auto i : range_el(1, limit))
        if (mod(i, 3) == 0 || mod(i, 5) == 0)
            sum += i;
    return sum;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(sum35(1000));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Sum_of_a_series#Python
print ( sum(1.0 / x**2 for x in range(1, 1001)) )
===
print(sum((1..1000).map(x -> 1.0 / x ^ 2)))
===
struct CodeBlock1
{
    CodeBlock1()
    {
        print(sum_map(range_ee(1, 1000), [](const auto &x){return 1.0 / square(x);}));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Sum_of_divisors#Python
def sum_of_divisors(n):
    ans = 0
    i = 1
    j = 1
    while i*i <= n:
        if 0 == n%i:
            ans += i
            j = n//i
            if j != i:
                ans += j
        i += 1
    return ans

print([sum_of_divisors(n) for n in range(1,101)])
===
F sum_of_divisors(n)
   V ans = 0
   V i = 1
   V j = 1
   L i * i <= n
      I 0 == n % i
         ans += i
         j = n I/ i
         I j != i
            ans += j
      i++
   R ans

print((1..100).map(n -> sum_of_divisors(n)))
===
template <typename T1> auto sum_of_divisors(const T1 &n)
{
    auto ans = 0;
    auto i = 1;
    auto j = 1;
    while (i * i <= n) {
        if (0 == mod(n, i)) {
            ans += i;
            j = idiv(n, i);
            if (j != i)
                ans += j;
        }
        i++;
    }
    return ans;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(range_ee(1, 100).map([](const auto &n){return sum_of_divisors(n);}));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Sum_of_squares#Python
print(sum(x**2 for x in [1, 2, 3, 4, 5]))
===
print(sum([1, 2, 3, 4, 5].map(x -> x ^ 2)))
===
struct CodeBlock1
{
    CodeBlock1()
    {
        print(sum_map(create_array({1, 2, 3, 4, 5}), [](const auto &x){return square(x);}));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Sutherland-Hodgman_polygon_clipping#Python
def clip(subjectPolygon, clipPolygon):
   def inside(p, cp1, cp2):
      return(cp2[0]-cp1[0])*(p[1]-cp1[1]) > (cp2[1]-cp1[1])*(p[0]-cp1[0])

   def computeIntersection(s, e, cp1, cp2):
      dc = (cp1[0] - cp2[0], cp1[1] - cp2[1])
      dp = (s[0] - e[0], s[1] - e[1])
      n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0]
      n2 = s[0] * e[1] - s[1] * e[0]
      n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0])
      return ((n1*dp[0] - n2*dc[0]) * n3, (n1*dp[1] - n2*dc[1]) * n3)

   outputList = subjectPolygon
   cp1 = clipPolygon[-1]

   for clipVertex in clipPolygon:
      cp2 = clipVertex
      inputList = outputList
      outputList = []
      s = inputList[-1]

      for subjectVertex in inputList:
         e = subjectVertex
         if inside(e, cp1, cp2):
            if not inside(s, cp1, cp2):
               outputList.append(computeIntersection(s, e, cp1, cp2))
            outputList.append(e)
         elif inside(s, cp1, cp2):
            outputList.append(computeIntersection(s, e, cp1, cp2))
         s = e
      cp1 = cp2
   return(outputList)

subjectp = [(50.0, 150.0), (200.0, 50.0), (350.0, 150.0), (350.0, 300.0), (250.0, 300.0), (200.0, 250.0), (150.0, 350.0), (100.0, 250.0), (100.0, 200.0)]
clipp = [(100.0, 100.0), (300.0, 100.0), (300.0, 300.0), (100.0, 300.0)]

print(*clip(subjectp, clipp), sep = "\n")
===
F clip(subjectPolygon, clipPolygon)
   F inside(p, cp1, cp2)
      R (cp2[0] - cp1[0]) * (p[1] - cp1[1]) > (cp2[1] - cp1[1]) * (p[0] - cp1[0])

   F computeIntersection(s, e, cp1, cp2)
      V dc = (cp1[0] - cp2[0], cp1[1] - cp2[1])
      V dp = (s[0] - e[0], s[1] - e[1])
      V n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0]
      V n2 = s[0] * e[1] - s[1] * e[0]
      V n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0])
      R ((n1 * dp[0] - n2 * dc[0]) * n3, (n1 * dp[1] - n2 * dc[1]) * n3)

   V outputList = subjectPolygon
   V cp1 = clipPolygon.last

   L(clipVertex) clipPolygon
      V cp2 = clipVertex
      V inputList = outputList
      outputList.drop()
      V s = inputList.last

      L(subjectVertex) inputList
         V e = subjectVertex
         I inside(e, cp1, cp2)
            I !inside(s, cp1, cp2)
               outputList.append(computeIntersection(s, e, cp1, cp2))
            outputList.append(e)
         E I inside(s, cp1, cp2)
            outputList.append(computeIntersection(s, e, cp1, cp2))
         s = e
      cp1 = cp2
   R (outputList)

V subjectp = [(50.0, 150.0), (200.0, 50.0), (350.0, 150.0), (350.0, 300.0), (250.0, 300.0), (200.0, 250.0), (150.0, 350.0), (100.0, 250.0), (100.0, 200.0)]
V clipp = [(100.0, 100.0), (300.0, 100.0), (300.0, 300.0), (100.0, 300.0)]

print_elements(clip(subjectp, clipp), sep' "\n")
===
template <typename T1, typename T2> auto clip(const T1 &subjectPolygon, const T2 &clipPolygon)
{
    auto inside = [](const auto &p, const auto &cp1, const auto &cp2)
    {
        return (_get<0>(cp2) - _get<0>(cp1)) * (_get<1>(p) - _get<1>(cp1)) > (_get<1>(cp2) - _get<1>(cp1)) * (_get<0>(p) - _get<0>(cp1));
    };

    auto computeIntersection = [](const auto &s, const auto &e, const auto &cp1, const auto &cp2)
    {
        auto dc = make_tuple(_get<0>(cp1) - _get<0>(cp2), _get<1>(cp1) - _get<1>(cp2));
        auto dp = make_tuple(_get<0>(s) - _get<0>(e), _get<1>(s) - _get<1>(e));
        auto n1 = _get<0>(cp1) * _get<1>(cp2) - _get<1>(cp1) * _get<0>(cp2);
        auto n2 = _get<0>(s) * _get<1>(e) - _get<1>(s) * _get<0>(e);
        auto n3 = 1.0 / (_get<0>(dc) * _get<1>(dp) - _get<1>(dc) * _get<0>(dp));
        return make_tuple((n1 * _get<0>(dp) - n2 * _get<0>(dc)) * n3, (n1 * _get<1>(dp) - n2 * _get<1>(dc)) * n3);
    };

    auto outputList = subjectPolygon;
    auto cp1 = clipPolygon.last();

    for (auto &&clipVertex : clipPolygon) {
        auto cp2 = clipVertex;
        auto inputList = outputList;
        outputList.drop();
        auto s = inputList.last();

        for (auto &&subjectVertex : inputList) {
            auto e = subjectVertex;
            if (inside(e, cp1, cp2)) {
                if (!inside(s, cp1, cp2))
                    outputList.append(computeIntersection(s, e, cp1, cp2));
                outputList.append(e);
            }
            else if (inside(s, cp1, cp2))
                outputList.append(computeIntersection(s, e, cp1, cp2));
            s = e;
        }
        cp1 = cp2;
    }
    return (outputList);
}

auto subjectp = create_array({make_tuple(50.0, 150.0), make_tuple(200.0, 50.0), make_tuple(350.0, 150.0), make_tuple(350.0, 300.0), make_tuple(250.0, 300.0), make_tuple(200.0, 250.0), make_tuple(150.0, 350.0), make_tuple(100.0, 250.0), make_tuple(100.0, 200.0)});
auto clipp = create_array({make_tuple(100.0, 100.0), make_tuple(300.0, 100.0), make_tuple(300.0, 300.0), make_tuple(100.0, 300.0)});

struct CodeBlock1
{
    CodeBlock1()
    {
        print_elements(clip(subjectp, clipp), u"\n"_S);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Symmetric_difference#Python
setA = {"John", "Bob", "Mary", "Serena"}
setB = {"Jim", "Mary", "John", "Bob"}
print(setA.symmetric_difference(setB))
print(setA - setB)
print(setB - setA)
===
V setA = Set([‘John’, ‘Bob’, ‘Mary’, ‘Serena’])
V setB = Set([‘Jim’, ‘Mary’, ‘John’, ‘Bob’])
print(setA.symmetric_difference(setB))
print(setA - setB)
print(setB - setA)
===
auto setA = create_set({u"John"_S, u"Bob"_S, u"Mary"_S, u"Serena"_S});
auto setB = create_set({u"Jim"_S, u"Mary"_S, u"John"_S, u"Bob"_S});

struct CodeBlock1
{
    CodeBlock1()
    {
        print(setA.symmetric_difference(setB));
        print(setA - setB);
        print(setB - setA);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Stirling_numbers_of_the_first_kind#Python
from typing import Dict, Tuple
BigInt = int

computed : Dict[Tuple[int, int], BigInt] = {}

def sterling1(n, k):
    key = (n, k)

    if key in computed:
        return computed[key]
    if n == k == 0:
        return BigInt(1)
    if n > 0 and k == 0:
        return BigInt(0)
    if k > n:
        return BigInt(0)
    result = sterling1(n - 1, k - 1) + (n - 1) * sterling1(n - 1, k)
    computed[key] = result
    return result

print("Unsigned Stirling numbers of the first kind:")
MAX = 12
print("n/k".ljust(10), end="")
for n in range(MAX + 1):
    print(str(n).rjust(10), end="")
print()
for n in range(MAX + 1):
    print(str(n).ljust(10), end="")
    for k in range(n + 1):
        print(str(sterling1(n, k)).rjust(10), end="")
    print()
print("The maximum value of S1(100, k) = ")
previous : BigInt = 0
for k in range(1, 100 + 1):
    current = sterling1(100, k)
    if current > previous:
        previous = current
    else:
        print("{0}\n({1} digits, k = {2})\n".format(previous, len(str(previous)), k - 1))
        break
===
[(Int, Int) = BigInt] computed

F sterling1(n, k)
   V key = (n, k)

   I key C :computed
      R :computed[key]
   I n == k == 0
      R BigInt(1)
   I n > 0 & k == 0
      R BigInt(0)
   I k > n
      R BigInt(0)
   V result = sterling1(n - 1, k - 1) + (n - 1) * sterling1(n - 1, k)
   :computed[key] = result
   R result

print(‘Unsigned Stirling numbers of the first kind:’)
V MAX = 12
print(‘n/k’.ljust(10), end' ‘’)
L(n) 0 .. MAX
   print(String(n).rjust(10), end' ‘’)
print()
L(n) 0 .. MAX
   print(String(n).ljust(10), end' ‘’)
   L(k) 0 .. n
      print(String(sterling1(n, k)).rjust(10), end' ‘’)
   print()
print(‘The maximum value of S1(100, k) = ’)
BigInt previous = 0
L(k) 1 .. 100
   V current = sterling1(100, k)
   I current > previous
      previous = current
   E
      print("#.\n(#. digits, k = #.)\n".format(previous, String(previous).len, k - 1))
      L.break
===
Dict<ivec2, BigInt> computed;

template <typename T1, typename T2> auto sterling1(const T1 &n, const T2 &k)
{
    auto key = make_tuple(n, k);

    if (in(key, ::computed))
        return ::computed[key];
    if (equal(n, k, 0))
        return BigInt(1);
    if (n > 0 && k == 0)
        return BigInt(0);
    if (k > n)
        return BigInt(0);
    auto result = sterling1(n - 1, k - 1) + (n - 1) * sterling1(n - 1, k);
    ::computed.set(key, result);
    return result;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"Unsigned Stirling numbers of the first kind:"_S);
    }
} code_block_1;

auto MAX = 12;

struct CodeBlock2
{
    CodeBlock2()
    {
        print(u"n/k"_S.ljust(10), u""_S);
        for (auto n : range_ee(0, MAX))
            print(String(n).rjust(10), u""_S);
        print();
        for (auto n : range_ee(0, MAX)) {
            print(String(n).ljust(10), u""_S);
            for (auto k : range_ee(0, n))
                print(String(sterling1(n, k)).rjust(10), u""_S);
            print();
        }
        print(u"The maximum value of S1(100, k) = "_S);
    }
} code_block_2;

BigInt previous = 0;

struct CodeBlock3
{
    CodeBlock3()
    {
        for (auto k : range_ee(1, 100)) {
            auto current = sterling1(100, k);
            if (current > previous)
                previous = current;
            else {
                print(u"#.\n(#. digits, k = #.)\n"_S.format(previous, String(previous).len(), k - 1));
                break;
            }
        }
    }
} code_block_3;


# https://www.rosettacode.org/wiki/Stirling_numbers_of_the_second_kind#Python
from typing import Dict, Tuple
BigInt = int

computed : Dict[Tuple[int, int], BigInt] = {}

def sterling2(n, k):
    key = (n, k)

    if key in computed:
        return computed[key]
    if n == k == 0:
        return BigInt(1)
    if (n > 0 and k == 0) or (n == 0 and k > 0):
        return BigInt(0)
    if n == k:
        return BigInt(1)
    if k > n:
        return BigInt(0)
    result = k * sterling2(n - 1, k) + sterling2(n - 1, k - 1)
    computed[key] = result
    return result

print("Stirling numbers of the second kind:")
MAX = 12
print("n/k".ljust(10), end="")
for n in range(MAX + 1):
    print(str(n).rjust(10), end="")
print()
for n in range(MAX + 1):
    print(str(n).ljust(10), end="")
    for k in range(n + 1):
        print(str(sterling2(n, k)).rjust(10), end="")
    print()
print("The maximum value of S2(100, k) = ")
previous : BigInt = 0
for k in range(1, 100 + 1):
    current = sterling2(100, k)
    if current > previous:
        previous = current
    else:
        print("{0}\n({1} digits, k = {2})\n".format(previous, len(str(previous)), k - 1))
        break
===
[(Int, Int) = BigInt] computed

F sterling2(n, k)
   V key = (n, k)

   I key C :computed
      R :computed[key]
   I n == k == 0
      R BigInt(1)
   I (n > 0 & k == 0) | (n == 0 & k > 0)
      R BigInt(0)
   I n == k
      R BigInt(1)
   I k > n
      R BigInt(0)
   V result = k * sterling2(n - 1, k) + sterling2(n - 1, k - 1)
   :computed[key] = result
   R result

print(‘Stirling numbers of the second kind:’)
V MAX = 12
print(‘n/k’.ljust(10), end' ‘’)
L(n) 0 .. MAX
   print(String(n).rjust(10), end' ‘’)
print()
L(n) 0 .. MAX
   print(String(n).ljust(10), end' ‘’)
   L(k) 0 .. n
      print(String(sterling2(n, k)).rjust(10), end' ‘’)
   print()
print(‘The maximum value of S2(100, k) = ’)
BigInt previous = 0
L(k) 1 .. 100
   V current = sterling2(100, k)
   I current > previous
      previous = current
   E
      print("#.\n(#. digits, k = #.)\n".format(previous, String(previous).len, k - 1))
      L.break
===
Dict<ivec2, BigInt> computed;

template <typename T1, typename T2> auto sterling2(const T1 &n, const T2 &k)
{
    auto key = make_tuple(n, k);

    if (in(key, ::computed))
        return ::computed[key];
    if (equal(n, k, 0))
        return BigInt(1);
    if ((n > 0 && k == 0) || (n == 0 && k > 0))
        return BigInt(0);
    if (n == k)
        return BigInt(1);
    if (k > n)
        return BigInt(0);
    auto result = k * sterling2(n - 1, k) + sterling2(n - 1, k - 1);
    ::computed.set(key, result);
    return result;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"Stirling numbers of the second kind:"_S);
    }
} code_block_1;

auto MAX = 12;

struct CodeBlock2
{
    CodeBlock2()
    {
        print(u"n/k"_S.ljust(10), u""_S);
        for (auto n : range_ee(0, MAX))
            print(String(n).rjust(10), u""_S);
        print();
        for (auto n : range_ee(0, MAX)) {
            print(String(n).ljust(10), u""_S);
            for (auto k : range_ee(0, n))
                print(String(sterling2(n, k)).rjust(10), u""_S);
            print();
        }
        print(u"The maximum value of S2(100, k) = "_S);
    }
} code_block_2;

BigInt previous = 0;

struct CodeBlock3
{
    CodeBlock3()
    {
        for (auto k : range_ee(1, 100)) {
            auto current = sterling2(100, k);
            if (current > previous)
                previous = current;
            else {
                print(u"#.\n(#. digits, k = #.)\n"_S.format(previous, String(previous).len(), k - 1));
                break;
            }
        }
    }
} code_block_3;


# https://www.rosettacode.org/wiki/Strange_unique_prime_triplets#Python
def primes_upto(limit):
    is_prime = [False] * 2 + [True] * (limit - 1)
    for n in range(int(limit**0.5 + 1.5)): # stop at ``sqrt(limit)``
        if is_prime[n]:
            for i in range(n*n, limit+1, n):
                is_prime[i] = False
    return [i for i, prime in enumerate(is_prime) if prime]

def strange_triplets(mx: int = 30):
    r : List[Tuple[int, int, int]] = []
    primes = list(primes_upto(mx))
    primes3 = set(primes_upto(3 * mx))
    for i, n in enumerate(primes):
        for j, m in enumerate(primes[i + 1:], i + 1):
            for p in primes[j + 1:]:
                if n + m + p in primes3:
                    r.append((n, m, p))
    return r

for c, nmp in enumerate(strange_triplets(), 1):
    (n, m, p) = nmp
    print('%2d: %2d+%2d+%2d = %d' % (c, n, m, p, n + m + p))

mx = 1_000
print("\nIf n, m, p < %d finds %d" % (mx, len(strange_triplets(mx))))
===
F primes_upto(limit)
   V is_prime = [0B] * 2 [+] [1B] * (limit - 1)
   L(n) 0 .< Int(limit ^ 0.5 + 1.5)
      I is_prime[n]
         L(i) (n * n .. limit).step(n)
            is_prime[i] = 0B
   R enumerate(is_prime).filter((i, prime) -> prime).map((i, prime) -> i)

F strange_triplets(Int mx = 30)
   [(Int, Int, Int)] r
   V primes = Array(primes_upto(mx))
   V primes3 = Set(primes_upto(3 * mx))
   L(n) primes
      V i = L.index
      L(m) primes[i + 1 ..]
         V j = L.index + i + 1
         L(p) primes[j + 1 ..]
            I n + m + p C primes3
               r.append((n, m, p))
   R r

L(nmp) strange_triplets()
   V c = L.index + 1
   V (n, m, p) = nmp
   print(‘#2: #2+#2+#2 = #.’.format(c, n, m, p, n + m + p))

V mx = 1'000
print("\nIf n, m, p < #. finds #.".format(mx, strange_triplets(mx).len))
===
template <typename T1> auto primes_upto(const T1 &limit)
{
    auto is_prime = create_array({false}) * 2 + create_array({true}) * (limit - 1);
    for (auto n : range_el(0, to_int(pow(limit, 0.5) + 1.5)))
        if (is_prime[n])
            for (auto i : range_ee(n * n, limit).step(n))
                is_prime.set(i, false);
    return enumerate(is_prime).filter([](const auto &i, const auto &prime){return prime;}).map([](const auto &i, const auto &prime){return i;});
}

auto strange_triplets(const int mx = 30)
{
    Array<ivec3> r;
    auto primes = create_array(primes_upto(mx));
    auto primes3 = create_set(primes_upto(3 * mx));
    {int Lindex = 0;
    for (auto &&n : primes) {
        auto i = Lindex;
        {int Lindex = 0;
        for (auto &&m : primes[range_ei(i + 1)]) {
            auto j = Lindex + i + 1;
            for (auto &&p : primes[range_ei(j + 1)])
                if (in(n + m + p, primes3))
                    r.append(make_tuple(n, m, p));
            Lindex++;
        }}
        Lindex++;
    }}
    return r;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        {int Lindex = 0;

        for (auto &&nmp : strange_triplets()) {
            auto c = Lindex + 1;
            auto [n, m, p] = nmp;
            print(u"#2: #2+#2+#2 = #."_S.format(c, n, m, p, n + m + p));
            Lindex++;
        }}
    }
} code_block_1;

auto mx = 1'000;

struct CodeBlock2
{
    CodeBlock2()
    {
        print(u"\nIf n, m, p < #. finds #."_S.format(mx, strange_triplets(mx).len()));
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Strong_and_weak_primes
from typing import List

def primes_upto(limit):
    is_prime = [False] * 2 + [True] * (limit - 1)
    for n in range(int(limit**0.5 + 1.5)): # stop at ``sqrt(limit)``
        if is_prime[n]:
            for i in range(n*n, limit+1, n):
                is_prime[i] = False
    return [i for i, prime in enumerate(is_prime) if prime]

p = primes_upto(10_000_000)
s : List[int] = []
w : List[int] = []
b : List[int] = []
for i in range(1, len(p) - 1):
    if p[i] > (p[i-1] + p[i+1]) * 0.5:
        s += [p[i]]
    elif p[i] < (p[i-1] + p[i+1]) * 0.5:
        w += [p[i]]
    else:
        b += [p[i]]

print('The first   36   strong primes:', s[:36])
print('The   count   of the strong primes below   1,000,000:',
      sum(1 for p in s if p < 1_000_000))
print('The   count   of the strong primes below  10,000,000:', len(s))
print('\nThe first   37   weak primes:', w[:37])
print('The   count   of the weak   primes below   1,000,000:',
      sum(1 for p in w if p < 1_000_000))
print('The   count   of the weak   primes below  10,000,000:', len(w))
print('\n\nThe first   10 balanced primes:', b[:10])
print('The   count   of balanced   primes below   1,000,000:',
      sum(1 for p in b if p < 1_000_000))
print('The   count   of balanced   primes below  10,000,000:', len(b))
print('\nTOTAL primes below   1,000,000:',
      sum(1 for pr in p if pr < 1_000_000))
print('TOTAL primes below  10,000,000:', len(p))
===
F primes_upto(limit)
   V is_prime = [0B] * 2 [+] [1B] * (limit - 1)
   L(n) 0 .< Int(limit ^ 0.5 + 1.5)
      I is_prime[n]
         L(i) (n * n .. limit).step(n)
            is_prime[i] = 0B
   R enumerate(is_prime).filter((i, prime) -> prime).map((i, prime) -> i)

V p = primes_upto(10'000'000)
[Int] s
[Int] w
[Int] b
L(i) 1 .< p.len - 1
   I p[i] > (p[i - 1] + p[i + 1]) * 0.5
      s [+]= p[i]
   E I p[i] < (p[i - 1] + p[i + 1]) * 0.5
      w [+]= p[i]
   E
      b [+]= p[i]

print(‘The first   36   strong primes: ’s[0.<36])
print(‘The   count   of the strong primes below   1,000,000: ’sum(s.filter(p -> p < 1'000'000).map(p -> 1)))
print(‘The   count   of the strong primes below  10,000,000: ’s.len)
print("\nThe first   37   weak primes: "w[0.<37])
print(‘The   count   of the weak   primes below   1,000,000: ’sum(w.filter(p -> p < 1'000'000).map(p -> 1)))
print(‘The   count   of the weak   primes below  10,000,000: ’w.len)
print("\n\nThe first   10 balanced primes: "b[0.<10])
print(‘The   count   of balanced   primes below   1,000,000: ’sum(b.filter(p -> p < 1'000'000).map(p -> 1)))
print(‘The   count   of balanced   primes below  10,000,000: ’b.len)
print("\nTOTAL primes below   1,000,000: "sum(p.filter(pr -> pr < 1'000'000).map(pr -> 1)))
print(‘TOTAL primes below  10,000,000: ’p.len)
===
template <typename T1> auto primes_upto(const T1 &limit)
{
    auto is_prime = create_array({false}) * 2 + create_array({true}) * (limit - 1);
    for (auto n : range_el(0, to_int(pow(limit, 0.5) + 1.5)))
        if (is_prime[n])
            for (auto i : range_ee(n * n, limit).step(n))
                is_prime.set(i, false);
    return enumerate(is_prime).filter([](const auto &i, const auto &prime){return prime;}).map([](const auto &i, const auto &prime){return i;});
}

auto p = primes_upto(10'000'000);
Array<int> s;
Array<int> w;
Array<int> b;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto i : range_el(1, p.len() - 1))
            if (p[i] > (p[i - 1] + p[i + 1]) * 0.5)
                s.append(p[i]);
            else if (p[i] < (p[i - 1] + p[i + 1]) * 0.5)
                w.append(p[i]);
            else
                b.append(p[i]);

        print(u"The first   36   strong primes: "_S & s[range_el(0, 36)]);
        print(u"The   count   of the strong primes below   1,000,000: "_S & sum_map(s.filter([](const auto &p){return p < 1'000'000;}), [](const auto &p){return 1;}));
        print(u"The   count   of the strong primes below  10,000,000: "_S & s.len());
        print(u"\nThe first   37   weak primes: "_S & w[range_el(0, 37)]);
        print(u"The   count   of the weak   primes below   1,000,000: "_S & sum_map(w.filter([](const auto &p){return p < 1'000'000;}), [](const auto &p){return 1;}));
        print(u"The   count   of the weak   primes below  10,000,000: "_S & w.len());
        print(u"\n\nThe first   10 balanced primes: "_S & b[range_el(0, 10)]);
        print(u"The   count   of balanced   primes below   1,000,000: "_S & sum_map(b.filter([](const auto &p){return p < 1'000'000;}), [](const auto &p){return 1;}));
        print(u"The   count   of balanced   primes below  10,000,000: "_S & b.len());
        print(u"\nTOTAL primes below   1,000,000: "_S & sum_map(p.filter([](const auto &pr){return pr < 1'000'000;}), [](const auto &pr){return 1;}));
        print(u"TOTAL primes below  10,000,000: "_S & p.len());
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Successive_prime_differences#D
def primes_upto(limit):
    is_prime = [False] * 2 + [True] * (limit - 1)
    for n in range(int(limit**0.5 + 1.5)): # stop at ``sqrt(limit)``
        if is_prime[n]:
            for i in range(n*n, limit+1, n):
                is_prime[i] = False
    return [i for i, prime in enumerate(is_prime) if prime]

def successive_primes(primes, diffs):
    results : List[List[int]] = []
    dl = len(diffs)

    for i in range(len(primes) - dl):
        group = [0] * (dl + 1)
        group[0] = primes[i]
        for j in range(i, i + dl):
            if primes[j + 1] - primes[j] != diffs[j - i]:
                break
            group[j - i + 1] = primes[j + 1]
        else:
            results += [group]

    return results

prime_list = primes_upto(1_000_000)

print('For primes less than 1,000,000:-')
for diffs in [[2], [1], [2, 2], [2, 4], [4, 2], [6, 4, 2]]:
    print('  For differences of %s ->' % diffs)
    sp = successive_primes(prime_list, diffs)
    print('    First group   =', sp[0])
    print('    Last group    =', sp[-1])
    print('    Number found  =', len(sp))
    print()
===
F primes_upto(limit)
   V is_prime = [0B] * 2 [+] [1B] * (limit - 1)
   L(n) 0 .< Int(limit ^ 0.5 + 1.5)
      I is_prime[n]
         L(i) (n * n .. limit).step(n)
            is_prime[i] = 0B
   R enumerate(is_prime).filter((i, prime) -> prime).map((i, prime) -> i)

F successive_primes(primes, diffs)
   [[Int]] results
   V dl = diffs.len

   L(i) 0 .< primes.len - dl
      V group = [0] * (dl + 1)
      group[0] = primes[i]
      L(j) i .< i + dl
         I primes[j + 1] - primes[j] != diffs[j - i]
            L.break
         group[j - i + 1] = primes[j + 1]
      L.was_no_break
         results [+]= group

   R results

V prime_list = primes_upto(1'000'000)

print(‘For primes less than 1,000,000:-’)
L(diffs) [[2], [1], [2, 2], [2, 4], [4, 2], [6, 4, 2]]
   print(‘  For differences of #. ->’.format(diffs))
   V sp = successive_primes(prime_list, diffs)
   print(‘    First group   = ’sp[0])
   print(‘    Last group    = ’sp.last)
   print(‘    Number found  = ’sp.len)
   print()
===
template <typename T1> auto primes_upto(const T1 &limit)
{
    auto is_prime = create_array({false}) * 2 + create_array({true}) * (limit - 1);
    for (auto n : range_el(0, to_int(pow(limit, 0.5) + 1.5)))
        if (is_prime[n])
            for (auto i : range_ee(n * n, limit).step(n))
                is_prime.set(i, false);
    return enumerate(is_prime).filter([](const auto &i, const auto &prime){return prime;}).map([](const auto &i, const auto &prime){return i;});
}

template <typename T1, typename T2> auto successive_primes(const T1 &primes, const T2 &diffs)
{
    Array<Array<int>> results;
    auto dl = diffs.len();

    for (auto i : range_el(0, primes.len() - dl)) {
        auto group = create_array({0}) * (dl + 1);
        _set<0>(group, primes[i]);
        for (auto j : range_el(i, i + dl)) {
            if (primes[j + 1] - primes[j] != diffs[j - i])
                goto break_;
            group.set(j - i + 1, primes[j + 1]);
        }
        results.append(group);
        break_:;
    }

    return results;
}

auto prime_list = primes_upto(1'000'000);

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"For primes less than 1,000,000:-"_S);
        for (auto &&diffs : create_array({create_array({2}), create_array({1}), create_array({2, 2}), create_array({2, 4}), create_array({4, 2}), create_array({6, 4, 2})})) {
            print(u"  For differences of #. ->"_S.format(diffs));
            auto sp = successive_primes(prime_list, diffs);
            print(u"    First group   = "_S & _get<0>(sp));
            print(u"    Last group    = "_S & sp.last());
            print(u"    Number found  = "_S & sp.len());
            print();
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Sexy_primes#Python
LIMIT = 1_000_000
def get_primes(limit):
    is_prime = [False] * 2 + [True] * (limit - 1)
    for n in range(int(limit**0.5 + 1.5)): # stop at ``sqrt(limit)``
        if is_prime[n]:
            for i in range(n*n, limit+1, n):
                is_prime[i] = False
    return [i for i, prime in enumerate(is_prime) if prime]

primes = get_primes(LIMIT)
primeset = set(primes)

s = [[[0]*0]*0 for x in range(4)]
unsexy = [0]*0
for p in primes:
    if p + 6 in primeset:
        s[0].append([p, p+6])
    else:
        if p - 6 not in primeset:
            unsexy.append(p)
        continue
    if p + 12 in primeset:
        s[1].append([p, p+6, p+12])
    else:
        continue
    if p + 18 in primeset:
        s[2].append([p, p+6, p+12, p+18])
    else:
        continue
    if p + 24 in primeset:
        s[3].append([p, p+6, p+12, p+18, p+24])

print('"SEXY" PRIME GROUPINGS:')
for sexy, name in zip(s, 'pairs triplets quadruplets quintuplets'.split(' ')):
    print('  {} {} ending with ...'.format(len(sexy), name))
    for sx in sexy[-5:]:
        print('   ',sx)

print('\nThere are %d unsexy primes ending with ...' % len(unsexy))
for usx in unsexy[-10:]:
    print(' ',usx)
===
V LIMIT = 1'000'000
F get_primes(limit)
   V is_prime = [0B] * 2 [+] [1B] * (limit - 1)
   L(n) 0 .< Int(limit ^ 0.5 + 1.5)
      I is_prime[n]
         L(i) (n * n .. limit).step(n)
            is_prime[i] = 0B
   R enumerate(is_prime).filter((i, prime) -> prime).map((i, prime) -> i)

V primes = get_primes(LIMIT)
V primeset = Set(primes)

V s = [[[Int]()] * 0] * 4
V unsexy = [Int]()
L(p) primes
   I p + 6 C primeset
      s[0].append([p, p + 6])
   E
      I p - 6 !C primeset
         unsexy.append(p)
      L.continue
   I p + 12 C primeset
      s[1].append([p, p + 6, p + 12])
   E
      L.continue
   I p + 18 C primeset
      s[2].append([p, p + 6, p + 12, p + 18])
   E
      L.continue
   I p + 24 C primeset
      s[3].append([p, p + 6, p + 12, p + 18, p + 24])

print(‘"SEXY" PRIME GROUPINGS:’)
L(sexy, name) zip(s, ‘pairs triplets quadruplets quintuplets’.split(‘ ’))
   print(‘  #. #. ending with ...’.format(sexy.len, name))
   L(sx) sexy[(len)-5 ..]
      print(‘    ’sx)

print("\nThere are #. unsexy primes ending with ...".format(unsexy.len))
L(usx) unsexy[(len)-10 ..]
   print(‘  ’usx)
===
auto LIMIT = 1'000'000;
template <typename T1> auto get_primes(const T1 &limit)
{
    auto is_prime = create_array({false}) * 2 + create_array({true}) * (limit - 1);
    for (auto n : range_el(0, to_int(pow(limit, 0.5) + 1.5)))
        if (is_prime[n])
            for (auto i : range_ee(n * n, limit).step(n))
                is_prime.set(i, false);
    return enumerate(is_prime).filter([](const auto &i, const auto &prime){return prime;}).map([](const auto &i, const auto &prime){return i;});
}

auto primes = get_primes(LIMIT);
auto primeset = create_set(primes);

auto s = create_array({create_array({Array<int>()}) * 0}) * 4;
auto unsexy = Array<int>();

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&p : primes) {
            if (in(p + 6, primeset))
                _get<0>(s).append(create_array({p, p + 6}));
            else {
                if (!in(p - 6, primeset))
                    unsexy.append(p);
                continue;
            }
            if (in(p + 12, primeset))
                _get<1>(s).append(create_array({p, p + 6, p + 12}));
            else
                continue;
            if (in(p + 18, primeset))
                _get<2>(s).append(create_array({p, p + 6, p + 12, p + 18}));
            else
                continue;
            if (in(p + 24, primeset))
                _get<3>(s).append(create_array({p, p + 6, p + 12, p + 18, p + 24}));
        }

        print(u"\"SEXY\" PRIME GROUPINGS:"_S);
        for (auto &&[sexy, name] : zip(s, u"pairs triplets quadruplets quintuplets"_S.split(u" "_S))) {
            print(u"  #. #. ending with ..."_S.format(sexy.len(), name));
            for (auto &&sx : sexy[range_elen_i( - 5)])
                print(u"    "_S & sx);
        }

        print(u"\nThere are #. unsexy primes ending with ..."_S.format(unsexy.len()));
        for (auto &&usx : unsexy[range_elen_i( - 10)])
            print(u"  "_S & usx);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Sokoban#Python
from typing import List
import collections

data : List[str] = []
nrows = 0
px = 0
py = 0
sdata = ""
ddata = ""

def init(board):
    global data, nrows, sdata, ddata, px, py
    data = board.split("\n")
    nrows = max(len(r) for r in data)

    maps = {' ':' ', '.': '.', '@':' ', '#':'#', '$':' '}
    mapd = {' ':' ', '.': ' ', '@':'@', '#':' ', '$':'*'}

    for r, row in enumerate(data):
        for c, ch in enumerate(row):
            sdata += maps[ch]
            ddata += mapd[ch]
            if ch == '@':
                px = c
                py = r

def push(x, y, dx, dy, data):
    if sdata[(y+2*dy) * nrows + x+2*dx] == '#' or \
       data[(y+2*dy) * nrows + x+2*dx] != ' ':
        return ''

    data2 = list(data)
    data2[y * nrows + x] = ' '
    data2[(y+dy) * nrows + x+dx] = '@'
    data2[(y+2*dy) * nrows + x+2*dx] = '*'
    return ''.join(data2)

def is_solved(data):
    for i in range(len(data)):
        if (sdata[i] == '.') != (data[i] == '*'):
            return False
    return True

def solve():
    open = collections.deque([(ddata, "", px, py)])
    visited = set([ddata])
    dirs = ((0, -1, 'u', 'U'), ( 1, 0, 'r', 'R'),
            (0,  1, 'd', 'D'), (-1, 0, 'l', 'L'))

    lnrows = nrows
    while len(open):
        (cur, csol, x, y) = open.popleft()

        for di in dirs:
            temp = cur
            (dx, dy) = (di[0], di[1])

            if temp[(y+dy) * lnrows + x+dx] == '*':
                temp = push(x, y, dx, dy, temp)
                if temp != '' and temp not in visited:
                    if is_solved(temp):
                        return csol + '' + di[3]
                    open.append((temp, csol + '' + di[3], x+dx, y+dy))
                    visited.add(temp)
            else:
                if sdata[(y+dy) * lnrows + x+dx] == '#' or \
                   temp[(y+dy) * lnrows + x+dx] != ' ':
                    continue

                data2 = list(temp)
                data2[y * lnrows + x] = ' '
                data2[(y+dy) * lnrows + x+dx] = '@'
                temp = ''.join(data2)

                if temp not in visited:
                    if is_solved(temp):
                        return csol + '' + di[2]
                    open.append((temp, csol + '' + di[2], x+dx, y+dy))
                    visited.add(temp)

    return "No solution"

level = \
"""#######
#     #
#     #
#. #  #
#. $$ #
#.$$  #
#.#  @#
#######"""

init(level)
print(level + "\n\n" + solve())
===
[String] data
V nrows = 0
V px = 0
V py = 0
V sdata = ‘’
V ddata = ‘’

F init(board)
   :data = board.split("\n")
   :nrows = max(:data.map(r -> r.len))

   V maps = [‘ ’ = ‘ ’, ‘.’ = ‘.’, ‘@’ = ‘ ’, ‘#’ = ‘#’, ‘$’ = ‘ ’]
   V mapd = [‘ ’ = ‘ ’, ‘.’ = ‘ ’, ‘@’ = ‘@’, ‘#’ = ‘ ’, ‘$’ = ‘*’]

   L(row) :data
      V r = L.index
      L(ch) row
         V c = L.index
         :sdata ‘’= maps[ch]
         :ddata ‘’= mapd[ch]
         I ch == ‘@’
            :px = c
            :py = r

F push(x, y, dx, dy, data)
   I :sdata[(y + 2 * dy) * :nrows + x + 2 * dx] == ‘#’ | data[(y + 2 * dy) * :nrows + x + 2 * dx] != ‘ ’
      R ‘’

   V data2 = Array(data)
   data2[y * :nrows + x] = ‘ ’
   data2[(y + dy) * :nrows + x + dx] = ‘@’
   data2[(y + 2 * dy) * :nrows + x + 2 * dx] = ‘*’
   R data2.join(‘’)

F is_solved(data)
   L(i) 0 .< data.len
      I (:sdata[i] == ‘.’) != (data[i] == ‘*’)
         R 0B
   R 1B

F solve()
   V open = Deque([(:ddata, ‘’, :px, :py)])
   V visited = Set([:ddata])
   V dirs = ((0, -1, ‘u’, ‘U’), (1, 0, ‘r’, ‘R’), (0, 1, ‘d’, ‘D’), (-1, 0, ‘l’, ‘L’))

   V lnrows = :nrows
   L !open.empty
      V (cur, csol, x, y) = open.pop_left()

      L(di) dirs
         V temp = cur
         V (dx, dy) = (di[0], di[1])

         I temp[(y + dy) * lnrows + x + dx] == ‘*’
            temp = push(x, y, dx, dy, temp)
            I temp != ‘’ & temp !C visited
               I is_solved(temp)
                  R csol‘’di[3]
               open.append((temp, csol‘’di[3], x + dx, y + dy))
               visited.add(temp)
         E
            I :sdata[(y + dy) * lnrows + x + dx] == ‘#’ | temp[(y + dy) * lnrows + x + dx] != ‘ ’
               L.continue

            V data2 = Array(temp)
            data2[y * lnrows + x] = ‘ ’
            data2[(y + dy) * lnrows + x + dx] = ‘@’
            temp = data2.join(‘’)

            I temp !C visited
               I is_solved(temp)
                  R csol‘’di[2]
               open.append((temp, csol‘’di[2], x + dx, y + dy))
               visited.add(temp)

   R ‘No solution’

V level = ‘#######
#     #
#     #
#. #  #
#. $$ #
#.$$  #
#.#  @#
#######’

init(level)
print(level"\n\n"solve())
===
Array<String> data;
auto nrows = 0;
auto px = 0;
auto py = 0;
auto sdata = u""_S;
auto ddata = u""_S;

template <typename T1> auto init(const T1 &board)
{
    ::data = board.split(u"\n"_S);
    ::nrows = max_map(::data, [](const auto &r){return r.len();});

    auto maps = create_dict(dict_of(u' '_C, u' '_C)(u'.'_C, u'.'_C)(u'@'_C, u' '_C)(u'#'_C, u'#'_C)(u'$'_C, u' '_C));
    auto mapd = create_dict(dict_of(u' '_C, u' '_C)(u'.'_C, u' '_C)(u'@'_C, u'@'_C)(u'#'_C, u' '_C)(u'$'_C, u'*'_C));
    {int Lindex = 0;

    for (auto &&row : ::data) {
        auto r = Lindex;
        {int Lindex = 0;
        for (auto &&ch : row) {
            auto c = Lindex;
            ::sdata &= maps[ch];
            ::ddata &= mapd[ch];
            if (ch == u'@') {
                ::px = c;
                ::py = r;
            }
            Lindex++;
        }}
        Lindex++;
    }}
}

template <typename T1, typename T2, typename T3, typename T4, typename T5> auto push(const T1 &x, const T2 &y, const T3 &dx, const T4 &dy, const T5 &data)
{
    if (::sdata[(y + 2 * dy) * ::nrows + x + 2 * dx] == u'#' || data[(y + 2 * dy) * ::nrows + x + 2 * dx] != u' ')
        return u""_S;

    auto data2 = create_array(data);
    data2.set(y * ::nrows + x, u' '_C);
    data2.set((y + dy) * ::nrows + x + dx, u'@'_C);
    data2.set((y + 2 * dy) * ::nrows + x + 2 * dx, u'*'_C);
    return data2.join(u""_S);
}

template <typename T1> auto is_solved(const T1 &data)
{
    for (auto i : range_el(0, data.len()))
        if ((::sdata[i] == u'.') != (data[i] == u'*'))
            return false;
    return true;
}

auto solve()
{
    auto open = create_deque({make_tuple(::ddata, u""_S, ::px, ::py)});
    auto visited = create_set({::ddata});
    auto dirs = make_tuple(make_tuple(0, -1, u"u"_S, u"U"_S), make_tuple(1, 0, u"r"_S, u"R"_S), make_tuple(0, 1, u"d"_S, u"D"_S), make_tuple(-1, 0, u"l"_S, u"L"_S));

    auto lnrows = ::nrows;
    while (!open.empty()) {
        auto [cur, csol, x, y] = open.pop_left();

        for (auto &&di : dirs) {
            auto temp = cur;
            auto [dx, dy] = make_tuple(_get<0>(di), _get<1>(di));

            if (temp[(y + dy) * lnrows + x + dx] == u'*') {
                temp = push(x, y, dx, dy, temp);
                if (temp != u"" && !in(temp, visited)) {
                    if (is_solved(temp))
                        return csol & _get<3>(di);
                    open.append(make_tuple(temp, csol & _get<3>(di), x + dx, y + dy));
                    visited.add(temp);
                }
            }
            else {
                if (::sdata[(y + dy) * lnrows + x + dx] == u'#' || temp[(y + dy) * lnrows + x + dx] != u' ')
                    continue;

                auto data2 = create_array(temp);
                data2.set(y * lnrows + x, u' '_C);
                data2.set((y + dy) * lnrows + x + dx, u'@'_C);
                temp = data2.join(u""_S);

                if (!in(temp, visited)) {
                    if (is_solved(temp))
                        return csol & _get<2>(di);
                    open.append(make_tuple(temp, csol & _get<2>(di), x + dx, y + dy));
                    visited.add(temp);
                }
            }
        }
    }

    return u"No solution"_S;
}

auto level = uR"(#######
#     #
#     #
#. #  #
#. $$ #
#.$$  #
#.#  @#
#######)"_S;

struct CodeBlock1
{
    CodeBlock1()
    {
        init(level);
        print(level & u"\n\n"_S & solve());
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Solve_a_Numbrix_puzzle#Python
from typing import List

neighbours = [[-1, 0], [0, -1], [1, 0], [0, 1]]
exists : List[int] = []
lastNumber = 0
wid = 0
hei = 0

def find_next(pa, x, y, z):
    for i in range(4):
        a = x + neighbours[i][0]
        b = y + neighbours[i][1]
        if -1 < a < wid and -1 < b < hei:
            if pa[a][b] == z:
                return (a, b)

    return (-1, -1)

def find_solution(pa : list, x, y, z):
    if z > lastNumber:
        return 1
    if exists[z] == 1:
        s = find_next(pa, x, y, z)
        if s[0] < 0:
            return 0
        return find_solution(pa, s[0], s[1], z + 1)

    for i in range(4):
        a = x + neighbours[i][0]
        b = y + neighbours[i][1]
        if -1 < a < wid and -1 < b < hei:
            if pa[a][b] == 0:
                pa[a][b] = z
                r = find_solution(pa, a, b, z + 1)
                if r == 1:
                    return 1
                pa[a][b] = 0

    return 0

def solve(pz, w, h):
    global lastNumber, wid, hei, exists

    lastNumber = w * h
    wid = w
    hei = h
    exists = [0] * (lastNumber + 1)

    pa = [[0] * h for i in range(w)]
    st = pz.split(' ')
    idx = 0
    for j in range(h):
        for i in range(w):
            if st[idx] == ".":
                idx += 1
            else:
                pa[i][j] = int(st[idx])
                exists[pa[i][j]] = 1
                idx += 1

    x = 0
    y = 0
    t = w * h + 1
    for j in range(h):
        for i in range(w):
            if pa[i][j] != 0 and pa[i][j] < t:
                t = pa[i][j]
                x = i
                y = j

    return (find_solution(pa, x, y, t + 1), pa)

def show_result(r):
    if r[0] == 1:
        for j in range(hei):
            for i in range(wid):
                print(" {:02}".format(r[1][i][j]), end = '')
            print()
    else:
        print("No Solution!")

    print()

r = solve(". . . . . . . . . . . 46 45 . 55 74 . . . 38 . . 43 . . 78 . . 35 . . . . . 71 . . . 33 . . . 59 . . . 17" +
          " . . . . . 67 . . 18 . . 11 . . 64 . . . 24 21 . 1 2 . . . . . . . . . . .", 9, 9)
show_result(r)

r = solve(". . . . . . . . . . 11 12 15 18 21 62 61 . . 6 . . . . . 60 . . 33 . . . . . 57 . . 32 . . . . . 56 . . 37" +
          " . 1 . . . 73 . . 38 . . . . . 72 . . 43 44 47 48 51 76 77 . . . . . . . . . .", 9, 9)
show_result(r)

r = solve("17 . . . 11 . . . 59 . 15 . . 6 . . 61 . . . 3 . . . 63 . . . . . . 66 . . . . 23 24 . 68 67 78 . 54 55" +
          " . . . . 72 . . . . . . 35 . . . 49 . . . 29 . . 40 . . 47 . 31 . . . 39 . . . 45", 9, 9)
show_result(r)
===
V neighbours = [[-1, 0], [0, -1], [1, 0], [0, 1]]
[Int] exists
V lastNumber = 0
V wid = 0
V hei = 0

F find_next(pa, x, y, z)
   L(i) 4
      V a = x + :neighbours[i][0]
      V b = y + :neighbours[i][1]
      I a C -1 <.< :wid & b C -1 <.< :hei
         I pa[a][b] == z
            R (a, b)

   R (-1, -1)

F find_solution(&pa, x, y, z)
   I z > :lastNumber
      R 1
   I :exists[z] == 1
      V s = find_next(pa, x, y, z)
      I s[0] < 0
         R 0
      R find_solution(&pa, s[0], s[1], z + 1)

   L(i) 4
      V a = x + :neighbours[i][0]
      V b = y + :neighbours[i][1]
      I a C -1 <.< :wid & b C -1 <.< :hei
         I pa[a][b] == 0
            pa[a][b] = z
            V r = find_solution(&pa, a, b, z + 1)
            I r == 1
               R 1
            pa[a][b] = 0

   R 0

F solve(pz, w, h)

   :lastNumber = w * h
   :wid = w
   :hei = h
   :exists = [0] * (:lastNumber + 1)

   V pa = [[0] * h] * w
   V st = pz.split(‘ ’)
   V idx = 0
   L(j) 0 .< h
      L(i) 0 .< w
         I st[idx] == ‘.’
            idx++
         E
            pa[i][j] = Int(st[idx])
            :exists[pa[i][j]] = 1
            idx++

   V x = 0
   V y = 0
   V t = w * h + 1
   L(j) 0 .< h
      L(i) 0 .< w
         I pa[i][j] != 0 & pa[i][j] < t
            t = pa[i][j]
            x = i
            y = j

   R (find_solution(&pa, x, y, t + 1), pa)

F show_result(r)
   I r[0] == 1
      L(j) 0 .< :hei
         L(i) 0 .< :wid
            print(‘ #02’.format(r[1][i][j]), end' ‘’)
         print()
   E
      print(‘No Solution!’)

   print()

V r = solve(‘. . . . . . . . . . . 46 45 . 55 74 . . . 38 . . 43 . . 78 . . 35 . . . . . 71 . . . 33 . . . 59 . . . 17’""‘ . . . . . 67 . . 18 . . 11 . . 64 . . . 24 21 . 1 2 . . . . . . . . . . .’, 9, 9)
show_result(r)

r = solve(‘. . . . . . . . . . 11 12 15 18 21 62 61 . . 6 . . . . . 60 . . 33 . . . . . 57 . . 32 . . . . . 56 . . 37’""‘ . 1 . . . 73 . . 38 . . . . . 72 . . 43 44 47 48 51 76 77 . . . . . . . . . .’, 9, 9)
show_result(r)

r = solve(‘17 . . . 11 . . . 59 . 15 . . 6 . . 61 . . . 3 . . . 63 . . . . . . 66 . . . . 23 24 . 68 67 78 . 54 55’""‘ . . . . 72 . . . . . . 35 . . . 49 . . . 29 . . 40 . . 47 . 31 . . . 39 . . . 45’, 9, 9)
show_result(r)
===
auto neighbours = create_array({create_array({-1, 0}), create_array({0, -1}), create_array({1, 0}), create_array({0, 1})});
Array<int> exists;
auto lastNumber = 0;
auto wid = 0;
auto hei = 0;

template <typename T1, typename T2, typename T3, typename T4> auto find_next(const T1 &pa, const T2 &x, const T3 &y, const T4 &z)
{
    for (int i = 0; i < 4; i++) {
        auto a = x + _get<0>(::neighbours[i]);
        auto b = y + _get<1>(::neighbours[i]);
        if (in(a, range_ll(-1, ::wid)) && in(b, range_ll(-1, ::hei))) {
            if (pa[a][b] == z)
                return make_tuple(a, b);
        }
    }

    return make_tuple(-1, -1);
}

template <typename T1, typename T2, typename T3, typename T4> auto find_solution(T1 &pa, const T2 &x, const T3 &y, const T4 &z)
{
    if (z > ::lastNumber)
        return 1;
    if (::exists[z] == 1) {
        auto s = find_next(pa, x, y, z);
        if (_get<0>(s) < 0)
            return 0;
        return find_solution(pa, _get<0>(s), _get<1>(s), z + 1);
    }

    for (int i = 0; i < 4; i++) {
        auto a = x + _get<0>(::neighbours[i]);
        auto b = y + _get<1>(::neighbours[i]);
        if (in(a, range_ll(-1, ::wid)) && in(b, range_ll(-1, ::hei))) {
            if (pa[a][b] == 0) {
                pa[a].set(b, z);
                auto r = find_solution(pa, a, b, z + 1);
                if (r == 1)
                    return 1;
                pa[a].set(b, 0);
            }
        }
    }

    return 0;
}

template <typename T1, typename T2, typename T3> auto solve(const T1 &pz, const T2 &w, const T3 &h)
{

    ::lastNumber = w * h;
    ::wid = w;
    ::hei = h;
    ::exists = create_array({0}) * (::lastNumber + 1);

    auto pa = create_array({create_array({0}) * h}) * w;
    auto st = pz.split(u" "_S);
    auto idx = 0;
    for (auto j : range_el(0, h))
        for (auto i : range_el(0, w))
            if (st[idx] == u'.')
                idx++;
            else {
                pa[i].set(j, to_int(st[idx]));
                ::exists.set(pa[i][j], 1);
                idx++;
            }

    auto x = 0;
    auto y = 0;
    auto t = w * h + 1;
    for (auto j : range_el(0, h))
        for (auto i : range_el(0, w))
            if (pa[i][j] != 0 && pa[i][j] < t) {
                t = pa[i][j];
                x = i;
                y = j;
            }

    return make_tuple(find_solution(pa, x, y, t + 1), pa);
}

template <typename T1> auto show_result(const T1 &r)
{
    if (_get<0>(r) == 1)
        for (auto j : range_el(0, ::hei)) {
            for (auto i : range_el(0, ::wid))
                print(u" #02"_S.format(_get<1>(r)[i][j]), u""_S);
            print();
        }
    else
        print(u"No Solution!"_S);

    print();
}

auto r = solve(u". . . . . . . . . . . 46 45 . 55 74 . . . 38 . . 43 . . 78 . . 35 . . . . . 71 . . . 33 . . . 59 . . . 17"_S & u" . . . . . 67 . . 18 . . 11 . . 64 . . . 24 21 . 1 2 . . . . . . . . . . ."_S, 9, 9);

struct CodeBlock1
{
    CodeBlock1()
    {
        show_result(r);

        r = solve(u". . . . . . . . . . 11 12 15 18 21 62 61 . . 6 . . . . . 60 . . 33 . . . . . 57 . . 32 . . . . . 56 . . 37"_S & u" . 1 . . . 73 . . 38 . . . . . 72 . . 43 44 47 48 51 76 77 . . . . . . . . . ."_S, 9, 9);
        show_result(r);

        r = solve(u"17 . . . 11 . . . 59 . 15 . . 6 . . 61 . . . 3 . . . 63 . . . . . . 66 . . . . 23 24 . 68 67 78 . 54 55"_S & u" . . . . 72 . . . . . . 35 . . . 49 . . . 29 . . 40 . . 47 . 31 . . . 39 . . . 45"_S, 9, 9);
        show_result(r);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Solve_the_no_connection_puzzle#Python
from _11l import *

connections = [(0, 2), (0, 3), (0, 4),
               (1, 3), (1, 4), (1, 5),
               (6, 2), (6, 3), (6, 4),
               (7, 3), (7, 4), (7, 5),
               (2, 3), (3, 4), (4, 5)]

def ok(conn, perm):
    """Connected numbers ok?"""
    return abs(perm[conn[0]] - perm[conn[1]]) != 1

def solve():
    r : List[List[int]] = []
    perm = list(range(1, 9))
    while True:
        if all(ok(conn, perm) for conn in connections):
            r += [perm[:]]
        if not next_permutation(perm):
            break
    return r

solutions = solve()
print("A, B, C, D, E, F, G, H =", ', '.join(str(i) for i in solutions[0]))
===
V connections = [(0, 2), (0, 3), (0, 4), (1, 3), (1, 4), (1, 5), (6, 2), (6, 3), (6, 4), (7, 3), (7, 4), (7, 5), (2, 3), (3, 4), (4, 5)]

F ok(conn, perm)
   ‘Connected numbers ok?’
   R abs(perm[conn[0]] - perm[conn[1]]) != 1

F solve()
   [[Int]] r
   V perm = Array(1..8)
   L
      I all(:connections.map(conn -> ok(conn, @perm)))
         r [+]= copy(perm)
      I !perm.next_permutation()
         L.break
   R r

V solutions = solve()
print(‘A, B, C, D, E, F, G, H = ’solutions[0].map(i -> String(i)).join(‘, ’))
===
auto connections = create_array({make_tuple(0, 2), make_tuple(0, 3), make_tuple(0, 4), make_tuple(1, 3), make_tuple(1, 4), make_tuple(1, 5), make_tuple(6, 2), make_tuple(6, 3), make_tuple(6, 4), make_tuple(7, 3), make_tuple(7, 4), make_tuple(7, 5), make_tuple(2, 3), make_tuple(3, 4), make_tuple(4, 5)});

template <typename T1, typename T2> auto ok(const T1 &conn, const T2 &perm)
{
    u"Connected numbers ok?"_S;
    return abs(perm[_get<0>(conn)] - perm[_get<1>(conn)]) != 1;
}

auto solve()
{
    Array<Array<int>> r;
    auto perm = create_array(range_ee(1, 8));
    while (true) {
        if (all_map(::connections, [&perm](const auto &conn){return ok(conn, perm);}))
            r.append(copy(perm));
        if (!perm.next_permutation())
            break;
    }
    return r;
}

auto solutions = solve();

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"A, B, C, D, E, F, G, H = "_S & _get<0>(solutions).map([](const auto &i){return String(i);}).join(u", "_S));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Solve_triangle_solitare_puzzle#Python
from typing import Tuple, List

def DrawBoard(board):
  peg = [''] * 16
  for n in range(1,16):
    peg[n] = '.'
    if n in board:
      peg[n] = hex(n)[2:].upper()
  print("     %s" % peg[1])
  print("    %s %s" % (peg[2],peg[3]))
  print("   %s %s %s" % (peg[4],peg[5],peg[6]))
  print("  %s %s %s %s" % (peg[7],peg[8],peg[9],peg[10]))
  print(" %s %s %s %s %s" % (peg[11],peg[12],peg[13],peg[14],peg[15]))
#

# remove peg n from board
def RemovePeg(board : list,n):
  board.remove(n)

# Add peg n on board
def AddPeg(board : list,n):
  board.append(n)

# return true if peg N is on board else false is empty position
def IsPeg(board,n):
  return n in board

# A dictionary of valid jump moves index by jumping peg
# then a list of moves where move has jumpOver and LandAt positions
JumpMoves = { 1: [ (2,4),(3,6) ],  # 1 can jump over 2 to land on 4, or jumper over 3 to land on 6
              2: [ (4,7),(5,9)  ],
              3: [ (5,8),(6,10) ],
              4: [ (2,1),(5,6),(7,11),(8,13) ],
              5: [ (8,12),(9,14) ],
              6: [ (3,1),(5,4),(9,13),(10,15) ],
              7: [ (4,2),(8,9)  ],
              8: [ (5,3),(9,10) ],
              9: [ (5,2),(8,7)  ],
             10: [ (9,8) ],
             11: [ (12,13) ],
             12: [ (8,5),(13,14) ],
             13: [ (8,4),(9,6),(12,11),(14,15) ],
             14: [ (9,5),(13,12)  ],
             15: [ (10,6),(14,13) ]
            }

Solution : List[Tuple[int, int, int]] = []
#
# Recursively solve the problem
#
def Solve(board):
  #DrawBoard(board)
  if len(board) == 1:
    return board # Solved one peg left
  # try a move for each peg on the board
  for peg in range(1,16): # try in numeric order not board order
    if IsPeg(board,peg):
      movelist = JumpMoves[peg]
      for over,land in movelist:
        if IsPeg(board,over) and not IsPeg(board,land):
          saveboard = board[:] # for back tracking
          RemovePeg(board,peg)
          RemovePeg(board,over)
          AddPeg(board,land) # board order changes!

          Solution.append((peg,over,land))

          board = Solve(board)
          if len(board) == 1:
            return board
        ## undo move and back track when stuck!
          board = saveboard[:] # back track
          Solution.pop() # remove last move
  return board

#
# Remove one peg and start solving
#
def InitSolve(empty):
  board = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]
  RemovePeg(board,empty)
  Solve(board)

#
empty_start = 1
InitSolve(empty_start)

board = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]
RemovePeg(board,empty_start)
for peg,over,land in Solution:
  RemovePeg(board,peg)
  RemovePeg(board,over)
  AddPeg(board,land) # board order changes!
  DrawBoard(board)
  print("Peg %s jumped over %s to land on %s\n" % (hex(peg)[2:].upper(),hex(over)[2:].upper(),hex(land)[2:].upper()))
===
F DrawBoard(board)
   V peg = [‘’] * 16
   L(n) 1..15
      peg[n] = ‘.’
      I n C board
         peg[n] = hex(n)
   print(‘     #.’.format(peg[1]))
   print(‘    #. #.’.format(peg[2], peg[3]))
   print(‘   #. #. #.’.format(peg[4], peg[5], peg[6]))
   print(‘  #. #. #. #.’.format(peg[7], peg[8], peg[9], peg[10]))
   print(‘ #. #. #. #. #.’.format(peg[11], peg[12], peg[13], peg[14], peg[15]))

F RemovePeg(&board, n)
   board.remove(n)

F AddPeg(&board, n)
   board.append(n)

F IsPeg(board, n)
   R n C board

V JumpMoves = [1 = [(2, 4), (3, 6)], 2 = [(4, 7), (5, 9)], 3 = [(5, 8), (6, 10)], 4 = [(2, 1), (5, 6), (7, 11), (8, 13)], 5 = [(8, 12), (9, 14)], 6 = [(3, 1), (5, 4), (9, 13), (10, 15)], 7 = [(4, 2), (8, 9)], 8 = [(5, 3), (9, 10)], 9 = [(5, 2), (8, 7)], 10 = [(9, 8)], 11 = [(12, 13)], 12 = [(8, 5), (13, 14)], 13 = [(8, 4), (9, 6), (12, 11), (14, 15)], 14 = [(9, 5), (13, 12)], 15 = [(10, 6), (14, 13)]]

[(Int, Int, Int)] Solution
F Solve(=board)
   I board.len == 1
      R board
   L(peg) 1..15
      I IsPeg(board, peg)
         V movelist = JumpMoves[peg]
         L(over, land) movelist
            I IsPeg(board, over) & !IsPeg(board, land)
               V saveboard = copy(board)
               RemovePeg(&board, peg)
               RemovePeg(&board, over)
               AddPeg(&board, land)

               Solution.append((peg, over, land))

               board = Solve(board)
               I board.len == 1
                  R board
               board = copy(saveboard)
               Solution.pop()
   R board

F InitSolve(empty)
   V board = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
   RemovePeg(&board, empty)
   Solve(board)

V empty_start = 1
InitSolve(empty_start)

V board = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
RemovePeg(&board, empty_start)
L(peg, over, land) Solution
   RemovePeg(&board, peg)
   RemovePeg(&board, over)
   AddPeg(&board, land)
   DrawBoard(board)
   print("Peg #. jumped over #. to land on #.\n".format(hex(peg), hex(over), hex(land)))
===
template <typename T1> auto DrawBoard(const T1 &board)
{
    auto peg = create_array({u""_S}) * 16;
    for (auto n : range_ee(1, 15)) {
        peg.set(n, u'.'_C);
        if (in(n, board))
            peg.set(n, hex(n));
    }
    print(u"     #."_S.format(_get<1>(peg)));
    print(u"    #. #."_S.format(_get<2>(peg), _get<3>(peg)));
    print(u"   #. #. #."_S.format(_get<4>(peg), _get<5>(peg), _get<6>(peg)));
    print(u"  #. #. #. #."_S.format(_get<7>(peg), _get<8>(peg), _get<9>(peg), _get<10>(peg)));
    print(u" #. #. #. #. #."_S.format(_get<11>(peg), _get<12>(peg), _get<13>(peg), _get<14>(peg), _get<15>(peg)));
}

template <typename T1, typename T2> auto RemovePeg(T1 &board, const T2 &n)
{
    board.remove(n);
}

template <typename T1, typename T2> auto AddPeg(T1 &board, const T2 &n)
{
    board.append(n);
}

template <typename T1, typename T2> auto IsPeg(const T1 &board, const T2 &n)
{
    return in(n, board);
}

auto JumpMoves = create_dict(dict_of(1, create_array({make_tuple(2, 4), make_tuple(3, 6)}))(2, create_array({make_tuple(4, 7), make_tuple(5, 9)}))(3, create_array({make_tuple(5, 8), make_tuple(6, 10)}))(4, create_array({make_tuple(2, 1), make_tuple(5, 6), make_tuple(7, 11), make_tuple(8, 13)}))(5, create_array({make_tuple(8, 12), make_tuple(9, 14)}))(6, create_array({make_tuple(3, 1), make_tuple(5, 4), make_tuple(9, 13), make_tuple(10, 15)}))(7, create_array({make_tuple(4, 2), make_tuple(8, 9)}))(8, create_array({make_tuple(5, 3), make_tuple(9, 10)}))(9, create_array({make_tuple(5, 2), make_tuple(8, 7)}))(10, create_array({make_tuple(9, 8)}))(11, create_array({make_tuple(12, 13)}))(12, create_array({make_tuple(8, 5), make_tuple(13, 14)}))(13, create_array({make_tuple(8, 4), make_tuple(9, 6), make_tuple(12, 11), make_tuple(14, 15)}))(14, create_array({make_tuple(9, 5), make_tuple(13, 12)}))(15, create_array({make_tuple(10, 6), make_tuple(14, 13)})));

Array<ivec3> Solution;
template <typename T1> auto Solve(T1 board)
{
    if (board.len() == 1)
        return board;
    for (auto peg : range_ee(1, 15))
        if (IsPeg(board, peg)) {
            auto movelist = JumpMoves[peg];
            for (auto &&[over, land] : movelist)
                if (IsPeg(board, over) && !IsPeg(board, land)) {
                    auto saveboard = copy(board);
                    RemovePeg(board, peg);
                    RemovePeg(board, over);
                    AddPeg(board, land);

                    Solution.append(make_tuple(peg, over, land));

                    board = Solve(board);
                    if (board.len() == 1)
                        return board;
                    board = copy(saveboard);
                    Solution.pop();
                }
        }
    return board;
}

template <typename T1> auto InitSolve(const T1 &empty)
{
    auto board = create_array({1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15});
    RemovePeg(board, empty);
    Solve(board);
}

auto empty_start = 1;

struct CodeBlock1
{
    CodeBlock1()
    {
        InitSolve(empty_start);
    }
} code_block_1;

auto board = create_array({1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15});

struct CodeBlock2
{
    CodeBlock2()
    {
        RemovePeg(board, empty_start);
        for (auto &&[peg, over, land] : Solution) {
            RemovePeg(board, peg);
            RemovePeg(board, over);
            AddPeg(board, land);
            DrawBoard(board);
            print(u"Peg #. jumped over #. to land on #.\n"_S.format(hex(peg), hex(over), hex(land)));
        }
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Sorting_algorithms/Bead_sort#Nim
def bead_sort(a : list):
    maxv = max(a)
    beads = [0] * (maxv * len(a))

    for i in range(len(a)):
        for j in range(a[i]):
            beads[i * maxv + j] = 1

    for j in range(maxv):
        sum = 0
        for i in range(len(a)):
            sum += beads[i * maxv + j]
            beads[i * maxv + j] = 0

        for i in range(len(a) - sum, len(a)):
            beads[i * maxv + j] = 1

    for i in range(len(a)):
        j = 0
        while j < maxv and beads[i * maxv + j] > 0:
            j += 1
        a[i] = j

a = [5, 3, 1, 7, 4, 1, 1, 20]
bead_sort(a)
print(a)
===
F bead_sort(&a)
   V maxv = max(a)
   V beads = [0] * (maxv * a.len)

   L(i) 0 .< a.len
      L(j) 0 .< a[i]
         beads[i * maxv + j] = 1

   L(j) 0 .< maxv
      V sum = 0
      L(i) 0 .< a.len
         sum += beads[i * maxv + j]
         beads[i * maxv + j] = 0

      L(i) a.len - sum .< a.len
         beads[i * maxv + j] = 1

   L(i) 0 .< a.len
      V j = 0
      L j < maxv & beads[i * maxv + j] > 0
         j++
      a[i] = j

V a = [5, 3, 1, 7, 4, 1, 1, 20]
bead_sort(&a)
print(a)
===
template <typename T1> auto bead_sort(T1 &a)
{
    auto maxv = max(a);
    auto beads = create_array({0}) * (maxv * a.len());

    for (auto i : range_el(0, a.len()))
        for (auto j : range_el(0, a[i]))
            beads.set(i * maxv + j, 1);

    for (auto j : range_el(0, maxv)) {
        auto sum = 0;
        for (auto i : range_el(0, a.len())) {
            sum += beads[i * maxv + j];
            beads.set(i * maxv + j, 0);
        }

        for (auto i : range_el(a.len() - sum, a.len()))
            beads.set(i * maxv + j, 1);
    }

    for (auto i : range_el(0, a.len())) {
        auto j = 0;
        while (j < maxv && beads[i * maxv + j] > 0)
            j++;
        a.set(i, j);
    }
}

auto a = create_array({5, 3, 1, 7, 4, 1, 1, 20});

struct CodeBlock1
{
    CodeBlock1()
    {
        bead_sort(a);
        print(a);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Sorting_algorithms/Patience_sort#Kotlin
from typing import List

def ref(obj):
    return obj

def patience_sort(arr : list):
    if len(arr) < 2: return

    piles : List[List[int]] = []
    for el in arr:
        for pile in piles: # &
            if pile[-1] > el:
                pile.append(el)
                break # `L(el).continue`
        else:
            piles.append([el])

    for i in range(len(arr)):
        min = piles[0][-1]
        minPileIndex = 0
        for j in range(1, len(piles)):
            if piles[j][-1] < min:
                min = piles[j][-1]
                minPileIndex = j
        arr[i] = min
        minPile = ref(piles[minPileIndex])
        minPile.pop()
        if len(minPile) == 0:
            piles.pop(minPileIndex)

iArr = [4, 65, 2, -31, 0, 99, 83, 782, 1]
patience_sort(iArr)
print(iArr)
===
F patience_sort(&arr)
   I arr.len < 2
      R

   [[Int]] piles
   L(el) arr
      L(&pile) piles
         I pile.last > el
            pile.append(el)
            L.break
      L.was_no_break
         piles.append([el])

   L(i) 0 .< arr.len
      V min = piles[0].last
      V minPileIndex = 0
      L(j) 1 .< piles.len
         I piles[j].last < min
            min = piles[j].last
            minPileIndex = j
      arr[i] = min
      V& minPile = piles[minPileIndex]
      minPile.pop()
      I minPile.empty
         piles.pop(minPileIndex)

V iArr = [4, 65, 2, -31, 0, 99, 83, 782, 1]
patience_sort(&iArr)
print(iArr)
===
template <typename T1> auto patience_sort(T1 &arr)
{
    if (arr.len() < 2)
        return;

    Array<Array<int>> piles;
    for (auto &&el : arr) {
        for (auto &pile : piles)
            if (pile.last() > el) {
                pile.append(el);
                goto break_;
            }
        piles.append(create_array({el}));
        break_:;
    }

    for (auto i : range_el(0, arr.len())) {
        auto min = _get<0>(piles).last();
        auto minPileIndex = 0;
        for (auto j : range_el(1, piles.len()))
            if (piles[j].last() < min) {
                min = piles[j].last();
                minPileIndex = j;
            }
        arr.set(i, min);
        auto& minPile = piles[minPileIndex];
        minPile.pop();
        if (minPile.empty())
            piles.pop(minPileIndex);
    }
}

auto iArr = create_array({4, 65, 2, -31, 0, 99, 83, 782, 1});

struct CodeBlock1
{
    CodeBlock1()
    {
        patience_sort(iArr);
        print(iArr);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Square-free_integers#Python
import math
Int64 = int

def SquareFree ( _number ) :
    max = int(math.sqrt ( _number ))

    for root in range ( 2, max+1 ):                 # Create a custom prime sieve
        if 0 == _number % ( Int64(root) ** 2 ):
            return False

    return True

def ListSquareFrees( _start : Int64, _end : Int64 ):
    count = 0
    for i in range ( _start, _end+1 ):
        if True == SquareFree( i ):
            print ( "{}\t".format(i), end="" )
            if count % 5 == 4:
                print()
            count += 1

    print ( "\n\nTotal count of square-free numbers between {} and {}: {}".format(_start, _end, count))

ListSquareFrees( 1, 100 )
ListSquareFrees( 1000000000000, 1000000000145 )
===
F SquareFree(_number)
   V max = Int(sqrt(_number))

   L(root) 2 .. max
      I 0 == _number % (Int64(root) ^ 2)
         R 0B

   R 1B

F ListSquareFrees(Int64 _start, Int64 _end)
   V count = 0
   L(i) _start .. _end
      I 1B == SquareFree(i)
         print("#.\t".format(i), end' ‘’)
         I count % 5 == 4
            print()
         count++

   print("\n\nTotal count of square-free numbers between #. and #.: #.".format(_start, _end, count))

ListSquareFrees(1, 100)
ListSquareFrees(1000000000000, 1000000000145)
===
template <typename T1> auto SquareFree(const T1 &_number)
{
    auto max = to_int(sqrt(_number));

    for (auto root : range_ee(2, max))
        if (0 == mod(_number, (square(to_int64(root)))))
            return false;

    return true;
}

auto ListSquareFrees(const Int64 &_start, const Int64 &_end)
{
    auto count = 0;
    for (auto i : range_ee(_start, _end))
        if (true == SquareFree(i)) {
            print(u"#.\t"_S.format(i), u""_S);
            if (mod(count, 5) == 4)
                print();
            count++;
        }

    print(u"\n\nTotal count of square-free numbers between #. and #.: #."_S.format(_start, _end, count));
}

struct CodeBlock1
{
    CodeBlock1()
    {
        ListSquareFrees(1, 100);
        ListSquareFrees(1000000000000, 1000000000145);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Stable_marriage_problem#Python
from copy import deepcopy

def ref(obj):
    return obj

guyprefers = {
 'abe':  ['abi', 'eve', 'cath', 'ivy', 'jan', 'dee', 'fay', 'bea', 'hope', 'gay'],
 'bob':  ['cath', 'hope', 'abi', 'dee', 'eve', 'fay', 'bea', 'jan', 'ivy', 'gay'],
 'col':  ['hope', 'eve', 'abi', 'dee', 'bea', 'fay', 'ivy', 'gay', 'cath', 'jan'],
 'dan':  ['ivy', 'fay', 'dee', 'gay', 'hope', 'eve', 'jan', 'bea', 'cath', 'abi'],
 'ed':   ['jan', 'dee', 'bea', 'cath', 'fay', 'eve', 'abi', 'ivy', 'hope', 'gay'],
 'fred': ['bea', 'abi', 'dee', 'gay', 'eve', 'ivy', 'cath', 'jan', 'hope', 'fay'],
 'gav':  ['gay', 'eve', 'ivy', 'bea', 'cath', 'abi', 'dee', 'hope', 'jan', 'fay'],
 'hal':  ['abi', 'eve', 'hope', 'fay', 'ivy', 'cath', 'jan', 'bea', 'gay', 'dee'],
 'ian':  ['hope', 'cath', 'dee', 'gay', 'bea', 'abi', 'fay', 'ivy', 'jan', 'eve'],
 'jon':  ['abi', 'fay', 'jan', 'gay', 'eve', 'bea', 'dee', 'cath', 'ivy', 'hope']}
galprefers = {
 'abi':  ['bob', 'fred', 'jon', 'gav', 'ian', 'abe', 'dan', 'ed', 'col', 'hal'],
 'bea':  ['bob', 'abe', 'col', 'fred', 'gav', 'dan', 'ian', 'ed', 'jon', 'hal'],
 'cath': ['fred', 'bob', 'ed', 'gav', 'hal', 'col', 'ian', 'abe', 'dan', 'jon'],
 'dee':  ['fred', 'jon', 'col', 'abe', 'ian', 'hal', 'gav', 'dan', 'bob', 'ed'],
 'eve':  ['jon', 'hal', 'fred', 'dan', 'abe', 'gav', 'col', 'ed', 'ian', 'bob'],
 'fay':  ['bob', 'abe', 'ed', 'ian', 'jon', 'dan', 'fred', 'gav', 'col', 'hal'],
 'gay':  ['jon', 'gav', 'hal', 'fred', 'bob', 'abe', 'col', 'ed', 'dan', 'ian'],
 'hope': ['gav', 'jon', 'bob', 'abe', 'ian', 'dan', 'hal', 'ed', 'col', 'fred'],
 'ivy':  ['ian', 'col', 'hal', 'gav', 'fred', 'bob', 'abe', 'ed', 'jon', 'dan'],
 'jan':  ['ed', 'hal', 'gav', 'abe', 'bob', 'jon', 'col', 'ian', 'fred', 'dan']}

guys = sorted(guyprefers.keys())
gals = sorted(galprefers.keys())

def check(engaged):
    inverseengaged = dict((v,k) for k,v in engaged.items())
    for she, he in engaged.items():
        shelikes = galprefers[she]
        shelikesbetter = shelikes[:shelikes.index(he)]
        helikes = guyprefers[he]
        helikesbetter = helikes[:helikes.index(she)]
        for guy in shelikesbetter:
            guysgirl = inverseengaged[guy]
            guylikes = guyprefers[guy]
            if guylikes.index(guysgirl) > guylikes.index(she):
                print("%s and %s like each other better than their present partners: %s and %s, respectively"
                      % (she, guy, he, guysgirl))
                return False
        for gal in helikesbetter:
            girlsguy = engaged[gal]
            gallikes = galprefers[gal]
            if gallikes.index(girlsguy) > gallikes.index(he):
                print("%s and %s like each other better than their present partners: %s and %s, respectively"
                      % (he, gal, she, girlsguy))
                return False
    return True

def matchmaker():
    guysfree = guys[:]
    engaged : Dict[str, str] = {}
    guyprefers2 = deepcopy(guyprefers)
    galprefers2 = deepcopy(galprefers)
    while len(guysfree):
        guy = guysfree.pop(0)
        guyslist = ref(guyprefers2[guy])
        gal = guyslist.pop(0)
        fiance = engaged.get(gal, '')
        if fiance == '':
            # She's free
            engaged[gal] = guy
            print("  %s and %s" % (guy, gal))
        else:
            # The bounder proposes to an engaged lass!
            galslist = galprefers2[gal]
            if galslist.index(fiance) > galslist.index(guy):
                # She prefers new guy
                engaged[gal] = guy
                print("  %s dumped %s for %s" % (gal, fiance, guy))
                if len(guyprefers2[fiance]):
                    # Ex has more girls to try
                    guysfree.append(fiance)
            else:
                # She is faithful to old fiance
                if len(guyslist):
                    # Look again
                    guysfree.append(guy)
    return engaged

print('\nEngagements:')
engaged = matchmaker()

print('\nCouples:')
print('  ' + ',\n  '.join('%s is engaged to %s' % (couple_key, couple_val)
                          for couple_key, couple_val in sorted(engaged.items())))
print()
print('Engagement stability check PASSED'
      if check(engaged) else 'Engagement stability check FAILED')

print('\n\nSwapping two fiances to introduce an error')
(engaged[gals[0]], engaged[gals[1]]) = (engaged[gals[1]], engaged[gals[0]])
for gal in gals[:2]:
    print('  %s is now engaged to %s' % (gal, engaged[gal]))
print()
print('Engagement stability check PASSED'
      if check(engaged) else 'Engagement stability check FAILED')
===
V guyprefers = [‘abe’ = [‘abi’, ‘eve’, ‘cath’, ‘ivy’, ‘jan’, ‘dee’, ‘fay’, ‘bea’, ‘hope’, ‘gay’], ‘bob’ = [‘cath’, ‘hope’, ‘abi’, ‘dee’, ‘eve’, ‘fay’, ‘bea’, ‘jan’, ‘ivy’, ‘gay’], ‘col’ = [‘hope’, ‘eve’, ‘abi’, ‘dee’, ‘bea’, ‘fay’, ‘ivy’, ‘gay’, ‘cath’, ‘jan’], ‘dan’ = [‘ivy’, ‘fay’, ‘dee’, ‘gay’, ‘hope’, ‘eve’, ‘jan’, ‘bea’, ‘cath’, ‘abi’], ‘ed’ = [‘jan’, ‘dee’, ‘bea’, ‘cath’, ‘fay’, ‘eve’, ‘abi’, ‘ivy’, ‘hope’, ‘gay’], ‘fred’ = [‘bea’, ‘abi’, ‘dee’, ‘gay’, ‘eve’, ‘ivy’, ‘cath’, ‘jan’, ‘hope’, ‘fay’], ‘gav’ = [‘gay’, ‘eve’, ‘ivy’, ‘bea’, ‘cath’, ‘abi’, ‘dee’, ‘hope’, ‘jan’, ‘fay’], ‘hal’ = [‘abi’, ‘eve’, ‘hope’, ‘fay’, ‘ivy’, ‘cath’, ‘jan’, ‘bea’, ‘gay’, ‘dee’], ‘ian’ = [‘hope’, ‘cath’, ‘dee’, ‘gay’, ‘bea’, ‘abi’, ‘fay’, ‘ivy’, ‘jan’, ‘eve’], ‘jon’ = [‘abi’, ‘fay’, ‘jan’, ‘gay’, ‘eve’, ‘bea’, ‘dee’, ‘cath’, ‘ivy’, ‘hope’]]
V galprefers = [‘abi’ = [‘bob’, ‘fred’, ‘jon’, ‘gav’, ‘ian’, ‘abe’, ‘dan’, ‘ed’, ‘col’, ‘hal’], ‘bea’ = [‘bob’, ‘abe’, ‘col’, ‘fred’, ‘gav’, ‘dan’, ‘ian’, ‘ed’, ‘jon’, ‘hal’], ‘cath’ = [‘fred’, ‘bob’, ‘ed’, ‘gav’, ‘hal’, ‘col’, ‘ian’, ‘abe’, ‘dan’, ‘jon’], ‘dee’ = [‘fred’, ‘jon’, ‘col’, ‘abe’, ‘ian’, ‘hal’, ‘gav’, ‘dan’, ‘bob’, ‘ed’], ‘eve’ = [‘jon’, ‘hal’, ‘fred’, ‘dan’, ‘abe’, ‘gav’, ‘col’, ‘ed’, ‘ian’, ‘bob’], ‘fay’ = [‘bob’, ‘abe’, ‘ed’, ‘ian’, ‘jon’, ‘dan’, ‘fred’, ‘gav’, ‘col’, ‘hal’], ‘gay’ = [‘jon’, ‘gav’, ‘hal’, ‘fred’, ‘bob’, ‘abe’, ‘col’, ‘ed’, ‘dan’, ‘ian’], ‘hope’ = [‘gav’, ‘jon’, ‘bob’, ‘abe’, ‘ian’, ‘dan’, ‘hal’, ‘ed’, ‘col’, ‘fred’], ‘ivy’ = [‘ian’, ‘col’, ‘hal’, ‘gav’, ‘fred’, ‘bob’, ‘abe’, ‘ed’, ‘jon’, ‘dan’], ‘jan’ = [‘ed’, ‘hal’, ‘gav’, ‘abe’, ‘bob’, ‘jon’, ‘col’, ‘ian’, ‘fred’, ‘dan’]]

V guys = sorted(guyprefers.keys())
V gals = sorted(galprefers.keys())

F check(engaged)
   V inverseengaged = Dict(engaged.map((k, v) -> (v, k)))
   L(she, he) engaged
      V shelikes = :galprefers[she]
      V shelikesbetter = shelikes[0 .< shelikes.index(he)]
      V helikes = :guyprefers[he]
      V helikesbetter = helikes[0 .< helikes.index(she)]
      L(guy) shelikesbetter
         V guysgirl = inverseengaged[guy]
         V guylikes = :guyprefers[guy]
         I guylikes.index(guysgirl) > guylikes.index(she)
            print(‘#. and #. like each other better than their present partners: #. and #., respectively’.format(she, guy, he, guysgirl))
            R 0B
      L(gal) helikesbetter
         V girlsguy = engaged[gal]
         V gallikes = :galprefers[gal]
         I gallikes.index(girlsguy) > gallikes.index(he)
            print(‘#. and #. like each other better than their present partners: #. and #., respectively’.format(he, gal, she, girlsguy))
            R 0B
   R 1B

F matchmaker()
   V guysfree = copy(:guys)
   [String = String] engaged
   V guyprefers2 = copy(:guyprefers)
   V galprefers2 = copy(:galprefers)
   L !guysfree.empty
      V guy = guysfree.pop(0)
      V& guyslist = guyprefers2[guy]
      V gal = guyslist.pop(0)
      V fiance = engaged.get(gal, ‘’)
      I fiance == ‘’
         engaged[gal] = guy
         print(‘  #. and #.’.format(guy, gal))
      E
         V galslist = galprefers2[gal]
         I galslist.index(fiance) > galslist.index(guy)
            engaged[gal] = guy
            print(‘  #. dumped #. for #.’.format(gal, fiance, guy))
            I !guyprefers2[fiance].empty
               guysfree.append(fiance)
         E
            I !guyslist.empty
               guysfree.append(guy)
   R engaged

print("\nEngagements:")
V engaged = matchmaker()

print("\nCouples:")
print(‘  ’sorted(engaged.items()).map((couple_key, couple_val) -> ‘#. is engaged to #.’.format(couple_key, couple_val)).join(",\n  "))
print()
print(I check(engaged) {‘Engagement stability check PASSED’} E ‘Engagement stability check FAILED’)

print("\n\nSwapping two fiances to introduce an error")
swap(&engaged[gals[0]], &engaged[gals[1]])
L(gal) gals[0.<2]
   print(‘  #. is now engaged to #.’.format(gal, engaged[gal]))
print()
print(I check(engaged) {‘Engagement stability check PASSED’} E ‘Engagement stability check FAILED’)
===
auto guyprefers = create_dict(dict_of(u"abe"_S, create_array({u"abi"_S, u"eve"_S, u"cath"_S, u"ivy"_S, u"jan"_S, u"dee"_S, u"fay"_S, u"bea"_S, u"hope"_S, u"gay"_S}))(u"bob"_S, create_array({u"cath"_S, u"hope"_S, u"abi"_S, u"dee"_S, u"eve"_S, u"fay"_S, u"bea"_S, u"jan"_S, u"ivy"_S, u"gay"_S}))(u"col"_S, create_array({u"hope"_S, u"eve"_S, u"abi"_S, u"dee"_S, u"bea"_S, u"fay"_S, u"ivy"_S, u"gay"_S, u"cath"_S, u"jan"_S}))(u"dan"_S, create_array({u"ivy"_S, u"fay"_S, u"dee"_S, u"gay"_S, u"hope"_S, u"eve"_S, u"jan"_S, u"bea"_S, u"cath"_S, u"abi"_S}))(u"ed"_S, create_array({u"jan"_S, u"dee"_S, u"bea"_S, u"cath"_S, u"fay"_S, u"eve"_S, u"abi"_S, u"ivy"_S, u"hope"_S, u"gay"_S}))(u"fred"_S, create_array({u"bea"_S, u"abi"_S, u"dee"_S, u"gay"_S, u"eve"_S, u"ivy"_S, u"cath"_S, u"jan"_S, u"hope"_S, u"fay"_S}))(u"gav"_S, create_array({u"gay"_S, u"eve"_S, u"ivy"_S, u"bea"_S, u"cath"_S, u"abi"_S, u"dee"_S, u"hope"_S, u"jan"_S, u"fay"_S}))(u"hal"_S, create_array({u"abi"_S, u"eve"_S, u"hope"_S, u"fay"_S, u"ivy"_S, u"cath"_S, u"jan"_S, u"bea"_S, u"gay"_S, u"dee"_S}))(u"ian"_S, create_array({u"hope"_S, u"cath"_S, u"dee"_S, u"gay"_S, u"bea"_S, u"abi"_S, u"fay"_S, u"ivy"_S, u"jan"_S, u"eve"_S}))(u"jon"_S, create_array({u"abi"_S, u"fay"_S, u"jan"_S, u"gay"_S, u"eve"_S, u"bea"_S, u"dee"_S, u"cath"_S, u"ivy"_S, u"hope"_S})));
auto galprefers = create_dict(dict_of(u"abi"_S, create_array({u"bob"_S, u"fred"_S, u"jon"_S, u"gav"_S, u"ian"_S, u"abe"_S, u"dan"_S, u"ed"_S, u"col"_S, u"hal"_S}))(u"bea"_S, create_array({u"bob"_S, u"abe"_S, u"col"_S, u"fred"_S, u"gav"_S, u"dan"_S, u"ian"_S, u"ed"_S, u"jon"_S, u"hal"_S}))(u"cath"_S, create_array({u"fred"_S, u"bob"_S, u"ed"_S, u"gav"_S, u"hal"_S, u"col"_S, u"ian"_S, u"abe"_S, u"dan"_S, u"jon"_S}))(u"dee"_S, create_array({u"fred"_S, u"jon"_S, u"col"_S, u"abe"_S, u"ian"_S, u"hal"_S, u"gav"_S, u"dan"_S, u"bob"_S, u"ed"_S}))(u"eve"_S, create_array({u"jon"_S, u"hal"_S, u"fred"_S, u"dan"_S, u"abe"_S, u"gav"_S, u"col"_S, u"ed"_S, u"ian"_S, u"bob"_S}))(u"fay"_S, create_array({u"bob"_S, u"abe"_S, u"ed"_S, u"ian"_S, u"jon"_S, u"dan"_S, u"fred"_S, u"gav"_S, u"col"_S, u"hal"_S}))(u"gay"_S, create_array({u"jon"_S, u"gav"_S, u"hal"_S, u"fred"_S, u"bob"_S, u"abe"_S, u"col"_S, u"ed"_S, u"dan"_S, u"ian"_S}))(u"hope"_S, create_array({u"gav"_S, u"jon"_S, u"bob"_S, u"abe"_S, u"ian"_S, u"dan"_S, u"hal"_S, u"ed"_S, u"col"_S, u"fred"_S}))(u"ivy"_S, create_array({u"ian"_S, u"col"_S, u"hal"_S, u"gav"_S, u"fred"_S, u"bob"_S, u"abe"_S, u"ed"_S, u"jon"_S, u"dan"_S}))(u"jan"_S, create_array({u"ed"_S, u"hal"_S, u"gav"_S, u"abe"_S, u"bob"_S, u"jon"_S, u"col"_S, u"ian"_S, u"fred"_S, u"dan"_S})));

auto guys = sorted(guyprefers.keys());
auto gals = sorted(galprefers.keys());

template <typename T1> auto check(const T1 &engaged)
{
    auto inverseengaged = create_dict(engaged.map([](const auto &k, const auto &v){return make_tuple(v, k);}));
    for (auto &&[she, he] : engaged) {
        auto shelikes = ::galprefers[she];
        auto shelikesbetter = shelikes[range_el(0, shelikes.index(he))];
        auto helikes = ::guyprefers[he];
        auto helikesbetter = helikes[range_el(0, helikes.index(she))];
        for (auto &&guy : shelikesbetter) {
            auto guysgirl = inverseengaged[guy];
            auto guylikes = ::guyprefers[guy];
            if (guylikes.index(guysgirl) > guylikes.index(she)) {
                print(u"#. and #. like each other better than their present partners: #. and #., respectively"_S.format(she, guy, he, guysgirl));
                return false;
            }
        }
        for (auto &&gal : helikesbetter) {
            auto girlsguy = engaged[gal];
            auto gallikes = ::galprefers[gal];
            if (gallikes.index(girlsguy) > gallikes.index(he)) {
                print(u"#. and #. like each other better than their present partners: #. and #., respectively"_S.format(he, gal, she, girlsguy));
                return false;
            }
        }
    }
    return true;
}

auto matchmaker()
{
    auto guysfree = copy(::guys);
    Dict<String, String> engaged;
    auto guyprefers2 = copy(::guyprefers);
    auto galprefers2 = copy(::galprefers);
    while (!guysfree.empty()) {
        auto guy = guysfree.pop(0);
        auto& guyslist = guyprefers2[guy];
        auto gal = guyslist.pop(0);
        auto fiance = engaged.get(gal, u""_S);
        if (fiance == u"") {
            engaged.set(gal, guy);
            print(u"  #. and #."_S.format(guy, gal));
        }
        else {
            auto galslist = galprefers2[gal];
            if (galslist.index(fiance) > galslist.index(guy)) {
                engaged.set(gal, guy);
                print(u"  #. dumped #. for #."_S.format(gal, fiance, guy));
                if (!guyprefers2[fiance].empty())
                    guysfree.append(fiance);
            }
            else
                if (!guyslist.empty())
                    guysfree.append(guy);
        }
    }
    return engaged;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"\nEngagements:"_S);
    }
} code_block_1;

auto engaged = matchmaker();

struct CodeBlock2
{
    CodeBlock2()
    {
        print(u"\nCouples:"_S);
        print(u"  "_S & sorted(engaged.items()).map([](const auto &couple_key, const auto &couple_val){return u"#. is engaged to #."_S.format(couple_key, couple_val);}).join(u",\n  "_S));
        print();
        print(check(engaged) ? u"Engagement stability check PASSED"_S : u"Engagement stability check FAILED"_S);

        print(u"\n\nSwapping two fiances to introduce an error"_S);
        swap(engaged[_get<0>(gals)], engaged[_get<1>(gals)]);
        for (auto &&gal : gals[range_el(0, 2)])
            print(u"  #. is now engaged to #."_S.format(gal, engaged[gal]));
        print();
        print(check(engaged) ? u"Engagement stability check PASSED"_S : u"Engagement stability check FAILED"_S);
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Straddling_checkerboard#Python
from typing import List

t = [[str("79"), "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"],
     [str(""),   "H", "O", "L", "",  "M", "E", "S", "",  "R", "T"],
     [str("3"),  "A", "B", "C", "D", "F", "G", "I", "J", "K", "N"],
     [str("7"),  "P", "Q", "U", "V", "W", "X", "Y", "Z", ".", "/"]]

def straddle(s):
    return "".join(l[0]+''+t[0][l.index(c)] for c in list(s.upper()) for l in t if c in l) # [-`list(s.upper())` -> `s.upper()` [`String` support in `multiloop_filtered()`]-]

def unstraddle(s):
    r : List[str] = []
    si = 0
    def next():
        nonlocal si
        r = s[si]
        si += 1
        return r
    while True:
        if si == len(s):
            break
        c = s[si]
        si += 1
        if c in (t[2][0], t[3][0]):
            i = [t[2][0], t[3][0]].index(c)
            n = t[2 + i][t[0].index(next())]
            r += [next() if n == "/" else n]
        else:
            r += [t[1][t[0].index(c)]]
    return r

O = "One night-it was on the twentieth of March, 1888-I was returning"
print("Encoded:", straddle(O))
print("Decoded:", "".join(unstraddle(straddle(O))))
===
V t = [[String(‘79’), ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’], [String(‘’), ‘H’, ‘O’, ‘L’, ‘’, ‘M’, ‘E’, ‘S’, ‘’, ‘R’, ‘T’], [String(‘3’), ‘A’, ‘B’, ‘C’, ‘D’, ‘F’, ‘G’, ‘I’, ‘J’, ‘K’, ‘N’], [String(‘7’), ‘P’, ‘Q’, ‘U’, ‘V’, ‘W’, ‘X’, ‘Y’, ‘Z’, ‘.’, ‘/’]]

F straddle(s)
   R multiloop_filtered(Array(s.uppercase()), :t, (c, l) -> c C l, (c, l) -> l[0]‘’:t[0][l.index(c)]).join(‘’)

F unstraddle(s)
   [String] r
   V si = 0
   F next()
      V r = @s[@si]
      @si++
      R r
   L
      I si == s.len
         L.break
      V c = s[si]
      si++
      I c C (:t[2][0], :t[3][0])
         V i = [:t[2][0], :t[3][0]].index(c)
         V n = :t[2 + i][:t[0].index(next())]
         r [+]= I n == ‘/’ {next()} E n
      E
         r [+]= :t[1][:t[0].index(c)]
   R r

V O = ‘One night-it was on the twentieth of March, 1888-I was returning’
print(‘Encoded: ’straddle(O))
print(‘Decoded: ’unstraddle(straddle(O)).join(‘’))
===
auto t = create_array({create_array<String>({String(u"79"_S), u"0"_S, u"1"_S, u"2"_S, u"3"_S, u"4"_S, u"5"_S, u"6"_S, u"7"_S, u"8"_S, u"9"_S}), create_array<String>({String(u""_S), u"H"_S, u"O"_S, u"L"_S, u""_S, u"M"_S, u"E"_S, u"S"_S, u""_S, u"R"_S, u"T"_S}), create_array<String>({String(u"3"_S), u"A"_S, u"B"_S, u"C"_S, u"D"_S, u"F"_S, u"G"_S, u"I"_S, u"J"_S, u"K"_S, u"N"_S}), create_array<String>({String(u"7"_S), u"P"_S, u"Q"_S, u"U"_S, u"V"_S, u"W"_S, u"X"_S, u"Y"_S, u"Z"_S, u"."_S, u"/"_S})});

template <typename T1> auto straddle(const T1 &s)
{
    return multiloop_filtered(create_array(s.uppercase()), ::t, [](const auto &c, const auto &l){return in(c, l);}, [](const auto &c, const auto &l){return _get<0>(l) & _get<0>(::t)[l.index(c)];}).join(u""_S);
}

template <typename T1> auto unstraddle(const T1 &s)
{
    Array<String> r;
    auto si = 0;
    auto next = [&s, &si]()
    {
        auto r = s[si];
        si++;
        return r;
    };
    while (true) {
        if (si == s.len())
            break;
        auto c = s[si];
        si++;
        if (in(c, make_tuple(_get<0>(_get<2>(::t)), _get<0>(_get<3>(::t))))) {
            auto i = create_array({_get<0>(_get<2>(::t)), _get<0>(_get<3>(::t))}).index(c);
            auto n = ::t[2 + i][_get<0>(::t).index(next())];
            r.append(n == u'/' ? next() : n);
        }
        else
            r.append(_get<1>(::t)[_get<0>(::t).index(c)]);
    }
    return r;
}

auto O = u"One night-it was on the twentieth of March, 1888-I was returning"_S;

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"Encoded: "_S & straddle(O));
        print(u"Decoded: "_S & unstraddle(straddle(O)).join(u""_S));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Sudoku#Kotlin
class Sudoku:
    solved = False

    def __init__(self, rows):
        assert len(rows) == 9 and all(len(row) == 9 for row in rows), "Grid must be 9 x 9"
        self.grid = [0] * 81
        for i in range(9):
            for j in range(9):
                self.grid[9 * i + j] = int(rows[i][j])

    def solve(self):
        print("Starting grid:\n\n" + str(self))
        self.placeNumber(0)
        print("Solution:\n\n" + str(self) if self.solved else "Unsolvable!")

    def placeNumber(self, pos):
        if self.solved:
            return
        if pos == 81:
            self.solved = True
            return

        if self.grid[pos] > 0:
            self.placeNumber(pos + 1)
            return

        for n in range(1, 10):
            if self.checkValidity(n, pos % 9, pos // 9):
                self.grid[pos] = n
                self.placeNumber(pos + 1)
                if self.solved:
                    return
                self.grid[pos] = 0

    def checkValidity(self, v, x, y):
        for i in range(9):
            if self.grid[y * 9 + i] == v or \
               self.grid[i * 9 + x] == v: return False

        startX = (x // 3) * 3
        startY = (y // 3) * 3
        for i in range(startY, startY + 3):
            for j in range(startX, startX + 3):
                if self.grid[i * 9 + j] == v: return False

        return True

    def __str__(self):
        s = ''
        for i in range(9):
            for j in range(9):
                s += str(self.grid[i * 9 + j]) + ' '
                if j in (2, 5):
                    s += '| '
            s += "\n"
            if i in (2, 5):
                s += "------+-------+------\n"
        return s

rows = ["850002400",
        "720000009",
        "004000000",
        "000107002",
        "305000900",
        "040000000",
        "000080070",
        "017000000",
        "000036040"]

Sudoku(rows).solve()
===
T Sudoku
   solved = 0B
   grid = [0] * 81

   F (rows)
      assert(rows.len == 9 & all(rows.map(row -> row.len == 9)), ‘Grid must be 9 x 9’)
      L(i) 9
         L(j) 9
            .grid[9 * i + j] = Int(rows[i][j])

   F solve()
      print("Starting grid:\n\n"String((.)))
      .placeNumber(0)
      print(I .solved {"Solution:\n\n"String((.))} E ‘Unsolvable!’)

   F placeNumber(pos)
      I .solved
         R
      I pos == 81
         .solved = 1B
         R

      I .grid[pos] > 0
         .placeNumber(pos + 1)
         R

      L(n) 1..9
         I .checkValidity(n, pos % 9, pos I/ 9)
            .grid[pos] = n
            .placeNumber(pos + 1)
            I .solved
               R
            .grid[pos] = 0

   F checkValidity(v, x, y)
      L(i) 9
         I .grid[y * 9 + i] == v | .grid[i * 9 + x] == v
            R 0B

      V startX = (x I/ 3) * 3
      V startY = (y I/ 3) * 3
      L(i) startY .< startY + 3
         L(j) startX .< startX + 3
            I .grid[i * 9 + j] == v
               R 0B

      R 1B

   F String()
      V s = ‘’
      L(i) 9
         L(j) 9
            s ‘’= String(.grid[i * 9 + j])‘ ’
            I j C (2, 5)
               s ‘’= ‘| ’
         s ‘’= "\n"
         I i C (2, 5)
            s ‘’= "------+-------+------\n"
      R s

V rows = [‘850002400’, ‘720000009’, ‘004000000’, ‘000107002’, ‘305000900’, ‘040000000’, ‘000080070’, ‘017000000’, ‘000036040’]

Sudoku(rows).solve()
===
class Sudoku
{
public:
    decltype(false) solved = false;
    decltype(create_array({0}) * 81) grid = create_array({0}) * 81;

    template <typename T1> Sudoku(const T1 &rows)
    {
        assert(rows.len() == 9 && all_map(rows, [](const auto &row){return row.len() == 9;}), u"Grid must be 9 x 9"_S);
        for (int i = 0; i < 9; i++)
            for (int j = 0; j < 9; j++)
                grid.set(9 * i + j, to_int(rows[i][j]));
    }

    auto solve()
    {
        print(u"Starting grid:\n\n"_S & String(*this));
        placeNumber(0);
        print(solved ? u"Solution:\n\n"_S & String(*this) : u"Unsolvable!"_S);
    }

    template <typename T1> auto placeNumber(const T1 &pos)
    {
        if (solved)
            return;
        if (pos == 81) {
            solved = true;
            return;
        }

        if (grid[pos] > 0) {
            placeNumber(pos + 1);
            return;
        }

        for (auto n : range_ee(1, 9))
            if (checkValidity(n, mod(pos, 9), idiv(pos, 9))) {
                grid.set(pos, n);
                placeNumber(pos + 1);
                if (solved)
                    return;
                grid.set(pos, 0);
            }
    }

    template <typename T1, typename T2, typename T3> auto checkValidity(const T1 &v, const T2 &x, const T3 &y)
    {
        for (int i = 0; i < 9; i++)
            if (grid[y * 9 + i] == v || grid[i * 9 + x] == v)
                return false;

        auto startX = (idiv(x, 3)) * 3;
        auto startY = (idiv(y, 3)) * 3;
        for (auto i : range_el(startY, startY + 3))
            for (auto j : range_el(startX, startX + 3))
                if (grid[i * 9 + j] == v)
                    return false;

        return true;
    }

    operator String() const
    {
        auto s = u""_S;
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                s &= String(grid[i * 9 + j]) & u" "_S;
                if (in(j, make_tuple(2, 5)))
                    s &= u"| "_S;
            }
            s &= u"\n"_S;
            if (in(i, make_tuple(2, 5)))
                s &= u"------+-------+------\n"_S;
        }
        return s;
    }
};

auto rows = create_array({u"850002400"_S, u"720000009"_S, u"004000000"_S, u"000107002"_S, u"305000900"_S, u"040000000"_S, u"000080070"_S, u"017000000"_S, u"000036040"_S});

struct CodeBlock1
{
    CodeBlock1()
    {
        Sudoku(rows).solve();
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Summarize_and_say_sequence#C++
import collections
from typing import List

result : List[str] = []
longest = 0

def make_sequence(n) -> None:
    map : DefaultDict[Char, int] = collections.defaultdict(int)
    for c in n:
        map[c] += 1

    z = ''
    for k in sorted(map.keys(), reverse = True):
        z += chr(map[k] + ord('0'))
        z += k

    global longest, result
    if longest <= len(z):
        longest = len(z)
        if z not in result:
            result += [z]
            make_sequence(z)

for test in ['9900', '9090', '9009']:
    result.clear()
    longest = 0
    make_sequence(test)
    print('[%s] Iterations: %d' % (test, len(result) + 1))
    print("\n".join(result))
    print("\n")
===
[String] result
V longest = 0

F make_sequence(n) -> N
   DefaultDict[Char, Int] map
   L(c) n
      map[c]++

   V z = ‘’
   L(k) sorted(map.keys(), reverse' 1B)
      z ‘’= Char(code' map[k] + ‘0’.code)
      z ‘’= k
   I :longest <= z.len
      :longest = z.len
      I z !C :result
         :result [+]= z
         make_sequence(z)

L(test) [‘9900’, ‘9090’, ‘9009’]
   result.clear()
   longest = 0
   make_sequence(test)
   print(‘[#.] Iterations: #.’.format(test, result.len + 1))
   print(result.join("\n"))
   print("\n")
===
Array<String> result;
auto longest = 0;

template <typename T1> void make_sequence(const T1 &n)
{
    DefaultDict<Char, int> map;
    for (auto &&c : n)
        map[c]++;

    auto z = u""_S;
    for (auto &&k : sorted(map.keys(), nullptr, true)) {
        z &= Char(map[k] + u'0'_C.code);
        z &= k;
    }
    if (::longest <= z.len()) {
        ::longest = z.len();
        if (!in(z, ::result)) {
            ::result.append(z);
            make_sequence(z);
        }
    }
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&test : create_array({u"9900"_S, u"9090"_S, u"9009"_S})) {
            result.clear();
            longest = 0;
            make_sequence(test);
            print(u"[#.] Iterations: #."_S.format(test, result.len() + 1));
            print(result.join(u"\n"_S));
            print(u"\n"_S);
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Sunflower_fractal#Perl
import math

phi = (1 + math.sqrt(5)) / 2

size = 600
seeds = 5 * size

print('<svg xmlns="http://www.w3.org/2000/svg" width="' + str(size) + '" height="' + str(size) + '" style="stroke:gold">')
print('<rect width="100%" height="100%" fill="black" />')

for i in range(1, seeds + 1):
    r = 2 * (i**phi) / seeds
    t = 2 * math.pi * phi * i
    print('<circle cx="%.2f" cy="%.2f" r="%.1f" />' % (r * math.sin(t) + size/2,
                                                       r * math.cos(t) + size/2, math.sqrt(i)/13))

print('</svg>')
===
V phi = (1 + sqrt(5)) / 2

V size = 600
V seeds = 5 * size

print(‘<svg xmlns="http://www.w3.org/2000/svg" width="’String(size)‘" height="’String(size)‘" style="stroke:gold">’)
print(‘<rect width="100%" height="100%" fill="black" />’)

L(i) 1 .. seeds
   V r = 2 * (i ^ phi) / seeds
   V t = 2 * math:pi * phi * i
   print(‘<circle cx="#.2" cy="#.2" r="#.1" />’.format(r * sin(t) + size / 2, r * cos(t) + size / 2, sqrt(i) / 13))

print(‘</svg>’)
===
auto phi = (1 + sqrt(5)) / 2.0;

auto size = 600;
auto seeds = 5 * size;

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"<svg xmlns=\"http://www.w3.org/2000/svg\" width=\""_S & String(size) & u"\" height=\""_S & String(size) & u"\" style=\"stroke:gold\">"_S);
        print(u"<rect width=\"100%\" height=\"100%\" fill=\"black\" />"_S);

        for (auto i : range_ee(1, seeds)) {
            auto r = 2 * (pow(i, phi)) / seeds;
            auto t = 2 * math::pi * phi * i;
            print(u"<circle cx=\"#.2\" cy=\"#.2\" r=\"#.1\" />"_S.format(r * sin(t) + size / 2.0, r * cos(t) + size / 2.0, sqrt(i) / 13.0));
        }

        print(u"</svg>"_S);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Super-d_numbers#D
# Slow BigInt
BigInt = int

rd = ["22", "333", "4444", "55555", "666666", "7777777", "88888888", "999999999"]

for ii in range(2, 8):
    print('First 10 super-%d numbers:' % ii)
    count = 0

    j : BigInt = 3
    while True:
        k = ii * j**ii
        if rd[ii-2] in str(k):
            count += 1
            print(j, end = ' ')
            if count == 10:
                print("\n")
                break
        j += 1
===
V rd = [‘22’, ‘333’, ‘4444’, ‘55555’, ‘666666’, ‘7777777’, ‘88888888’, ‘999999999’]

L(ii) 2..7
   print(‘First 10 super-#. numbers:’.format(ii))
   V count = 0

   BigInt j = 3
   L
      V k = ii * j ^ ii
      I rd[ii - 2] C String(k)
         count++
         print(j, end' ‘ ’)
         I count == 10
            print("\n")
            L.break
      j++
===
auto rd = create_array({u"22"_S, u"333"_S, u"4444"_S, u"55555"_S, u"666666"_S, u"7777777"_S, u"88888888"_S, u"999999999"_S});

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto ii : range_ee(2, 7)) {
            print(u"First 10 super-#. numbers:"_S.format(ii));
            auto count = 0;

            BigInt j = 3;
            while (true) {
                auto k = ii * pow(j, ii);
                if (in(rd[ii - 2], String(k))) {
                    count++;
                    print(j, u" "_S);
                    if (count == 10) {
                        print(u"\n"_S);
                        break;
                    }
                }
                j++;
            }
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Superpermutation_minimisation#Kotlin
from typing import List
Char = str

MAX = 12

sp : List[Char] = []
count = [0] * MAX
pos = 0

def factSum(n):
    s = 0
    x = 0
    f = 1
    while x < n:
        x += 1
        f *= x
        s += f
    return s

def r(n):
    if n == 0: return False
    global pos
    c = sp[pos - n]
    count[n] -= 1
    if count[n] == 0:
        count[n] = n
        if not r(n - 1): return False
    sp[pos] = c
    pos += 1
    return True

def superPerm(n):
    global pos, sp
    pos = n
    len = factSum(n)
    if len > 0: sp = [Char("\0")] * len
    for i in range(n + 1):
        count[i] = i
    for i in range(1, n + 1):
        sp[i - 1] = chr(ord('0') + i)
    while r(n):
        pass

for n in range(MAX):
    superPerm(n)
    print("superPerm(%2d) len = %i" % (n, len(sp)))
===
V MAX = 12

[Char] sp
V count = [0] * MAX
V pos = 0

F factSum(n)
   V s = 0
   V x = 0
   V f = 1
   L x < n
      x++
      f *= x
      s += f
   R s

F r(n)
   I n == 0
      R 0B
   V c = :sp[:pos - n]
   I --:count[n] == 0
      :count[n] = n
      I !r(n - 1)
         R 0B
   :sp[:pos] = c
   :pos++
   R 1B

F superPerm(n)
   :pos = n
   V len = factSum(n)
   I len > 0
      :sp = [Char("\0")] * len
   L(i) 0 .. n
      :count[i] = i
   L(i) 1 .. n
      :sp[i - 1] = Char(code' ‘0’.code + i)
   L r(n)
   {
   }

L(n) 0 .< MAX
   superPerm(n)
   print(‘superPerm(#2) len = #.’.format(n, sp.len))
===
auto MAX = 12;

Array<Char> sp;
auto count = create_array({0}) * MAX;
auto pos = 0;

template <typename T1> auto factSum(const T1 &n)
{
    auto s = 0;
    auto x = 0;
    auto f = 1;
    while (x < n) {
        x++;
        f *= x;
        s += f;
    }
    return s;
}

template <typename T1> auto r(const T1 &n)
{
    if (n == 0)
        return false;
    auto c = ::sp[::pos - n];
    if (--::count[n] == 0) {
        ::count.set(n, n);
        if (!r(n - 1))
            return false;
    }
    ::sp.set(::pos, c);
    ::pos++;
    return true;
}

template <typename T1> auto superPerm(const T1 &n)
{
    ::pos = n;
    auto len = factSum(n);
    if (len > 0)
        ::sp = create_array({u'\0'_C}) * len;
    for (auto i : range_ee(0, n))
        ::count.set(i, i);
    for (auto i : range_ee(1, n))
        ::sp.set(i - 1, Char(u'0'_C.code + i));
    while (r(n)) {
    }
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto n : range_el(0, MAX)) {
            superPerm(n);
            print(u"superPerm(#2) len = #."_S.format(n, sp.len()));
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/S-expressions#Nim
from enum import IntEnum
Char = str

class Token:
    class Kind(IntEnum):
        INT = 0
        FLOAT = 1
        STRING = 2
        IDENT = 3
        LPAR = 4
        RPAR = 5
        END = 6

    kind : Kind
    val : str

    def __init__(self, kind, val = ''):
        self.kind = kind
        self.val = val

def lex(input_str):
    result : List[Token] = []
    pos = 0

    def current():
        return input_str[pos] if pos < len(input_str) else Char("\0")

    while pos < len(input_str):
        ch = input_str[pos]
        if ch == '(':
            pos += 1
            result.append(Token(Token.Kind.LPAR))
        elif ch == ')':
            pos += 1
            result.append(Token(Token.Kind.RPAR))
        elif '0' <= ch <= '9':
            num = ''
            kind = Token.Kind.INT
            while '0' <= current() <= '9':
                num += current()
                pos += 1
            if current() == '.':
                num += current()
                kind = Token.Kind.FLOAT
                pos += 1
                while '0' <= current() <= '9':
                    num += current()
                    pos += 1
            result.append(Token(kind, num))
        elif ch in (' ', "\t", "\n", "\r"):
            pos += 1
        elif ch == '"':
            str = ''
            pos += 1
            while current() != '"':
                str += current()
                pos += 1
            pos += 1
            result.append(Token(Token.Kind.STRING, str))
        else:
            BannedChars = {' ', '\t', '"', '(', ')', ';'}
            ident = ''
            while current() not in BannedChars:
                ident += current()
                pos += 1
            result.append(Token(Token.Kind.IDENT, ident))

    result.append(Token(Token.Kind.END))
    return result

def indent(s, count):
    return count * ' ' + s.replace("\n", "\n" + count * ' ')

class SExpr:
    class Kind(IntEnum):
        INT = 0
        FLOAT = 1
        STRING = 2
        IDENT = 3
        LIST = 4

    kind : Kind
    val : str

    def __init__(self, kind, val = ''):
        self.kind = kind
        self.val = val
        self.children : List[SExpr] = []

    def to_str(self):
        if self.kind in (SExpr.Kind.INT, SExpr.Kind.FLOAT, SExpr.Kind.IDENT):
            return self.val
        elif self.kind == SExpr.Kind.STRING:
            return '"' + self.val + '"'
        elif self.kind == SExpr.Kind.LIST:
            result = '('
            for i, ex in enumerate(self.children):
                if ex.kind == SExpr.Kind.LIST and len(ex.children) > 1:
                    result += "\n"
                    result += indent(ex.to_str(), 2)
                else:
                    if i > 0:
                        result += ' '
                    result += ex.to_str()
            return result + ')'
        assert(False)

input_str = """
((data "quoted data" 123 4.5)
 (data (!@# (4.5) "(more" "data)")))
"""
tokens = lex(input_str)
pos = 0

def current():
    return tokens[pos] if pos < len(tokens) else Token(Token.Kind.END)

def parse() -> SExpr:
    token = current()
    global pos
    pos += 1
    if token.kind == Token.Kind.INT:
        return SExpr(SExpr.Kind.INT, token.val)
    elif token.kind == Token.Kind.FLOAT:
        return SExpr(SExpr.Kind.FLOAT, token.val)
    elif token.kind == Token.Kind.STRING:
        return SExpr(SExpr.Kind.STRING, token.val)
    elif token.kind == Token.Kind.IDENT:
        return SExpr(SExpr.Kind.IDENT, token.val)
    elif token.kind == Token.Kind.LPAR:
        result = SExpr(SExpr.Kind.LIST)
        while current().kind not in (Token.Kind.RPAR, Token.Kind.END):
            result.children.append(parse())
        assert current().kind != Token.Kind.END, "Missing right paren ')'"
        pos += 1
        return result
    assert(False)

print(parse().to_str())
===
T Token
   T.enum Kind
      INT
      FLOAT
      STRING
      IDENT
      LPAR
      RPAR
      END

   Kind kind
   String val

   F (kind, val = ‘’)
      .kind = kind
      .val = val

F lex(input_str)
   [Token] result
   V pos = 0

   F current()
      R I @pos < @input_str.len {@input_str[@pos]} E Char("\0")

   L pos < input_str.len
      V ch = input_str[pos]
      I ch == ‘(’
         pos++
         result.append(Token(Token.Kind.LPAR))
      E I ch == ‘)’
         pos++
         result.append(Token(Token.Kind.RPAR))
      E I ch C ‘0’..‘9’
         V num = ‘’
         V kind = Token.Kind.INT
         L current() C ‘0’..‘9’
            num ‘’= current()
            pos++
         I current() == ‘.’
            num ‘’= current()
            kind = FLOAT
            pos++
            L current() C ‘0’..‘9’
               num ‘’= current()
               pos++
         result.append(Token(kind, num))
      E I ch C (‘ ’, "\t", "\n", "\r")
         pos++
      E I ch == ‘"’
         V str = ‘’
         pos++
         L current() != ‘"’
            str ‘’= current()
            pos++
         pos++
         result.append(Token(Token.Kind.STRING, str))
      E
         V BannedChars = Set([‘ ’, "\t", ‘"’, ‘(’, ‘)’, ‘;’])
         V ident = ‘’
         L current() !C BannedChars
            ident ‘’= current()
            pos++
         result.append(Token(Token.Kind.IDENT, ident))

   result.append(Token(Token.Kind.END))
   R result

F indent(s, count)
   R (count * ‘ ’)‘’s.replace("\n", "\n"(count * ‘ ’))

T SExpr
   T.enum Kind
      INT
      FLOAT
      STRING
      IDENT
      LIST

   Kind kind
   String val
   [SExpr] children

   F (kind, val = ‘’)
      .kind = kind
      .val = val

   F to_str()
      I .kind C (SExpr.Kind.INT, SExpr.Kind.FLOAT, SExpr.Kind.IDENT)
         R .val
      E I .kind == STRING
         R ‘"’(.val)‘"’
      E I .kind == LIST
         V result = ‘(’
         L(i, ex) enumerate(.children)
            I ex.kind == LIST & ex.children.len > 1
               result ‘’= "\n"
               result ‘’= indent(ex.to_str(), 2)
            E
               I i > 0
                  result ‘’= ‘ ’
               result ‘’= ex.to_str()
         R result‘)’
      assert(0B)

V input_str = ‘
((data "quoted data" 123 4.5)
 (data (!@# (4.5) "(more" "data)")))
’
V tokens = lex(input_str)
V pos = 0

F current()
   R I :pos < :tokens.len {:tokens[:pos]} E Token(Token.Kind.END)

F parse() -> SExpr
   V token = current()
   :pos++
   I token.kind == INT
      R SExpr(SExpr.Kind.INT, token.val)
   E I token.kind == FLOAT
      R SExpr(SExpr.Kind.FLOAT, token.val)
   E I token.kind == STRING
      R SExpr(SExpr.Kind.STRING, token.val)
   E I token.kind == IDENT
      R SExpr(SExpr.Kind.IDENT, token.val)
   E I token.kind == LPAR
      V result = SExpr(SExpr.Kind.LIST)
      L current().kind !C (Token.Kind.RPAR, Token.Kind.END)
         result.children.append(parse())
      assert(current().kind != END, ‘Missing right paren ')'’)
      :pos++
      R result
   assert(0B)

print(parse().to_str())
===
class Token
{
public:
    enum class Kind {
        INT,
        FLOAT,
        STRING,
        IDENT,
        LPAR,
        RPAR,
        END
    };

    Kind kind;
    String val;

    template <typename T1, typename T2 = decltype(u""_S)> Token(const T1 &kind, const T2 &val = u""_S) :
        kind(kind),
        val(val)
    {
    }
};

template <typename T1> auto lex(const T1 &input_str)
{
    Array<Token> result;
    auto pos = 0;

    auto current = [&input_str, &pos]()
    {
        return pos < input_str.len() ? input_str[pos] : u'\0'_C;
    };

    while (pos < input_str.len()) {
        auto ch = input_str[pos];
        if (ch == u'(') {
            pos++;
            result.append(Token(Token::Kind::LPAR));
        }
        else if (ch == u')') {
            pos++;
            result.append(Token(Token::Kind::RPAR));
        }
        else if (in(ch, range_ee(u'0'_C, u'9'_C))) {
            auto num = u""_S;
            auto kind = Token::Kind::INT;
            while (in(current(), range_ee(u'0'_C, u'9'_C))) {
                num &= current();
                pos++;
            }
            if (current() == u'.') {
                num &= current();
                kind = TYPE_RM_REF(kind)::FLOAT;
                pos++;
                while (in(current(), range_ee(u'0'_C, u'9'_C))) {
                    num &= current();
                    pos++;
                }
            }
            result.append(Token(kind, num));
        }
        else if (in(ch, make_tuple(u" "_S, u"\t"_S, u"\n"_S, u"\r"_S)))
            pos++;
        else if (ch == u'"') {
            auto str = u""_S;
            pos++;
            while (current() != u'"') {
                str &= current();
                pos++;
            }
            pos++;
            result.append(Token(Token::Kind::STRING, str));
        }
        else {
            auto BannedChars = create_set({u" "_S, u"\t"_S, u"\""_S, u"("_S, u")"_S, u";"_S});
            auto ident = u""_S;
            while (!in(current(), BannedChars)) {
                ident &= current();
                pos++;
            }
            result.append(Token(Token::Kind::IDENT, ident));
        }
    }

    result.append(Token(Token::Kind::END));
    return result;
}

template <typename T1, typename T2> auto indent(const T1 &s, const T2 &count)
{
    return (count * u" "_S) & s.replace(u"\n"_S, u"\n"_S & (count * u" "_S));
}

class SExpr
{
public:
    enum class Kind {
        INT,
        FLOAT,
        STRING,
        IDENT,
        LIST
    };

    Kind kind;
    String val;
    Array<SExpr> children;

    template <typename T1, typename T2 = decltype(u""_S)> SExpr(const T1 &kind, const T2 &val = u""_S) :
        kind(kind),
        val(val)
    {
    }

    auto to_str()
    {
        if (in(kind, make_tuple(SExpr::Kind::INT, SExpr::Kind::FLOAT, SExpr::Kind::IDENT)))
            return val;
        else if (kind == TYPE_RM_REF(kind)::STRING)
            return u"\""_S & (val) & u"\""_S;
        else if (kind == TYPE_RM_REF(kind)::LIST) {
            auto result = u"("_S;
            for (auto &&[i, ex] : enumerate(children))
                if (ex.kind == TYPE_RM_REF(ex.kind)::LIST && ex.children.len() > 1) {
                    result &= u"\n"_S;
                    result &= indent(ex.to_str(), 2);
                }
                else {
                    if (i > 0)
                        result &= u" "_S;
                    result &= ex.to_str();
                }
            return result & u")"_S;
        }
        assert(false);
    }
};

auto input_str = uR"'(
((data "quoted data" 123 4.5)
 (data (!@# (4.5) "(more" "data)")))
)'"_S;
auto tokens = lex(input_str);
auto pos = 0;

auto current()
{
    return ::pos < ::tokens.len() ? ::tokens[::pos] : Token(Token::Kind::END);
}

SExpr parse()
{
    auto token = current();
    ::pos++;
    if (token.kind == TYPE_RM_REF(token.kind)::INT)
        return SExpr(SExpr::Kind::INT, token.val);
    else if (token.kind == TYPE_RM_REF(token.kind)::FLOAT)
        return SExpr(SExpr::Kind::FLOAT, token.val);
    else if (token.kind == TYPE_RM_REF(token.kind)::STRING)
        return SExpr(SExpr::Kind::STRING, token.val);
    else if (token.kind == TYPE_RM_REF(token.kind)::IDENT)
        return SExpr(SExpr::Kind::IDENT, token.val);
    else if (token.kind == TYPE_RM_REF(token.kind)::LPAR) {
        auto result = SExpr(SExpr::Kind::LIST);
        while (!in(current().kind, make_tuple(Token::Kind::RPAR, Token::Kind::END)))
            result.children.append(parse());
        assert(current().kind != TYPE_RM_REF(current().kind)::END, u"Missing right paren ')'"_S);
        ::pos++;
        return result;
    }
    assert(false);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(parse().to_str());
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Separate_the_house_number_from_the_street_name#Nim
def separateHouseNumber(address):
    fields = address.split()
    last = fields[-1]
    penult = fields[-2]
    house = ''
    if last[0].isdigit():
        isdig = penult[0].isdigit()
        if len(fields) > 2 and isdig and not penult.startswith("194"):
            house = penult + ' ' + last
        else:
            house = last
    elif len(fields) > 2:
        house = penult + ' ' + last
    return (address[:len(address)-len(house)].rstrip(' '), house)

Addresses = ["Plataanstraat 5",
             "Straat 12",
             "Straat 12 II",
             "Dr. J. Straat   12",
             "Dr. J. Straat 12 a",
             "Dr. J. Straat 12-14",
             "Laan 1940 - 1945 37",
             "Plein 1940 2",
             "1213-laan 11",
             "16 april 1944 Pad 1",
             "1e Kruisweg 36",
             "Laan 1940-'45 66",
             "Laan '40-'45",
             "Langeloerduinen 3 46",
             "Marienwaerdt 2e Dreef 2",
             "Provincialeweg N205 1",
             "Rivium 2e Straat 59.",
             "Nieuwe gracht 20rd",
             "Nieuwe gracht 20rd 2",
             "Nieuwe gracht 20zw /2",
             "Nieuwe gracht 20zw/3",
             "Nieuwe gracht 20 zw/4",
             "Bahnhofstr. 4",
             "Wertstr. 10",
             "Lindenhof 1",
             "Nordesch 20",
             "Weilstr. 6",
             "Harthauer Weg 2",
             "Mainaustr. 49",
             "August-Horch-Str. 3",
             "Marktplatz 31",
             "Schmidener Weg 3",
             "Karl-Weysser-Str. 6"]

print("       Street            House Number")
print("---------------------    ------------")
for address in Addresses:
    (street, house) = separateHouseNumber(address)
    print(street.rjust(22), " ", house if len(house) != 0 else "(none)")
===
F separateHouseNumber(address)
   V fields = address.split_py()
   V last = fields.last
   V penult = fields[(len)-2]
   V house = ‘’
   I last[0].is_digit()
      V isdig = penult[0].is_digit()
      I fields.len > 2 & isdig & !penult.starts_with(‘194’)
         house = penult‘ ’last
      E
         house = last
   E I fields.len > 2
      house = penult‘ ’last
   R (address[0 .< address.len - house.len].rtrim(‘ ’), house)

V Addresses = [‘Plataanstraat 5’, ‘Straat 12’, ‘Straat 12 II’, ‘Dr. J. Straat   12’, ‘Dr. J. Straat 12 a’, ‘Dr. J. Straat 12-14’, ‘Laan 1940 - 1945 37’, ‘Plein 1940 2’, ‘1213-laan 11’, ‘16 april 1944 Pad 1’, ‘1e Kruisweg 36’, ‘Laan 1940-'45 66’, ‘Laan '40-'45’, ‘Langeloerduinen 3 46’, ‘Marienwaerdt 2e Dreef 2’, ‘Provincialeweg N205 1’, ‘Rivium 2e Straat 59.’, ‘Nieuwe gracht 20rd’, ‘Nieuwe gracht 20rd 2’, ‘Nieuwe gracht 20zw /2’, ‘Nieuwe gracht 20zw/3’, ‘Nieuwe gracht 20 zw/4’, ‘Bahnhofstr. 4’, ‘Wertstr. 10’, ‘Lindenhof 1’, ‘Nordesch 20’, ‘Weilstr. 6’, ‘Harthauer Weg 2’, ‘Mainaustr. 49’, ‘August-Horch-Str. 3’, ‘Marktplatz 31’, ‘Schmidener Weg 3’, ‘Karl-Weysser-Str. 6’]

print(‘       Street            House Number’)
print(‘---------------------    ------------’)
L(address) Addresses
   V (street, house) = separateHouseNumber(address)
   print(street.rjust(22)‘   ’(I !house.empty {house} E ‘(none)’))
===
template <typename T1> auto separateHouseNumber(const T1 &address)
{
    auto fields = address.split_py();
    auto last = fields.last();
    auto penult = fields.at_plus_len( - 2);
    auto house = u""_S;
    if (_get<0>(last).is_digit()) {
        auto isdig = _get<0>(penult).is_digit();
        if (fields.len() > 2 && isdig && !penult.starts_with(u"194"_S))
            house = penult & u" "_S & last;
        else
            house = last;
    }
    else if (fields.len() > 2)
        house = penult & u" "_S & last;
    return make_tuple(address[range_el(0, address.len() - house.len())].rtrim(u" "_S), house);
}

auto Addresses = create_array({u"Plataanstraat 5"_S, u"Straat 12"_S, u"Straat 12 II"_S, u"Dr. J. Straat   12"_S, u"Dr. J. Straat 12 a"_S, u"Dr. J. Straat 12-14"_S, u"Laan 1940 - 1945 37"_S, u"Plein 1940 2"_S, u"1213-laan 11"_S, u"16 april 1944 Pad 1"_S, u"1e Kruisweg 36"_S, u"Laan 1940-'45 66"_S, u"Laan '40-'45"_S, u"Langeloerduinen 3 46"_S, u"Marienwaerdt 2e Dreef 2"_S, u"Provincialeweg N205 1"_S, u"Rivium 2e Straat 59."_S, u"Nieuwe gracht 20rd"_S, u"Nieuwe gracht 20rd 2"_S, u"Nieuwe gracht 20zw /2"_S, u"Nieuwe gracht 20zw/3"_S, u"Nieuwe gracht 20 zw/4"_S, u"Bahnhofstr. 4"_S, u"Wertstr. 10"_S, u"Lindenhof 1"_S, u"Nordesch 20"_S, u"Weilstr. 6"_S, u"Harthauer Weg 2"_S, u"Mainaustr. 49"_S, u"August-Horch-Str. 3"_S, u"Marktplatz 31"_S, u"Schmidener Weg 3"_S, u"Karl-Weysser-Str. 6"_S});

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"       Street            House Number"_S);
        print(u"---------------------    ------------"_S);
        for (auto &&address : Addresses) {
            auto [street, house] = separateHouseNumber(address);
            print(street.rjust(22) & u"   "_S & (!house.empty() ? house : u"(none)"_S));
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Shift_list_elements_to_left_by_3#Python
def rotate(l, n):
    k = (len(l) + n) % len(l)
    return l[k:] + [] + l[:k]

l = [1,2,3,4,5,6,7,8,9]
print(l, " => ", rotate(l, 3))
===
F rotate(l, n)
   V k = (l.len + n) % l.len
   R l[k ..] [+] l[0 .< k]

V l = [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(l‘  =>  ’rotate(l, 3))
===
template <typename T1, typename T2> auto rotate(const T1 &l, const T2 &n)
{
    auto k = mod((l.len() + n), l.len());
    return l[range_ei(k)] + l[range_el(0, k)];
}

auto l = create_array({1, 2, 3, 4, 5, 6, 7, 8, 9});

struct CodeBlock1
{
    CodeBlock1()
    {
        print(l & u"  =>  "_S & rotate(l, 3));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Show_the_(decimal)_value_of_a_number_of_1s_appended_with_a_3,_then_squared#Python
Int64 = int
for i in range(0,8):
    print("( " + "1"*i + "3 ) ^ 2 = " + str(Int64("1"*i + "3")**2))
===
L(i) 0..7
   print(‘( ’(‘1’ * i)‘3 ) ^ 2 = ’String(Int64((‘1’ * i)‘3’) ^ 2))
===
struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto i : range_ee(0, 7))
            print(u"( "_S & (u"1"_S * i) & u"3 ) ^ 2 = "_S & String(square(to_int64((u"1"_S * i) & u"3"_S))));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Sleeping_Beauty_problem#Python
import random

def sleeping_beauty_experiment(repetitions):
    """
    Run the Sleeping Beauty Problem experiment `repetitions` times, checking to see
    how often we had heads on waking Sleeping Beauty.
    """
    gotheadsonwaking = 0
    wakenings = 0
    for _ in range(repetitions):
        coin_result = random.choice(["heads", "tails"])

        # On Monday, we check if we got heads.
        wakenings += 1
        if coin_result == "heads":
            gotheadsonwaking += 1

        # If tails, we do this again, but of course we will not add as if it was heads..
        if coin_result == "tails":
            wakenings += 1
            if coin_result == "heads":
                gotheadsonwaking += 1   # never done

    # Show the number of times she was wakened.
    print("Wakenings over", repetitions, "experiments:", wakenings)

    # Return the number of correct bets SB made out of the total number
    # of times she is awoken over all the experiments with that bet.
    return float(gotheadsonwaking) / wakenings

CREDENCE = sleeping_beauty_experiment(1_000_000)
print("Results of experiment:  Sleeping Beauty should estimate a credence of:", CREDENCE)
===
F sleeping_beauty_experiment(repetitions)
   ‘
    Run the Sleeping Beauty Problem experiment `repetitions` times, checking to see
    how often we had heads on waking Sleeping Beauty.
    ’
   V gotheadsonwaking = 0
   V wakenings = 0
   L(_) 0 .< repetitions
      V coin_result = random:choice([‘heads’, ‘tails’])

      wakenings++
      I coin_result == ‘heads’
         gotheadsonwaking++

      I coin_result == ‘tails’
         wakenings++
         I coin_result == ‘heads’
            gotheadsonwaking++

   print(‘Wakenings over ’repetitions‘ experiments: ’wakenings)

   R Float(gotheadsonwaking) / wakenings

V CREDENCE = sleeping_beauty_experiment(1'000'000)
print(‘Results of experiment:  Sleeping Beauty should estimate a credence of: ’CREDENCE)
===
template <typename T1> auto sleeping_beauty_experiment(const T1 &repetitions)
{
    uR"(
    Run the Sleeping Beauty Problem experiment `repetitions` times, checking to see
    how often we had heads on waking Sleeping Beauty.
    )"_S;
    auto gotheadsonwaking = 0;
    auto wakenings = 0;
    for (auto _ : range_el(0, repetitions)) {
        auto coin_result = randomns::choice(create_array({u"heads"_S, u"tails"_S}));

        wakenings++;
        if (coin_result == u"heads")
            gotheadsonwaking++;

        if (coin_result == u"tails") {
            wakenings++;
            if (coin_result == u"heads")
                gotheadsonwaking++;
        }
    }

    print(u"Wakenings over "_S & repetitions & u" experiments: "_S & wakenings);

    return to_float(gotheadsonwaking) / wakenings;
}

auto CREDENCE = sleeping_beauty_experiment(1'000'000);

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"Results of experiment:  Sleeping Beauty should estimate a credence of: "_S & CREDENCE);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Simple_database#Kotlin
from typing import NamedTuple
import datetime, sys

class Item(NamedTuple):
    name : str
    date : str
    category : str

    def __str__(self):
        return self.name + ', ' + self.date + ', ' + self.category

db_filename = 'simdb.csv'

def load():
    db : List[Item] = []
    for line in open(db_filename).read().rstrip("\n").split("\n"):
        item = line.split(', ')
        db.append(Item(item[0], item[1], item[2]))
    return db

def store(item):
    open(db_filename, 'a', newline = "\n").write(str(item) + "\n")

def printUsage():
    print("""
Usage:
  simdb cmd [categoryName]
  add     add item, followed by optional category
  latest  print last added item(s), followed by optional category
  all     print all
  For instance: add "some item name" "some category name""")

def addItem(args):
    if len(args) < 2:
        printUsage()
        return

    date = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    cat = args[2] if len(args) == 3 else "none"
    store(Item(args[1], date, cat))

def printLatest(a):
    db = load()
    if len(db) == 0:
        print("No entries in database.")
        return

    if len(a) == 2:
        for item in reversed(db):
            if item.category == a[1]:
                print(item)
                break
        else:
            print(f"There are no items for category '{a[1]}'")
    else:
        print(db[-1])

def printAll():
    db = load()
    if len(db) == 0:
        print("No entries in database.")
        return

    for item in db:
        print(item)

if __name__ == '__main__':
    if 2 <= len(sys.argv) <= 4:
        cmd = sys.argv[1].lower()
        if cmd == 'add':
            addItem(sys.argv[1:])
        elif cmd == 'latest':
            printLatest(sys.argv[1:])
        elif cmd == 'all':
            printAll()
        else:
            printUsage()
    else:
        printUsage()
===
T Item
   String name
   String date
   String category

   F String()
      R .name‘, ’(.date)‘, ’(.category)
   F (name, date, category)
      .name = name
      .date = date
      .category = category

V db_filename = ‘simdb.csv’

F load()
   [Item] db
   L(line) File(:db_filename).read().rtrim("\n").split("\n")
      V item = line.split(‘, ’)
      db.append(Item(item[0], item[1], item[2]))
   R db

F store(item)
   File(:db_filename, ‘a’).write(String(item)"\n")

F printUsage()
   print(‘
Usage:
  simdb cmd [categoryName]
  add     add item, followed by optional category
  latest  print last added item(s), followed by optional category
  all     print all
  For instance: add "some item name" "some category name’)

F addItem(args)
   I args.len < 2
      printUsage()
      R

   V date = Time().strftime(‘%Y-%m-%d %H:%M:%S’)
   V cat = I args.len == 3 {args[2]} E ‘none’
   store(Item(args[1], date, cat))

F printLatest(a)
   V db = load()
   I db.empty
      print(‘No entries in database.’)
      R

   I a.len == 2
      L(item) reversed(db)
         I item.category == a[1]
            print(item)
            L.break
      L.was_no_break
         print(‘There are no items for category '’a[1]‘'’)
   E
      print(db.last)

F printAll()
   V db = load()
   I db.empty
      print(‘No entries in database.’)
      R

   L(item) db
      print(item)

:start:
I :argv.len C 2..4
   S :argv[1].lowercase()
      ‘add’
         addItem(:argv[1..])
      ‘latest’
         printLatest(:argv[1..])
      ‘all’
         printAll()
      E
         printUsage()
E
   printUsage()
===
Array<String> argv;

class Item
{
public:
    String name;
    String date;
    String category;

    operator String() const
    {
        return name & u", "_S & (date) & u", "_S & (category);
    }
    template <typename T1, typename T2, typename T3> Item(const T1 &name, const T2 &date, const T3 &category) :
        name(name),
        date(date),
        category(category)
    {
    }
};

auto db_filename = u"simdb.csv"_S;

auto load()
{
    Array<Item> db;
    for (auto &&line : File(::db_filename).read().rtrim(u"\n"_S).split(u"\n"_S)) {
        auto item = line.split(u", "_S);
        db.append(Item(_get<0>(item), _get<1>(item), _get<2>(item)));
    }
    return db;
}

template <typename T1> auto store(const T1 &item)
{
    File(::db_filename, u"a"_S).write(String(item) & u"\n"_S);
}

auto printUsage()
{
    print(uR"(
Usage:
  simdb cmd [categoryName]
  add     add item, followed by optional category
  latest  print last added item(s), followed by optional category
  all     print all
  For instance: add "some item name" "some category name)"_S);
}

template <typename T1> auto addItem(const T1 &args)
{
    if (args.len() < 2) {
        printUsage();
        return;
    }

    auto date = Time().strftime(u"%Y-%m-%d %H:%M:%S"_S);
    auto cat = args.len() == 3 ? _get<2>(args) : u"none"_S;
    store(Item(_get<1>(args), date, cat));
}

template <typename T1> auto printLatest(const T1 &a)
{
    auto db = load();
    if (db.empty()) {
        print(u"No entries in database."_S);
        return;
    }

    if (a.len() == 2) {
        for (auto &&item : reversed(db))
            if (item.category == _get<1>(a)) {
                print(item);
                goto break_;
            }
        print(u"There are no items for category '"_S & _get<1>(a) & u"'"_S);
        break_:;
    }
    else
        print(db.last());
}

auto printAll()
{
    auto db = load();
    if (db.empty()) {
        print(u"No entries in database."_S);
        return;
    }

    for (auto &&item : db)
        print(item);
}

int MAIN_WITH_ARGV()
{
    INIT_ARGV();

    if (in(::argv.len(), range_ee(2, 4)))
        if (_get<1>(::argv).lowercase() == u"add"_S)
            addItem(::argv[range_ei(1)]);
        else if (_get<1>(::argv).lowercase() == u"latest"_S)
            printLatest(::argv[range_ei(1)]);
        else if (_get<1>(::argv).lowercase() == u"all"_S)
            printAll();
        else
            printUsage();
    else
        printUsage();
}