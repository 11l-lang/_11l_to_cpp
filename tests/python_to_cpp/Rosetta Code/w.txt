# https://www.rosettacode.org/wiki/Water_collected_between_towers#Python
def water_collected(tower):
    N = len(tower)
    highest_left = [0] + [max(tower[:n]) for n in range(1,N)]
    highest_right = [max(tower[n:N]) for n in range(1,N)] + [0]
    water_level = [max(min(highest_left[n], highest_right[n]) - tower[n], 0)
        for n in range(N)]
    print("highest_left:  ", highest_left)
    print("highest_right: ", highest_right)
    print("water_level:   ", water_level)
    print("tower_level:   ", tower)
    print("total_water:   ", sum(water_level))
    print("")
    return sum(water_level)

towers = [[1, 5, 3, 7, 2],
    [5, 3, 7, 2, 6, 4, 5, 9, 1, 2],
    [2, 6, 3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1],
    [5, 5, 5, 5],
    [5, 6, 7, 8],
    [8, 7, 7, 6],
    [6, 7, 10, 7, 6]]

print([water_collected(tower) for tower in towers])
===
F water_collected(tower)
   V _n_ = tower.len
   V highest_left = [0] [+] (1 .< _n_).map(n -> max(@tower[0 .< n]))
   V highest_right = (1 .< _n_).map(n -> max(@tower[n .< @_n_])) [+] [0]
   V water_level = (0 .< _n_).map(n -> max(min(@highest_left[n], @highest_right[n]) - @tower[n], 0))
   print(‘highest_left:   ’highest_left)
   print(‘highest_right:  ’highest_right)
   print(‘water_level:    ’water_level)
   print(‘tower_level:    ’tower)
   print(‘total_water:    ’sum(water_level))
   print(‘’)
   R sum(water_level)

V towers = [[1, 5, 3, 7, 2], [5, 3, 7, 2, 6, 4, 5, 9, 1, 2], [2, 6, 3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1], [5, 5, 5, 5], [5, 6, 7, 8], [8, 7, 7, 6], [6, 7, 10, 7, 6]]

print(towers.map(tower -> water_collected(tower)))
===
template <typename T1> auto water_collected(const T1 &tower)
{
    auto _n_ = tower.len();
    auto highest_left = create_array({0}) + range_el(1, _n_).map([&tower](const auto &n){return max(tower[range_el(0, n)]);});
    auto highest_right = range_el(1, _n_).map([&_n_, &tower](const auto &n){return max(tower[range_el(n, _n_)]);}) + create_array({0});
    auto water_level = range_el(0, _n_).map([&highest_left, &highest_right, &tower](const auto &n){return max(min(highest_left[n], highest_right[n]) - tower[n], 0);});
    print(u"highest_left:   "_S & highest_left);
    print(u"highest_right:  "_S & highest_right);
    print(u"water_level:    "_S & water_level);
    print(u"tower_level:    "_S & tower);
    print(u"total_water:    "_S & sum(water_level));
    print(u""_S);
    return sum(water_level);
}

auto towers = create_array({create_array({1, 5, 3, 7, 2}), create_array({5, 3, 7, 2, 6, 4, 5, 9, 1, 2}), create_array({2, 6, 3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1}), create_array({5, 5, 5, 5}), create_array({5, 6, 7, 8}), create_array({8, 7, 7, 6}), create_array({6, 7, 10, 7, 6})});

struct CodeBlock1
{
    CodeBlock1()
    {
        print(towers.map([](const auto &tower){return water_collected(tower);}));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Word_frequency#Python
import collections, re

cnt = collections.defaultdict(int) # str
for word in re.findall(r"\w+", open('135-0.txt', encoding = 'utf-8-sig').read().lower()):
    cnt[word] += 1

print(sorted(cnt.items(), key = lambda wordc: wordc[1], reverse = True)[:10])
===
V cnt = DefaultDict[String, Int]()
L(word) re:‘\w+’.find_strings(File(‘135-0.txt’, encoding' ‘utf-8-sig’).read().lowercase())
   cnt[word]++

print(sorted(cnt.items(), key' wordc -> wordc[1], reverse' 1B)[0.<10])
===
auto cnt = DefaultDict<String, int>();

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&word : re::_(uR"(\w+)"_S).find_strings(File(u"135-0.txt"_S, u"utf-8-sig"_S).read().lowercase()))
            cnt[word]++;

        print(sorted(cnt.items(), [](const auto &wordc){return _get<1>(wordc);}, true)[range_el(0, 10)]);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Word_search#Python
import re, random

dirs = [[1, 0], [0, 1], [1, 1], [1, -1], [-1, 0], [0, -1], [-1, -1], [-1, 1]]
n_rows = 10
n_cols = 10
grid_size = n_rows * n_cols
min_words = 25

class Grid:
    def __init__(self):
        self.num_attempts = 0
        self.cells : List[List[str]] = [['' for _ in range(n_cols)] for _ in range(n_rows)]
        self.solutions : List[str] = []

def read_words(filename):
    #max_len = max(n_rows, n_cols)

    words : List[str] = []
    for line in open(filename, "r").readlines():
        s = line.strip().lower()
        #if re.match(r'^[a-z]{3,' + re.escape(str(max_len)) + r'}$', s) is not None:
        if re.match(r'^[a-z]{3,10}$', s):
            words.append(s)

    return words

def place_message(grid : "Grid", msg):
    msg = re.sub(r'[^A-Z]', "", msg.upper())

    message_len = len(msg)
    if 0 < message_len < grid_size:
        gap_size = grid_size // message_len

        for i in range(0, message_len):
            pos = i * gap_size + random.randint(0, gap_size)
            grid.cells[pos // n_cols][pos % n_cols] = msg[i]

        return message_len

    return 0

def try_location(grid : "Grid", word, direction, pos):
    r = pos // n_cols
    c = pos % n_cols
    length = len(word)

    # check bounds
    if (dirs[direction][0] == 1 and (length + c) > n_cols) or \
       (dirs[direction][0] == -1 and (length - 1) > c) or \
       (dirs[direction][1] == 1 and (length + r) > n_rows) or \
       (dirs[direction][1] == -1 and (length - 1) > r):
        return 0

    rr = r
    cc = c
    i = 0
    overlaps = 0

    # check cells
    while i < length:
        if grid.cells[rr][cc] != '' and grid.cells[rr][cc] != word[i]:
            return 0
        cc += dirs[direction][0]
        rr += dirs[direction][1]
        i += 1

    rr = r
    cc = c
    i = 0
    # place
    while i < length:
        if grid.cells[rr][cc] == word[i]:
            overlaps += 1
        else:
            grid.cells[rr][cc] = word[i]

        if i < length - 1:
            cc += dirs[direction][0]
            rr += dirs[direction][1]

        i += 1

    letters_placed = length - overlaps
    if letters_placed > 0:
        grid.solutions.append("{0:<10} ({1},{2})({3},{4})".format(word, c, r, cc, rr))

    return letters_placed

def try_place_word(grid : "Grid", word):
    rand_dir = random.randint(0, len(dirs))
    rand_pos = random.randint(0, grid_size)

    for direction in range(0, len(dirs)):
        direction = (direction + rand_dir) % len(dirs)

        for pos in range(0, grid_size):
            pos = (pos + rand_pos) % grid_size

            letters_placed = try_location(grid, word, direction, pos)
            if letters_placed > 0:
                return letters_placed

    return 0

def create_word_search(words : list):
    grid = Grid()
    num_attempts = 0

    while num_attempts < 100:
        num_attempts += 1
        random.shuffle(words)

        grid = Grid()
        message_len = place_message(grid, "Rosetta Code")
        target = grid_size - message_len

        cells_filled = 0
        for word in words:
            cells_filled += try_place_word(grid, word)
            if cells_filled == target:
                if len(grid.solutions) >= min_words:
                    grid.num_attempts = num_attempts
                    return grid
                else:
                    break # grid is full but we didn't pack enough words, start over

    return grid

def print_result(grid):
    if grid.num_attempts == 0:
        print("No grid to display")
        return

    size = len(grid.solutions)

    print("Attempts: {0}".format(grid.num_attempts))
    print("Number of words: {0}".format(size))

    print("\n     0  1  2  3  4  5  6  7  8  9\n")
    for r in range(0, n_rows):
        print("{0}   ".format(r), end='')
        for c in range(0, n_cols):
            print(" %s " % grid.cells[r][c], end='')
        print()
    print()

    for i in range(0, size - 1, 2):
        print("{0}   {1}".format(grid.solutions[i], grid.solutions[i+1]))

    if size % 2 == 1:
        print(grid.solutions[size - 1])

print_result(create_word_search(read_words("unixdict.txt")))
===
V dirs = [[1, 0], [0, 1], [1, 1], [1, -1], [-1, 0], [0, -1], [-1, -1], [-1, 1]]
V n_rows = 10
V n_cols = 10
V grid_size = n_rows * n_cols
V min_words = 25

T Grid
   num_attempts = 0
   [[String]] cells = (0 .< :n_rows).map(_ -> (0 .< :n_cols).map(_ -> ‘’))
   [String] solutions
   F ()
   {
   }

F read_words(filename)

   [String] words
   L(line) File(filename).read_lines(1B)
      V s = line.trim((‘ ’, "\t", "\r", "\n")).lowercase()
      I re:‘^[a-z]{3,10}’.match(s)
         words.append(s)

   R words

F place_message(Grid &grid; =msg)
   msg = msg.uppercase().replace(re:‘[^A-Z]’, ‘’)

   V message_len = msg.len
   I message_len C 0 <.< :grid_size
      V gap_size = :grid_size I/ message_len

      L(i) 0 .< message_len
         V pos = i * gap_size + random:(0 .. gap_size)
         grid.cells[pos I/ :n_cols][pos % :n_cols] = msg[i]

      R message_len

   R 0

F try_location(Grid &grid; word, direction, pos)
   V r = pos I/ :n_cols
   V c = pos % :n_cols
   V length = word.len

   I (:dirs[direction][0] == 1 & (length + c) > :n_cols) | (:dirs[direction][0] == -1 & (length - 1) > c) | (:dirs[direction][1] == 1 & (length + r) > :n_rows) | (:dirs[direction][1] == -1 & (length - 1) > r)
      R 0

   V rr = r
   V cc = c
   V i = 0
   V overlaps = 0

   L i < length
      I grid.cells[rr][cc] != ‘’ & grid.cells[rr][cc] != word[i]
         R 0
      cc += :dirs[direction][0]
      rr += :dirs[direction][1]
      i++

   rr = r
   cc = c
   i = 0
   L i < length
      I grid.cells[rr][cc] == word[i]
         overlaps++
      E
         grid.cells[rr][cc] = word[i]

      I i < length - 1
         cc += :dirs[direction][0]
         rr += :dirs[direction][1]

      i++

   V letters_placed = length - overlaps
   I letters_placed > 0
      grid.solutions.append(‘#<10 (#.,#.)(#.,#.)’.format(word, c, r, cc, rr))

   R letters_placed

F try_place_word(Grid &grid; word)
   V rand_dir = random:(0 .. :dirs.len)
   V rand_pos = random:(0 .. :grid_size)

   L(=direction) 0 .< :dirs.len
      direction = (direction + rand_dir) % :dirs.len

      L(=pos) 0 .< :grid_size
         pos = (pos + rand_pos) % :grid_size

         V letters_placed = try_location(&grid, word, direction, pos)
         I letters_placed > 0
            R letters_placed

   R 0

F create_word_search(&words)
   V grid = Grid()
   V num_attempts = 0

   L num_attempts < 100
      num_attempts++
      random:shuffle(&words)

      grid = Grid()
      V message_len = place_message(&grid, ‘Rosetta Code’)
      V target = :grid_size - message_len

      V cells_filled = 0
      L(word) words
         cells_filled += try_place_word(&grid, word)
         I cells_filled == target
            I grid.solutions.len >= :min_words
               grid.num_attempts = num_attempts
               R grid
            E
               L.break

   R grid

F print_result(grid)
   I grid.num_attempts == 0
      print(‘No grid to display’)
      R

   V size = grid.solutions.len

   print(‘Attempts: #.’.format(grid.num_attempts))
   print(‘Number of words: #.’.format(size))

   print("\n     0  1  2  3  4  5  6  7  8  9\n")
   L(r) 0 .< :n_rows
      print(‘#.   ’.format(r), end' ‘’)
      L(c) 0 .< :n_cols
         print(‘ #. ’.format(grid.cells[r][c]), end' ‘’)
      print()
   print()

   L(i) (0 .< size - 1).step(2)
      print(‘#.   #.’.format(grid.solutions[i], grid.solutions[i + 1]))

   I size % 2 == 1
      print(grid.solutions[size - 1])

print_result(create_word_search(&read_words(‘unixdict.txt’)))
===
auto dirs = create_array({create_array({1, 0}), create_array({0, 1}), create_array({1, 1}), create_array({1, -1}), create_array({-1, 0}), create_array({0, -1}), create_array({-1, -1}), create_array({-1, 1})});
auto n_rows = 10;
auto n_cols = 10;
auto grid_size = n_rows * n_cols;
auto min_words = 25;

class Grid
{
public:
    decltype(0) num_attempts = 0;
    Array<Array<String>> cells = range_el(0, ::n_rows).map([](const auto &_){return range_el(0, ::n_cols).map([](const auto &_){return u""_S;});});
    Array<String> solutions;
    Grid()
    {
    }
};

template <typename T1> auto read_words(const T1 &filename)
{

    Array<String> words;
    for (auto &&line : File(filename).read_lines(true)) {
        auto s = line.trim(make_tuple(u" "_S, u"\t"_S, u"\r"_S, u"\n"_S)).lowercase();
        if (re::_(u"^[a-z]{3,10}"_S).match(s))
            words.append(s);
    }

    return words;
}

template <typename T2> auto place_message(Grid &grid, T2 msg)
{
    msg = msg.uppercase().replace(re::_(u"[^A-Z]"_S), u""_S);

    auto message_len = msg.len();
    if (in(message_len, range_ll(0, ::grid_size))) {
        auto gap_size = idiv(::grid_size, message_len);

        for (auto i : range_el(0, message_len)) {
            auto pos = i * gap_size + randomns::_(range_ee(0, gap_size));
            grid.cells[idiv(pos, ::n_cols)].set(mod(pos, ::n_cols), msg[i]);
        }

        return message_len;
    }

    return 0;
}

template <typename T2, typename T3, typename T4> auto try_location(Grid &grid, const T2 &word, const T3 &direction, const T4 &pos)
{
    auto r = idiv(pos, ::n_cols);
    auto c = mod(pos, ::n_cols);
    auto length = word.len();

    if ((_get<0>(::dirs[direction]) == 1 && (length + c) > ::n_cols) || (_get<0>(::dirs[direction]) == -1 && (length - 1) > c) || (_get<1>(::dirs[direction]) == 1 && (length + r) > ::n_rows) || (_get<1>(::dirs[direction]) == -1 && (length - 1) > r))
        return 0;

    auto rr = r;
    auto cc = c;
    auto i = 0;
    auto overlaps = 0;

    while (i < length) {
        if (grid.cells[rr][cc] != u"" && grid.cells[rr][cc] != word[i])
            return 0;
        cc += _get<0>(::dirs[direction]);
        rr += _get<1>(::dirs[direction]);
        i++;
    }

    rr = r;
    cc = c;
    i = 0;
    while (i < length) {
        if (grid.cells[rr][cc] == word[i])
            overlaps++;
        else
            grid.cells[rr].set(cc, word[i]);

        if (i < length - 1) {
            cc += _get<0>(::dirs[direction]);
            rr += _get<1>(::dirs[direction]);
        }

        i++;
    }

    auto letters_placed = length - overlaps;
    if (letters_placed > 0)
        grid.solutions.append(u"#<10 (#.,#.)(#.,#.)"_S.format(word, c, r, cc, rr));

    return letters_placed;
}

template <typename T2> auto try_place_word(Grid &grid, const T2 &word)
{
    auto rand_dir = randomns::_(range_ee(0, ::dirs.len()));
    auto rand_pos = randomns::_(range_ee(0, ::grid_size));

    for (auto direction : range_el(0, ::dirs.len())) {
        direction = mod((direction + rand_dir), ::dirs.len());

        for (auto pos : range_el(0, ::grid_size)) {
            pos = mod((pos + rand_pos), ::grid_size);

            auto letters_placed = try_location(grid, word, direction, pos);
            if (letters_placed > 0)
                return letters_placed;
        }
    }

    return 0;
}

template <typename T1> auto create_word_search(T1 &words)
{
    auto grid = Grid();
    auto num_attempts = 0;

    while (num_attempts < 100) {
        num_attempts++;
        randomns::shuffle(words);

        grid = Grid();
        auto message_len = place_message(grid, u"Rosetta Code"_S);
        auto target = ::grid_size - message_len;

        auto cells_filled = 0;
        for (auto &&word : words) {
            cells_filled += try_place_word(grid, word);
            if (cells_filled == target) {
                if (grid.solutions.len() >= ::min_words) {
                    grid.num_attempts = num_attempts;
                    return grid;
                }
                else
                    break;
            }
        }
    }

    return grid;
}

template <typename T1> auto print_result(const T1 &grid)
{
    if (grid.num_attempts == 0) {
        print(u"No grid to display"_S);
        return;
    }

    auto size = grid.solutions.len();

    print(u"Attempts: #."_S.format(grid.num_attempts));
    print(u"Number of words: #."_S.format(size));

    print(u"\n     0  1  2  3  4  5  6  7  8  9\n"_S);
    for (auto r : range_el(0, ::n_rows)) {
        print(u"#.   "_S.format(r), u""_S);
        for (auto c : range_el(0, ::n_cols))
            print(u" #. "_S.format(grid.cells[r][c]), u""_S);
        print();
    }
    print();

    for (auto i : range_el(0, size - 1).step(2))
        print(u"#.   #."_S.format(grid.solutions[i], grid.solutions[i + 1]));

    if (mod(size, 2) == 1)
        print(grid.solutions[size - 1]);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print_result(create_word_search(make_ref(read_words(u"unixdict.txt"_S))));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Word_wheel#Python
import collections

GRID = """
N   D   E
O   K   G
E   L   W
"""

def getwords():
    "Return lowercased words of 3 to 9 characters"
    words = open('unixdict.txt').read().lower().split("\n")
    return [w for w in words if 3 <= len(w) <= 9]

def solve(grid, dictionary):
    gridcount = collections.defaultdict(int) # Char
    for g in grid:
        gridcount[g] += 1

    def check_word(word):
        lcount = collections.defaultdict(int) # Char
        for l in word:
            lcount[l] += 1
        for l, c in lcount.items():
            if c > gridcount[l]:
                return True
        return False

    mid = grid[4]
    return [word for word in dictionary
            if mid in word and not check_word(word)]

chars = ''.join(GRID.strip().lower().split())
found = solve(chars, dictionary=getwords())
print('\n'.join(found))
===
V GRID = ‘
N   D   E
O   K   G
E   L   W
’

F getwords()
   ‘Return lowercased words of 3 to 9 characters’
   V words = File(‘unixdict.txt’).read().lowercase().split("\n")
   R words.filter(w -> w.len C 3..9)

F solve(grid, dictionary)
   V gridcount = DefaultDict[Char, Int]()
   L(g) grid
      gridcount[g]++

   F check_word(word)
      V lcount = DefaultDict[Char, Int]()
      L(l) word
         lcount[l]++
      L(l, c) lcount
         I c > @gridcount[l]
            R 1B
      R 0B

   V mid = grid[4]
   R dictionary.filter(word -> @mid C word & !@check_word(word))

V chars = GRID.trim((‘ ’, "\t", "\r", "\n")).lowercase().split_py().join(‘’)
V found = solve(chars, dictionary' getwords())
print(found.join("\n"))
===
auto GRID = uR"(
N   D   E
O   K   G
E   L   W
)"_S;

auto getwords()
{
    u"Return lowercased words of 3 to 9 characters"_S;
    auto words = File(u"unixdict.txt"_S).read().lowercase().split(u"\n"_S);
    return words.filter([](const auto &w){return in(w.len(), range_ee(3, 9));});
}

template <typename T1, typename T2> auto solve(const T1 &grid, const T2 &dictionary)
{
    auto gridcount = DefaultDict<Char, int>();
    for (auto &&g : grid)
        gridcount[g]++;

    auto check_word = [&gridcount](const auto &word)
    {
        auto lcount = DefaultDict<Char, int>();
        for (auto &&l : word)
            lcount[l]++;
        for (auto &&[l, c] : lcount)
            if (c > gridcount[l])
                return true;
        return false;
    };

    auto mid = _get<4>(grid);
    return dictionary.filter([&check_word, &mid](const auto &word){return in(mid, word) && !check_word(word);});
}

auto chars = GRID.trim(make_tuple(u" "_S, u"\t"_S, u"\r"_S, u"\n"_S)).lowercase().split_py().join(u""_S);
auto found = solve(chars, getwords());

struct CodeBlock1
{
    CodeBlock1()
    {
        print(found.join(u"\n"_S));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Word_wrap#Go
def word_wrap(text, line_width):
    words = text.split()
    if len(words) == 0:
        return ''
    wrapped = words[0]
    space_left = line_width - len(wrapped)
    for word in words[1:]:
        if len(word)+1 > space_left:
            wrapped += "\n" + word
            space_left = line_width - len(word)
        else:
            wrapped += " " + word
            space_left -= 1 + len(word)
    return wrapped

frog = '''
In olden times when wishing still helped one, there lived a king
whose daughters were all beautiful, but the youngest was so beautiful
that the sun itself, which has seen so much, was astonished whenever
it shone in her face.  Close by the king's castle lay a great dark
forest, and under an old lime-tree in the forest was a well, and when
the day was very warm, the king's child went out into the forest and
sat down by the side of the cool fountain, and when she was bored she
took a golden ball, and threw it up on high and caught it, and this
ball was her favorite plaything.'''

for width in (72, 80):
    print('Wrapped at ' + str(width) + ":\n" + word_wrap(frog, width))
    print()
===
F word_wrap(text, line_width)
   V words = text.split_py()
   I words.empty
      R ‘’
   V wrapped = words[0]
   V space_left = line_width - wrapped.len
   L(word) words[1..]
      I word.len + 1 > space_left
         wrapped ‘’= "\n"word
         space_left = line_width - word.len
      E
         wrapped ‘’= ‘ ’word
         space_left -= 1 + word.len
   R wrapped

V frog = ‘
In olden times when wishing still helped one, there lived a king
whose daughters were all beautiful, but the youngest was so beautiful
that the sun itself, which has seen so much, was astonished whenever
it shone in her face.  Close by the king's castle lay a great dark
forest, and under an old lime-tree in the forest was a well, and when
the day was very warm, the king's child went out into the forest and
sat down by the side of the cool fountain, and when she was bored she
took a golden ball, and threw it up on high and caught it, and this
ball was her favorite plaything.’

L(width) (72, 80)
   print(‘Wrapped at ’String(width)":\n"word_wrap(frog, width))
   print()
===
template <typename T1, typename T2> auto word_wrap(const T1 &text, const T2 &line_width)
{
    auto words = text.split_py();
    if (words.empty())
        return u""_S;
    auto wrapped = _get<0>(words);
    auto space_left = line_width - wrapped.len();
    for (auto &&word : words[range_ei(1)])
        if (word.len() + 1 > space_left) {
            wrapped &= u"\n"_S & word;
            space_left = line_width - word.len();
        }
        else {
            wrapped &= u" "_S & word;
            space_left -= 1 + word.len();
        }
    return wrapped;
}

auto frog = uR"(
In olden times when wishing still helped one, there lived a king
whose daughters were all beautiful, but the youngest was so beautiful
that the sun itself, which has seen so much, was astonished whenever
it shone in her face.  Close by the king's castle lay a great dark
forest, and under an old lime-tree in the forest was a well, and when
the day was very warm, the king's child went out into the forest and
sat down by the side of the cool fountain, and when she was bored she
took a golden ball, and threw it up on high and caught it, and this
ball was her favorite plaything.)"_S;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&width : make_tuple(72, 80)) {
            print(u"Wrapped at "_S & String(width) & u":\n"_S & word_wrap(frog, width));
            print();
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Words_containing_%22the%22_substring#Python
for word in open('unixdict.txt').read().split("\n"):
    if "the" in word and len(word) > 11:
        print(word)
===
L(word) File(‘unixdict.txt’).read().split("\n")
   I ‘the’ C word & word.len > 11
      print(word)
===
struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&word : File(u"unixdict.txt"_S).read().split(u"\n"_S))
            if (in(u"the"_S, word) && word.len() > 11)
                print(word);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/World_Cup_group_stage#Go
games = ["12", "13", "14", "23", "24", "34"]
results = "000000"

# [https://stackoverflow.com/a/28666223/2692494 <- google:‘python integer to string radix’]
def numberToBase(n, b):
    if n == 0:
        return '0'
    digits = ''
    while n != 0:
        digits += str(int(n % b))
        n //= b
    return digits[::-1]

def nextResult():
    global results
    if results == "222222":
        return False
    res = int(results, base = 3) + 1
    results = numberToBase(res, 3).zfill(6)
    return True

points = [[0]*10 for i in range(4)]
while True:
    records = [0]*4
    for i in range(len(games)):
        r = results[i]
        if r == '2':
            records[ord(games[i][0]) - ord('1')] += 3
        elif r == '1':
            records[ord(games[i][0]) - ord('1')] += 1
            records[ord(games[i][1]) - ord('1')] += 1
        elif r == '0':
            records[ord(games[i][1]) - ord('1')] += 3

    records.sort()
    for i in range(4):
        points[i][records[i]] += 1

    if not nextResult():
        break

print("POINTS       0    1    2    3    4    5    6    7    8    9")
print("-------------------------------------------------------------")
places = ["1st", "2nd", "3rd", "4th"]
for i in range(4):
    print(places[i], end = ' place    ')
    for j in range(10):
        print("%-5d" % points[3-i][j], end = '')
    print()
===
V games = [‘12’, ‘13’, ‘14’, ‘23’, ‘24’, ‘34’]
V results = ‘000000’

F numberToBase(=n, b)
   I n == 0
      R ‘0’
   V digits = ‘’
   L n != 0
      digits ‘’= String(Int(n % b))
      n I/= b
   R reversed(digits)

F nextResult()
   I :results == ‘222222’
      R 0B
   V res = Int(:results, radix' 3) + 1
   :results = numberToBase(res, 3).zfill(6)
   R 1B

V points = [[0] * 10] * 4
L
   V records = [0] * 4
   L(i) 0 .< games.len
      S results[i]
         ‘2’
            records[games[i][0].code - ‘1’.code] += 3
         ‘1’
            records[games[i][0].code - ‘1’.code]++
            records[games[i][1].code - ‘1’.code]++
         ‘0’
            records[games[i][1].code - ‘1’.code] += 3

   records.sort()
   L(i) 4
      points[i][records[i]]++

   I !nextResult()
      L.break

print(‘POINTS       0    1    2    3    4    5    6    7    8    9’)
print(‘-------------------------------------------------------------’)
V places = [‘1st’, ‘2nd’, ‘3rd’, ‘4th’]
L(i) 4
   print(places[i], end' ‘ place    ’)
   L(j) 10
      print(‘#<5’.format(points[3 - i][j]), end' ‘’)
   print()
===
auto games = create_array({u"12"_S, u"13"_S, u"14"_S, u"23"_S, u"24"_S, u"34"_S});
auto results = u"000000"_S;

template <typename T1, typename T2> auto numberToBase(T1 n, const T2 &b)
{
    if (n == 0)
        return u"0"_S;
    auto digits = u""_S;
    while (n != 0) {
        digits &= String(to_int(mod(n, b)));
        n = idiv(n, b);
    }
    return reversed(digits);
}

auto nextResult()
{
    if (::results == u"222222")
        return false;
    auto res = to_int(::results, 3) + 1;
    ::results = numberToBase(res, 3).zfill(6);
    return true;
}

auto points = create_array({create_array({0}) * 10}) * 4;

struct CodeBlock1
{
    CodeBlock1()
    {
        while (true) {
            auto records = create_array({0}) * 4;
            for (auto i : range_el(0, games.len()))
                switch (results[i])
                {
                case u'2':
                    records[_get<0>(games[i]).code - u'1'_C.code] += 3;
                    break;
                case u'1':
                    records[_get<0>(games[i]).code - u'1'_C.code]++;
                    records[_get<1>(games[i]).code - u'1'_C.code]++;
                    break;
                case u'0':
                    records[_get<1>(games[i]).code - u'1'_C.code] += 3;
                    break;
                }

            records.sort();
            for (int i = 0; i < 4; i++)
                points[i][records[i]]++;

            if (!nextResult())
                break;
        }

        print(u"POINTS       0    1    2    3    4    5    6    7    8    9"_S);
        print(u"-------------------------------------------------------------"_S);
    }
} code_block_1;

auto places = create_array({u"1st"_S, u"2nd"_S, u"3rd"_S, u"4th"_S});

struct CodeBlock2
{
    CodeBlock2()
    {
        for (int i = 0; i < 4; i++) {
            print(places[i], u" place    "_S);
            for (int j = 0; j < 10; j++)
                print(u"#<5"_S.format(points[3 - i][j]), u""_S);
            print();
        }
    }
} code_block_2;


# https://www.rosettacode.org/wiki/War_card_game#Python
from typing import List
UInt32 = int

seed : UInt32 = 0
def nonrandom(n):
    global seed
    seed = (1664525 * seed + 1013904223) & 0xFFFF_FFFF
    return (seed >> 16) % n

def nonrandom_shuffle(x : list):
    for i in range(len(x)-1, 0, -1):
        j = nonrandom(i + 1)
        (x[i], x[j]) = (x[j], x[i])

SUITS = ['♣', '♦', '♥', '♠']
FACES = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']
DECK = [f + '' + s for f in FACES for s in SUITS]
CARD_TO_RANK = dict((DECK[i], (i + 3) // 4) for i in range(len(DECK)))

class WarCardGame:
    deck1 : List[str]
    deck2 : List[str]

    def __init__(self):
        deck = DECK[:]
        nonrandom_shuffle(deck)
        self.deck1 = deck[:26]
        self.deck2 = deck[26:]
        self.pending : List[str] = []

    def gameover(self):
        """ game over who won message """
        if len(self.deck2) == 0:
            if len(self.deck1) == 0:
                print('\nGame ends as a tie.')
            else:
                print('\nPlayer 1 wins the game.')
        else:
            print('\nPlayer 2 wins the game.')

        return False

    def turn(self):
        """ one turn, may recurse on tie """
        if len(self.deck1) == 0 or len(self.deck2) == 0:
            return self.gameover()

        card1 = self.deck1.pop(0)
        card2 = self.deck2.pop(0)
        (rank1, rank2) = (CARD_TO_RANK[card1], CARD_TO_RANK[card2])
        print("{:<10}{:<10}".format(card1, card2), end='')
        if rank1 > rank2:
            print('Player 1 takes the cards.')
            self.deck1.extend([card1, card2])
            self.deck1.extend(self.pending)
            self.pending.clear()
        elif rank1 < rank2:
            print('Player 2 takes the cards.')
            self.deck2.extend([card2, card1])
            self.deck2.extend(self.pending)
            self.pending.clear()
        else:  #  rank1 == rank2
            print('Tie!')
            if len(self.deck1) == 0 or len(self.deck2) == 0:
                return self.gameover()

            card3 = self.deck1.pop(0)
            card4 = self.deck2.pop(0)
            self.pending.extend([card1, card2, card3, card4])
            print("{:<10}{:<10}".format("?", "?"), 'Cards are face down.', sep='')
            return self.turn()

        return True

WG = WarCardGame()
while WG.turn():
    continue
===
UInt32 seed = 0
F nonrandom(n)
   :seed = (1664525 * :seed + 1013904223) [&] FFFF'FFFF
   R (:seed >> 16) % n

F nonrandom_shuffle(&x)
   L(i) (x.len - 1 .< 0).step(-1)
      V j = nonrandom(i + 1)
      swap(&x[i], &x[j])

V SUITS = [‘♣’, ‘♦’, ‘♥’, ‘♠’]
V FACES = [‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’, ‘10’, ‘J’, ‘Q’, ‘K’, ‘A’]
V DECK = multiloop(FACES, SUITS, (f, s) -> f‘’s)
V CARD_TO_RANK = Dict((0 .< DECK.len).map(i -> (:DECK[i], (i + 3) I/ 4)))

T WarCardGame
   [String] deck1
   [String] deck2
   [String] pending

   F ()
      V deck = copy(:DECK)
      nonrandom_shuffle(&deck)
      .deck1 = deck[0.<26]
      .deck2 = deck[26..]

   F gameover()
      ‘ game over who won message ’
      I .deck2.empty
         I .deck1.empty
            print("\nGame ends as a tie.")
         E
            print("\nPlayer 1 wins the game.")
      E
         print("\nPlayer 2 wins the game.")

      R 0B

   F turn()
      ‘ one turn, may recurse on tie ’
      I .deck1.empty | .deck2.empty
         R .gameover()

      V card1 = .deck1.pop(0)
      V card2 = .deck2.pop(0)
      V (rank1, rank2) = (:CARD_TO_RANK[card1], :CARD_TO_RANK[card2])
      print(‘#<10#<10’.format(card1, card2), end' ‘’)
      I rank1 > rank2
         print(‘Player 1 takes the cards.’)
         .deck1.extend([card1, card2])
         .deck1.extend(.pending)
         .pending.clear()
      E I rank1 < rank2
         print(‘Player 2 takes the cards.’)
         .deck2.extend([card2, card1])
         .deck2.extend(.pending)
         .pending.clear()
      E
         print(‘Tie!’)
         I .deck1.empty | .deck2.empty
            R .gameover()

         V card3 = .deck1.pop(0)
         V card4 = .deck2.pop(0)
         .pending.extend([card1, card2, card3, card4])
         print(‘#<10#<10’.format(‘?’, ‘?’)‘Cards are face down.’)
         R .turn()

      R 1B

V WG = WarCardGame()
L WG.turn()
   L.continue
===
uint32_t seed = 0;
template <typename T1> auto nonrandom(const T1 &n)
{
    ::seed = (1664525 * ::seed + 1013904223) & 0xFFFF'FFFF;
    return mod((::seed >> 16), n);
}

template <typename T1> auto nonrandom_shuffle(T1 &x)
{
    for (auto i : range_el(x.len() - 1, 0).step(-1)) {
        auto j = nonrandom(i + 1);
        swap(x[i], x[j]);
    }
}

auto SUITS = create_array({u'♣'_C, u'♦'_C, u'♥'_C, u'♠'_C});
auto FACES = create_array({u"2"_S, u"3"_S, u"4"_S, u"5"_S, u"6"_S, u"7"_S, u"8"_S, u"9"_S, u"10"_S, u"J"_S, u"Q"_S, u"K"_S, u"A"_S});
auto DECK = multiloop(FACES, SUITS, [](const auto &f, const auto &s){return f & s;});
auto CARD_TO_RANK = create_dict(range_el(0, DECK.len()).map([](const auto &i){return make_tuple(::DECK[i], idiv((i + 3), 4));}));

class WarCardGame
{
public:
    Array<String> deck1;
    Array<String> deck2;
    Array<String> pending;

    WarCardGame()
    {
        auto deck = copy(::DECK);
        nonrandom_shuffle(deck);
        deck1 = deck[range_el(0, 26)];
        deck2 = deck[range_ei(26)];
    }

    auto gameover()
    {
        u" game over who won message "_S;
        if (deck2.empty()) {
            if (deck1.empty())
                print(u"\nGame ends as a tie."_S);
            else
                print(u"\nPlayer 1 wins the game."_S);
        }
        else
            print(u"\nPlayer 2 wins the game."_S);

        return false;
    }

    auto turn()
    {
        u" one turn, may recurse on tie "_S;
        if (deck1.empty() || deck2.empty())
            return gameover();

        auto card1 = deck1.pop(0);
        auto card2 = deck2.pop(0);
        auto [rank1, rank2] = make_tuple(::CARD_TO_RANK[card1], ::CARD_TO_RANK[card2]);
        print(u"#<10#<10"_S.format(card1, card2), u""_S);
        if (rank1 > rank2) {
            print(u"Player 1 takes the cards."_S);
            deck1.extend(create_array({card1, card2}));
            deck1.extend(pending);
            pending.clear();
        }
        else if (rank1 < rank2) {
            print(u"Player 2 takes the cards."_S);
            deck2.extend(create_array({card2, card1}));
            deck2.extend(pending);
            pending.clear();
        }
        else {
            print(u"Tie!"_S);
            if (deck1.empty() || deck2.empty())
                return gameover();

            auto card3 = deck1.pop(0);
            auto card4 = deck2.pop(0);
            pending.extend(create_array({card1, card2, card3, card4}));
            print(u"#<10#<10"_S.format(u"?"_S, u"?"_S) & u"Cards are face down."_S);
            return turn();
        }

        return true;
    }
};

auto WG = WarCardGame();

struct CodeBlock1
{
    CodeBlock1()
    {
        while (WG.turn())
            continue;
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Welch%27s_t-test#Python
import math

def betain(x, p, q):
    if p <= 0 or q <= 0 or x < 0 or x > 1:
        raise ValueError(0)

    if x == 0 or x == 1:
        return x

    acu = 1e-15
    lnbeta = math.lgamma(p) + math.lgamma(q) - math.lgamma(p + q)

    xx = x
    cx = 1 - x
    pp = p
    qq = q
    indx = False
    psq = p + q
    if p < psq * x:
        xx = 1 - x
        cx = x
        pp = q
        qq = p
        indx = True

    term = 1.0
    ai = 1.0
    value = 1.0
    ns = math.floor(qq + cx * psq)
    rx = xx / cx
    temp = qq - ai
    if ns == 0:
        rx = xx

    while True:
        term *= temp * rx / (pp + ai)
        value += term
        temp = abs(term)

        if temp <= acu and temp <= acu * value:
            value *= math.exp(pp * math.log(xx) + (qq - 1) * math.log(cx) - lnbeta) / pp
            return 1 - value if indx else value

        ai += 1
        ns -= 1
        if ns >= 0:
            temp = qq - ai
            if ns == 0:
                rx = xx
        else:
            temp = psq
            psq += 1

def welch_ttest(a1, a2):
    n1 = len(a1)
    n2 = len(a2)
    if n1 <= 1 or n2 <= 1:
        raise ValueError(0)

    mean1 = sum(a1) / n1
    mean2 = sum(a2) / n2

    var1 = sum((x - mean1)**2 for x in a1) / (n1 - 1)
    var2 = sum((x - mean2)**2 for x in a2) / (n2 - 1)

    t = (mean1 - mean2) / math.sqrt(var1 / n1 + var2 / n2)
    df = (var1 / n1 + var2 / n2)**2 / (var1**2 / (n1**2 * (n1 - 1)) + var2**2 / (n2**2 * (n2 - 1)))
    p = betain(df / (t**2 + df), df / 2, 1 / 2)

    return (t, df, p)

a1 = [float(3), 4, 1, 2.1]
a2 = [float(490.2), 340, 433.9]
print(welch_ttest(a1, a2))
===
F betain(x, p, q)
   I p <= 0 | q <= 0 | x < 0 | x > 1
      X ValueError(0)

   I x == 0 | x == 1
      R x

   V acu = 1e-15
   V lnbeta = lgamma(p) + lgamma(q) - lgamma(p + q)

   V xx = x
   V cx = 1 - x
   V pp = p
   V qq = q
   V indx = 0B
   V psq = p + q
   I p < psq * x
      xx = 1 - x
      cx = x
      pp = q
      qq = p
      indx = 1B

   V term = 1.0
   V ai = 1.0
   V value = 1.0
   V ns = floori(qq + cx * psq)
   V rx = xx / cx
   V temp = qq - ai
   I ns == 0
      rx = xx

   L
      term *= temp * rx / (pp + ai)
      value += term
      temp = abs(term)

      I temp <= acu & temp <= acu * value
         value *= exp(pp * log(xx) + (qq - 1) * log(cx) - lnbeta) / pp
         R I indx {1 - value} E value

      ai++
      I --ns >= 0
         temp = qq - ai
         I ns == 0
            rx = xx
      E
         temp = psq
         psq++

F welch_ttest(a1, a2)
   V n1 = a1.len
   V n2 = a2.len
   I n1 <= 1 | n2 <= 1
      X ValueError(0)

   V mean1 = sum(a1) / n1
   V mean2 = sum(a2) / n2

   V var1 = sum(a1.map(x -> (x - @mean1) ^ 2)) / (n1 - 1)
   V var2 = sum(a2.map(x -> (x - @mean2) ^ 2)) / (n2 - 1)

   V t = (mean1 - mean2) / sqrt(var1 / n1 + var2 / n2)
   V df = (var1 / n1 + var2 / n2) ^ 2 / (var1 ^ 2 / (n1 ^ 2 * (n1 - 1)) + var2 ^ 2 / (n2 ^ 2 * (n2 - 1)))
   V p = betain(df / (t ^ 2 + df), df / 2, 1 / 2)

   R (t, df, p)

V a1 = [Float(3), 4, 1, 2.1]
V a2 = [Float(490.2), 340, 433.9]
print(welch_ttest(a1, a2))
===
template <typename T1, typename T2, typename T3> auto betain(const T1 &x, const T2 &p, const T3 &q)
{
    if (p <= 0 || q <= 0 || x < 0 || x > 1)
        throw ValueError(0);

    if (x == 0 || x == 1)
        return x;

    auto acu = 1e-15;
    auto lnbeta = lgamma(p) + lgamma(q) - lgamma(p + q);

    auto xx = x;
    auto cx = 1 - x;
    auto pp = p;
    auto qq = q;
    auto indx = false;
    auto psq = p + q;
    if (p < psq * x) {
        xx = 1 - x;
        cx = x;
        pp = q;
        qq = p;
        indx = true;
    }

    auto term = 1.0;
    auto ai = 1.0;
    auto value = 1.0;
    auto ns = floori(qq + cx * psq);
    auto rx = xx / cx;
    auto temp = qq - ai;
    if (ns == 0)
        rx = xx;

    while (true) {
        term *= temp * rx / (pp + ai);
        value += term;
        temp = abs(term);

        if (temp <= acu && temp <= acu * value) {
            value *= exp(pp * log(xx) + (qq - 1) * log(cx) - lnbeta) / pp;
            return indx ? 1 - value : value;
        }

        ai++;
        if (--ns >= 0) {
            temp = qq - ai;
            if (ns == 0)
                rx = xx;
        }
        else {
            temp = psq;
            psq++;
        }
    }
}

template <typename T1, typename T2> auto welch_ttest(const T1 &a1, const T2 &a2)
{
    auto n1 = a1.len();
    auto n2 = a2.len();
    if (n1 <= 1 || n2 <= 1)
        throw ValueError(0);

    auto mean1 = sum(a1) / n1;
    auto mean2 = sum(a2) / n2;

    auto var1 = sum_map(a1, [&mean1](const auto &x){return square((x - mean1));}) / (n1 - 1);
    auto var2 = sum_map(a2, [&mean2](const auto &x){return square((x - mean2));}) / (n2 - 1);

    auto t = (mean1 - mean2) / sqrt(var1 / n1 + var2 / n2);
    auto df = square((var1 / n1 + var2 / n2)) / (square(var1) / (square(n1) * (n1 - 1)) + square(var2) / (square(n2) * (n2 - 1)));
    auto p = betain(df / (square(t) + df), df / 2.0, 1.0 / 2);

    return make_tuple(t, df, p);
}

auto a1 = create_array<double>({to_float(3), 4, 1, 2.1});
auto a2 = create_array<double>({to_float(490.2), 340, 433.9});

struct CodeBlock1
{
    CodeBlock1()
    {
        print(welch_ttest(a1, a2));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Word_ladder#Nim
import collections
from typing import DefaultDict, List

def move(obj):
    return obj

def isOneAway(word1, word2):
    result = False
    for i in range(len(word1)):
        if word1[i] != word2[i]:
            if result:
                return False
            else:
                result = True
    return result

words : DefaultDict[int, List[str]] = collections.defaultdict(list)

for word in open('unixdict.txt').read().split("\n"):
    words[len(word)] += [word]

def find_path(start, target):
    lg = len(start)
    assert len(target) == lg, "Source and destination must have same length."
    assert start in words[lg], "Source must exist in the dictionary."
    assert target in words[lg], "Destination must exist in the dictionary."

    currPaths = [[start]]
    pool = words[lg][:]

    while True:
        newPaths : List[List[str]] = []
        added : List[str] = []
        for candidate in pool:
            for path in currPaths:
                if isOneAway(candidate, path[-1]):
                    newPath = path + [candidate]
                    if candidate == target:
                        return newPath
                    else:
                        newPaths.append(newPath)
                        added.append(candidate)
                        break

        if len(newPaths) == 0: break
        currPaths = move(newPaths)
        for w in added:
            pool.remove(w)

    return [''] * 0

for start, target in [("boy", "man"), ("girl", "lady"), ("john", "jane"),
                      ("child", "adult"), ("cat", "dog"), ("lead", "gold"),
                      ("white", "black"), ("bubble", "tickle")]:
    path = find_path(start, target)
    if len(path) == 0:
        print(f'No path from "{start}" to "{target}".')
    else:
        print(" -> ".join(path))
===
F isOneAway(word1, word2)
   V result = 0B
   L(i) 0 .< word1.len
      I word1[i] != word2[i]
         I result
            R 0B
         E
            result = 1B
   R result

DefaultDict[Int, [String]] words

L(word) File(‘unixdict.txt’).read().split("\n")
   words[word.len] [+]= word

F find_path(start, target)
   V lg = start.len
   assert(target.len == lg, ‘Source and destination must have same length.’)
   assert(start C :words[lg], ‘Source must exist in the dictionary.’)
   assert(target C :words[lg], ‘Destination must exist in the dictionary.’)

   V currPaths = [[start]]
   V pool = copy(:words[lg])

   L
      [[String]] newPaths
      [String] added
      L(candidate) pool
         L(path) currPaths
            I isOneAway(candidate, path.last)
               V newPath = path [+] [candidate]
               I candidate == target
                  R newPath
               E
                  newPaths.append(newPath)
                  added.append(candidate)
                  L.break

      I newPaths.empty
         L.break
      currPaths = move(newPaths)
      L(w) added
         pool.remove(w)

   R [‘’] * 0

L(start, target) [(‘boy’, ‘man’), (‘girl’, ‘lady’), (‘john’, ‘jane’), (‘child’, ‘adult’), (‘cat’, ‘dog’), (‘lead’, ‘gold’), (‘white’, ‘black’), (‘bubble’, ‘tickle’)]
   V path = find_path(start, target)
   I path.empty
      print(‘No path from "’start‘" to "’target‘".’)
   E
      print(path.join(‘ -> ’))
===
template <typename T1, typename T2> auto isOneAway(const T1 &word1, const T2 &word2)
{
    auto result = false;
    for (auto i : range_el(0, word1.len()))
        if (word1[i] != word2[i]) {
            if (result)
                return false;
            else
                result = true;
        }
    return result;
}

DefaultDict<int, Array<String>> words;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&word : File(u"unixdict.txt"_S).read().split(u"\n"_S))
            words[word.len()].append(word);
    }
} code_block_1;

template <typename T1, typename T2> auto find_path(const T1 &start, const T2 &target)
{
    auto lg = start.len();
    assert(target.len() == lg, u"Source and destination must have same length."_S);
    assert(in(start, ::words[lg]), u"Source must exist in the dictionary."_S);
    assert(in(target, ::words[lg]), u"Destination must exist in the dictionary."_S);

    auto currPaths = create_array({create_array({start})});
    auto pool = copy(::words[lg]);

    while (true) {
        Array<Array<String>> newPaths;
        Array<String> added;
        for (auto &&candidate : pool)
            for (auto &&path : currPaths)
                if (isOneAway(candidate, path.last())) {
                    auto newPath = path + create_array({candidate});
                    if (candidate == target)
                        return newPath;
                    else {
                        newPaths.append(newPath);
                        added.append(candidate);
                        break;
                    }
                }

        if (newPaths.empty())
            break;
        currPaths = std::move(newPaths);
        for (auto &&w : added)
            pool.remove(w);
    }

    return create_array({u""_S}) * 0;
}

struct CodeBlock2
{
    CodeBlock2()
    {
        for (auto &&[start, target] : create_array({make_tuple(u"boy"_S, u"man"_S), make_tuple(u"girl"_S, u"lady"_S), make_tuple(u"john"_S, u"jane"_S), make_tuple(u"child"_S, u"adult"_S), make_tuple(u"cat"_S, u"dog"_S), make_tuple(u"lead"_S, u"gold"_S), make_tuple(u"white"_S, u"black"_S), make_tuple(u"bubble"_S, u"tickle"_S)})) {
            auto path = find_path(start, target);
            if (path.empty())
                print(u"No path from \""_S & start & u"\" to \""_S & target & u"\"."_S);
            else
                print(path.join(u" -> "_S));
        }
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Wordiff#Python
import re, collections, random

dict_fname = 'unixdict.txt'

def load_dictionary(fname: str=dict_fname):
    "Return appropriate words from a dictionary file"
    return {word for word in open(fname).read().split("\n") if re.fullmatch('[a-z]{3,}', word)}

def get_players():
    names = input('Space separated list of contestants: ')
    return [n.capitalize() for n in names.strip(' ').split(' ')]

def is_wordiff_removal(word, prev : str, comment=True):
    "Is word derived from prev by removing one letter?"
    ans = word in {prev[:i] + prev[i+1:] for i in range(len(prev))}
    if not ans:
        if comment:
            print('Word is not derived from previous by removal of one letter.')
    return ans

def counter(s):
    d = collections.defaultdict(int) # Char
    for c in s:
        d[c] += 1
    return d

def is_wordiff_insertion(word: str, prev: str, comment=True) -> bool:
    "Is word derived from prev by adding one letter?"
    diff = counter(word)
    for c in prev:
        diff[c] -= 1
        if diff[c] <= 0: del diff[c]
    diffcount = sum(diff.values())
    if diffcount != 1:
        if comment:
            print('More than one character insertion difference.')
        return False

    insert = list(diff.keys())[0]
    ans =  word in {prev[:i] + insert + prev[i:] for i in range(len(prev) + 1)}
    if not ans:
        if comment:
            print('Word is not derived from previous by insertion of one letter.')
    return ans

def is_wordiff_change(word: str, prev: str, comment=True) -> bool:
    "Is word derived from prev by changing exactly one letter?"
    diffcount = sum(int(w != p) for w, p in zip(word, prev))
    if diffcount != 1:
        if comment:
            print('More or less than exactly one character changed.')
        return False
    return True

def is_wordiff(wordiffs, word, dic, comment=True):
    "Is word a valid wordiff from wordiffs[-1] ?"
    if word not in dic:
        if comment:
            print('That word is not in my dictionary')
        return False
    if word in wordiffs:
        if comment:
            print('That word was already used.')
        return False
    if len(word) < len(wordiffs[-1]):
        return is_wordiff_removal(word, wordiffs[-1], comment)
    elif len(word) > len(wordiffs[-1]):
        return is_wordiff_insertion(word, wordiffs[-1], comment)

    return is_wordiff_change(word, wordiffs[-1], comment)

def could_have_got(wordiffs, dic):
    return [word for word in (dic - set(wordiffs))
            if is_wordiff(wordiffs, word, dic, comment=False)]

dic = load_dictionary()
dic_3_4 = [word for word in dic if len(word) in (3, 4)]
start = random.choice(dic_3_4)
wordiffs = [start]
players = get_players()
cur_player = 0
while True:
    name = players[cur_player]
    cur_player = (cur_player + 1) % len(players)

    word = input(f"{name}: Input a wordiff from '{wordiffs[-1]}': ").strip(' ')
    if is_wordiff(wordiffs, word, dic):
        wordiffs.append(word)
    else:
        print(f'YOU HAVE LOST {name}!')
        print("Could have used:",
              ', '.join(could_have_got(wordiffs, dic)[:10]), '...')
        break
===
V dict_fname = ‘unixdict.txt’

F load_dictionary(String fname = dict_fname)
   ‘Return appropriate words from a dictionary file’
   R Set(File(fname).read().split("\n").filter(word -> re:‘[a-z]{3,}’.match(word)))

F get_players()
   V names = input(‘Space separated list of contestants: ’)
   R names.trim(‘ ’).split(‘ ’).map(n -> n.capitalize())

F is_wordiff_removal(word, String prev; comment = 1B)
   ‘Is word derived from prev by removing one letter?’
   V ans = word C Set((0 .< prev.len).map(i -> @prev[0 .< i]‘’@prev[i + 1 ..]))
   I !ans
      I comment
         print(‘Word is not derived from previous by removal of one letter.’)
   R ans

F counter(s)
   V d = DefaultDict[Char, Int]()
   L(c) s
      d[c]++
   R d

F is_wordiff_insertion(String word, String prev; comment = 1B) -> Bool
   ‘Is word derived from prev by adding one letter?’
   V diff = counter(word)
   L(c) prev
      I --diff[c] <= 0
         diff.pop(c)
   V diffcount = sum(diff.values())
   I diffcount != 1
      I comment
         print(‘More than one character insertion difference.’)
      R 0B

   V insert = Array(diff.keys())[0]
   V ans = word C Set((0 .. prev.len).map(i -> @prev[0 .< i]‘’@insert‘’@prev[i ..]))
   I !ans
      I comment
         print(‘Word is not derived from previous by insertion of one letter.’)
   R ans

F is_wordiff_change(String word, String prev; comment = 1B) -> Bool
   ‘Is word derived from prev by changing exactly one letter?’
   V diffcount = sum(zip(word, prev).map((w, p) -> Int(w != p)))
   I diffcount != 1
      I comment
         print(‘More or less than exactly one character changed.’)
      R 0B
   R 1B

F is_wordiff(wordiffs, word, dic, comment = 1B)
   ‘Is word a valid wordiff from wordiffs[-1] ?’
   I word !C dic
      I comment
         print(‘That word is not in my dictionary’)
      R 0B
   I word C wordiffs
      I comment
         print(‘That word was already used.’)
      R 0B
   I word.len < wordiffs.last.len
      R is_wordiff_removal(word, wordiffs.last, comment)
   E I word.len > wordiffs.last.len
      R is_wordiff_insertion(word, wordiffs.last, comment)

   R is_wordiff_change(word, wordiffs.last, comment)

F could_have_got(wordiffs, dic)
   R (dic - Set(wordiffs)).filter(word -> is_wordiff(@wordiffs, word, @dic, comment' 0B))

V dic = load_dictionary()
V dic_3_4 = dic.filter(word -> word.len C (3, 4))
V start = random:choice(dic_3_4)
V wordiffs = [start]
V players = get_players()
V cur_player = 0
L
   V name = players[cur_player]
   cur_player = (cur_player + 1) % players.len

   V word = input(name‘: Input a wordiff from '’wordiffs.last‘': ’).trim(‘ ’)
   I is_wordiff(wordiffs, word, dic)
      wordiffs.append(word)
   E
      print(‘YOU HAVE LOST ’name‘!’)
      print(‘Could have used: ’(could_have_got(wordiffs, dic)[0.<10]).join(‘, ’)‘ ...’)
      L.break
===
auto dict_fname = u"unixdict.txt"_S;

auto load_dictionary(const String &fname = dict_fname)
{
    u"Return appropriate words from a dictionary file"_S;
    return create_set(File(fname).read().split(u"\n"_S).filter([](const auto &word){return re::_(u"[a-z]{3,}"_S).match(word);}));
}

auto get_players()
{
    auto names = input(u"Space separated list of contestants: "_S);
    return names.trim(u" "_S).split(u" "_S).map([](const auto &n){return n.capitalize();});
}

template <typename T1, typename T3 = decltype(true)> auto is_wordiff_removal(const T1 &word, const String &prev, const T3 &comment = true)
{
    u"Is word derived from prev by removing one letter?"_S;
    auto ans = in(word, create_set(range_el(0, prev.len()).map([&prev](const auto &i){return prev[range_el(0, i)] & prev[range_ei(i + 1)];})));
    if (!ans) {
        if (comment)
            print(u"Word is not derived from previous by removal of one letter."_S);
    }
    return ans;
}

template <typename T1> auto counter(const T1 &s)
{
    auto d = DefaultDict<Char, int>();
    for (auto &&c : s)
        d[c]++;
    return d;
}

template <typename T3 = decltype(true)> bool is_wordiff_insertion(const String &word, const String &prev, const T3 &comment = true)
{
    u"Is word derived from prev by adding one letter?"_S;
    auto diff = counter(word);
    for (auto &&c : prev)
        if (--diff[c] <= 0)
            diff.pop(c);
    auto diffcount = sum(diff.values());
    if (diffcount != 1) {
        if (comment)
            print(u"More than one character insertion difference."_S);
        return false;
    }

    auto insert = _get<0>(create_array(diff.keys()));
    auto ans = in(word, create_set(range_ee(0, prev.len()).map([&insert, &prev](const auto &i){return prev[range_el(0, i)] & insert & prev[range_ei(i)];})));
    if (!ans) {
        if (comment)
            print(u"Word is not derived from previous by insertion of one letter."_S);
    }
    return ans;
}

template <typename T3 = decltype(true)> bool is_wordiff_change(const String &word, const String &prev, const T3 &comment = true)
{
    u"Is word derived from prev by changing exactly one letter?"_S;
    auto diffcount = sum_map(zip(word, prev), [](const auto &w, const auto &p){return to_int(w != p);});
    if (diffcount != 1) {
        if (comment)
            print(u"More or less than exactly one character changed."_S);
        return false;
    }
    return true;
}

template <typename T1, typename T2, typename T3, typename T4 = decltype(true)> auto is_wordiff(const T1 &wordiffs, const T2 &word, const T3 &dic, const T4 &comment = true)
{
    u"Is word a valid wordiff from wordiffs[-1] ?"_S;
    if (!in(word, dic)) {
        if (comment)
            print(u"That word is not in my dictionary"_S);
        return false;
    }
    if (in(word, wordiffs)) {
        if (comment)
            print(u"That word was already used."_S);
        return false;
    }
    if (word.len() < wordiffs.last().len())
        return is_wordiff_removal(word, wordiffs.last(), comment);
    else if (word.len() > wordiffs.last().len())
        return is_wordiff_insertion(word, wordiffs.last(), comment);

    return is_wordiff_change(word, wordiffs.last(), comment);
}

template <typename T1, typename T2> auto could_have_got(const T1 &wordiffs, const T2 &dic)
{
    return (dic - create_set(wordiffs)).filter([&dic, &wordiffs](const auto &word){return is_wordiff(wordiffs, word, dic, false);});
}

auto dic = load_dictionary();
auto dic_3_4 = dic.filter([](const auto &word){return in(word.len(), make_tuple(3, 4));});
auto start = randomns::choice(dic_3_4);
auto wordiffs = create_array({start});
auto players = get_players();
auto cur_player = 0;

struct CodeBlock1
{
    CodeBlock1()
    {
        while (true) {
            auto name = players[cur_player];
            cur_player = mod((cur_player + 1), players.len());

            auto word = input(name & u": Input a wordiff from '"_S & wordiffs.last() & u"': "_S).trim(u" "_S);
            if (is_wordiff(wordiffs, word, dic))
                wordiffs.append(word);
            else {
                print(u"YOU HAVE LOST "_S & name & u"!"_S);
                print(u"Could have used: "_S & (could_have_got(wordiffs, dic)[range_el(0, 10)]).join(u", "_S) & u" ..."_S);
                break;
            }
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Words_from_neighbour_ones#Python
wordList = open("unixdict.txt").read().split('\n')

filteredWords = [chosenWord for chosenWord in wordList if len(chosenWord)>=9]

for word in filteredWords[:-9]:
    position = filteredWords.index(word)
    newWord = "".join([filteredWords[position+i][i] for i in range(0,9)])
    if newWord in filteredWords:
        print(newWord)
===
V wordList = File(‘unixdict.txt’).read().split("\n")

V filteredWords = wordList.filter(chosenWord -> chosenWord.len >= 9)

L(word) filteredWords[0 .< (len)-9]
   V position = filteredWords.index(word)
   V newWord = ((0..8).map(i -> :filteredWords[@position + i][i])).join(‘’)
   I newWord C filteredWords
      print(newWord)
===
auto wordList = File(u"unixdict.txt"_S).read().split(u"\n"_S);

auto filteredWords = wordList.filter([](const auto &chosenWord){return chosenWord.len() >= 9;});

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&word : filteredWords[range_e_llen(0,  - 9)]) {
            auto position = filteredWords.index(word);
            auto newWord = (range_ee(0, 8).map([&position](const auto &i){return ::filteredWords[position + i][i];})).join(u""_S);
            if (in(newWord, filteredWords))
                print(newWord);
        }
    }
} code_block_1;