# https://www.rosettacode.org/wiki/Largest_int_from_concatenated_ints#Python
def maxnum(x):
    maxlen = len(str(max(x)))
    return ''.join(sorted((str(v) for v in x),
                          key=lambda i: i*(maxlen * 2 // len(i)), reverse=True))

for numbers in [[212, 21221], [1, 34, 3, 98, 9, 76, 45, 4], [54, 546, 548, 60]]:
    print('Numbers: %s\n  Largest integer: %15s' % (numbers, maxnum(numbers)))
===
F maxnum(x)
   V maxlen = String(max(x)).len
   R sorted((x.map(v -> String(v))), key' i -> i * (@maxlen * 2 I/ i.len), reverse' 1B).join(‘’)

L(numbers) [[212, 21221], [1, 34, 3, 98, 9, 76, 45, 4], [54, 546, 548, 60]]
   print("Numbers: #.\n  Largest integer: #15".format(numbers, maxnum(numbers)))
===
template <typename T1> auto maxnum(const T1 &x)
{
    auto maxlen = String(max(x)).len();
    return sorted((x.map([](const auto &v){return String(v);})), [&maxlen](const auto &i){return i * (idiv(maxlen * 2, i.len()));}, true).join(u""_S);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&numbers : create_array({create_array({212, 21221}), create_array({1, 34, 3, 98, 9, 76, 45, 4}), create_array({54, 546, 548, 60})}))
            print(u"Numbers: #.\n  Largest integer: #15"_S.format(numbers, maxnum(numbers)));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Largest_number_divisible_by_its_digits#C.2B.2B
def check_dec(num):
    st = set() # int
    for c in str(num):
        d = int(c)
        if d == 0 or num % d != 0 or d in st:
            return False
        st.add(d)
    return True

for i in range(98764321, 0, -1):
    if check_dec(i):
        print(i)
        break
===
F check_dec(num)
   V st = Set[Int]()
   L(c) String(num)
      V d = Int(c)
      I d == 0 | num % d != 0 | d C st
         R 0B
      st.add(d)
   R 1B

L(i) (98764321.<0).step(-1)
   I check_dec(i)
      print(i)
      L.break
===
template <typename T1> auto check_dec(const T1 &num)
{
    auto st = Set<int>();
    for (auto &&c : String(num)) {
        auto d = to_int(c);
        if (d == 0 || mod(num, d) != 0 || in(d, st))
            return false;
        st.add(d);
    }
    return true;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto i : range_el(98764321, 0).step(-1))
            if (check_dec(i)) {
                print(i);
                break;
            }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Leap_year#Python
def is_leap_year(year):
    if year % 100 == 0:
        return year % 400 == 0
    return year % 4 == 0
===
F is_leap_year(year)
   I year % 100 == 0
      R year % 400 == 0
   R year % 4 == 0
===
template <typename T1> auto is_leap_year(const T1 &year)
{
    if (mod(year, 100) == 0)
        return mod(year, 400) == 0;
    return mod(year, 4) == 0;
}


# https://www.rosettacode.org/wiki/Least_common_multiple
def gcd(a, b):
    while b != 0:
        (a, b) = (b, a % b)
    return a

def lcm(m, n):
    return m // gcd(m, n) * n

print(lcm(12, 18))
===
F gcd(=a, =b)
   L b != 0
      (a, b) = (b, a % b)
   R a

F lcm(m, n)
   R m I/ gcd(m, n) * n

print(lcm(12, 18))
===
template <typename T1, typename T2> auto gcd(T1 a, T2 b)
{
    while (b != 0)
        assign_from_tuple(a, b, make_tuple(b, mod(a, b)));
    return a;
}

template <typename T1, typename T2> auto lcm(const T1 &m, const T2 &n)
{
    return idiv(m, gcd(m, n)) * n;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(lcm(12, 18));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Length_of_an_arc_between_two_angles#Python
import math

def arc_length(r, angleA, angleB):
    return (360.0 - abs(angleB - angleA)) * math.pi * r / 180.0

print(arc_length(10, 10, 120))
===
F arc_length(r, angleA, angleB)
   R (360.0 - abs(angleB - angleA)) * math:pi * r / 180.0

print(arc_length(10, 10, 120))
===
template <typename T1, typename T2, typename T3> auto arc_length(const T1 &r, const T2 &angleA, const T3 &angleB)
{
    return (360.0 - abs(angleB - angleA)) * math::pi * r / 180.0;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(arc_length(10, 10, 120));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Leonardo_numbers#C.2B.2B
def leo_numbers(cnt, l0 = 1, l1 = 1, add = 1):
    for i in range(cnt):
        print(l0, end = ' ')
        (l0, l1) = (l1, l0 + l1 + add)
    print()

print('Leonardo Numbers: ', end = '')
leo_numbers(25)
print('Fibonacci Numbers: ', end = '')
leo_numbers(25, 0, 1, 0)
===
F leo_numbers(cnt, =l0 = 1, =l1 = 1, add = 1)
   L(i) 0 .< cnt
      print(l0, end' ‘ ’)
      (l0, l1) = (l1, l0 + l1 + add)
   print()

print(‘Leonardo Numbers: ’, end' ‘’)
leo_numbers(25)
print(‘Fibonacci Numbers: ’, end' ‘’)
leo_numbers(25, 0, 1, 0)
===
template <typename T1, typename T2 = decltype(1), typename T3 = decltype(1), typename T4 = decltype(1)> auto leo_numbers(const T1 &cnt, T2 l0 = 1, T3 l1 = 1, const T4 &add = 1)
{
    for (auto i : range_el(0, cnt)) {
        print(l0, u" "_S);
        assign_from_tuple(l0, l1, make_tuple(l1, l0 + l1 + add));
    }
    print();
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"Leonardo Numbers: "_S, u""_S);
        leo_numbers(25);
        print(u"Fibonacci Numbers: "_S, u""_S);
        leo_numbers(25, 0, 1, 0);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Levenshtein_distance#Python
def minimumEditDistance(s1,s2):
    if len(s1) > len(s2):
        (s1, s2) = (s2, s1)
    distances = list(range(len(s1) + 1))
    for index2,char2 in enumerate(s2):
        newDistances = [index2+1]
        for index1,char1 in enumerate(s1):
            if char1 == char2:
                newDistances.append(distances[index1])
            else:
                newDistances.append(1 + min((distances[index1],
                                             distances[index1+1],
                                             newDistances[-1])))
        distances = newDistances
    return distances[-1]

print(minimumEditDistance("kitten","sitting"))
print(minimumEditDistance("rosettacode","raisethysword"))
===
F minimumEditDistance(=s1, =s2)
   I s1.len > s2.len
      swap(&s1, &s2)
   V distances = Array(0 .. s1.len)
   L(char2) s2
      V index2 = L.index
      V newDistances = [index2 + 1]
      L(char1) s1
         V index1 = L.index
         I char1 == char2
            newDistances.append(distances[index1])
         E
            newDistances.append(1 + min((distances[index1], distances[index1 + 1], newDistances.last)))
      distances = newDistances
   R distances.last

print(minimumEditDistance(‘kitten’, ‘sitting’))
print(minimumEditDistance(‘rosettacode’, ‘raisethysword’))
===
template <typename T1, typename T2> auto minimumEditDistance(T1 s1, T2 s2)
{
    if (s1.len() > s2.len())
        swap(s1, s2);
    auto distances = create_array(range_ee(0, s1.len()));
    {int Lindex = 0;
    for (auto &&char2 : s2) {
        auto index2 = Lindex;
        auto newDistances = create_array({index2 + 1});
        {int Lindex = 0;
        for (auto &&char1 : s1) {
            auto index1 = Lindex;
            if (char1 == char2)
                newDistances.append(distances[index1]);
            else
                newDistances.append(1 + min(make_tuple(distances[index1], distances[index1 + 1], newDistances.last())));
            Lindex++;
        }}
        distances = newDistances;
        Lindex++;
    }}
    return distances.last();
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(minimumEditDistance(u"kitten"_S, u"sitting"_S));
        print(minimumEditDistance(u"rosettacode"_S, u"raisethysword"_S));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Linear_congruential_generator
class LinearCongruentialGenerator:
    seed = 0
    a : int
    c : int
    m : int
    def __init__(self, a, c, m):
        self.a = a
        self.c = c
        self.m = m

    def __call__(self):
        self.seed = (self.a * self.seed + self.c) & self.m
        return self.seed

bsd_rnd = LinearCongruentialGenerator(1103515245, 12345, 0x7FFF_FFFF)
ms_rnd  = LinearCongruentialGenerator(214013, 2531011, 0x7FFF_FFFF)

print('BSD RAND:')
for i in range(5):
    print(bsd_rnd())
print()
print('MS RAND:')
for i in range(5):
    print(ms_rnd() >> 16)
===
T LinearCongruentialGenerator
   seed = 0
   Int a
   Int c
   Int m
   F (a, c, m)
      .a = a
      .c = c
      .m = m

   F ()()
      .seed = (.a * .seed + .c) [&] .m
      R .seed

V bsd_rnd = LinearCongruentialGenerator(1103515245, 12345, 7FFF'FFFF)
V ms_rnd = LinearCongruentialGenerator(214013, 2531011, 7FFF'FFFF)

print(‘BSD RAND:’)
L(i) 5
   print(bsd_rnd())
print()
print(‘MS RAND:’)
L(i) 5
   print(ms_rnd() >> 16)
===
class LinearCongruentialGenerator
{
public:
    decltype(0) seed = 0;
    int a;
    int c;
    int m;
    template <typename T1, typename T2, typename T3> LinearCongruentialGenerator(const T1 &a, const T2 &c, const T3 &m) :
        a(a),
        c(c),
        m(m)
    {
    }

    auto operator()()
    {
        seed = (a * seed + c) & m;
        return seed;
    }
};

auto bsd_rnd = LinearCongruentialGenerator(1103515245, 12345, 0x7FFF'FFFF);
auto ms_rnd = LinearCongruentialGenerator(214013, 2531011, 0x7FFF'FFFF);

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"BSD RAND:"_S);
        for (int i = 0; i < 5; i++)
            print(bsd_rnd());
        print();
        print(u"MS RAND:"_S);
        for (int i = 0; i < 5; i++)
            print(ms_rnd() >> 16);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/List_comprehensions#Python
from itertools import product

print([(x, y, z) for x, y, z in product(range(1,21), range(1,21), range(1,21)) if x**2 + y**2 == z**2 and x <= y <= z])
===
print(cart_product(1..20, 1..20, 1..20).filter((x, y, z) -> x ^ 2 + y ^ 2 == z ^ 2 & y C x .. z))
===
struct CodeBlock1
{
    CodeBlock1()
    {
        print(cart_product(range_ee(1, 20), range_ee(1, 20), range_ee(1, 20)).filter([](const auto &x, const auto &y, const auto &z){return square(x) + square(y) == square(z) && in(y, range_ee(x, z));}));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/List_rooted_trees#Python
def bagchain(x, n, bb, start=0):
    if n == 0:
        return [x]

    out : List[Tuple[int, str]] = []
    for i in range(start, len(bb)):
        (c, s) = bb[i]
        if c <= n:
            out.extend(bagchain((x[0] + c, x[1] + '' + s), n-c, bb, i))
    return out

def bags(n):
    if n == 0:
        return [(0, "")]

    upto : List[Tuple[int, str]] = []
    for x in range(n-1, 0, -1):
        upto.extend(bags(x))

    return [(c+1, '('+s+')') for c, s in bagchain((0, ""), n-1, upto)]

# Maybe this lessens eye strain. Maybe not.
def replace_brackets(s):
    depth = 0
    out : List[str] = []
    for c in s:
        if c == '(':
            out.append("([{"[depth%3])
            depth += 1
        else:
            depth -= 1
            out.append(")]}"[depth%3])
    return "".join(out)

for x in bags(5):
    print(replace_brackets(x[1]))
===
F bagchain(x, n, bb, start = 0)
   I n == 0
      R [x]

   [(Int, String)] out
   L(i) start .< bb.len
      V (c, s) = bb[i]
      I c <= n
         out.extend(bagchain((x[0] + c, x[1]‘’s), n - c, bb, i))
   R out

F bags(n)
   I n == 0
      R [(0, ‘’)]

   [(Int, String)] upto
   L(x) (n - 1 .< 0).step(-1)
      upto.extend(bags(x))

   R bagchain((0, ‘’), n - 1, upto).map((c, s) -> (c + 1, ‘(’s‘)’))

F replace_brackets(s)
   V depth = 0
   [String] out
   L(c) s
      I c == ‘(’
         out.append(‘([{’[depth % 3])
         depth++
      E
         depth--
         out.append(‘)]}’[depth % 3])
   R out.join(‘’)

L(x) bags(5)
   print(replace_brackets(x[1]))
===
template <typename T1, typename T2, typename T3, typename T4 = decltype(0)> auto bagchain(const T1 &x, const T2 &n, const T3 &bb, const T4 &start = 0)
{
    if (n == 0)
        return create_array({x});

    Array<Tuple<int, String>> out;
    for (auto i : range_el(start, bb.len())) {
        auto [c, s] = bb[i];
        if (c <= n)
            out.extend(bagchain(make_tuple(_get<0>(x) + c, _get<1>(x) & s), n - c, bb, i));
    }
    return out;
}

template <typename T1> auto bags(const T1 &n)
{
    if (n == 0)
        return create_array({make_tuple(0, u""_S)});

    Array<Tuple<int, String>> upto;
    for (auto x : range_el(n - 1, 0).step(-1))
        upto.extend(bags(x));

    return bagchain(make_tuple(0, u""_S), n - 1, upto).map([](const auto &c, const auto &s){return make_tuple(c + 1, u"("_S & s & u")"_S);});
}

template <typename T1> auto replace_brackets(const T1 &s)
{
    auto depth = 0;
    Array<String> out;
    for (auto &&c : s)
        if (c == u'(') {
            out.append(u"([{"_S[mod(depth, 3)]);
            depth++;
        }
        else {
            depth--;
            out.append(u")]}"_S[mod(depth, 3)]);
        }
    return out.join(u""_S);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&x : bags(5))
            print(replace_brackets(_get<1>(x)));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Long_primes#Python
def sieve(limit):
    primes : List[int] = []
    c = [False] * (limit + 1) # composite = true
    # no need to process even numbers
    p = 3
    while True:
        p2 = p * p
        if p2 > limit: break
        for i in range(p2, limit, 2 * p): c[i] = True
        while True:
            p += 2
            if not c[p]: break

    for i in range(3, limit, 2):
        if not c[i]: primes.append(i)
    return primes

# finds the period of the reciprocal of n
def findPeriod(n):
    r = 1
    for i in range(1, n): r = (10 * r) % n
    rr = r
    period = 0
    while True:
        r = (10 * r) % n
        period += 1
        if r == rr: break
    return period

primes = sieve(64000)
longPrimes : List[int] = []
for prime in primes:
    if findPeriod(prime) == prime - 1:
        longPrimes.append(prime)
numbers = [500, 1000, 2000, 4000, 8000, 16000, 32000, 64000]
count = 0
index = 0
totals = [0] * len(numbers)
for longPrime in longPrimes:
    if longPrime > numbers[index]:
        totals[index] = count
        index += 1
    count += 1
totals[-1] = count
print('The long primes up to 500 are:')
print(str(longPrimes[:totals[0]]).replace(',', ''))
print('\nThe number of long primes up to:')
for i, total in enumerate(totals):
    print('  %5d is %d' % (numbers[i], total))
===
F sieve(limit)
   [Int] primes
   V c = [0B] * (limit + 1)
   V p = 3
   L
      V p2 = p * p
      I p2 > limit
         L.break
      L(i) (p2 .< limit).step(2 * p)
         c[i] = 1B
      L
         p += 2
         I !c[p]
            L.break

   L(i) (3 .< limit).step(2)
      I !c[i]
         primes.append(i)
   R primes

F findPeriod(n)
   V r = 1
   L(i) 1 .< n
      r = (10 * r) % n
   V rr = r
   V period = 0
   L
      r = (10 * r) % n
      period++
      I r == rr
         L.break
   R period

V primes = sieve(64000)
[Int] longPrimes
L(prime) primes
   I findPeriod(prime) == prime - 1
      longPrimes.append(prime)
V numbers = [500, 1000, 2000, 4000, 8000, 16000, 32000, 64000]
V count = 0
V index = 0
V totals = [0] * numbers.len
L(longPrime) longPrimes
   I longPrime > numbers[index]
      totals[index] = count
      index++
   count++
totals.last = count
print(‘The long primes up to 500 are:’)
print(String(longPrimes[0 .< totals[0]]).replace(‘,’, ‘’))
print("\nThe number of long primes up to:")
L(total) totals
   V i = L.index
   print(‘  #5 is #.’.format(numbers[i], total))
===
template <typename T1> auto sieve(const T1 &limit)
{
    Array<int> primes;
    auto c = create_array({false}) * (limit + 1);
    auto p = 3;
    while (true) {
        auto p2 = p * p;
        if (p2 > limit)
            break;
        for (auto i : range_el(p2, limit).step(2 * p))
            c.set(i, true);
        while (true) {
            p += 2;
            if (!c[p])
                break;
        }
    }

    for (auto i : range_el(3, limit).step(2))
        if (!c[i])
            primes.append(i);
    return primes;
}

template <typename T1> auto findPeriod(const T1 &n)
{
    auto r = 1;
    for (auto i : range_el(1, n))
        r = mod((10 * r), n);
    auto rr = r;
    auto period = 0;
    while (true) {
        r = mod((10 * r), n);
        period++;
        if (r == rr)
            break;
    }
    return period;
}

auto primes = sieve(64000);
Array<int> longPrimes;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&prime : primes)
            if (findPeriod(prime) == prime - 1)
                longPrimes.append(prime);
    }
} code_block_1;

auto numbers = create_array({500, 1000, 2000, 4000, 8000, 16000, 32000, 64000});
auto count = 0;
auto index = 0;
auto totals = create_array({0}) * numbers.len();

struct CodeBlock2
{
    CodeBlock2()
    {
        for (auto &&longPrime : longPrimes) {
            if (longPrime > numbers[index]) {
                totals.set(index, count);
                index++;
            }
            count++;
        }
        totals.last() = count;
        print(u"The long primes up to 500 are:"_S);
        print(String(longPrimes[range_el(0, _get<0>(totals))]).replace(u","_S, u""_S));
        print(u"\nThe number of long primes up to:"_S);
        {int Lindex = 0;
        for (auto &&total : totals) {
            auto i = Lindex;
            print(u"  #5 is #."_S.format(numbers[i], total));
            Lindex++;
        }}
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Long_year#C.2B.2B
def is_long_year(year):
    def p(year):
        return (year + (year//4) - (year//100) + (year//400)) % 7
    return p(year) == 4 or p(year - 1) == 3

for year in range(2000, 2100 + 1):
    if is_long_year(year):
        print(year, end = ' ')
===
F is_long_year(year)
   F p(year)
      R (year + (year I/ 4) - (year I/ 100) + (year I/ 400)) % 7
   R p(year) == 4 | p(year - 1) == 3

L(year) 2000 .. 2100
   I is_long_year(year)
      print(year, end' ‘ ’)
===
template <typename T1> auto is_long_year(const T1 &year)
{
    auto p = [](const auto &year)
    {
        return mod((year + (idiv(year, 4)) - (idiv(year, 100)) + (idiv(year, 400))), 7);
    };
    return p(year) == 4 || p(year - 1) == 3;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto year : range_ee(2000, 2100))
            if (is_long_year(year))
                print(year, u" "_S);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Longest_common_prefix
# (based on Kotlin solution)
def lcp(sa):
    if len(sa) == 0:
        return ''
    if len(sa) == 1:
        return sa[0]

    min_len = min(len(s) for s in sa)

    for i in range(min_len):
        p = sa[0][i]
        for j in range(1, len(sa)):
            if sa[j][i] != p:
                return sa[0][:i]

    return sa[0][:min_len]

def test(sa):
    print(str(sa), '->', lcp(sa))

test(["interspecies", "interstellar", "interstate"])
test(["throne", "throne"])
test(["throne", "dungeon"])
test(["throne", "", "throne"])
test(["cheese"])
test([""])
test(["prefix", "suffix"])
test(["foo", "foobar"])
===
F lcp(sa)
   I sa.empty
      R ‘’
   I sa.len == 1
      R sa[0]

   V min_len = min(sa.map(s -> s.len))

   L(i) 0 .< min_len
      V p = sa[0][i]
      L(j) 1 .< sa.len
         I sa[j][i] != p
            R sa[0][0 .< i]

   R sa[0][0 .< min_len]

F test(sa)
   print(String(sa)‘ -> ’lcp(sa))

test([‘interspecies’, ‘interstellar’, ‘interstate’])
test([‘throne’, ‘throne’])
test([‘throne’, ‘dungeon’])
test([‘throne’, ‘’, ‘throne’])
test([‘cheese’])
test([‘’])
test([‘prefix’, ‘suffix’])
test([‘foo’, ‘foobar’])
===
template <typename T1> auto lcp(const T1 &sa)
{
    if (sa.empty())
        return u""_S;
    if (sa.len() == 1)
        return _get<0>(sa);

    auto min_len = min_map(sa, [](const auto &s){return s.len();});

    for (auto i : range_el(0, min_len)) {
        auto p = _get<0>(sa)[i];
        for (auto j : range_el(1, sa.len()))
            if (sa[j][i] != p)
                return _get<0>(sa)[range_el(0, i)];
    }

    return _get<0>(sa)[range_el(0, min_len)];
}

template <typename T1> auto test(const T1 &sa)
{
    print(String(sa) & u" -> "_S & lcp(sa));
}

struct CodeBlock1
{
    CodeBlock1()
    {
        test(create_array({u"interspecies"_S, u"interstellar"_S, u"interstate"_S}));
        test(create_array({u"throne"_S, u"throne"_S}));
        test(create_array({u"throne"_S, u"dungeon"_S}));
        test(create_array({u"throne"_S, u""_S, u"throne"_S}));
        test(create_array({u"cheese"_S}));
        test(create_array({u""_S}));
        test(create_array({u"prefix"_S, u"suffix"_S}));
        test(create_array({u"foo"_S, u"foobar"_S}));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Longest_common_subsequence#Python
def lcs(a, b):
    # generate matrix of length of longest common subsequence for substrings of both words
    lengths = [[0] * (len(b)+1) for _ in range(len(a)+1)]
    for i, x in enumerate(a):
        for j, y in enumerate(b):
            if x == y:
                lengths[i+1][j+1] = lengths[i][j] + 1
            else:
                lengths[i+1][j+1] = max(lengths[i+1][j], lengths[i][j+1])

    # read a substring from the matrix
    result = ''
    j = len(b)
    for i in range(1, len(a)+1):
        if lengths[i][j] != lengths[i-1][j]:
            result += a[i-1]

    return result

print(lcs('1234', '1224533324'))
print(lcs('thisisatest', 'testing123testing'))
===
F lcs(a, b)
   V lengths = [[0] * (b.len + 1)] * (a.len + 1)
   L(x) a
      V i = L.index
      L(y) b
         V j = L.index
         I x == y
            lengths[i + 1][j + 1] = lengths[i][j] + 1
         E
            lengths[i + 1][j + 1] = max(lengths[i + 1][j], lengths[i][j + 1])

   V result = ‘’
   V j = b.len
   L(i) 1 .. a.len
      I lengths[i][j] != lengths[i - 1][j]
         result ‘’= a[i - 1]

   R result

print(lcs(‘1234’, ‘1224533324’))
print(lcs(‘thisisatest’, ‘testing123testing’))
===
template <typename T1, typename T2> auto lcs(const T1 &a, const T2 &b)
{
    auto lengths = create_array({create_array({0}) * (b.len() + 1)}) * (a.len() + 1);
    {int Lindex = 0;
    for (auto &&x : a) {
        auto i = Lindex;
        {int Lindex = 0;
        for (auto &&y : b) {
            auto j = Lindex;
            if (x == y)
                lengths[i + 1].set(j + 1, lengths[i][j] + 1);
            else
                lengths[i + 1].set(j + 1, max(lengths[i + 1][j], lengths[i][j + 1]));
            Lindex++;
        }}
        Lindex++;
    }}

    auto result = u""_S;
    auto j = b.len();
    for (auto i : range_ee(1, a.len()))
        if (lengths[i][j] != lengths[i - 1][j])
            result &= a[i - 1];

    return result;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(lcs(u"1234"_S, u"1224533324"_S));
        print(lcs(u"thisisatest"_S, u"testing123testing"_S));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Longest_common_substring#Python
def longest_common_substring(s1, s2):
    ir = 0
    jr = -1
    for i1 in range(len(s1)):
        i2 = s2.find(s1[i1])
        while i2 >= 0:
            (j1, j2) = (i1, i2)
            while j1 < len(s1) and j2 < len(s2) and s2[j2] == s1[j1]:
                if j1-i1 >= jr-ir:
                    (ir, jr) = (i1, j1)
                j1 += 1
                j2 += 1
            i2 = s2.find(s1[i1], i2+1)
    return s1[ir:jr+1]

print(longest_common_substring("thisisatest", "testing123testing"))
===
F longest_common_substring(s1, s2)
   V ir = 0
   V jr = -1
   L(i1) 0 .< s1.len
      V i2 = s2.findi(s1[i1])
      L i2 >= 0
         V (j1, j2) = (i1, i2)
         L j1 < s1.len & j2 < s2.len & s2[j2] == s1[j1]
            I j1 - i1 >= jr - ir
               (ir, jr) = (i1, j1)
            j1++
            j2++
         i2 = s2.findi(s1[i1], i2 + 1)
   R s1[ir .< jr + 1]

print(longest_common_substring(‘thisisatest’, ‘testing123testing’))
===
template <typename T1, typename T2> auto longest_common_substring(const T1 &s1, const T2 &s2)
{
    auto ir = 0;
    auto jr = -1;
    for (auto i1 : range_el(0, s1.len())) {
        auto i2 = s2.findi(s1[i1]);
        while (i2 >= 0) {
            auto [_j1_, j2] = make_tuple(i1, i2);
            while (_j1_ < s1.len() && j2 < s2.len() && s2[j2] == s1[_j1_]) {
                if (_j1_ - i1 >= jr - ir)
                    assign_from_tuple(ir, jr, make_tuple(i1, _j1_));
                _j1_++;
                j2++;
            }
            i2 = s2.findi(s1[i1], i2 + 1);
        }
    }
    return s1[range_el(ir, jr + 1)];
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(longest_common_substring(u"thisisatest"_S, u"testing123testing"_S));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Longest_common_suffix
def lcs(sa):
    if len(sa) == 0:
        return ''
    if len(sa) == 1:
        return sa[0]

    min_len = min(len(s) for s in sa)

    for i in range(1, min_len + 1):
        p = sa[0][-i]
        for j in range(1, len(sa)):
            if sa[j][-i] != p:
                return sa[0][-i+1:]

    return sa[0][-min_len:]

print(lcs(["11Sunday", "2Sunday"]))
print(lcs(["Sunday", "Monday", "Tuesday"]))
print(lcs(["Sunday", "Monday", "Tuesday", "day"]))
print(lcs(["Sondag", "Maandag", "Dinsdag", "Woensdag"]))
===
F lcs(sa)
   I sa.empty
      R ‘’
   I sa.len == 1
      R sa[0]

   V min_len = min(sa.map(s -> s.len))

   L(i) 1 .. min_len
      V p = sa[0][(len)-i]
      L(j) 1 .< sa.len
         I sa[j][(len)-i] != p
            R sa[0][(len)-i + 1 ..]

   R sa[0][(len)-min_len ..]

print(lcs([‘11Sunday’, ‘2Sunday’]))
print(lcs([‘Sunday’, ‘Monday’, ‘Tuesday’]))
print(lcs([‘Sunday’, ‘Monday’, ‘Tuesday’, ‘day’]))
print(lcs([‘Sondag’, ‘Maandag’, ‘Dinsdag’, ‘Woensdag’]))
===
template <typename T1> auto lcs(const T1 &sa)
{
    if (sa.empty())
        return u""_S;
    if (sa.len() == 1)
        return _get<0>(sa);

    auto min_len = min_map(sa, [](const auto &s){return s.len();});

    for (auto i : range_ee(1, min_len)) {
        auto p = _get<0>(sa).at_plus_len( - i);
        for (auto j : range_el(1, sa.len()))
            if (sa[j].at_plus_len( - i) != p)
                return _get<0>(sa)[range_elen_i( - i + 1)];
    }

    return _get<0>(sa)[range_elen_i( - min_len)];
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(lcs(create_array({u"11Sunday"_S, u"2Sunday"_S})));
        print(lcs(create_array({u"Sunday"_S, u"Monday"_S, u"Tuesday"_S})));
        print(lcs(create_array({u"Sunday"_S, u"Monday"_S, u"Tuesday"_S, u"day"_S})));
        print(lcs(create_array({u"Sondag"_S, u"Maandag"_S, u"Dinsdag"_S, u"Woensdag"_S})));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Longest_increasing_subsequence#Python
def longest_increasing_subsequence(x):
    """Returns the Longest Increasing Subsequence in the Given List/Array"""
    n = len(x)
    P = [0] * n
    M = [0] * (n+1)
    l = 0
    for i in range(n):
       lo = 1
       hi = l
       while lo <= hi:
           mid = (lo+hi)//2
           if (x[M[mid]] < x[i]):
               lo = mid+1
           else:
               hi = mid-1

       newl = lo
       P[i] = M[newl-1]
       M[newl] = i

       if (newl > l):
           l = newl

    s : List[int] = []
    k = M[l]
    for i in range(l-1, -1, -1):
        s.append(x[k])
        k = P[k]
    return s[::-1]

for d in [[3,2,6,4,5,1], [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]]:
    print('a L.I.S. of %s is %s' % (d, longest_increasing_subsequence(d)))
===
F longest_increasing_subsequence(x)
   ‘Returns the Longest Increasing Subsequence in the Given List/Array’
   V n = x.len
   V P = [0] * n
   V M = [0] * (n + 1)
   V l = 0
   L(i) 0 .< n
      V lo = 1
      V hi = l
      L lo <= hi
         V mid = (lo + hi) I/ 2
         I (x[M[mid]] < x[i])
            lo = mid + 1
         E
            hi = mid - 1

      V newl = lo
      P[i] = M[newl - 1]
      M[newl] = i

      I (newl > l)
         l = newl

   [Int] s
   V k = M[l]
   L(i) (l - 1 .< -1).step(-1)
      s.append(x[k])
      k = P[k]
   R reversed(s)

L(d) [[3, 2, 6, 4, 5, 1], [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]]
   print(‘a L.I.S. of #. is #.’.format(d, longest_increasing_subsequence(d)))
===
template <typename T1> auto longest_increasing_subsequence(const T1 &x)
{
    u"Returns the Longest Increasing Subsequence in the Given List/Array"_S;
    auto n = x.len();
    auto P = create_array({0}) * n;
    auto M = create_array({0}) * (n + 1);
    auto l = 0;
    for (auto i : range_el(0, n)) {
        auto lo = 1;
        auto hi = l;
        while (lo <= hi) {
            auto mid = idiv((lo + hi), 2);
            if ((x[M[mid]] < x[i]))
                lo = mid + 1;
            else
                hi = mid - 1;
        }

        auto newl = lo;
        P.set(i, M[newl - 1]);
        M.set(newl, i);

        if ((newl > l))
            l = newl;
    }

    Array<int> s;
    auto k = M[l];
    for (auto i : range_el(l - 1, -1).step(-1)) {
        s.append(x[k]);
        k = P[k];
    }
    return reversed(s);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&d : create_array({create_array({3, 2, 6, 4, 5, 1}), create_array({0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15})}))
            print(u"a L.I.S. of #. is #."_S.format(d, longest_increasing_subsequence(d)));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Longest_palindromic_substrings
# [https://leetcode.com/problems/longest-palindromic-substring/discuss/3337/Manacher-algorithm-in-Python-O(n) <- google:‘Manacher algorithm python’]
def longest_palindrome(s):
    # transform s into t.
    # For example, s = "abba", t = "^#a#b#b#a#$".
    # ^ and $ signs are sentinels appended to each end to avoid bounds checking
    t = '#'.join(list('^'+s+'$'))
    n = len(t)
    p = [0] * n
    c = 0
    r = 0
    for i in range (1, n-1):
        p[i] = (r > i) and min(r - i, p[2*c - i]) != 0 # equals to i' = c - (i-c)
        # Attempt to expand palindrome centered at i
        while t[i + 1 + p[i]] == t[i - 1 - p[i]]:
            p[i] += 1

        # If palindrome centered at i expand past r,
        # adjust center based on expanded palindrome.
        if i + p[i] > r:
            (c, r) = (i, i + p[i])

    # Find the maximum element in p.
    (max_len, center_index) = max((n, i) for i, n in enumerate(p))
    return s[(center_index  - max_len)//2: (center_index  + max_len)//2]

for s in [
            'three old rotators',
            'never reverse',
            'stable was I ere I saw elbatrosses',
            'abracadabra',
            'drome',
            'the abbatial palace'
         ]:
    print("'" + s + "' -> '" + longest_palindrome(s) + "'")
===
F longest_palindrome(s)
   V t = Array(‘^’s‘$’).join(‘#’)
   V n = t.len
   V p = [0] * n
   V c = 0
   V r = 0
   L(i) 1 .< n - 1
      p[i] = (r > i) & min(r - i, p[2 * c - i]) != 0
      L t[i + 1 + p[i]] == t[i - 1 - p[i]]
         p[i]++

      I i + p[i] > r
         (c, r) = (i, i + p[i])

   V (max_len, center_index) = max(enumerate(p).map((i, n) -> (n, i)))
   R s[(center_index - max_len) I/ 2 .< (center_index + max_len) I/ 2]

L(s) [‘three old rotators’, ‘never reverse’, ‘stable was I ere I saw elbatrosses’, ‘abracadabra’, ‘drome’, ‘the abbatial palace’]
   print(‘'’s‘' -> '’longest_palindrome(s)‘'’)
===
template <typename T1> auto longest_palindrome(const T1 &s)
{
    auto t = create_array(u"^"_S & s & u"$"_S).join(u"#"_S);
    auto n = t.len();
    auto p = create_array({0}) * n;
    auto c = 0;
    auto r = 0;
    for (auto i : range_el(1, n - 1)) {
        p.set(i, (r > i) && min(r - i, p[2 * c - i]) != 0);
        while (t[i + 1 + p[i]] == t[i - 1 - p[i]])
            p[i]++;

        if (i + p[i] > r)
            assign_from_tuple(c, r, make_tuple(i, i + p[i]));
    }

    auto [max_len, center_index] = max_map(enumerate(p), [](const auto &i, const auto &n){return make_tuple(n, i);});
    return s[range_el(idiv((center_index - max_len), 2), idiv((center_index + max_len), 2))];
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&s : create_array({u"three old rotators"_S, u"never reverse"_S, u"stable was I ere I saw elbatrosses"_S, u"abracadabra"_S, u"drome"_S, u"the abbatial palace"_S}))
            print(u"'"_S & s & u"' -> '"_S & longest_palindrome(s) & u"'"_S);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Loop_over_multiple_arrays_simultaneously#Python
for x, y, z in zip('abc', 'ABC', '123'):
    print(x, y, z, sep = '')
===
L(x, y, z) zip(‘abc’, ‘ABC’, ‘123’)
   print(x‘’y‘’z)
===
struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&[x, y, z] : zip(u"abc"_S, u"ABC"_S, u"123"_S))
            print(x & y & z);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Loops/Continue#Python
for i in range(1, 11):
    if i % 5 == 0:
        print(i)
        continue
    print(i, end = ', ')
===
L(i) 1..10
   I i % 5 == 0
      print(i)
      L.continue
   print(i, end' ‘, ’)
===
struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto i : range_ee(1, 10)) {
            if (mod(i, 5) == 0) {
                print(i);
                continue;
            }
            print(i, u", "_S);
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Loops/Do-while#Python
val = 0
while True:
   val += 1
   print(val)
   if val % 6 == 0: break
===
V val = 0
L
   val++
   print(val)
   I val % 6 == 0
      L.break
===
auto val = 0;

struct CodeBlock1
{
    CodeBlock1()
    {
        while (true) {
            val++;
            print(val);
            if (mod(val, 6) == 0)
                break;
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Loops/Downward_for#Python
for i in range(10, -1, -1):
    print(i)
===
L(i) (10 .< -1).step(-1)
   print(i)
===
struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto i : range_el(10, -1).step(-1))
            print(i);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Loops/For#Python
for i in range(1, 6):
    for j in range(i):
        print("*", end = '')
    print()
===
L(i) 1..5
   L(j) 0 .< i
      print(‘*’, end' ‘’)
   print()
===
struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto i : range_ee(1, 5)) {
            for (auto j : range_el(0, i))
                print(u"*"_S, u""_S);
            print();
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Loops/For#Python
for i in range(1, 6):
    print('*' * i)
===
L(i) 1..5
   print(‘*’ * i)
===
struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto i : range_ee(1, 5))
            print(u"*"_S * i);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Loops/For_with_a_specified_step
for i in range(1, 10, 2):
    print(i)
===
L(i) (1.<10).step(2)
   print(i)
===
struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto i : range_el(1, 10).step(2))
            print(i);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Loops/Foreach#C.23
things = ["Apple", "Banana", "Coconut"]

for thing in things:
    print(thing)
===
V things = [‘Apple’, ‘Banana’, ‘Coconut’]

L(thing) things
   print(thing)
===
auto things = create_array({u"Apple"_S, u"Banana"_S, u"Coconut"_S});

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&thing : things)
            print(thing);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Loops/Increment_loop_index_within_loop_body#Python
Int64 = int

def is_prime(n):
    for x in (2, 3):
        if n % x == 0:
            return n == x
    d = Int64(5)
    while d * d <= n:
        for x in (2, 4):
            if n % d == 0:
                return False
            d += x
    return True

i = Int64(42)
n = 0
while n < 42:
    if is_prime(i):
        n += 1
        print('n = %2d %16d' % (n, i))
        i += i - 1
    i += 1
===
F is_prime(n)
   L(x) (2, 3)
      I n % x == 0
         R n == x
   V d = Int64(5)
   L d * d <= n
      L(x) (2, 4)
         I n % d == 0
            R 0B
         d += x
   R 1B

V i = Int64(42)
V n = 0
L n < 42
   I is_prime(i)
      n++
      print(‘n = #2 #16’.format(n, i))
      i += i - 1
   i++
===
template <typename T1> auto is_prime(const T1 &n)
{
    for (auto &&x : make_tuple(2, 3))
        if (mod(n, x) == 0)
            return n == x;
    auto d = to_int64(5);
    while (d * d <= n)
        for (auto &&x : make_tuple(2, 4)) {
            if (mod(n, d) == 0)
                return false;
            d += x;
        }
    return true;
}

auto i = to_int64(42);
auto n = 0;

struct CodeBlock1
{
    CodeBlock1()
    {
        while (n < 42) {
            if (is_prime(i)) {
                n++;
                print(u"n = #2 #16"_S.format(n, i));
                i += i - 1;
            }
            i++;
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Loops/While#Python
n = 1024
while n > 0:
    print(n)
    n //= 2
===
V n = 1024
L n > 0
   print(n)
   n I/= 2
===
auto n = 1024;

struct CodeBlock1
{
    CodeBlock1()
    {
        while (n > 0) {
            print(n);
            n = idiv(n, 2);
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Ludic_numbers#Python
def ludic(nmax=100000):
    r = [1]
    lst = list(range(2, nmax + 1))
    while len(lst):
        r.append(lst[0])
        newlst : List[int] = []
        step = lst[0]
        for i in range(len(lst)):
            if i % step != 0:
                newlst.append(lst[i])
        lst = newlst
    return r

ludics = [l for l in ludic()]

print('First 25 ludic primes:')
print(ludics[:25])
print("\nThere are %i ludic numbers <= 1000"
      % sum(1 for l in ludics if l <= 1000))
print("\n2000'th..2005'th ludic primes:")
print(ludics[2000-1: 2005])

n = 250
triplets = [(x, x+2, x+6)
            for x in ludics
            if x+6 < n and x+2 in ludics and x+6 in ludics]
print('\nThere are %i triplets less than %i:\n  %s'
      % (len(triplets), n, triplets))
===
F ludic(nmax = 100000)
   V r = [1]
   V lst = Array(2 .. nmax)
   L !lst.empty
      r.append(lst[0])
      [Int] newlst
      V step = lst[0]
      L(i) 0 .< lst.len
         I i % step != 0
            newlst.append(lst[i])
      lst = newlst
   R r

V ludics = ludic()

print(‘First 25 ludic primes:’)
print(ludics[0.<25])
print("\nThere are #. ludic numbers <= 1000".format(sum(ludics.filter(l -> l <= 1000).map(l -> 1))))
print("\n2000'th..2005'th ludic primes:")
print(ludics[2000 - 1 .< 2005])

V n = 250
V triplets = ludics.filter(x -> x + 6 < :n & x + 2 C :ludics & x + 6 C :ludics).map(x -> (x, x + 2, x + 6))
print("\nThere are #. triplets less than #.:\n  #.".format(triplets.len, n, triplets))
===
template <typename T1 = decltype(100000)> auto ludic(const T1 &nmax = 100000)
{
    auto r = create_array({1});
    auto lst = create_array(range_ee(2, nmax));
    while (!lst.empty()) {
        r.append(_get<0>(lst));
        Array<int> newlst;
        auto step = _get<0>(lst);
        for (auto i : range_el(0, lst.len()))
            if (mod(i, step) != 0)
                newlst.append(lst[i]);
        lst = newlst;
    }
    return r;
}

auto ludics = ludic();

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"First 25 ludic primes:"_S);
        print(ludics[range_el(0, 25)]);
        print(u"\nThere are #. ludic numbers <= 1000"_S.format(sum_map(ludics.filter([](const auto &l){return l <= 1000;}), [](const auto &l){return 1;})));
        print(u"\n2000'th..2005'th ludic primes:"_S);
        print(ludics[range_el(2000 - 1, 2005)]);
    }
} code_block_1;

auto n = 250;
auto triplets = ludics.filter([](const auto &x){return x + 6 < ::n && in(x + 2, ::ludics) && in(x + 6, ::ludics);}).map([](const auto &x){return make_tuple(x, x + 2, x + 6);});

struct CodeBlock2
{
    CodeBlock2()
    {
        print(u"\nThere are #. triplets less than #.:\n  #."_S.format(triplets.len(), n, triplets));
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Luhn_test_of_credit_card_numbers#Python
def luhn(n):
    ch = str(n)
    sum = 0
    chParity = len(ch) % 2
    for i in range(len(ch)-1, -1, -1):
        j = int(ch[i])
        if (i + 1) % 2 != chParity:
            j *= 2
            if j > 9:
                j -= 9
        sum += j
    return sum % 10 == 0

for n in (49927398716,
          49927398717,
          1234567812345678,
          1234567812345670):
    print(luhn(n))
===
F luhn(n)
   V ch = String(n)
   V sum = 0
   V chParity = ch.len % 2
   L(i) (ch.len - 1 .< -1).step(-1)
      V j = Int(ch[i])
      I (i + 1) % 2 != chParity
         j *= 2
         I j > 9
            j -= 9
      sum += j
   R sum % 10 == 0

L(n) (49927398716, 49927398717, 1234567812345678, 1234567812345670)
   print(luhn(n))
===
template <typename T1> auto luhn(const T1 &n)
{
    auto ch = String(n);
    auto sum = 0;
    auto chParity = mod(ch.len(), 2);
    for (auto i : range_el(ch.len() - 1, -1).step(-1)) {
        auto j = to_int(ch[i]);
        if (mod((i + 1), 2) != chParity) {
            j *= 2;
            if (j > 9)
                j -= 9;
        }
        sum += j;
    }
    return mod(sum, 10) == 0;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&n : make_tuple(49927398716, 49927398717, 1234567812345678, 1234567812345670))
            print(luhn(n));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Left_factorials#D
BigInt = int

def left_fact(n):
    result : BigInt = 0
    factorial : BigInt = 1
    for i in range(1, n + 1):
        result += factorial
        factorial *= i
    return result

print("First 11 left factorials:")
print([left_fact(i) for i in range(11)])
print("\n20 through 110 (inclusive) by tens:")
for i in range(20, 111, 10):
    print(left_fact(i))
print("\nDigits in 1,000 through 10,000 by thousands:")
print([len(str(left_fact(i))) for i in range(1000, 10001, 1000)])
===
F left_fact(n)
   BigInt result = 0
   BigInt factorial = 1
   L(i) 1 .. n
      result += factorial
      factorial *= i
   R result

print(‘First 11 left factorials:’)
print((0.<11).map(i -> left_fact(i)))
print("\n20 through 110 (inclusive) by tens:")
L(i) (20.<111).step(10)
   print(left_fact(i))
print("\nDigits in 1,000 through 10,000 by thousands:")
print((1000.<10001).step(1000).map(i -> String(left_fact(i)).len))
===
template <typename T1> auto left_fact(const T1 &n)
{
    BigInt result = 0;
    BigInt factorial = 1;
    for (auto i : range_ee(1, n)) {
        result += factorial;
        factorial *= i;
    }
    return result;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"First 11 left factorials:"_S);
        print(range_el(0, 11).map([](const auto &i){return left_fact(i);}));
        print(u"\n20 through 110 (inclusive) by tens:"_S);
        for (auto i : range_el(20, 111).step(10))
            print(left_fact(i));
        print(u"\nDigits in 1,000 through 10,000 by thousands:"_S);
        print(range_el(1000, 10001).step(1000).map([](const auto &i){return String(left_fact(i)).len();}));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Lychrel_numbers#D
from typing import Dict, Tuple, List
BigInt = int

def rev(n):
    return BigInt(str(n)[::-1])

cache : Dict[BigInt, Tuple[bool, BigInt]] = {}

def lychrel(n : BigInt):
    if n in cache:
        return cache[n]

    r = rev(n)
    res = (True, n)
    seen : List[BigInt] = []
    for i in range(1000):
        n += r
        r = rev(n)
        if n == r:
            res = (False, BigInt(0))
            break
        if n in cache:
            res = cache[n]
            break
        seen += [n]

    for x in seen:
        cache[x] = res
    return res

seeds : List[int] = []
related : List[int] = []
palin : List[int] = []

for i in range(1, 10000):
    tf_s = lychrel(i)
    if not tf_s[0]:
        continue
    if BigInt(i) == tf_s[1]:
        seeds += [i]
    else:
        related += [i]
    if BigInt(i) == rev(i):
        palin += [i]

print(len(seeds), 'Lychrel seeds:', seeds)
print(len(related), 'Lychrel related')
print(len(palin), 'Lychrel palindromes:', palin)
===
F rev(n)
   R BigInt(reversed(String(n)))

[BigInt = (Bool, BigInt)] cache

F lychrel(BigInt =n)
   I n C :cache
      R :cache[n]

   V r = rev(n)
   V res = (1B, n)
   [BigInt] seen
   L(i) 1000
      n += r
      r = rev(n)
      I n == r
         res = (0B, BigInt(0))
         L.break
      I n C :cache
         res = :cache[n]
         L.break
      seen [+]= n

   L(x) seen
      :cache[x] = res
   R res

[Int] seeds
[Int] related
[Int] palin

L(i) 1..9999
   V tf_s = lychrel(i)
   I !tf_s[0]
      L.continue
   I BigInt(i) == tf_s[1]
      seeds [+]= i
   E
      related [+]= i
   I BigInt(i) == rev(i)
      palin [+]= i

print(seeds.len‘ Lychrel seeds: ’seeds)
print(related.len‘ Lychrel related’)
print(palin.len‘ Lychrel palindromes: ’palin)
===
template <typename T1> auto rev(const T1 &n)
{
    return BigInt(reversed(String(n)));
}

Dict<BigInt, Tuple<bool, BigInt>> cache;

auto lychrel(BigInt n)
{
    if (in(n, ::cache))
        return ::cache[n];

    auto r = rev(n);
    auto res = make_tuple(true, n);
    Array<BigInt> seen;
    for (int i = 0; i < 1000; i++) {
        n += r;
        r = rev(n);
        if (n == r) {
            res = make_tuple(false, BigInt(0));
            break;
        }
        if (in(n, ::cache)) {
            res = ::cache[n];
            break;
        }
        seen.append(n);
    }

    for (auto &&x : seen)
        ::cache.set(x, res);
    return res;
}

Array<int> seeds;
Array<int> related;
Array<int> palin;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto i : range_ee(1, 9999)) {
            auto tf_s = lychrel(i);
            if (!_get<0>(tf_s))
                continue;
            if (BigInt(i) == _get<1>(tf_s))
                seeds.append(i);
            else
                related.append(i);
            if (BigInt(i) == rev(i))
                palin.append(i);
        }

        print(seeds.len() & u" Lychrel seeds: "_S & seeds);
        print(related.len() & u" Lychrel related"_S);
        print(palin.len() & u" Lychrel palindromes: "_S & palin);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Latin_Squares_in_reduced_form#Python
import math

def dList(n, start):
    start -= 1 # use 0 basing
    a = list(range(n))
    a[start] = a[0]
    a[0] = start
    a[1:] = sorted(a[1:])
    first = a[1]
    # rescursive closure permutes a[1:]
    r : List[List[int]] = []
    def recurse(last : int) -> None:
        if (last == first):
            # bottom of recursion. you get here once for each permutation.
            # test if permutation is deranged.
            # yes, save a copy with 1 based indexing
            for j,v in enumerate(a[1:]):
                if j + 1 == v:
                    return # no, ignore it
            b = [x + 1 for x in a]
            r.append(b)
            return
        for i in range(last, 0, -1):
            (a[i], a[last]) = (a[last], a[i])
            recurse(last - 1)
            (a[i], a[last]) = (a[last], a[i])
    recurse(n - 1)
    return r

def printSquare(latin,n):
    for row in latin:
        print(row)
    print()

def reducedLatinSquares(n,echo):
    if n <= 0:
        if echo:
            print('[]')
        return 0
    elif n == 1:
        if echo:
            print([1])
        return 1

    rlatin  = [[0] * n for i in range(n)]
    # first row
    for j in range(0, n):
        rlatin[0][j] = j + 1

    count = 0
    def recurse(i : int) -> None:
        nonlocal count

        rows = dList(n, i)

        for r in range(len(rows)):
            rlatin[i - 1] = rows[r]
            justContinue = False
            k = 0
            while not justContinue and k < i - 1:
                for j in range(1, n):
                    if rlatin[k][j] == rlatin[i - 1][j]:
                        if r < len(rows) - 1:
                            justContinue = True
                            break
                        if i > 2:
                            return
                k += 1
            if not justContinue:
                if i < n:
                    recurse(i + 1)
                else:
                    count += 1
                    if echo:
                        printSquare(rlatin, n)

    # remaining rows
    recurse(2)
    return count

print("The four reduced latin squares of order 4 are:\n")
reducedLatinSquares(4,True)

print("The size of the set of reduced latin squares for the following orders")
print("and hence the total number of latin squares of these orders are:\n")
for n in range(1, 7):
    size = reducedLatinSquares(n, False)
    f = math.factorial(n - 1)
    f *= f * n * size
    print("Order %d: Size %-4d x %d! x %d! => Total %d" % (n, size, n, n - 1, f))
===
F dList(n, =start)
   start--
   V a = Array(0 .< n)
   a[start] = a[0]
   a[0] = start
   a.sort_range(1..)
   V first = a[1]
   [[Int]] r
   F recurse(Int last) -> N
      I (last == @first)
         L(v) @a[1..]
            V j = L.index
            I j + 1 == v
               R
         V b = @a.map(x -> x + 1)
         @r.append(b)
         R
      L(i) (last .< 0).step(-1)
         swap(&@a[i], &@a[last])
         @recurse(last - 1)
         swap(&@a[i], &@a[last])
   recurse(n - 1)
   R r

F printSquare(latin, n)
   L(row) latin
      print(row)
   print()

F reducedLatinSquares(n, echo)
   I n <= 0
      I echo
         print(‘[]’)
      R 0
   E I n == 1
      I echo
         print([1])
      R 1

   V rlatin = [[0] * n] * n
   L(j) 0 .< n
      rlatin[0][j] = j + 1

   V count = 0
   F recurse(Int i) -> N

      V rows = dList(@n, i)

      L(r) 0 .< rows.len
         @rlatin[i - 1] = rows[r]
         V justContinue = 0B
         V k = 0
         L !justContinue & k < i - 1
            L(j) 1 .< @n
               I @rlatin[k][j] == @rlatin[i - 1][j]
                  I r < rows.len - 1
                     justContinue = 1B
                     L.break
                  I i > 2
                     R
            k++
         I !justContinue
            I i < @n
               @recurse(i + 1)
            E
               @count++
               I @echo
                  printSquare(@rlatin, @n)

   recurse(2)
   R count

print("The four reduced latin squares of order 4 are:\n")
reducedLatinSquares(4, 1B)

print(‘The size of the set of reduced latin squares for the following orders’)
print("and hence the total number of latin squares of these orders are:\n")
L(n) 1..6
   V size = reducedLatinSquares(n, 0B)
   V f = factorial(n - 1)
   f *= f * n * size
   print(‘Order #.: Size #<4 x #.! x #.! => Total #.’.format(n, size, n, n - 1, f))
===
template <typename T1, typename T2> auto dList(const T1 &n, T2 start)
{
    start--;
    auto a = create_array(range_el(0, n));
    a.set(start, _get<0>(a));
    _set<0>(a, start);
    a.sort_range(range_ei(1));
    auto first = _get<1>(a);
    Array<Array<int>> r;
    std::function<void(int)> recurse = [&a, &first, &r, &recurse](const int last) -> void
    {
        if ((last == first)) {
            {int Lindex = 0;
            for (auto &&v : a[range_ei(1)]) {
                auto j = Lindex;
                if (j + 1 == v)
                    return;
                Lindex++;
            }}
            auto b = a.map([](const auto &x){return x + 1;});
            r.append(b);
            return;
        }
        for (auto i : range_el(last, 0).step(-1)) {
            swap(a[i], a[last]);
            recurse(last - 1);
            swap(a[i], a[last]);
        }
    };
    recurse(n - 1);
    return r;
}

template <typename T1, typename T2> auto printSquare(const T1 &latin, const T2 &n)
{
    for (auto &&row : latin)
        print(row);
    print();
}

template <typename T1, typename T2> auto reducedLatinSquares(const T1 &n, const T2 &echo)
{
    if (n <= 0) {
        if (echo)
            print(u"[]"_S);
        return 0;
    }
    else if (n == 1) {
        if (echo)
            print(create_array({1}));
        return 1;
    }

    auto rlatin = create_array({create_array({0}) * n}) * n;
    for (auto j : range_el(0, n))
        _get<0>(rlatin).set(j, j + 1);

    auto count = 0;
    std::function<void(int)> recurse = [&count, &echo, &n, &recurse, &rlatin](const int i) -> void
    {

        auto rows = dList(n, i);

        for (auto r : range_el(0, rows.len())) {
            rlatin.set(i - 1, rows[r]);
            auto justContinue = false;
            auto k = 0;
            while (!justContinue && k < i - 1) {
                for (auto j : range_el(1, n))
                    if (rlatin[k][j] == rlatin[i - 1][j]) {
                        if (r < rows.len() - 1) {
                            justContinue = true;
                            break;
                        }
                        if (i > 2)
                            return;
                    }
                k++;
            }
            if (!justContinue) {
                if (i < n)
                    recurse(i + 1);
                else {
                    count++;
                    if (echo)
                        printSquare(rlatin, n);
                }
            }
        }
    };

    recurse(2);
    return count;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"The four reduced latin squares of order 4 are:\n"_S);
        reducedLatinSquares(4, true);

        print(u"The size of the set of reduced latin squares for the following orders"_S);
        print(u"and hence the total number of latin squares of these orders are:\n"_S);
        for (auto n : range_ee(1, 6)) {
            auto size = reducedLatinSquares(n, false);
            auto f = factorial(n - 1);
            f *= f * n * size;
            print(u"Order #.: Size #<4 x #.! x #.! => Total #."_S.format(n, size, n, n - 1, f));
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Logistic_curve_fitting_in_epidemiology#C.2B.2B
import math

K = 7.8e9
n0 = 27
actual = [
    27, 27, 27, 44, 44, 59, 59, 59, 59, 59, 59, 59, 59, 60, 60,
    61, 61, 66, 83, 219, 239, 392, 534, 631, 897, 1350, 2023, 2820,
    4587, 6067, 7823, 9826, 11946, 14554, 17372, 20615, 24522, 28273,
    31491, 34933, 37552, 40540, 43105, 45177, 60328, 64543, 67103,
    69265, 71332, 73327, 75191, 75723, 76719, 77804, 78812, 79339,
    80132, 80995, 82101, 83365, 85203, 87024, 89068, 90664, 93077,
    95316, 98172, 102133, 105824, 109695, 114232, 118610, 125497,
    133852, 143227, 151367, 167418, 180096, 194836, 213150, 242364,
    271106, 305117, 338133, 377918, 416845, 468049, 527767, 591704,
    656866, 715353, 777796, 851308, 928436, 1000249, 1082054, 1174652
]

def f(r : float) -> float:
    sq = 0.0
    for i, act in enumerate(actual):
        eri = math.exp(r * i)
        guess = (n0 * eri)/(1 + n0 * (eri - 1)/K)
        diff = guess - act
        sq += diff * diff
    return sq

def solve(func, guess = 0.5, epsilon = 0.0):
    delta = guess if guess != 0 else 1
    f0 = func(guess)
    factor = 2.0
    while delta > epsilon and guess != guess - delta:
        nf = func(guess - delta)
        if nf < f0:
            f0 = nf
            guess -= delta
        else:
            nf = func(guess + delta)
            if nf < f0:
                f0 = nf
                guess += delta
            else:
                factor = 0.5
        delta *= factor
    return guess

r = solve(f)
R0 = math.exp(12 * r)
print('r = %f, R0 = %f' % (r, R0))
===
V K = 7.8e9
V n0 = 27
V actual = [27, 27, 27, 44, 44, 59, 59, 59, 59, 59, 59, 59, 59, 60, 60, 61, 61, 66, 83, 219, 239, 392, 534, 631, 897, 1350, 2023, 2820, 4587, 6067, 7823, 9826, 11946, 14554, 17372, 20615, 24522, 28273, 31491, 34933, 37552, 40540, 43105, 45177, 60328, 64543, 67103, 69265, 71332, 73327, 75191, 75723, 76719, 77804, 78812, 79339, 80132, 80995, 82101, 83365, 85203, 87024, 89068, 90664, 93077, 95316, 98172, 102133, 105824, 109695, 114232, 118610, 125497, 133852, 143227, 151367, 167418, 180096, 194836, 213150, 242364, 271106, 305117, 338133, 377918, 416845, 468049, 527767, 591704, 656866, 715353, 777796, 851308, 928436, 1000249, 1082054, 1174652]

F f(Float r) -> Float
   V sq = 0.0
   L(act) :actual
      V i = L.index
      V eri = exp(r * i)
      V guess = (:n0 * eri) / (1 + :n0 * (eri - 1) / :K)
      V diff = guess - act
      sq += diff * diff
   R sq

F solve(func, =guess = 0.5, epsilon = 0.0)
   V delta = I guess != 0 {guess} E 1
   V f0 = func(guess)
   V factor = 2.0
   L delta > epsilon & guess != guess - delta
      V nf = func(guess - delta)
      I nf < f0
         f0 = nf
         guess -= delta
      E
         nf = func(guess + delta)
         I nf < f0
            f0 = nf
            guess += delta
         E
            factor = 0.5
      delta *= factor
   R guess

V r = solve(f)
V R0 = exp(12 * r)
print(‘r = #.6, R0 = #.6’.format(r, R0))
===
auto K = 7.8e9;
auto n0 = 27;
auto actual = create_array({27, 27, 27, 44, 44, 59, 59, 59, 59, 59, 59, 59, 59, 60, 60, 61, 61, 66, 83, 219, 239, 392, 534, 631, 897, 1350, 2023, 2820, 4587, 6067, 7823, 9826, 11946, 14554, 17372, 20615, 24522, 28273, 31491, 34933, 37552, 40540, 43105, 45177, 60328, 64543, 67103, 69265, 71332, 73327, 75191, 75723, 76719, 77804, 78812, 79339, 80132, 80995, 82101, 83365, 85203, 87024, 89068, 90664, 93077, 95316, 98172, 102133, 105824, 109695, 114232, 118610, 125497, 133852, 143227, 151367, 167418, 180096, 194836, 213150, 242364, 271106, 305117, 338133, 377918, 416845, 468049, 527767, 591704, 656866, 715353, 777796, 851308, 928436, 1000249, 1082054, 1174652});

double f(const double r)
{
    auto sq = 0.0;
    {int Lindex = 0;
    for (auto &&act : ::actual) {
        auto i = Lindex;
        auto eri = exp(r * i);
        auto guess = (::n0 * eri) / (1 + ::n0 * (eri - 1) / ::K);
        auto diff = guess - act;
        sq += diff * diff;
        Lindex++;
    }}
    return sq;
}

template <typename T1, typename T2 = decltype(0.5), typename T3 = decltype(0.0)> auto solve(const T1 &func, T2 guess = 0.5, const T3 &epsilon = 0.0)
{
    auto delta = guess != 0 ? guess : 1;
    auto f0 = func(guess);
    auto factor = 2.0;
    while (delta > epsilon && guess != guess - delta) {
        auto nf = func(guess - delta);
        if (nf < f0) {
            f0 = nf;
            guess -= delta;
        }
        else {
            nf = func(guess + delta);
            if (nf < f0) {
                f0 = nf;
                guess += delta;
            }
            else
                factor = 0.5;
        }
        delta *= factor;
    }
    return guess;
}

auto r = solve(f);
auto R0 = exp(12 * r);

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"r = #.6, R0 = #.6"_S.format(r, R0));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/LU_decomposition#Python
def pprint(m):
    for row in m:
        print(row)

def matrix_mul(a, b):
    result = [[0.0]*len(a) for i in range(len(a))]
    for j in range(len(a)):
        for i in range(len(a)):
            r = 0.0
            for k in range(len(a)):
                r += a[i][k] * b[k][j]
            result[i][j] = r
    return result

def pivotize(m):
    """Creates the pivoting matrix for m."""
    n = len(m)
    ID = [[float(i == j) for i in range(n)] for j in range(n)]
    for j in range(n):
        row = max(range(j, n), key=lambda i: abs(m[i][j]))
        if j != row:
            (ID[j], ID[row]) = (ID[row], ID[j])
    return ID

def lu(A):
    """Decomposes a nxn matrix A by PA=lU and returns l, U and P."""
    n = len(A)
    l = [[0.0] * n for i in range(n)]
    U = [[0.0] * n for i in range(n)]
    P = pivotize(A)
    A2 = matrix_mul(P, A)
    for j in range(n):
        l[j][j] = 1.0
        for i in range(j+1):
            s1 = sum(U[k][j] * l[i][k] for k in range(i))
            U[i][j] = A2[i][j] - s1
        for i in range(j, n):
            s2 = sum(U[k][j] * l[i][k] for k in range(j))
            l[i][j] = (A2[i][j] - s2) / U[j][j]
    return (l, U, P)

a = [[1, 3, 5], [2, 4, 7], [1, 1, 0]]
for part in lu(a):
    pprint(part)
    print()
print()
b = [[11,9,24,2],[1,5,2,6],[3,17,18,1],[2,5,7,1]]
for part in lu(b):
    pprint(part)
    print()
===
F pprint(m)
   L(row) m
      print(row)

F matrix_mul(a, b)
   V result = [[0.0] * a.len] * a.len
   L(j) 0 .< a.len
      L(i) 0 .< a.len
         V r = 0.0
         L(k) 0 .< a.len
            r += a[i][k] * b[k][j]
         result[i][j] = r
   R result

F pivotize(m)
   ‘Creates the pivoting matrix for m.’
   V n = m.len
   V ID = (0 .< n).map(j -> (0 .< @n).map(i -> Float(i == @j)))
   L(j) 0 .< n
      V row = max(j .< n, key' i -> abs(@m[i][@j]))
      I j != row
         swap(&ID[j], &ID[row])
   R ID

F lu(A)
   ‘Decomposes a nxn matrix A by PA=lU and returns l, U and P.’
   V n = A.len
   V l = [[0.0] * n] * n
   V U = [[0.0] * n] * n
   V P = pivotize(A)
   V A2 = matrix_mul(P, A)
   L(j) 0 .< n
      l[j][j] = 1.0
      L(i) 0 .. j
         V s1 = sum((0 .< i).map(k -> @U[k][@j] * @l[@i][k]))
         U[i][j] = A2[i][j] - s1
      L(i) j .< n
         V s2 = sum((0 .< j).map(k -> @U[k][@j] * @l[@i][k]))
         l[i][j] = (A2[i][j] - s2) / U[j][j]
   R (l, U, P)

V a = [[1, 3, 5], [2, 4, 7], [1, 1, 0]]
L(part) lu(a)
   pprint(part)
   print()
print()
V b = [[11, 9, 24, 2], [1, 5, 2, 6], [3, 17, 18, 1], [2, 5, 7, 1]]
L(part) lu(b)
   pprint(part)
   print()
===
template <typename T1> auto pprint(const T1 &m)
{
    for (auto &&row : m)
        print(row);
}

template <typename T1, typename T2> auto matrix_mul(const T1 &a, const T2 &b)
{
    auto result = create_array({create_array({0.0}) * a.len()}) * a.len();
    for (auto j : range_el(0, a.len()))
        for (auto i : range_el(0, a.len())) {
            auto r = 0.0;
            for (auto k : range_el(0, a.len()))
                r += a[i][k] * b[k][j];
            result[i].set(j, r);
        }
    return result;
}

template <typename T1> auto pivotize(const T1 &m)
{
    u"Creates the pivoting matrix for m."_S;
    auto n = m.len();
    auto ID = range_el(0, n).map([&n](const auto &j){return range_el(0, n).map([&j](const auto &i){return to_float(i == j);});});
    for (auto j : range_el(0, n)) {
        auto row = max_with_key(range_el(j, n), [&j, &m](const auto &i){return abs(m[i][j]);});
        if (j != row)
            swap(ID[j], ID[row]);
    }
    return ID;
}

template <typename T1> auto lu(const T1 &A)
{
    u"Decomposes a nxn matrix A by PA=lU and returns l, U and P."_S;
    auto n = A.len();
    auto l = create_array({create_array({0.0}) * n}) * n;
    auto U = create_array({create_array({0.0}) * n}) * n;
    auto P = pivotize(A);
    auto A2 = matrix_mul(P, A);
    for (auto j : range_el(0, n)) {
        l[j].set(j, 1.0);
        for (auto i : range_ee(0, j)) {
            auto s1 = sum_map(range_el(0, i), [&U, &i, &j, &l](const auto &k){return U[k][j] * l[i][k];});
            U[i].set(j, A2[i][j] - s1);
        }
        for (auto i : range_el(j, n)) {
            auto s2 = sum_map(range_el(0, j), [&U, &i, &j, &l](const auto &k){return U[k][j] * l[i][k];});
            l[i].set(j, (A2[i][j] - s2) / U[j][j]);
        }
    }
    return make_tuple(l, U, P);
}

auto a = create_array({create_array({1, 3, 5}), create_array({2, 4, 7}), create_array({1, 1, 0})});

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&part : lu(a)) {
            pprint(part);
            print();
        }
        print();
    }
} code_block_1;

auto b = create_array({create_array({11, 9, 24, 2}), create_array({1, 5, 2, 6}), create_array({3, 17, 18, 1}), create_array({2, 5, 7, 1})});

struct CodeBlock2
{
    CodeBlock2()
    {
        for (auto &&part : lu(b)) {
            pprint(part);
            print();
        }
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Largest_proper_divisor_of_n#Python
def lpd(n):
    for i in range(n-1,0,-1):
        if n%i==0: return i
    return 1

for i in range(1,101):
    print("{:3}".format(lpd(i)), end="\n" if i%10==0 else '')
===
F lpd(n)
   L(i) (n - 1 .< 0).step(-1)
      I n % i == 0
         R i
   R 1

L(i) 1..100
   print(‘#3’.format(lpd(i)), end' I i % 10 == 0 {"\n"} E ‘’)
===
template <typename T1> auto lpd(const T1 &n)
{
    for (auto i : range_el(n - 1, 0).step(-1))
        if (mod(n, i) == 0)
            return i;
    return 1;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto i : range_ee(1, 100))
            print(u"#3"_S.format(lpd(i)), mod(i, 10) == 0 ? u"\n"_S : u""_S);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Levenshtein_distance/Alignment#Nim
def levenshteinAlign(aa, bb):
    a = aa.lower()
    b = bb.lower()
    costs = [[0] * (len(b) + 1) for i in range(len(a) + 1)]
    for j in range(len(b) + 1): costs[0][j] = j
    for i in range(1, len(a) + 1):
        costs[i][0] = i
        for j in range(1, len(b) + 1):
            tmp = costs[i - 1][j - 1] + int(a[i - 1] != b[j - 1])
            costs[i][j] = min(1 + min(costs[i - 1][j], costs[i][j - 1]), tmp)

    # Walk back through matrix to figure out path.
    aPathRev = ''
    bPathRev = ''
    i = len(a)
    j = len(b)
    while i != 0 and j != 0:
        tmp = costs[i - 1][j - 1] + int(a[i - 1] != b[j - 1])
        if costs[i][j] == tmp:
            i -= 1
            j -= 1
            aPathRev += a[i]
            bPathRev += b[j]
        elif costs[i][j] == 1 + costs[i-1][j]:
            i -= 1
            aPathRev += a[i]
            bPathRev += '-'
        elif costs[i][j] == 1 + costs[i][j-1]:
            j -= 1
            aPathRev += '-'
            bPathRev += b[j]
        else:
            assert False, "Internal error"

    return (aPathRev[::-1], bPathRev[::-1])

result = levenshteinAlign("place", "palace")
print(result[0])
print(result[1])
print()

result = levenshteinAlign("rosettacode","raisethysword")
print(result[0])
print(result[1])
===
F levenshteinAlign(aa, bb)
   V a = aa.lowercase()
   V b = bb.lowercase()
   V costs = [[0] * (b.len + 1)] * (a.len + 1)
   L(j) 0 .. b.len
      costs[0][j] = j
   L(i) 1 .. a.len
      costs[i][0] = i
      L(j) 1 .. b.len
         V tmp = costs[i - 1][j - 1] + Int(a[i - 1] != b[j - 1])
         costs[i][j] = min(1 + min(costs[i - 1][j], costs[i][j - 1]), tmp)

   V aPathRev = ‘’
   V bPathRev = ‘’
   V i = a.len
   V j = b.len
   L i != 0 & j != 0
      V tmp = costs[i - 1][j - 1] + Int(a[i - 1] != b[j - 1])
      I costs[i][j] == tmp
         i--
         j--
         aPathRev ‘’= a[i]
         bPathRev ‘’= b[j]
      E I costs[i][j] == 1 + costs[i - 1][j]
         i--
         aPathRev ‘’= a[i]
         bPathRev ‘’= ‘-’
      E I costs[i][j] == 1 + costs[i][j - 1]
         j--
         aPathRev ‘’= ‘-’
         bPathRev ‘’= b[j]
      E
         assert(0B, ‘Internal error’)

   R (reversed(aPathRev), reversed(bPathRev))

V result = levenshteinAlign(‘place’, ‘palace’)
print(result[0])
print(result[1])
print()

result = levenshteinAlign(‘rosettacode’, ‘raisethysword’)
print(result[0])
print(result[1])
===
template <typename T1, typename T2> auto levenshteinAlign(const T1 &aa, const T2 &bb)
{
    auto a = aa.lowercase();
    auto b = bb.lowercase();
    auto costs = create_array({create_array({0}) * (b.len() + 1)}) * (a.len() + 1);
    for (auto j : range_ee(0, b.len()))
        _get<0>(costs).set(j, j);
    for (auto i : range_ee(1, a.len())) {
        _set<0>(costs[i], i);
        for (auto j : range_ee(1, b.len())) {
            auto tmp = costs[i - 1][j - 1] + to_int(a[i - 1] != b[j - 1]);
            costs[i].set(j, min(1 + min(costs[i - 1][j], costs[i][j - 1]), tmp));
        }
    }

    auto aPathRev = u""_S;
    auto bPathRev = u""_S;
    auto i = a.len();
    auto j = b.len();
    while (i != 0 && j != 0) {
        auto tmp = costs[i - 1][j - 1] + to_int(a[i - 1] != b[j - 1]);
        if (costs[i][j] == tmp) {
            i--;
            j--;
            aPathRev &= a[i];
            bPathRev &= b[j];
        }
        else if (costs[i][j] == 1 + costs[i - 1][j]) {
            i--;
            aPathRev &= a[i];
            bPathRev &= u"-"_S;
        }
        else if (costs[i][j] == 1 + costs[i][j - 1]) {
            j--;
            aPathRev &= u"-"_S;
            bPathRev &= b[j];
        }
        else
            assert(false, u"Internal error"_S);
    }

    return make_tuple(reversed(aPathRev), reversed(bPathRev));
}

auto result = levenshteinAlign(u"place"_S, u"palace"_S);

struct CodeBlock1
{
    CodeBlock1()
    {
        print(_get<0>(result));
        print(_get<1>(result));
        print();

        result = levenshteinAlign(u"rosettacode"_S, u"raisethysword"_S);
        print(_get<0>(result));
        print(_get<1>(result));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Long_literals,_with_continuations#Python
revdate = "2021-11-14"

elements = \
    "hydrogen helium lithium beryllium boron carbon nitrogen oxygen fluorine " + \
    "neon sodium magnesium aluminum silicon phosphorous sulfur chlorine argon " + \
    "potassium calcium scandium titanium vanadium chromium manganese iron " + \
    "cobalt nickel copper zinc gallium germanium arsenic selenium bromine " + \
    "krypton rubidium strontium yttrium zirconium niobium molybdenum " + \
    "technetium ruthenium rhodium palladium silver cadmium indium tin " + \
    "antimony tellurium iodine xenon cesium barium lanthanum cerium " + \
    "praseodymium neodymium promethium samarium europium gadolinium terbium " + \
    "dysprosium holmium erbium thulium ytterbium lutetium hafnium tantalum " + \
    "tungsten rhenium osmium iridium platinum gold mercury thallium lead " + \
    "bismuth polonium astatine radon francium radium actinium thorium " + \
    "protactinium uranium neptunium plutonium americium curium berkelium " + \
    "californium einsteinium fermium mendelevium nobelium lawrencium " + \
    "rutherfordium dubnium seaborgium bohrium hassium meitnerium darmstadtium " + \
    "roentgenium copernicium nihonium flerovium moscovium livermorium " + \
    "tennessine oganesson"

items = elements.split(' ')

print("Last revision date:", revdate)
print("Number of elements:", len(items))
print("Last element      :", items[-1])
===
V revdate = ‘2021-11-14’

V elements = ‘hydrogen helium lithium beryllium boron carbon nitrogen oxygen fluorine ’""‘neon sodium magnesium aluminum silicon phosphorous sulfur chlorine argon ’""‘potassium calcium scandium titanium vanadium chromium manganese iron ’""‘cobalt nickel copper zinc gallium germanium arsenic selenium bromine ’""‘krypton rubidium strontium yttrium zirconium niobium molybdenum ’""‘technetium ruthenium rhodium palladium silver cadmium indium tin ’""‘antimony tellurium iodine xenon cesium barium lanthanum cerium ’""‘praseodymium neodymium promethium samarium europium gadolinium terbium ’""‘dysprosium holmium erbium thulium ytterbium lutetium hafnium tantalum ’""‘tungsten rhenium osmium iridium platinum gold mercury thallium lead ’""‘bismuth polonium astatine radon francium radium actinium thorium ’""‘protactinium uranium neptunium plutonium americium curium berkelium ’""‘californium einsteinium fermium mendelevium nobelium lawrencium ’""‘rutherfordium dubnium seaborgium bohrium hassium meitnerium darmstadtium ’""‘roentgenium copernicium nihonium flerovium moscovium livermorium ’""‘tennessine oganesson’

V items = elements.split(‘ ’)

print(‘Last revision date: ’revdate)
print(‘Number of elements: ’items.len)
print(‘Last element      : ’items.last)
===
auto revdate = u"2021-11-14"_S;

auto elements = u"hydrogen helium lithium beryllium boron carbon nitrogen oxygen fluorine "_S & u"neon sodium magnesium aluminum silicon phosphorous sulfur chlorine argon "_S & u"potassium calcium scandium titanium vanadium chromium manganese iron "_S & u"cobalt nickel copper zinc gallium germanium arsenic selenium bromine "_S & u"krypton rubidium strontium yttrium zirconium niobium molybdenum "_S & u"technetium ruthenium rhodium palladium silver cadmium indium tin "_S & u"antimony tellurium iodine xenon cesium barium lanthanum cerium "_S & u"praseodymium neodymium promethium samarium europium gadolinium terbium "_S & u"dysprosium holmium erbium thulium ytterbium lutetium hafnium tantalum "_S & u"tungsten rhenium osmium iridium platinum gold mercury thallium lead "_S & u"bismuth polonium astatine radon francium radium actinium thorium "_S & u"protactinium uranium neptunium plutonium americium curium berkelium "_S & u"californium einsteinium fermium mendelevium nobelium lawrencium "_S & u"rutherfordium dubnium seaborgium bohrium hassium meitnerium darmstadtium "_S & u"roentgenium copernicium nihonium flerovium moscovium livermorium "_S & u"tennessine oganesson"_S;

auto items = elements.split(u" "_S);

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"Last revision date: "_S & revdate);
        print(u"Number of elements: "_S & items.len());
        print(u"Last element      : "_S & items.last());
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Longest_substrings_without_repeating_characters#Python:_Some_optimisation
def longest_substring2(s):
    max_subs = [s[0:1]] * 0
    mx = 0
    for x in range(len(s)):
        for y in range(x+1, len(s) + 1):
            sub = s[x:y]
            if y - x >= mx and len(sub) == len(set(list(sub))):
                if y - x == mx and sub not in max_subs:
                    max_subs.append(sub)
                else:
                    max_subs = [sub]
                    mx = y - x
    return max_subs

for s in ["xyzyabcybdfd", "xyzyab", "zzzzz", "a", ""]:
    print(s, '=>', longest_substring2(s))

arr = [1, 2, 3, 4, 1, 2, 5, 6, 1, 7, 8, 1, 0]
print(arr, '=>', longest_substring2(arr))
===
F longest_substring2(s)
   V max_subs = [s[0.<1]] * 0
   V mx = 0
   L(x) 0 .< s.len
      L(y) x + 1 .. s.len
         V sub = s[x .< y]
         I y - x >= mx & sub.len == Set(Array(sub)).len
            I y - x == mx & sub !C max_subs
               max_subs.append(sub)
            E
               max_subs = [sub]
               mx = y - x
   R max_subs

L(s) [‘xyzyabcybdfd’, ‘xyzyab’, ‘zzzzz’, ‘a’, ‘’]
   print(s‘ => ’longest_substring2(s))

V arr = [1, 2, 3, 4, 1, 2, 5, 6, 1, 7, 8, 1, 0]
print(arr‘ => ’longest_substring2(arr))
===
template <typename T1> auto longest_substring2(const T1 &s)
{
    auto max_subs = create_array({s[range_el(0, 1)]}) * 0;
    auto mx = 0;
    for (auto x : range_el(0, s.len()))
        for (auto y : range_ee(x + 1, s.len())) {
            auto sub = s[range_el(x, y)];
            if (y - x >= mx && sub.len() == create_set(create_array(sub)).len()) {
                if (y - x == mx && !in(sub, max_subs))
                    max_subs.append(sub);
                else {
                    max_subs = create_array({sub});
                    mx = y - x;
                }
            }
        }
    return max_subs;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&s : create_array({u"xyzyabcybdfd"_S, u"xyzyab"_S, u"zzzzz"_S, u"a"_S, u""_S}))
            print(s & u" => "_S & longest_substring2(s));
    }
} code_block_1;

auto arr = create_array({1, 2, 3, 4, 1, 2, 5, 6, 1, 7, 8, 1, 0});

struct CodeBlock2
{
    CodeBlock2()
    {
        print(arr & u" => "_S & longest_substring2(arr));
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Loops/With_multiple_ranges#Nim
prod = 1
s = 0

x = +5
y = -5
z = -2
one = 1
three = 3
seven = 7

def body(j):
    global s, prod
    s += abs(j)
    if abs(prod) < 2**27 and j != 0: prod *= j

for j in range(-three, 3**3 + 1, three): body(j)
for j in range(-seven, seven + 1, x): body(j)
for j in range(555, 550 - y + 1): body(j)
for j in range(22, -28 - 1, -three): body(j)
for j in range(1927, 1939 + 1): body(j)
for j in range(x, y - 1, z): body(j)
for j in range(11**x, 11**x + one + 1): body(j)

ss = str(s)
ps = str(prod)
m = max(len(ss), len(ps))
print(" sum =", ss.rjust(m))
print("prod =", ps.rjust(m))
===
V prod = 1
V s = 0

V x = +5
V y = -5
V z = -2
V one = 1
V three = 3
V seven = 7

F body(j)
   :s += abs(j)
   I abs(:prod) < 2 ^ 27 & j != 0
      :prod *= j

L(j) (-three .. 3 ^ 3).step(three)
   body(j)
L(j) (-seven .. seven).step(x)
   body(j)
L(j) 555 .. 550 - y
   body(j)
L(j) (22 .< -28 - 1).step(-three)
   body(j)
L(j) 1927 .. 1939
   body(j)
L(j) (x .< y - 1).step(z)
   body(j)
L(j) 11 ^ x .. 11 ^ x + one
   body(j)

V ss = String(s)
V ps = String(prod)
V m = max(ss.len, ps.len)
print(‘ sum = ’ss.rjust(m))
print(‘prod = ’ps.rjust(m))
===
auto prod = 1;
auto s = 0;

auto x = +5;
auto y = -5;
auto z = -2;
auto one = 1;
auto three = 3;
auto seven = 7;

template <typename T1> auto body(const T1 &j)
{
    ::s += abs(j);
    if (abs(::prod) < pow(2, 27) && j != 0)
        ::prod *= j;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto j : range_ee(-three, cube(3)).step(three))
            body(j);
        for (auto j : range_ee(-seven, seven).step(x))
            body(j);
        for (auto j : range_ee(555, 550 - y))
            body(j);
        for (auto j : range_el(22, -28 - 1).step(-three))
            body(j);
        for (auto j : range_ee(1927, 1939))
            body(j);
        for (auto j : range_el(x, y - 1).step(z))
            body(j);
        for (auto j : range_ee(pow(11, x), pow(11, x) + one))
            body(j);
    }
} code_block_1;

auto ss = String(s);
auto ps = String(prod);
auto m = max(ss.len(), ps.len());

struct CodeBlock2
{
    CodeBlock2()
    {
        print(u" sum = "_S & ss.rjust(m));
        print(u"prod = "_S & ps.rjust(m));
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Lucky_and_even_lucky_numbers#Nim
import sys

NoValue = 0

def initLuckyNumbers(nelems, evenlucky, limit = -1):
    result : List[int] = []
    for i in range(nelems):
        k = i
        for j in range(len(result) - 1, 0, -1):
            k = k * result[j] // (result[j] - 1)
        n = 2 * k + 1 + evenlucky
        if limit != -1 and n > limit:
            break
        result.append(n)
    return result

def name(evenlucky):
    return ['Lucky', 'Even lucky'][evenlucky]

def printSingle(j, evenlucky):
    luckySeq = initLuckyNumbers(j, evenlucky)
    print(name(evenlucky), 'number at index', j, 'is', luckySeq[j - 1])

def printRange(j, k, evenlucky):
    luckySeq = initLuckyNumbers(k, evenlucky)
    print(name(evenlucky), 'numbers at indexes', j, 'to', k, 'are: ', end = '')
    for idx in range(j - 1, k):
        if idx != j - 1:
            print(', ', end = '')
        print(luckySeq[idx], end = '')
    print()

def printInRange(j, k, evenlucky):
    luckySeq = initLuckyNumbers(k, evenlucky, k)
    print(name(evenlucky), 'numbers between', j, 'to', k, 'are: ', end = '')
    first = True
    for val in luckySeq:
        #if val > k: break
        if val > j:
            if first:
                first = False
            else:
                print(', ', end = '')
            print(val, end = '')
    print()

def process_args(args):
    assert 1 <= len(args) <= 3, 'Wrong number of arguments'

    # First argument: "j" value.
    j = int(args[0])

    k = NoValue
    # Second argument: "k" value or a comma.
    if len(args) > 1:
        if args[1] == ',':
            # Must be followed by the kind of lucky number.
            assert len(args) == 3, 'Missing kind argument'
        else:
            k = int(args[1])
            assert k != 0, 'Expected a non null number'

    evenlucky = 0
    # Third argument: number kind.
    if len(args) == 3:
        kind = args[2].lower()
        assert kind in ('lucky', 'evenlucky'), 'Wrong kind'
        if kind == 'evenlucky':
            evenlucky = 1

    if k == NoValue:
        # Print jth value.
        printSingle(j, evenlucky)
    elif k > 0:
        # Print jth to kth values.
        printRange(j, k, evenlucky)
    else:
        # Print values in range j..(-k).
        printInRange(j, -k, evenlucky)

if __name__ == '__main__':
    if True:
        for args in ['1 20', '1 20 evenlucky', '6000 -6100', '6000 -6100 evenlucky', '10000', '10000 , lucky', '10000 , evenlucky']:
            print('Command line arguments: ' + args)
            process_args(args.split(' '))
            print()
    else:
        process_args(sys.argv[1:])
===
V NoValue = 0

F initLuckyNumbers(nelems, evenlucky, limit = -1)
   [Int] result
   L(i) 0 .< nelems
      V k = i
      L(j) (result.len - 1 .< 0).step(-1)
         k = k * result[j] I/ (result[j] - 1)
      V n = 2 * k + 1 + evenlucky
      I limit != -1 & n > limit
         L.break
      result.append(n)
   R result

F name(evenlucky)
   R [‘Lucky’, ‘Even lucky’][evenlucky]

F printSingle(j, evenlucky)
   V luckySeq = initLuckyNumbers(j, evenlucky)
   print(name(evenlucky)‘ number at index ’j‘ is ’luckySeq[j - 1])

F printRange(j, k, evenlucky)
   V luckySeq = initLuckyNumbers(k, evenlucky)
   print(name(evenlucky)‘ numbers at indexes ’j‘ to ’k‘ are: ’, end' ‘’)
   L(idx) j - 1 .< k
      I idx != j - 1
         print(‘, ’, end' ‘’)
      print(luckySeq[idx], end' ‘’)
   print()

F printInRange(j, k, evenlucky)
   V luckySeq = initLuckyNumbers(k, evenlucky, k)
   print(name(evenlucky)‘ numbers between ’j‘ to ’k‘ are: ’, end' ‘’)
   V first = 1B
   L(val) luckySeq
      I val > j
         I first
            first = 0B
         E
            print(‘, ’, end' ‘’)
         print(val, end' ‘’)
   print()

F process_args(args)
   assert(args.len C 1..3, ‘Wrong number of arguments’)

   V j = Int(args[0])

   V k = NoValue
   I args.len > 1
      I args[1] == ‘,’
         assert(args.len == 3, ‘Missing kind argument’)
      E
         k = Int(args[1])
         assert(k != 0, ‘Expected a non null number’)

   V evenlucky = 0
   I args.len == 3
      V kind = args[2].lowercase()
      assert(kind C (‘lucky’, ‘evenlucky’), ‘Wrong kind’)
      I kind == ‘evenlucky’
         evenlucky = 1

   I k == NoValue
      printSingle(j, evenlucky)
   E I k > 0
      printRange(j, k, evenlucky)
   E
      printInRange(j, -k, evenlucky)

:start:
I 1B
   L(args) [‘1 20’, ‘1 20 evenlucky’, ‘6000 -6100’, ‘6000 -6100 evenlucky’, ‘10000’, ‘10000 , lucky’, ‘10000 , evenlucky’]
      print(‘Command line arguments: ’args)
      process_args(args.split(‘ ’))
      print()
E
   process_args(:argv[1..])
===
Array<String> argv;

auto NoValue = 0;

template <typename T1, typename T2, typename T3 = decltype(-1)> auto initLuckyNumbers(const T1 &nelems, const T2 &evenlucky, const T3 &limit = -1)
{
    Array<int> result;
    for (auto i : range_el(0, nelems)) {
        auto k = i;
        for (auto j : range_el(result.len() - 1, 0).step(-1))
            k = idiv(k * result[j], (result[j] - 1));
        auto n = 2 * k + 1 + evenlucky;
        if (limit != -1 && n > limit)
            break;
        result.append(n);
    }
    return result;
}

template <typename T1> auto name(const T1 &evenlucky)
{
    return create_array({u"Lucky"_S, u"Even lucky"_S})[evenlucky];
}

template <typename T1, typename T2> auto printSingle(const T1 &j, const T2 &evenlucky)
{
    auto luckySeq = initLuckyNumbers(j, evenlucky);
    print(name(evenlucky) & u" number at index "_S & j & u" is "_S & luckySeq[j - 1]);
}

template <typename T1, typename T2, typename T3> auto printRange(const T1 &j, const T2 &k, const T3 &evenlucky)
{
    auto luckySeq = initLuckyNumbers(k, evenlucky);
    print(name(evenlucky) & u" numbers at indexes "_S & j & u" to "_S & k & u" are: "_S, u""_S);
    for (auto idx : range_el(j - 1, k)) {
        if (idx != j - 1)
            print(u", "_S, u""_S);
        print(luckySeq[idx], u""_S);
    }
    print();
}

template <typename T1, typename T2, typename T3> auto printInRange(const T1 &j, const T2 &k, const T3 &evenlucky)
{
    auto luckySeq = initLuckyNumbers(k, evenlucky, k);
    print(name(evenlucky) & u" numbers between "_S & j & u" to "_S & k & u" are: "_S, u""_S);
    auto first = true;
    for (auto &&val : luckySeq)
        if (val > j) {
            if (first)
                first = false;
            else
                print(u", "_S, u""_S);
            print(val, u""_S);
        }
    print();
}

template <typename T1> auto process_args(const T1 &args)
{
    assert(in(args.len(), range_ee(1, 3)), u"Wrong number of arguments"_S);

    auto j = to_int(_get<0>(args));

    auto k = NoValue;
    if (args.len() > 1) {
        if (_get<1>(args) == u',')
            assert(args.len() == 3, u"Missing kind argument"_S);
        else {
            k = to_int(_get<1>(args));
            assert(k != 0, u"Expected a non null number"_S);
        }
    }

    auto evenlucky = 0;
    if (args.len() == 3) {
        auto kind = _get<2>(args).lowercase();
        assert(in(kind, make_tuple(u"lucky"_S, u"evenlucky"_S)), u"Wrong kind"_S);
        if (kind == u"evenlucky")
            evenlucky = 1;
    }

    if (k == NoValue)
        printSingle(j, evenlucky);
    else if (k > 0)
        printRange(j, k, evenlucky);
    else
        printInRange(j, -k, evenlucky);
}

int MAIN_WITH_ARGV()
{
    INIT_ARGV();

    if (true)
        for (auto &&args : create_array({u"1 20"_S, u"1 20 evenlucky"_S, u"6000 -6100"_S, u"6000 -6100 evenlucky"_S, u"10000"_S, u"10000 , lucky"_S, u"10000 , evenlucky"_S})) {
            print(u"Command line arguments: "_S & args);
            process_args(args.split(u" "_S));
            print();
        }
    else
        process_args(::argv[range_ei(1)]);
}


# https://www.rosettacode.org/wiki/Largest_difference_between_adjacent_primes
def primes_upto(limit):
    is_prime = [False] * 2 + [True] * (limit - 1)
    for n in range(int(limit**0.5 + 1.5)): # stop at ``sqrt(limit)``
        if is_prime[n]:
            for i in range(n*n, limit+1, n):
                is_prime[i] = False
    return [i for i, prime in enumerate(is_prime) if prime]

primes = primes_upto(1_000_000)

maxdiff = 0
for n in range(1, len(primes)):
    maxdiff = max(maxdiff, primes[n] - primes[n-1])

print('Largest difference is', maxdiff)
===
F primes_upto(limit)
   V is_prime = [0B] * 2 [+] [1B] * (limit - 1)
   L(n) 0 .< Int(limit ^ 0.5 + 1.5)
      I is_prime[n]
         L(i) (n * n .. limit).step(n)
            is_prime[i] = 0B
   R enumerate(is_prime).filter((i, prime) -> prime).map((i, prime) -> i)

V primes = primes_upto(1'000'000)

V maxdiff = 0
L(n) 1 .< primes.len
   maxdiff = max(maxdiff, primes[n] - primes[n - 1])

print(‘Largest difference is ’maxdiff)
===
template <typename T1> auto primes_upto(const T1 &limit)
{
    auto is_prime = create_array({false}) * 2 + create_array({true}) * (limit - 1);
    for (auto n : range_el(0, to_int(pow(limit, 0.5) + 1.5)))
        if (is_prime[n])
            for (auto i : range_ee(n * n, limit).step(n))
                is_prime.set(i, false);
    return enumerate(is_prime).filter([](const auto &i, const auto &prime){return prime;}).map([](const auto &i, const auto &prime){return i;});
}

auto primes = primes_upto(1'000'000);

auto maxdiff = 0;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto n : range_el(1, primes.len()))
            maxdiff = max(maxdiff, primes[n] - primes[n - 1]);

        print(u"Largest difference is "_S & maxdiff);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Largest_five_adjacent_number#Python
import random

largeNum = [random.randint(1, 9)] + [random.randint(0, 9) for i in range(999)]

(maxNum, minNum) = (0, 99999)

for i in range(996):
    num = int(''.join(map(str, largeNum[i:i+5])))
    if num > maxNum:
        maxNum = num
    elif num < minNum:
        minNum = num

print( "Largest 5-digit number extracted from random 1000-digit number:", maxNum)
print("Smallest 5-digit number extracted from random 1000-digit number: %05d" % minNum)
===
V largeNum = [random:(1 .. 9)] [+] (0.<999).map(i -> random:(0 .. 9))

V (maxNum, minNum) = (0, 99999)

L(i) 996
   V num = Int(largeNum[i .< i + 5].map(String).join(‘’))
   I num > maxNum
      maxNum = num
   E I num < minNum
      minNum = num

print(‘Largest 5-digit number extracted from random 1000-digit number: ’maxNum)
print(‘Smallest 5-digit number extracted from random 1000-digit number: #05’.format(minNum))
===
auto largeNum = create_array({randomns::_(range_ee(1, 9))}) + range_el(0, 999).map([](const auto &i){return randomns::_(range_ee(0, 9));});

auto [maxNum, minNum] = make_tuple(0, 99999);

struct CodeBlock1
{
    CodeBlock1()
    {
        for (int i = 0; i < 996; i++) {
            auto num = to_int(largeNum[range_el(i, i + 5)].map([](const auto &x){return String(x);}).join(u""_S));
            if (num > maxNum)
                maxNum = num;
            else if (num < minNum)
                minNum = num;
        }

        print(u"Largest 5-digit number extracted from random 1000-digit number: "_S & maxNum);
        print(u"Smallest 5-digit number extracted from random 1000-digit number: #05"_S.format(minNum));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Largest_palindrome_product#Wren
Int64 = int

def reverse(n):
    r = Int64(0)
    while n > 0:
        r = n%10 + r*10
        n //= 10
    return r

po = Int64(10)
for n in range(2, 8):
    low = po * 9
    po *= 10
    high = po - 1
    nextN = False
    for i in range(high, low - 1, -1):
        j = reverse(i)
        p = i * po + j
        k = high
        while k > low:
            if k % 10 != 5:
                l = p // k
                if l > high: break
                if p % k == 0:
                    print(f'Largest palindromic product of two {n}-digit integers: {k} x {l} = {p}')
                    nextN = True
                    break
            k -= 2
        if nextN:
            break
===
F reverse(=n)
   V r = Int64(0)
   L n > 0
      r = n % 10 + r * 10
      n I/= 10
   R r

V po = Int64(10)
L(n) 2..7
   V low = po * 9
   po *= 10
   V high = po - 1
   V nextN = 0B
   L(i) (high .< low - 1).step(-1)
      V j = reverse(i)
      V p = i * po + j
      V k = high
      L k > low
         I k % 10 != 5
            V l = p I/ k
            I l > high
               L.break
            I p % k == 0
               print(‘Largest palindromic product of two ’n‘-digit integers: ’k‘ x ’l‘ = ’p)
               nextN = 1B
               L.break
         k -= 2
      I nextN
         L.break
===
template <typename T1> auto reverse(T1 n)
{
    auto r = to_int64(0);
    while (n > 0) {
        r = mod(n, 10) + r * 10;
        n = idiv(n, 10);
    }
    return r;
}

auto po = to_int64(10);

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto n : range_ee(2, 7)) {
            auto low = po * 9;
            po *= 10;
            auto high = po - 1;
            auto nextN = false;
            for (auto i : range_el(high, low - 1).step(-1)) {
                auto j = reverse(i);
                auto p = i * po + j;
                auto k = high;
                while (k > low) {
                    if (mod(k, 10) != 5) {
                        auto l = idiv(p, k);
                        if (l > high)
                            break;
                        if (mod(p, k) == 0) {
                            print(u"Largest palindromic product of two "_S & n & u"-digit integers: "_S & k & u" x "_S & l & u" = "_S & p);
                            nextN = true;
                            break;
                        }
                    }
                    k -= 2;
                }
                if (nextN)
                    break;
            }
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Largest_product_in_a_grid#Python
from _11l import *

def maxproduct(mat, length):
    """ find the largest product of len length horizontal or vertical length in matrix """
    (nrow, ncol) = (len(mat), len(mat[0]))
    (maxprod, maxrow, maxcol, arr) = (Int64(0), [0, 0], [0, 0], [0])
    for row in range(nrow):
        for col in range(ncol):
            (row2, col2) = (row + length, col + length)
            if row < nrow - length:
                array = [r[col] for r in mat[row:row2]]
                pro = product_of_a_seq(map(Int64, array))
                if pro > maxprod:
                    (maxprod, maxrow, maxcol, arr) = (pro, [row, row2], [col], array)
            if col < ncol - length:
                pro = product_of_a_seq(map(Int64, mat[row][col:col2]))
                if pro > maxprod:
                    (maxprod, maxrow, maxcol, arr) = (pro, [row], [col, col2], mat[row][col:col2])

    print(f"The max {length}-product is {maxprod}, product of {arr} at row {maxrow}, col {maxcol}.")

MATRIX = [
    [ 8,  2, 22, 97, 38, 15,  0, 40,  0, 75,  4,  5,  7, 78, 52, 12, 50, 77, 91,  8],
    [49, 49, 99, 40, 17, 81, 18, 57, 60, 87, 17, 40, 98, 43, 69, 48,  4, 56, 62,  0],
    [81, 49, 31, 73, 55, 79, 14, 29, 93, 71, 40, 67, 53, 88, 30,  3, 49, 13, 36, 65],
    [52, 70, 95, 23,  4, 60, 11, 42, 69, 24, 68, 56,  1, 32, 56, 71, 37,  2, 36, 91],
    [22, 31, 16, 71, 51, 67, 63, 89, 41, 92, 36, 54, 22, 40, 40, 28, 66, 33, 13, 80],
    [24, 47, 32, 60, 99,  3, 45,  2, 44, 75, 33, 53, 78, 36, 84, 20, 35, 17, 12, 50],
    [32, 98, 81, 28, 64, 23, 67, 10, 26, 38, 40, 67, 59, 54, 70, 66, 18, 38, 64, 70],
    [67, 26, 20, 68,  2, 62, 12, 20, 95, 63, 94, 39, 63,  8, 40, 91, 66, 49, 94, 21],
    [24, 55, 58,  5, 66, 73, 99, 26, 97, 17, 78, 78, 96, 83, 14, 88, 34, 89, 63, 72],
    [21, 36, 23,  9, 75,  0, 76, 44, 20, 45, 35, 14,  0, 61, 33, 97, 34, 31, 33, 95],
    [78, 17, 53, 28, 22, 75, 31, 67, 15, 94,  3, 80,  4, 62, 16, 14,  9, 53, 56, 92],
    [16, 39,  5, 42, 96, 35, 31, 47, 55, 58, 88, 24,  0, 17, 54, 24, 36, 29, 85, 57],
    [86, 56,  0, 48, 35, 71, 89,  7,  5, 44, 44, 37, 44, 60, 21, 58, 51, 54, 17, 58],
    [19, 80, 81, 68,  5, 94, 47, 69, 28, 73, 92, 13, 86, 52, 17, 77,  4, 89, 55, 40],
    [ 4, 52,  8, 83, 97, 35, 99, 16,  7, 97, 57, 32, 16, 26, 26, 79, 33, 27, 98, 66],
    [88, 36, 68, 87, 57, 62, 20, 72,  3, 46, 33, 67, 46, 55, 12, 32, 63, 93, 53, 69],
    [ 4, 42, 16, 73, 38, 25, 39, 11, 24, 94, 72, 18,  8, 46, 29, 32, 40, 62, 76, 36],
    [20, 69, 36, 41, 72, 30, 23, 88, 34, 62, 99, 69, 82, 67, 59, 85, 74,  4, 36, 16],
    [20, 73, 35, 29, 78, 31, 90,  1, 74, 31, 49, 71, 48, 86, 81, 16, 23, 57,  5, 54],
    [ 1, 70, 54, 71, 83, 51, 54, 69, 16, 92, 33, 48, 61, 43, 52,  1, 89, 19, 67, 48]
]

for n in range(2, 6):
    maxproduct(MATRIX, n)
===
F maxproduct(mat, length)
   ‘ find the largest product of len length horizontal or vertical length in matrix ’
   V (nrow, ncol) = (mat.len, mat[0].len)
   V (maxprod, maxrow, maxcol, arr) = (Int64(0), [0, 0], [0, 0], [0])
   L(row) 0 .< nrow
      L(col) 0 .< ncol
         V (row2, col2) = (row + length, col + length)
         I row < nrow - length
            V array = mat[row .< row2].map(r -> r[@col])
            V pro = product(array.map(Int64))
            I pro > maxprod
               (maxprod, maxrow, maxcol, arr) = (pro, [row, row2], [col], array)
         I col < ncol - length
            V pro = product(mat[row][col .< col2].map(Int64))
            I pro > maxprod
               (maxprod, maxrow, maxcol, arr) = (pro, [row], [col, col2], mat[row][col .< col2])

   print(‘The max ’length‘-product is ’maxprod‘, product of ’arr‘ at row ’maxrow‘, col ’maxcol‘.’)

V MATRIX = [[8, 2, 22, 97, 38, 15, 0, 40, 0, 75, 4, 5, 7, 78, 52, 12, 50, 77, 91, 8], [49, 49, 99, 40, 17, 81, 18, 57, 60, 87, 17, 40, 98, 43, 69, 48, 4, 56, 62, 0], [81, 49, 31, 73, 55, 79, 14, 29, 93, 71, 40, 67, 53, 88, 30, 3, 49, 13, 36, 65], [52, 70, 95, 23, 4, 60, 11, 42, 69, 24, 68, 56, 1, 32, 56, 71, 37, 2, 36, 91], [22, 31, 16, 71, 51, 67, 63, 89, 41, 92, 36, 54, 22, 40, 40, 28, 66, 33, 13, 80], [24, 47, 32, 60, 99, 3, 45, 2, 44, 75, 33, 53, 78, 36, 84, 20, 35, 17, 12, 50], [32, 98, 81, 28, 64, 23, 67, 10, 26, 38, 40, 67, 59, 54, 70, 66, 18, 38, 64, 70], [67, 26, 20, 68, 2, 62, 12, 20, 95, 63, 94, 39, 63, 8, 40, 91, 66, 49, 94, 21], [24, 55, 58, 5, 66, 73, 99, 26, 97, 17, 78, 78, 96, 83, 14, 88, 34, 89, 63, 72], [21, 36, 23, 9, 75, 0, 76, 44, 20, 45, 35, 14, 0, 61, 33, 97, 34, 31, 33, 95], [78, 17, 53, 28, 22, 75, 31, 67, 15, 94, 3, 80, 4, 62, 16, 14, 9, 53, 56, 92], [16, 39, 5, 42, 96, 35, 31, 47, 55, 58, 88, 24, 0, 17, 54, 24, 36, 29, 85, 57], [86, 56, 0, 48, 35, 71, 89, 7, 5, 44, 44, 37, 44, 60, 21, 58, 51, 54, 17, 58], [19, 80, 81, 68, 5, 94, 47, 69, 28, 73, 92, 13, 86, 52, 17, 77, 4, 89, 55, 40], [4, 52, 8, 83, 97, 35, 99, 16, 7, 97, 57, 32, 16, 26, 26, 79, 33, 27, 98, 66], [88, 36, 68, 87, 57, 62, 20, 72, 3, 46, 33, 67, 46, 55, 12, 32, 63, 93, 53, 69], [4, 42, 16, 73, 38, 25, 39, 11, 24, 94, 72, 18, 8, 46, 29, 32, 40, 62, 76, 36], [20, 69, 36, 41, 72, 30, 23, 88, 34, 62, 99, 69, 82, 67, 59, 85, 74, 4, 36, 16], [20, 73, 35, 29, 78, 31, 90, 1, 74, 31, 49, 71, 48, 86, 81, 16, 23, 57, 5, 54], [1, 70, 54, 71, 83, 51, 54, 69, 16, 92, 33, 48, 61, 43, 52, 1, 89, 19, 67, 48]]

L(n) 2..5
   maxproduct(MATRIX, n)
===
template <typename T1, typename T2> auto maxproduct(const T1 &mat, const T2 &length)
{
    u" find the largest product of len length horizontal or vertical length in matrix "_S;
    auto [nrow, ncol] = make_tuple(mat.len(), _get<0>(mat).len());
    auto [maxprod, maxrow, maxcol, arr] = make_tuple(to_int64(0), create_array({0, 0}), create_array({0, 0}), create_array({0}));
    for (auto row : range_el(0, nrow))
        for (auto col : range_el(0, ncol)) {
            auto [row2, col2] = make_tuple(row + length, col + length);
            if (row < nrow - length) {
                auto array = mat[range_el(row, row2)].map([&col](const auto &r){return r[col];});
                auto pro = product(array.map([](const auto &x){return to_int64(x);}));
                if (pro > maxprod)
                    assign_from_tuple(maxprod, maxrow, maxcol, arr, make_tuple(pro, create_array({row, row2}), create_array({col}), array));
            }
            if (col < ncol - length) {
                auto pro = product(mat[row][range_el(col, col2)].map([](const auto &x){return to_int64(x);}));
                if (pro > maxprod)
                    assign_from_tuple(maxprod, maxrow, maxcol, arr, make_tuple(pro, create_array({row}), create_array({col, col2}), mat[row][range_el(col, col2)]));
            }
        }

    print(u"The max "_S & length & u"-product is "_S & maxprod & u", product of "_S & arr & u" at row "_S & maxrow & u", col "_S & maxcol & u"."_S);
}

auto MATRIX = create_array({create_array({8, 2, 22, 97, 38, 15, 0, 40, 0, 75, 4, 5, 7, 78, 52, 12, 50, 77, 91, 8}), create_array({49, 49, 99, 40, 17, 81, 18, 57, 60, 87, 17, 40, 98, 43, 69, 48, 4, 56, 62, 0}), create_array({81, 49, 31, 73, 55, 79, 14, 29, 93, 71, 40, 67, 53, 88, 30, 3, 49, 13, 36, 65}), create_array({52, 70, 95, 23, 4, 60, 11, 42, 69, 24, 68, 56, 1, 32, 56, 71, 37, 2, 36, 91}), create_array({22, 31, 16, 71, 51, 67, 63, 89, 41, 92, 36, 54, 22, 40, 40, 28, 66, 33, 13, 80}), create_array({24, 47, 32, 60, 99, 3, 45, 2, 44, 75, 33, 53, 78, 36, 84, 20, 35, 17, 12, 50}), create_array({32, 98, 81, 28, 64, 23, 67, 10, 26, 38, 40, 67, 59, 54, 70, 66, 18, 38, 64, 70}), create_array({67, 26, 20, 68, 2, 62, 12, 20, 95, 63, 94, 39, 63, 8, 40, 91, 66, 49, 94, 21}), create_array({24, 55, 58, 5, 66, 73, 99, 26, 97, 17, 78, 78, 96, 83, 14, 88, 34, 89, 63, 72}), create_array({21, 36, 23, 9, 75, 0, 76, 44, 20, 45, 35, 14, 0, 61, 33, 97, 34, 31, 33, 95}), create_array({78, 17, 53, 28, 22, 75, 31, 67, 15, 94, 3, 80, 4, 62, 16, 14, 9, 53, 56, 92}), create_array({16, 39, 5, 42, 96, 35, 31, 47, 55, 58, 88, 24, 0, 17, 54, 24, 36, 29, 85, 57}), create_array({86, 56, 0, 48, 35, 71, 89, 7, 5, 44, 44, 37, 44, 60, 21, 58, 51, 54, 17, 58}), create_array({19, 80, 81, 68, 5, 94, 47, 69, 28, 73, 92, 13, 86, 52, 17, 77, 4, 89, 55, 40}), create_array({4, 52, 8, 83, 97, 35, 99, 16, 7, 97, 57, 32, 16, 26, 26, 79, 33, 27, 98, 66}), create_array({88, 36, 68, 87, 57, 62, 20, 72, 3, 46, 33, 67, 46, 55, 12, 32, 63, 93, 53, 69}), create_array({4, 42, 16, 73, 38, 25, 39, 11, 24, 94, 72, 18, 8, 46, 29, 32, 40, 62, 76, 36}), create_array({20, 69, 36, 41, 72, 30, 23, 88, 34, 62, 99, 69, 82, 67, 59, 85, 74, 4, 36, 16}), create_array({20, 73, 35, 29, 78, 31, 90, 1, 74, 31, 49, 71, 48, 86, 81, 16, 23, 57, 5, 54}), create_array({1, 70, 54, 71, 83, 51, 54, 69, 16, 92, 33, 48, 61, 43, 52, 1, 89, 19, 67, 48})});

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto n : range_ee(2, 5))
            maxproduct(MATRIX, n);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Last_list_item#Python
def add_least_reduce(lis : list):
    while len(lis) > 1:
        el1 = lis.pop(lis.index(min(lis)))
        el2 = lis.pop(lis.index(min(lis)))
        lis.append(el1 + el2)
        print('Interim list:', lis)
    return lis

LIST = [6, 81, 243, 14, 25, 49, 123, 69, 11]

print(LIST, ' ==> ', add_least_reduce(LIST[:]))
===
F add_least_reduce(&lis)
   L lis.len > 1
      V el1 = lis.pop(lis.index(min(lis)))
      V el2 = lis.pop(lis.index(min(lis)))
      lis.append(el1 + el2)
      print(‘Interim list: ’lis)
   R lis

V LIST = [6, 81, 243, 14, 25, 49, 123, 69, 11]

print(LIST‘  ==>  ’add_least_reduce(&copy(LIST)))
===
template <typename T1> auto add_least_reduce(T1 &lis)
{
    while (lis.len() > 1) {
        auto el1 = lis.pop(lis.index(min(lis)));
        auto el2 = lis.pop(lis.index(min(lis)));
        lis.append(el1 + el2);
        print(u"Interim list: "_S & lis);
    }
    return lis;
}

auto LIST = create_array({6, 81, 243, 14, 25, 49, 123, 69, 11});

struct CodeBlock1
{
    CodeBlock1()
    {
        print(LIST & u"  ==>  "_S & add_least_reduce(make_ref(copy(LIST))));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Long_stairs#C
import random

secs_tot  = 0
steps_tot = 0
print('Seconds    steps behind    steps ahead')

for trial in range(1, 10001):
    sbeh = 0; slen = 100; secs = 0
    while sbeh < slen:
        sbeh += 1
        for wiz in range(5):
            if random.randrange(slen) < sbeh:
                sbeh += 1
            slen += 1

        secs += 1
        if trial == 1 and 600 <= secs <= 609:
            print("%d        %d            %d" % (secs, sbeh, slen-sbeh))

    secs_tot += secs
    steps_tot += slen

print("Average secs taken: %f" % (secs_tot/10000.0))
print("Average final length of staircase: %f" % (steps_tot/10000.0))
===
V secs_tot = 0
V steps_tot = 0
print(‘Seconds    steps behind    steps ahead’)

L(trial) 1..10000
   V sbeh = 0
   V slen = 100
   V secs = 0
   L sbeh < slen
      sbeh++
      L(wiz) 5
         I random:(slen) < sbeh
            sbeh++
         slen++

      secs++
      I trial == 1 & secs C 600..609
         print(‘#.        #.            #.’.format(secs, sbeh, slen - sbeh))

   secs_tot += secs
   steps_tot += slen

print(‘Average secs taken: #.6’.format(secs_tot / 10000.0))
print(‘Average final length of staircase: #.6’.format(steps_tot / 10000.0))
===
auto secs_tot = 0;
auto steps_tot = 0;

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"Seconds    steps behind    steps ahead"_S);

        for (auto trial : range_ee(1, 10000)) {
            auto sbeh = 0;
            auto slen = 100;
            auto secs = 0;
            while (sbeh < slen) {
                sbeh++;
                for (int wiz = 0; wiz < 5; wiz++) {
                    if (randomns::_(slen) < sbeh)
                        sbeh++;
                    slen++;
                }

                secs++;
                if (trial == 1 && in(secs, range_ee(600, 609)))
                    print(u"#.        #.            #."_S.format(secs, sbeh, slen - sbeh));
            }

            secs_tot += secs;
            steps_tot += slen;
        }

        print(u"Average secs taken: #.6"_S.format(secs_tot / 10000.0));
        print(u"Average final length of staircase: #.6"_S.format(steps_tot / 10000.0));
    }
} code_block_1;