# https://www.rosettacode.org/wiki/Mad_Libs#Python
import re

template = '''<name> went for a walk in the park. <he or she>
found a <noun>. <name> decided to take it home.'''

def madlibs(template):
    print('The story template is:\n' + template)
    fields = sorted(list(set( re.findall('<[^>]+>', template) )))
    values = input('\nInput a comma-separated list of words to replace the following items\n  %s: ' % ','.join(fields)).split(',')
    story = template
    for f,v in zip(fields, values):
        story = story.replace(f, v)
    print('\nThe story becomes:\n\n' + story)

madlibs(template)
===
V template = ‘<name> went for a walk in the park. <he or she>
found a <noun>. <name> decided to take it home.’

F madlibs(template)
   print("The story template is:\n"template)
   V fields = sorted(Array(Set(re:‘<[^>]+>’.find_strings(template))))
   V values = input("\nInput a comma-separated list of words to replace the following items\n  #.: ".format(fields.join(‘,’))).split(‘,’)
   V story = template
   L(f, v) zip(fields, values)
      story = story.replace(f, v)
   print("\nThe story becomes:\n\n"story)

madlibs(template)
===
auto _template_ = uR"(<name> went for a walk in the park. <he or she>
found a <noun>. <name> decided to take it home.)"_S;

template <typename T1> auto madlibs(const T1 &_template_)
{
    print(u"The story template is:\n"_S & _template_);
    auto fields = sorted(create_array(create_set(re::_(u"<[^>]+>"_S).find_strings(_template_))));
    auto values = input(u"\nInput a comma-separated list of words to replace the following items\n  #.: "_S.format(fields.join(u","_S))).split(u","_S);
    auto story = _template_;
    for (auto &&[f, v] : zip(fields, values))
        story = story.replace(f, v);
    print(u"\nThe story becomes:\n\n"_S & story);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        madlibs(_template_);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Magic_squares_of_odd_order#Python
def magic(n):
    for row in range(1, n + 1):
        print(' '.join(str(cell).rjust(len(str(n**2))) for cell in
                       (n * ((row + col - 1 + n // 2) % n) +
                       ((row + 2 * col - 2) % n) + 1
                       for col in range(1, n + 1))))
    print('\nAll sum to magic number %i' % ((n * n + 1) * n // 2))

for n in (5, 3, 7):
    print('\nOrder %i\n=======' % n)
    magic(n)
===
F magic(n)
   L(row) 1 .. n
      print(((1 .. n).map(col -> @n * ((@row + col - 1 + @n I/ 2) % @n) + ((@row + 2 * col - 2) % @n) + 1)).map(cell -> String(cell).rjust(String(@n ^ 2).len)).join(‘ ’))
   print("\nAll sum to magic number #.".format((n * n + 1) * n I/ 2))

L(n) (5, 3, 7)
   print("\nOrder #.\n=======".format(n))
   magic(n)
===
template <typename T1> auto magic(const T1 &n)
{
    for (auto row : range_ee(1, n))
        print((range_ee(1, n).map([&n, &row](const auto &col){return n * (mod((row + col - 1 + idiv(n, 2)), n)) + (mod((row + 2 * col - 2), n)) + 1;})).map([&n](const auto &cell){return String(cell).rjust(String(square(n)).len());}).join(u" "_S));
    print(u"\nAll sum to magic number #."_S.format(idiv((n * n + 1) * n, 2)));
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&n : make_tuple(5, 3, 7)) {
            print(u"\nOrder #.\n======="_S.format(n));
            magic(n);
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Magic_squares_of_singly_even_order#Python
import math

LOG_10 = 2.302585092994

# build odd magic square
def build_oms(s):
    if s % 2 == 0:
        s += 1
    q = [[0 for j in range(s)] for i in range(s)]
    p = 1
    i = s // 2
    j = 0
    while p <= (s * s):
        q[i][j] = p
        ti = i + 1
        if ti >= s: ti = 0
        tj = j - 1
        if tj < 0: tj = s - 1
        if q[ti][tj] != 0:
            ti = i
            tj = j + 1
        i = ti
        j = tj
        p += 1

    return (q, s)

# build singly even magic square
def build_sems(s):
    if s % 2 == 1:
        s += 1
    while s % 4 == 0:
        s += 2

    q = [[0 for j in range(s)] for i in range(s)]
    z = s // 2
    b = z * z
    c = 2 * b
    d = 3 * b
    o = build_oms(z)

    for j in range(0, z):
        for i in range(0, z):
            a = o[0][i][j]
            q[i][j] = a
            q[i + z][j + z] = a + b
            q[i + z][j] = a + c
            q[i][j + z] = a + d

    lc = z // 2
    rc = lc
    for j in range(0, z):
        for i in range(0, s):
            if i < lc or i > s - rc or (i == lc and j == lc):
                if not (i == 0 and j == lc):
                    (q[i][j], q[i][j + z]) = (q[i][j + z], q[i][j])

    return (q, s)

def display(q):
    s = q[1]
    print(" - %i x %i\n" % (s, s))
    k = 1 + int(math.floor(math.log(s * s) / LOG_10))
    for j in range(0, s):
        for i in range(0, s):
            print(str(q[0][i][j]).zfill(k), end = ' ')
        print()
    print("Magic sum: %i" % (s * ((s * s) + 1) // 2))

print("Singly Even Magic Square", end = '')
display(build_sems(6))
===
V LOG_10 = 2.302585092994

F build_oms(=s)
   I s % 2 == 0
      s++
   V q = (0 .< s).map(i -> (0 .< @s).map(j -> 0))
   V p = 1
   V i = s I/ 2
   V j = 0
   L p <= (s * s)
      q[i][j] = p
      V ti = i + 1
      I ti >= s
         ti = 0
      V tj = j - 1
      I tj < 0
         tj = s - 1
      I q[ti][tj] != 0
         ti = i
         tj = j + 1
      i = ti
      j = tj
      p++

   R (q, s)

F build_sems(=s)
   I s % 2 == 1
      s++
   L s % 4 == 0
      s += 2

   V q = (0 .< s).map(i -> (0 .< @s).map(j -> 0))
   V z = s I/ 2
   V b = z * z
   V c = 2 * b
   V d = 3 * b
   V o = build_oms(z)

   L(j) 0 .< z
      L(i) 0 .< z
         V a = o[0][i][j]
         q[i][j] = a
         q[i + z][j + z] = a + b
         q[i + z][j] = a + c
         q[i][j + z] = a + d

   V lc = z I/ 2
   V rc = lc
   L(j) 0 .< z
      L(i) 0 .< s
         I i < lc | i > s - rc | (i == lc & j == lc)
            I !(i == 0 & j == lc)
               swap(&q[i][j], &q[i][j + z])

   R (q, s)

F display(q)
   V s = q[1]
   print(" - #. x #.\n".format(s, s))
   V k = 1 + Int(floor(log(s * s) / :LOG_10))
   L(j) 0 .< s
      L(i) 0 .< s
         print(String(q[0][i][j]).zfill(k), end' ‘ ’)
      print()
   print(‘Magic sum: #.’.format(s * ((s * s) + 1) I/ 2))

print(‘Singly Even Magic Square’, end' ‘’)
display(build_sems(6))
===
auto LOG_10 = 2.302585092994;

template <typename T1> auto build_oms(T1 s)
{
    if (mod(s, 2) == 0)
        s++;
    auto q = range_el(0, s).map([&s](const auto &i){return range_el(0, s).map([](const auto &j){return 0;});});
    auto p = 1;
    auto i = idiv(s, 2);
    auto j = 0;
    while (p <= (s * s)) {
        q[i].set(j, p);
        auto ti = i + 1;
        if (ti >= s)
            ti = 0;
        auto tj = j - 1;
        if (tj < 0)
            tj = s - 1;
        if (q[ti][tj] != 0) {
            ti = i;
            tj = j + 1;
        }
        i = ti;
        j = tj;
        p++;
    }

    return make_tuple(q, s);
}

template <typename T1> auto build_sems(T1 s)
{
    if (mod(s, 2) == 1)
        s++;
    while (mod(s, 4) == 0)
        s += 2;

    auto q = range_el(0, s).map([&s](const auto &i){return range_el(0, s).map([](const auto &j){return 0;});});
    auto z = idiv(s, 2);
    auto b = z * z;
    auto c = 2 * b;
    auto d = 3 * b;
    auto o = build_oms(z);

    for (auto j : range_el(0, z))
        for (auto i : range_el(0, z)) {
            auto a = _get<0>(o)[i][j];
            q[i].set(j, a);
            q[i + z].set(j + z, a + b);
            q[i + z].set(j, a + c);
            q[i].set(j + z, a + d);
        }

    auto lc = idiv(z, 2);
    auto rc = lc;
    for (auto j : range_el(0, z))
        for (auto i : range_el(0, s))
            if (i < lc || i > s - rc || (i == lc && j == lc)) {
                if (!(i == 0 && j == lc))
                    swap(q[i][j], q[i][j + z]);
            }

    return make_tuple(q, s);
}

template <typename T1> auto display(const T1 &q)
{
    auto s = _get<1>(q);
    print(u" - #. x #.\n"_S.format(s, s));
    auto k = 1 + to_int(floor(log(s * s) / ::LOG_10));
    for (auto j : range_el(0, s)) {
        for (auto i : range_el(0, s))
            print(String(_get<0>(q)[i][j]).zfill(k), u" "_S);
        print();
    }
    print(u"Magic sum: #."_S.format(idiv(s * ((s * s) + 1), 2)));
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"Singly Even Magic Square"_S, u""_S);
        display(build_sems(6));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Map_range#Python
def maprange( a, b, s):
    return  b[0] + (float(s - a[0]) * (b[1] - b[0]) / (a[1] - a[0]))

for s in range(11):
    print("%2g maps to %g" % (s, maprange( (0, 10), (-1, 0), s)))
===
F maprange(a, b, s)
   R b[0] + (Float(s - a[0]) * (b[1] - b[0]) / (a[1] - a[0]))

L(s) 11
   print(‘#2 maps to #.’.format(s, maprange((0, 10), (-1, 0), s)))
===
template <typename T1, typename T2, typename T3> auto maprange(const T1 &a, const T2 &b, const T3 &s)
{
    return _get<0>(b) + (to_float(s - _get<0>(a)) * (_get<1>(b) - _get<0>(b)) / (_get<1>(a) - _get<0>(a)));
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (int s = 0; s < 11; s++)
            print(u"#2 maps to #."_S.format(s, maprange(make_tuple(0, 10), make_tuple(-1, 0), s)));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Maximum_triangle_path_sum#Python
from typing import List

def solve(tri : List[List[int]]):
    while len(tri) > 1:
        t0 = tri.pop()
        t1 = tri.pop()
        tri.append([max(t0[i], t0[i+1]) + t for i,t in enumerate(t1)])
    return tri[0][0]

data = """                55
                        94 48
                       95 30 96
                     77 71 26 67
                    97 13 76 38 45
                  07 36 79 16 37 68
                 48 07 09 18 70 26 06
               18 72 79 46 59 79 29 90
              20 76 87 11 32 07 07 49 18
            27 83 58 35 71 11 25 57 29 85
           14 64 36 96 27 11 58 56 92 18 55
         02 90 03 60 48 49 41 46 33 36 47 23
        92 50 48 02 36 59 42 79 72 20 82 77 42
      56 78 38 80 39 75 02 71 66 66 01 03 55 72
     44 25 67 84 71 67 11 61 40 57 58 89 40 56 36
   85 32 25 85 57 48 84 35 47 62 17 01 01 99 89 52
  06 71 28 75 94 48 37 10 23 51 06 48 53 18 74 98 15
27 02 92 23 08 71 76 84 15 52 92 63 81 10 44 10 69 93"""

print(solve([list(map(int, row.split())) for row in data.split("\n")]))
===
F solve([[Int]] &tri)
   L tri.len > 1
      V t0 = tri.pop()
      V t1 = tri.pop()
      tri.append(enumerate(t1).map((i, t) -> max(@t0[i], @t0[i + 1]) + t))
   R tri[0][0]

V data = ‘                55
                        94 48
                       95 30 96
                     77 71 26 67
                    97 13 76 38 45
                  07 36 79 16 37 68
                 48 07 09 18 70 26 06
               18 72 79 46 59 79 29 90
              20 76 87 11 32 07 07 49 18
            27 83 58 35 71 11 25 57 29 85
           14 64 36 96 27 11 58 56 92 18 55
         02 90 03 60 48 49 41 46 33 36 47 23
        92 50 48 02 36 59 42 79 72 20 82 77 42
      56 78 38 80 39 75 02 71 66 66 01 03 55 72
     44 25 67 84 71 67 11 61 40 57 58 89 40 56 36
   85 32 25 85 57 48 84 35 47 62 17 01 01 99 89 52
  06 71 28 75 94 48 37 10 23 51 06 48 53 18 74 98 15
27 02 92 23 08 71 76 84 15 52 92 63 81 10 44 10 69 93’

print(solve(&data.split("\n").map(row -> row.split_py().map(Int))))
===
auto solve(Array<Array<int>> &tri)
{
    while (tri.len() > 1) {
        auto t0 = tri.pop();
        auto t1 = tri.pop();
        tri.append(enumerate(t1).map([&t0](const auto &i, const auto &t){return max(t0[i], t0[i + 1]) + t;}));
    }
    return _get<0>(_get<0>(tri));
}

auto data = uR"(                55
                        94 48
                       95 30 96
                     77 71 26 67
                    97 13 76 38 45
                  07 36 79 16 37 68
                 48 07 09 18 70 26 06
               18 72 79 46 59 79 29 90
              20 76 87 11 32 07 07 49 18
            27 83 58 35 71 11 25 57 29 85
           14 64 36 96 27 11 58 56 92 18 55
         02 90 03 60 48 49 41 46 33 36 47 23
        92 50 48 02 36 59 42 79 72 20 82 77 42
      56 78 38 80 39 75 02 71 66 66 01 03 55 72
     44 25 67 84 71 67 11 61 40 57 58 89 40 56 36
   85 32 25 85 57 48 84 35 47 62 17 01 01 99 89 52
  06 71 28 75 94 48 37 10 23 51 06 48 53 18 74 98 15
27 02 92 23 08 71 76 84 15 52 92 63 81 10 44 10 69 93)"_S;

struct CodeBlock1
{
    CodeBlock1()
    {
        print(solve(make_ref(data.split(u"\n"_S).map([](const auto &row){return row.split_py().map([](const auto &x){return to_int(x);});}))));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Menu
items = ['fee fie', 'huff and puff', 'mirror mirror', 'tick tock']

while True:
    for i, item in enumerate(items):
        print ("%2i. %s" % (i + 1, item))
    reply = input('Which is from the three pigs: ').strip(' ')
    if not reply.isdigit():
        continue
    if 1 <= int(reply) <= len(items):
        print('You chose:', items[int(reply) - 1])
        break
===
V items = [‘fee fie’, ‘huff and puff’, ‘mirror mirror’, ‘tick tock’]

L
   L(item) items
      V i = L.index
      print(‘#2. #.’.format(i + 1, item))
   V reply = input(‘Which is from the three pigs: ’).trim(‘ ’)
   I !reply.is_digit()
      L.continue
   I Int(reply) C 1 .. items.len
      print(‘You chose: ’items[Int(reply) - 1])
      L.break
===
auto items = create_array({u"fee fie"_S, u"huff and puff"_S, u"mirror mirror"_S, u"tick tock"_S});

struct CodeBlock1
{
    CodeBlock1()
    {
        while (true) {
            {int Lindex = 0;
            for (auto &&item : items) {
                auto i = Lindex;
                print(u"#2. #."_S.format(i + 1, item));
                Lindex++;
            }}
            auto reply = input(u"Which is from the three pigs: "_S).trim(u" "_S);
            if (!reply.is_digit())
                continue;
            if (in(to_int(reply), range_ee(1, items.len()))) {
                print(u"You chose: "_S & items[to_int(reply) - 1]);
                break;
            }
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Metronome
import time

def main(bpm = 72, bpb = 4):
    t = 60.0 / bpm
    counter = 0
    while True:
        counter += 1
        if counter % bpb != 0:
            print('tick')
        else:
            print('TICK')
        time.sleep(t)

main()
===
F main(bpm = 72, bpb = 4)
   V t = 60.0 / bpm
   V counter = 0
   L
      counter++
      I counter % bpb != 0
         print(‘tick’)
      E
         print(‘TICK’)
      sleep(t)

main()
===
template <typename T1 = decltype(72), typename T2 = decltype(4)> auto _main_(const T1 &bpm = 72, const T2 &bpb = 4)
{
    auto t = 60.0 / bpm;
    auto counter = 0;
    while (true) {
        counter++;
        if (mod(counter, bpb) != 0)
            print(u"tick"_S);
        else
            print(u"TICK"_S);
        sleep(t);
    }
}

struct CodeBlock1
{
    CodeBlock1()
    {
        _main_();
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Mian-Chowla_sequence#C.2B.2B
def contains(sums, s, ss):
    for i in range(ss):
        if sums[i] == s:
            return True
    return False

def mian_chowla():
    n = 100
    mc = [0] * n
    mc[0] = 1
    sums = [0] * ((n * (n + 1)) >> 1)
    sums[0] = 2
    ss = 1
    for i in range(1, n):
        le = ss
        j = mc[i - 1] + 1
        while True:
            mc[i] = j
            nxtJ = False
            for k in range(i + 1):
                sum = mc[k] + j
                if contains(sums, sum, ss):
                    ss = le
                    nxtJ = True
                    break
                sums[ss] = sum
                ss += 1
            if not nxtJ:
                break
            j += 1
    return mc

print('The first 30 terms of the Mian-Chowla sequence are:')
mc = mian_chowla()
print(*mc[:30])
print()
print('Terms 91 to 100 of the Mian-Chowla sequence are:')
print(*mc[90:])
===
F contains(sums, s, ss)
   L(i) 0 .< ss
      I sums[i] == s
         R 1B
   R 0B

F mian_chowla()
   V n = 100
   V mc = [0] * n
   mc[0] = 1
   V sums = [0] * ((n * (n + 1)) >> 1)
   sums[0] = 2
   V ss = 1
   L(i) 1 .< n
      V le = ss
      V j = mc[i - 1] + 1
      L
         mc[i] = j
         V nxtJ = 0B
         L(k) 0 .. i
            V sum = mc[k] + j
            I contains(sums, sum, ss)
               ss = le
               nxtJ = 1B
               L.break
            sums[ss] = sum
            ss++
         I !nxtJ
            L.break
         j++
   R mc

print(‘The first 30 terms of the Mian-Chowla sequence are:’)
V mc = mian_chowla()
print_elements(mc[0.<30])
print()
print(‘Terms 91 to 100 of the Mian-Chowla sequence are:’)
print_elements(mc[90..])
===
template <typename T1, typename T2, typename T3> auto contains(const T1 &sums, const T2 &s, const T3 &ss)
{
    for (auto i : range_el(0, ss))
        if (sums[i] == s)
            return true;
    return false;
}

auto mian_chowla()
{
    auto n = 100;
    auto mc = create_array({0}) * n;
    _set<0>(mc, 1);
    auto sums = create_array({0}) * ((n * (n + 1)) >> 1);
    _set<0>(sums, 2);
    auto ss = 1;
    for (auto i : range_el(1, n)) {
        auto le = ss;
        auto j = mc[i - 1] + 1;
        while (true) {
            mc.set(i, j);
            auto nxtJ = false;
            for (auto k : range_ee(0, i)) {
                auto sum = mc[k] + j;
                if (contains(sums, sum, ss)) {
                    ss = le;
                    nxtJ = true;
                    break;
                }
                sums.set(ss, sum);
                ss++;
            }
            if (!nxtJ)
                break;
            j++;
        }
    }
    return mc;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"The first 30 terms of the Mian-Chowla sequence are:"_S);
    }
} code_block_1;

auto mc = mian_chowla();

struct CodeBlock2
{
    CodeBlock2()
    {
        print_elements(mc[range_el(0, 30)]);
        print();
        print(u"Terms 91 to 100 of the Mian-Chowla sequence are:"_S);
        print_elements(mc[range_ei(90)]);
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Modular_inverse#C
def mul_inv(a, b):
    b0 = b
    x0 = 0
    x1 = 1
    if b == 1: return 1
    while a > 1:
        q = a // b
        (a, b) = (b, a % b)
        (x0, x1) = (x1 - q * x0, x0)
    if x1 < 0: x1 += b0
    return x1

print(mul_inv(42, 2017))
===
F mul_inv(=a, =b)
   V b0 = b
   V x0 = 0
   V x1 = 1
   I b == 1
      R 1
   L a > 1
      V q = a I/ b
      (a, b) = (b, a % b)
      (x0, x1) = (x1 - q * x0, x0)
   I x1 < 0
      x1 += b0
   R x1

print(mul_inv(42, 2017))
===
template <typename T1, typename T2> auto mul_inv(T1 a, T2 b)
{
    auto b0 = b;
    auto x0 = 0;
    auto x1 = 1;
    if (b == 1)
        return 1;
    while (a > 1) {
        auto q = idiv(a, b);
        assign_from_tuple(a, b, make_tuple(b, mod(a, b)));
        assign_from_tuple(x0, x1, make_tuple(x1 - q * x0, x0));
    }
    if (x1 < 0)
        x1 += b0;
    return x1;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(mul_inv(42, 2017));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Monte_Carlo_methods
import random

def monte_carlo_pi(n):
    inside = 0
    for i in range(n):
        x = random.random()
        y = random.random()
        if x*x + y*y <= 1:
            inside += 1
    return 4.0 * inside / n

print(monte_carlo_pi(1000000))
===
F monte_carlo_pi(n)
   V inside = 0
   L(i) 0 .< n
      V x = random:()
      V y = random:()
      I x * x + y * y <= 1
         inside++
   R 4.0 * inside / n

print(monte_carlo_pi(1000000))
===
template <typename T1> auto monte_carlo_pi(const T1 &n)
{
    auto inside = 0;
    for (auto i : range_el(0, n)) {
        auto x = randomns::_();
        auto y = randomns::_();
        if (x * x + y * y <= 1)
            inside++;
    }
    return 4.0 * inside / n;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(monte_carlo_pi(1000000));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Move-to-front_algorithm#Python
symboltable = list('abcdefghijklmnopqrstuvwxyz')

def move2front_encode(strng):
    sequence : List[int] = []
    pad = symboltable[:]
    for char in strng:
        indx = pad.index(char)
        sequence.append(indx)
        pad = [pad.pop(indx)] + pad
    return sequence

def move2front_decode(sequence):
    chars : List[Char] = []
    pad = symboltable[:]
    for indx in sequence:
        char = pad[indx]
        chars.append(char)
        pad = [pad.pop(indx)] + pad
    return ''.join(chars)

for s in ['broood', 'bananaaa', 'hiphophiphop']:
    encode = move2front_encode(s)
    print('%14s encodes to %s' % (s, encode), end=', ')
    decode = move2front_decode(encode)
    print('which decodes back to %s' % decode)
    assert s == decode, 'Whoops!'
===
V symboltable = Array(‘abcdefghijklmnopqrstuvwxyz’)

F move2front_encode(strng)
   [Int] sequence
   V pad = copy(:symboltable)
   L(char) strng
      V indx = pad.index(char)
      sequence.append(indx)
      pad = [pad.pop(indx)] [+] pad
   R sequence

F move2front_decode(sequence)
   [Char] chars
   V pad = copy(:symboltable)
   L(indx) sequence
      V char = pad[indx]
      chars.append(char)
      pad = [pad.pop(indx)] [+] pad
   R chars.join(‘’)

L(s) [‘broood’, ‘bananaaa’, ‘hiphophiphop’]
   V encode = move2front_encode(s)
   print(‘#14 encodes to #.’.format(s, encode), end' ‘, ’)
   V decode = move2front_decode(encode)
   print(‘which decodes back to #.’.format(decode))
   assert(s == decode, ‘Whoops!’)
===
auto symboltable = create_array(u"abcdefghijklmnopqrstuvwxyz"_S);

template <typename T1> auto move2front_encode(const T1 &strng)
{
    Array<int> sequence;
    auto pad = copy(::symboltable);
    for (auto &&_char_ : strng) {
        auto indx = pad.index(_char_);
        sequence.append(indx);
        pad = create_array({pad.pop(indx)}) + pad;
    }
    return sequence;
}

template <typename T1> auto move2front_decode(const T1 &sequence)
{
    Array<Char> chars;
    auto pad = copy(::symboltable);
    for (auto &&indx : sequence) {
        auto _char_ = pad[indx];
        chars.append(_char_);
        pad = create_array({pad.pop(indx)}) + pad;
    }
    return chars.join(u""_S);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&s : create_array({u"broood"_S, u"bananaaa"_S, u"hiphophiphop"_S})) {
            auto encode = move2front_encode(s);
            print(u"#14 encodes to #."_S.format(s, encode), u", "_S);
            auto decode = move2front_decode(encode);
            print(u"which decodes back to #."_S.format(decode));
            assert(s == decode, u"Whoops!"_S);
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Multisplit#Python
def multisplit(text, sep):
    lastmatch = 0
    i = 0
    matches = ''
    while i < len(text):
        for j, s in enumerate(sep):
            if text[i:].startswith(s):
                if i > lastmatch:
                    matches += text[lastmatch:i]
                matches += '{' + s + '}'
                lastmatch = i + len(s)
                i += len(s)
                break
        else:
            i += 1
    if i > lastmatch:
        matches += text[lastmatch:i]
    return matches

print(multisplit('a!===b=!=c', ['==', '!=', '=']))
===
F multisplit(text, sep)
   V lastmatch = 0
   V i = 0
   V matches = ‘’
   L i < text.len
      L(s) sep
         V j = L.index
         I text[i ..].starts_with(s)
            I i > lastmatch
               matches ‘’= text[lastmatch .< i]
            matches ‘’= ‘{’s‘}’
            lastmatch = i + s.len
            i += s.len
            L.break
      L.was_no_break
         i++
   I i > lastmatch
      matches ‘’= text[lastmatch .< i]
   R matches

print(multisplit(‘a!===b=!=c’, [‘==’, ‘!=’, ‘=’]))
===
template <typename T1, typename T2> auto multisplit(const T1 &text, const T2 &sep)
{
    auto lastmatch = 0;
    auto i = 0;
    auto matches = u""_S;
    while (i < text.len()) {
        {int Lindex = 0;
        for (auto &&s : sep) {
            auto j = Lindex;
            if (text[range_ei(i)].starts_with(s)) {
                if (i > lastmatch)
                    matches &= text[range_el(lastmatch, i)];
                matches &= u"{"_S & s & u"}"_S;
                lastmatch = i + s.len();
                i += s.len();
                goto break_;
            }
            Lindex++;
        }}
        i++;
        break_:;
    }
    if (i > lastmatch)
        matches &= text[range_el(lastmatch, i)];
    return matches;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(multisplit(u"a!===b=!=c"_S, create_array({u"=="_S, u"!="_S, u"="_S})));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Munchausen_numbers#Python
for i in range(5000):
    if i == sum(int(x) ** int(x) for x in str(i)):
        print(i)
===
L(i) 5000
   I i == sum(String(i).map(x -> Int(x) ^ Int(x)))
      print(i)
===
struct CodeBlock1
{
    CodeBlock1()
    {
        for (int i = 0; i < 5000; i++)
            if (i == sum_map(String(i), [](const auto &x){return pow(to_int(x), to_int(x));}))
                print(i);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Magic_squares_of_doubly_even_order#Java
def magicSquareDoublyEven(n):
    bits = 0b1001_0110_0110_1001
    size = n * n
    mult = n // 4

    result = [[0]*n for i in range(n)]
    i = 0
    for r in range(n):
        for c in range(n):
            bitPos = c // mult + (r // mult) * 4
            result[r][c] = i + 1 if (bits & (1 << bitPos)) != 0 else size - i
            i += 1
    return result

n = 8
for row in magicSquareDoublyEven(n):
    for x in row:
        print('%2s ' % x, end = '')
    print()
print("\nMagic constant: %d" % ((n * n + 1) * n // 2))
===
F magicSquareDoublyEven(n)
   V bits = 1001'0110'0110'1001b
   V size = n * n
   V mult = n I/ 4

   V result = [[0] * n] * n
   V i = 0
   L(r) 0 .< n
      L(c) 0 .< n
         V bitPos = c I/ mult + (r I/ mult) * 4
         result[r][c] = I (bits [&] (1 << bitPos)) != 0 {i + 1} E size - i
         i++
   R result

V n = 8
L(row) magicSquareDoublyEven(n)
   L(x) row
      print(‘#2 ’.format(x), end' ‘’)
   print()
print("\nMagic constant: #.".format((n * n + 1) * n I/ 2))
===
template <typename T1> auto magicSquareDoublyEven(const T1 &n)
{
    auto bits = 0b1001'0110'0110'1001;
    auto size = n * n;
    auto mult = idiv(n, 4);

    auto result = create_array({create_array({0}) * n}) * n;
    auto i = 0;
    for (auto r : range_el(0, n))
        for (auto c : range_el(0, n)) {
            auto bitPos = idiv(c, mult) + (idiv(r, mult)) * 4;
            result[r].set(c, (bits & (1 << bitPos)) != 0 ? i + 1 : size - i);
            i++;
        }
    return result;
}

auto n = 8;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&row : magicSquareDoublyEven(n)) {
            for (auto &&x : row)
                print(u"#2 "_S.format(x), u""_S);
            print();
        }
        print(u"\nMagic constant: #."_S.format(idiv((n * n + 1) * n, 2)));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Maze_solving#Python
def dijkstra(graph, source):
    # graph[u][v] is the weight from u to v (however 0 means infinity)
    n = len(graph)
    dist = [float('infinity')]*n   # Unknown distance function from source to v
    previous = [-1]*n # Previous node in optimal path from source
    dist[source] = 0        # Distance from source to source
    Q = list(range(n)) # All nodes in the graph are unoptimized - thus are in Q
    while len(Q) != 0:           # The main loop
        u = min(Q, key=lambda n:dist[n])                 # vertex in Q with smallest dist[]
        Q.remove(u)
        if dist[u] == float('infinity'):
            break # all remaining vertices are inaccessible from source
        for v in range(n):               # each neighbor v of u
            if graph[u][v] and (v in Q): # where v has not yet been visited
                alt = dist[u] + graph[u][v]
                if alt < dist[v]:       # Relax (u,v,a)
                    dist[v] = alt
                    previous[v] = u
    return previous

def display_solution(predecessor):
    cell = len(predecessor)-1
    while cell != 0:
        print(cell,end='<')
        cell = predecessor[cell]
    print(0)

graph = [
    [0,1,0,0,0,0,],
    [1,0,1,0,1,0,],
    [0,1,0,0,0,1,],
    [0,0,0,0,1,0,],
    [0,1,0,1,0,0,],
    [0,0,1,0,0,0,]
]

display_solution(dijkstra(graph, 0))
===
F dijkstra(graph, source)
   V n = graph.len
   V dist = [Float.infinity] * n
   V previous = [-1] * n
   dist[source] = 0
   V Q = Array(0 .< n)
   L !Q.empty
      V u = min(Q, key' n -> @dist[n])
      Q.remove(u)
      I dist[u] == Float.infinity
         L.break
      L(v) 0 .< n
         I graph[u][v] & (v C Q)
            V alt = dist[u] + graph[u][v]
            I alt < dist[v]
               dist[v] = alt
               previous[v] = u
   R previous

F display_solution(predecessor)
   V cell = predecessor.len - 1
   L cell != 0
      print(cell, end' ‘<’)
      cell = predecessor[cell]
   print(0)

V graph = [[0, 1, 0, 0, 0, 0], [1, 0, 1, 0, 1, 0], [0, 1, 0, 0, 0, 1], [0, 0, 0, 0, 1, 0], [0, 1, 0, 1, 0, 0], [0, 0, 1, 0, 0, 0]]

display_solution(dijkstra(graph, 0))
===
template <typename T1, typename T2> auto dijkstra(const T1 &graph, const T2 &source)
{
    auto n = graph.len();
    auto dist = create_array({std::numeric_limits<double>::infinity()}) * n;
    auto previous = create_array({-1}) * n;
    dist.set(source, 0);
    auto Q = create_array(range_el(0, n));
    while (!Q.empty()) {
        auto u = min_with_key(Q, [&dist](const auto &n){return dist[n];});
        Q.remove(u);
        if (dist[u] == std::numeric_limits<double>::infinity())
            break;
        for (auto v : range_el(0, n))
            if (graph[u][v] && (in(v, Q))) {
                auto alt = dist[u] + graph[u][v];
                if (alt < dist[v]) {
                    dist.set(v, alt);
                    previous.set(v, u);
                }
            }
    }
    return previous;
}

template <typename T1> auto display_solution(const T1 &predecessor)
{
    auto cell = predecessor.len() - 1;
    while (cell != 0) {
        print(cell, u"<"_S);
        cell = predecessor[cell];
    }
    print(0);
}

auto graph = create_array({create_array({0, 1, 0, 0, 0, 0}), create_array({1, 0, 1, 0, 1, 0}), create_array({0, 1, 0, 0, 0, 1}), create_array({0, 0, 0, 0, 1, 0}), create_array({0, 1, 0, 1, 0, 0}), create_array({0, 0, 1, 0, 0, 0})});

struct CodeBlock1
{
    CodeBlock1()
    {
        display_solution(dijkstra(graph, 0));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Merge_and_aggregate_datasets#Python
from copy import deepcopy

patients_csv = '''PATIENT_ID,LASTNAME
1001,Hopper
4004,Wirth
3003,Kemeny
2002,Gosling
5005,Kurtz'''

visits_csv = '''PATIENT_ID,VISIT_DATE,SCORE
2002,2020-09-10,6.8
1001,2020-09-17,5.5
4004,2020-09-24,8.4
2002,2020-10-08,
1001,,6.6
3003,2020-11-12,
4004,2020-11-05,7.0
1001,2020-11-19,5.3'''

def csv2list(s):
    rows : List[List[str]] = []
    for row in s.split("\n"):
        rows += [row.split(',')]
    return rows

patients = csv2list(patients_csv)
visits   = csv2list(visits_csv)
result = deepcopy(patients)
result[1:] = sorted(result[1:])
#%%
result[0].append('LAST_VISIT')
last = {p_vis[0]: p_vis[1] for p_vis in visits[1:]}
for record in range(1, len(result)):
    result[record].append(last.get(result[record][0], ''))
#%%
result[0] += ['SCORE_SUM', 'SCORE_AVG']
n = {p[0]: 0 for p in patients[1:]}
tot = {p[0]: 0.0 for p in patients[1:]}
for record in visits[1:]:
    p = record[0]
    score = record[2]
    if len(score) != 0:
        n[p] += 1
        tot[p] += float(score)
for record in range(1, len(result)):
    p = result[record][0]
    if n[p] != 0:
        result[record] += ['{:5.1f}'.format(tot[p]), '{:5.2f}'.format(tot[p] / n[p])]
    else:
        result[record] += ['', '']
#%%
for record in result:
    print('| ' + ' | '.join(r.center(10) for r in record) + ' |')
===
V patients_csv = ‘PATIENT_ID,LASTNAME
1001,Hopper
4004,Wirth
3003,Kemeny
2002,Gosling
5005,Kurtz’

V visits_csv = ‘PATIENT_ID,VISIT_DATE,SCORE
2002,2020-09-10,6.8
1001,2020-09-17,5.5
4004,2020-09-24,8.4
2002,2020-10-08,
1001,,6.6
3003,2020-11-12,
4004,2020-11-05,7.0
1001,2020-11-19,5.3’

F csv2list(s)
   [[String]] rows
   L(row) s.split("\n")
      rows [+]= row.split(‘,’)
   R rows

V patients = csv2list(patients_csv)
V visits = csv2list(visits_csv)
V result = copy(patients)
result.sort_range(1..)
result[0].append(‘LAST_VISIT’)
V last = Dict(visits[1..], p_vis -> (p_vis[0], p_vis[1]))
L(record) 1 .< result.len
   result[record].append(last.get(result[record][0], ‘’))
result[0] [+]= [‘SCORE_SUM’, ‘SCORE_AVG’]
V n = Dict(patients[1..], p -> (p[0], 0))
V tot = Dict(patients[1..], p -> (p[0], 0.0))
L(record) visits[1..]
   V p = record[0]
   V score = record[2]
   I !score.empty
      n[p]++
      tot[p] += Float(score)
L(record) 1 .< result.len
   V p = result[record][0]
   I n[p] != 0
      result[record] [+]= [‘#3.1’.format(tot[p]), ‘#2.2’.format(tot[p] / n[p])]
   E
      result[record] [+]= [‘’, ‘’]
L(record) result
   print(‘| ’record.map(r -> r.center(10)).join(‘ | ’)‘ |’)
===
auto patients_csv = uR"(PATIENT_ID,LASTNAME
1001,Hopper
4004,Wirth
3003,Kemeny
2002,Gosling
5005,Kurtz)"_S;

auto visits_csv = uR"(PATIENT_ID,VISIT_DATE,SCORE
2002,2020-09-10,6.8
1001,2020-09-17,5.5
4004,2020-09-24,8.4
2002,2020-10-08,
1001,,6.6
3003,2020-11-12,
4004,2020-11-05,7.0
1001,2020-11-19,5.3)"_S;

template <typename T1> auto csv2list(const T1 &s)
{
    Array<Array<String>> rows;
    for (auto &&row : s.split(u"\n"_S))
        rows.append(row.split(u","_S));
    return rows;
}

auto patients = csv2list(patients_csv);
auto visits = csv2list(visits_csv);
auto result = copy(patients);

struct CodeBlock1
{
    CodeBlock1()
    {
        result.sort_range(range_ei(1));
        _get<0>(result).append(u"LAST_VISIT"_S);
    }
} code_block_1;

auto last = create_dict(visits[range_ei(1)], [](const auto &p_vis){return make_tuple(_get<0>(p_vis), _get<1>(p_vis));});

struct CodeBlock2
{
    CodeBlock2()
    {
        for (auto record : range_el(1, result.len()))
            result[record].append(last.get(_get<0>(result[record]), u""_S));
        _get<0>(result).append(create_array({u"SCORE_SUM"_S, u"SCORE_AVG"_S}));
    }
} code_block_2;

auto n = create_dict(patients[range_ei(1)], [](const auto &p){return make_tuple(_get<0>(p), 0);});
auto tot = create_dict(patients[range_ei(1)], [](const auto &p){return make_tuple(_get<0>(p), 0.0);});

struct CodeBlock3
{
    CodeBlock3()
    {
        for (auto &&record : visits[range_ei(1)]) {
            auto p = _get<0>(record);
            auto score = _get<2>(record);
            if (!score.empty()) {
                n[p]++;
                tot[p] += to_float(score);
            }
        }
        for (auto record : range_el(1, result.len())) {
            auto p = _get<0>(result[record]);
            if (n[p] != 0)
                result[record].append(create_array({u"#3.1"_S.format(tot[p]), u"#2.2"_S.format(tot[p] / n[p])}));
            else
                result[record].append(create_array({u""_S, u""_S}));
        }
        for (auto &&record : result)
            print(u"| "_S & record.map([](const auto &r){return r.center(10);}).join(u" | "_S) & u" |"_S);
    }
} code_block_3;


# https://www.rosettacode.org/wiki/Montgomery_reduction#Python
BigInt = int

class Montgomery:
    m : BigInt
    n : int
    rrm : BigInt

    def __init__(self, m):
        self.m = m
        self.n = m.bit_length()
        self.rrm = (BigInt(2) ** (self.n * 2)) % m

    def reduce(self, t):
        a = t
        for i in range(self.n):
            if (a % 2) == 1:
                a += self.m
            a //= 2
        if a >= self.m:
            a -= self.m
        return a

m  = BigInt('750791094644726559640638407699')
x1 = BigInt('540019781128412936473322405310')
x2 = BigInt('515692107665463680305819378593')

mont = Montgomery(m)
t1 = x1 * mont.rrm
t2 = x2 * mont.rrm

r1 = mont.reduce(t1)
r2 = mont.reduce(t2)
r = BigInt(2) ** mont.n

print("b :", 2)
print("n :", mont.n)
print("r :", r)
print("m :", mont.m)
print("t1:", t1)
print("t2:", t2)
print("r1:", r1)
print("r2:", r2)
print()
print("Original x1       :", x1)
print("Recovered from r1 :", mont.reduce(r1))
print("Original x2       :", x2)
print("Recovered from r2 :", mont.reduce(r2))

print("\nMontgomery computation of x1 ^ x2 mod m:")
prod = mont.reduce(mont.rrm)
base = mont.reduce(x1 * mont.rrm)
ex = x2
while ex.bit_length() > 0:
    if (ex % 2) == 1:
        prod = mont.reduce(prod * base)
    ex //= 2
    base = mont.reduce(base * base)
print(mont.reduce(prod))
print("\nAlternate computation of x1 ^ x2 mod m:")
print(pow(x1, x2, m))
===
T Montgomery
   BigInt m
   Int n
   BigInt rrm

   F (m)
      .m = m
      .n = bit_length(m)
      .rrm = (BigInt(2) ^ (.n * 2)) % m

   F reduce(t)
      V a = t
      L(i) 0 .< .n
         I (a % 2) == 1
            a += .m
         a I/= 2
      I a >= .m
         a -= .m
      R a

V m = BigInt(‘750791094644726559640638407699’)
V x1 = BigInt(‘540019781128412936473322405310’)
V x2 = BigInt(‘515692107665463680305819378593’)

V mont = Montgomery(m)
V t1 = x1 * mont.rrm
V t2 = x2 * mont.rrm

V r1 = mont.reduce(t1)
V r2 = mont.reduce(t2)
V r = BigInt(2) ^ mont.n

print(‘b : ’(2))
print(‘n : ’(mont.n))
print(‘r : ’r)
print(‘m : ’(mont.m))
print(‘t1: ’t1)
print(‘t2: ’t2)
print(‘r1: ’r1)
print(‘r2: ’r2)
print()
print(‘Original x1       : ’x1)
print(‘Recovered from r1 : ’mont.reduce(r1))
print(‘Original x2       : ’x2)
print(‘Recovered from r2 : ’mont.reduce(r2))

print("\nMontgomery computation of x1 ^ x2 mod m:")
V prod = mont.reduce(mont.rrm)
V base = mont.reduce(x1 * mont.rrm)
V ex = x2
L bit_length(ex) > 0
   I (ex % 2) == 1
      prod = mont.reduce(prod * base)
   ex I/= 2
   base = mont.reduce(base * base)
print(mont.reduce(prod))
print("\nAlternate computation of x1 ^ x2 mod m:")
print(pow(x1, x2, m))
===
class Montgomery
{
public:
    BigInt m;
    int n;
    BigInt rrm;

    template <typename T1> Montgomery(const T1 &m) :
        m(m)
    {
        n = bit_length(m);
        rrm = mod((pow(BigInt(2), (n * 2))), m);
    }

    template <typename T1> auto reduce(const T1 &t)
    {
        auto a = t;
        for (auto i : range_el(0, n)) {
            if ((mod(a, 2)) == 1)
                a += m;
            a = idiv(a, 2);
        }
        if (a >= m)
            a -= m;
        return a;
    }
};

auto m = BigInt(u"750791094644726559640638407699"_S);
auto x1 = BigInt(u"540019781128412936473322405310"_S);
auto x2 = BigInt(u"515692107665463680305819378593"_S);

auto mont = Montgomery(m);
auto t1 = x1 * mont.rrm;
auto t2 = x2 * mont.rrm;

auto r1 = mont.reduce(t1);
auto r2 = mont.reduce(t2);
auto r = pow(BigInt(2), mont.n);

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"b : "_S & (2));
        print(u"n : "_S & (mont.n));
        print(u"r : "_S & r);
        print(u"m : "_S & (mont.m));
        print(u"t1: "_S & t1);
        print(u"t2: "_S & t2);
        print(u"r1: "_S & r1);
        print(u"r2: "_S & r2);
        print();
        print(u"Original x1       : "_S & x1);
        print(u"Recovered from r1 : "_S & mont.reduce(r1));
        print(u"Original x2       : "_S & x2);
        print(u"Recovered from r2 : "_S & mont.reduce(r2));

        print(u"\nMontgomery computation of x1 ^ x2 mod m:"_S);
    }
} code_block_1;

auto prod = mont.reduce(mont.rrm);
auto base = mont.reduce(x1 * mont.rrm);
auto ex = x2;

struct CodeBlock2
{
    CodeBlock2()
    {
        while (bit_length(ex) > 0) {
            if ((mod(ex, 2)) == 1)
                prod = mont.reduce(prod * base);
            ex = idiv(ex, 2);
            base = mont.reduce(base * base);
        }
        print(mont.reduce(prod));
        print(u"\nAlternate computation of x1 ^ x2 mod m:"_S);
        print(pow(x1, x2, m));
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Magic_8-ball#Python
import random

s = ['It is certain', 'It is decidedly so', 'Without a doubt', 'Yes, definitely',
 'You may rely on it', 'As I see it, yes', 'Most likely', 'Outlook good',
 'Signs point to yes', 'Yes', 'Reply hazy, try again', 'Ask again later',
 'Better not tell you now', 'Cannot predict now', 'Concentrate and ask again',
 "Don't bet on it", 'My reply is no', 'My sources say no', 'Outlook not so good',
 'Very doubtful']

qs = set() # str

while True:
    question = input('Ask your question:')
    if len(question) == 0: break

    answer = random.choice(s)

    if question in qs:
        print('Your question has already been answered')
    else:
        qs.add(question)
        print(answer)
===
V s = [‘It is certain’, ‘It is decidedly so’, ‘Without a doubt’, ‘Yes, definitely’, ‘You may rely on it’, ‘As I see it, yes’, ‘Most likely’, ‘Outlook good’, ‘Signs point to yes’, ‘Yes’, ‘Reply hazy, try again’, ‘Ask again later’, ‘Better not tell you now’, ‘Cannot predict now’, ‘Concentrate and ask again’, ‘Don't bet on it’, ‘My reply is no’, ‘My sources say no’, ‘Outlook not so good’, ‘Very doubtful’]

V qs = Set[String]()

L
   V question = input(‘Ask your question:’)
   I question.empty
      L.break

   V answer = random:choice(s)

   I question C qs
      print(‘Your question has already been answered’)
   E
      qs.add(question)
      print(answer)
===
auto s = create_array({u"It is certain"_S, u"It is decidedly so"_S, u"Without a doubt"_S, u"Yes, definitely"_S, u"You may rely on it"_S, u"As I see it, yes"_S, u"Most likely"_S, u"Outlook good"_S, u"Signs point to yes"_S, u"Yes"_S, u"Reply hazy, try again"_S, u"Ask again later"_S, u"Better not tell you now"_S, u"Cannot predict now"_S, u"Concentrate and ask again"_S, u"Don't bet on it"_S, u"My reply is no"_S, u"My sources say no"_S, u"Outlook not so good"_S, u"Very doubtful"_S});

auto qs = Set<String>();

struct CodeBlock1
{
    CodeBlock1()
    {
        while (true) {
            auto question = input(u"Ask your question:"_S);
            if (question.empty())
                break;

            auto answer = randomns::choice(s);

            if (in(question, qs))
                print(u"Your question has already been answered"_S);
            else {
                qs.add(question);
                print(answer);
            }
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Markov_chain_text_generator#Python
import random

def makerule(data, context):
    '''Make a rule dict for given data.'''
    rule : Dict[str, List[str]] = {}
    words = data.split(' ')
    index = context

    for word in words[index:]:
        key = ' '.join(words[index-context:index])
        if key in rule:
            rule[key].append(word)
        else:
            rule[key] = [word]
        index += 1

    return rule

def makestring(rule, length):
    '''Use a given rule to make a string.'''
    oldwords = random.choice(list(rule.keys())).split(' ') #random starting words
    string = ' '.join(oldwords) + ' '

    for i in range(length):
        try:
            key = ' '.join(oldwords)
            newword = random.choice(rule[key])
            string += newword + ' '

            for word in range(len(oldwords)):
                oldwords[word] = oldwords[(word + 1) % len(oldwords)]
            oldwords[-1] = newword

        except KeyError:
            return string
    return string

data = open('alice_oz.txt').read()
rule = makerule(data, 3)
string = makestring(rule, 100)
max_line_size = 100
cur_line_size = 0
for word in string.split(' '):
    if cur_line_size + len(word) >= max_line_size:
        print()
        cur_line_size = 0
    cur_line_size += len(word) + 1
    print(word, end = ' ')
print()
===
F makerule(data, context)
   ‘Make a rule dict for given data.’
   [String = [String]] rule
   V words = data.split(‘ ’)
   V index = context

   L(word) words[index ..]
      V key = (words[index - context .< index]).join(‘ ’)
      I key C rule
         rule[key].append(word)
      E
         rule[key] = [word]
      index++

   R rule

F makestring(rule, length)
   ‘Use a given rule to make a string.’
   V oldwords = random:choice(Array(rule.keys())).split(‘ ’)
   V string = oldwords.join(‘ ’)‘ ’

   L(i) 0 .< length
      X.try
         V key = oldwords.join(‘ ’)
         V newword = random:choice(rule[key])
         string ‘’= newword‘ ’

         L(word) 0 .< oldwords.len
            oldwords[word] = oldwords[(word + 1) % oldwords.len]
         oldwords.last = newword

      X.catch KeyError
         R string
   R string

V data = File(‘alice_oz.txt’).read()
V rule = makerule(data, 3)
V string = makestring(rule, 100)
V max_line_size = 100
V cur_line_size = 0
L(word) string.split(‘ ’)
   I cur_line_size + word.len >= max_line_size
      print()
      cur_line_size = 0
   cur_line_size += word.len + 1
   print(word, end' ‘ ’)
print()
===
template <typename T1, typename T2> auto makerule(const T1 &data, const T2 &context)
{
    u"Make a rule dict for given data."_S;
    Dict<String, Array<String>> rule;
    auto words = data.split(u" "_S);
    auto index = context;

    for (auto &&word : words[range_ei(index)]) {
        auto key = (words[range_el(index - context, index)]).join(u" "_S);
        if (in(key, rule))
            rule[key].append(word);
        else
            rule.set(key, create_array({word}));
        index++;
    }

    return rule;
}

template <typename T1, typename T2> auto makestring(const T1 &rule, const T2 &length)
{
    u"Use a given rule to make a string."_S;
    auto oldwords = randomns::choice(create_array(rule.keys())).split(u" "_S);
    auto string = oldwords.join(u" "_S) & u" "_S;

    for (auto i : range_el(0, length)) {
        try
        {
            auto key = oldwords.join(u" "_S);
            auto newword = randomns::choice(rule[key]);
            string &= newword & u" "_S;

            for (auto word : range_el(0, oldwords.len()))
                oldwords.set(word, oldwords[mod((word + 1), oldwords.len())]);
            oldwords.last() = newword;
        }

        catch (const KeyError&)
        {
            return string;
        }
    }
    return string;
}

auto data = File(u"alice_oz.txt"_S).read();
auto rule = makerule(data, 3);
auto string = makestring(rule, 100);
auto max_line_size = 100;
auto cur_line_size = 0;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&word : string.split(u" "_S)) {
            if (cur_line_size + word.len() >= max_line_size) {
                print();
                cur_line_size = 0;
            }
            cur_line_size += word.len() + 1;
            print(word, u" "_S);
        }
        print();
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Mastermind#Python
import random

def encode(correct, guess):
    output_arr : List[str] = []

    for i in range(len(correct)):
        output_arr += ['X' if guess[i] == correct[i] else 'O' if guess[i] in correct else '-']

    return output_arr

def safe_int_input(prompt, min_val, max_val):
    while True:
        user_input_str = input(prompt)

        try:
            user_input = int(user_input_str)
            if min_val <= user_input <= max_val:
                return user_input
        except ValueError:
            continue

def play_game():
    print("Welcome to Mastermind.")
    print("You will need to guess a random code.")
    print("For each guess, you will receive a hint.")
    print("In this hint, X denotes a correct letter, and O a letter in the original string but in a different position.")
    print()

    number_of_letters = safe_int_input("Select a number of possible letters for the code (2-20): ", 2, 20)
    code_length = safe_int_input("Select a length for the code (4-10): ", 4, 10)

    letters = 'ABCDEFGHIJKLMNOPQRST'[:number_of_letters]
    code = ''
    for i in range(code_length):
        code += random.choice(letters)
    guesses : List[str] = []

    while True:
        print()
        guess = input("Enter a guess of length {} ({}): ".format(code_length, letters)).upper()

        if len(guess) != code_length or any([char not in letters for char in guess]):
            continue
        elif guess == code:
            print("\nYour guess", guess, 'was correct!')
            break
        else:
            guesses.append("{}: {} => {}".format(len(guesses)+1, ' '.join(list(guess)), ' '.join(encode(code, guess))))

        for i_guess in guesses:
            print("------------------------------------")
            print(i_guess)
        print("------------------------------------")

play_game()
===
F encode(correct, guess)
   [String] output_arr

   L(i) 0 .< correct.len
      output_arr [+]= I guess[i] == correct[i] {‘X’} E I guess[i] C correct {‘O’} E ‘-’

   R output_arr

F safe_int_input(prompt, min_val, max_val)
   L
      V user_input_str = input(prompt)

      X.try
         V user_input = Int(user_input_str)
         I user_input C min_val .. max_val
            R user_input
      X.catch ValueError
         L.continue

F play_game()
   print(‘Welcome to Mastermind.’)
   print(‘You will need to guess a random code.’)
   print(‘For each guess, you will receive a hint.’)
   print(‘In this hint, X denotes a correct letter, and O a letter in the original string but in a different position.’)
   print()

   V number_of_letters = safe_int_input(‘Select a number of possible letters for the code (2-20): ’, 2, 20)
   V code_length = safe_int_input(‘Select a length for the code (4-10): ’, 4, 10)

   V letters = ‘ABCDEFGHIJKLMNOPQRST’[0 .< number_of_letters]
   V code = ‘’
   L(i) 0 .< code_length
      code ‘’= random:choice(letters)
   [String] guesses

   L
      print()
      V guess = input(‘Enter a guess of length #. (#.): ’.format(code_length, letters)).uppercase()

      I guess.len != code_length | any(guess.map(char -> char !C @letters))
         L.continue
      E I guess == code
         print("\nYour guess "guess‘ was correct!’)
         L.break
      E
         guesses.append(‘#.: #. => #.’.format(guesses.len + 1, Array(guess).join(‘ ’), encode(code, guess).join(‘ ’)))

      L(i_guess) guesses
         print(‘------------------------------------’)
         print(i_guess)
      print(‘------------------------------------’)

play_game()
===
template <typename T1, typename T2> auto encode(const T1 &correct, const T2 &guess)
{
    Array<String> output_arr;

    for (auto i : range_el(0, correct.len()))
        output_arr.append(guess[i] == correct[i] ? u"X"_S : in(guess[i], correct) ? u"O"_S : u"-"_S);

    return output_arr;
}

template <typename T1, typename T2, typename T3> auto safe_int_input(const T1 &prompt, const T2 &min_val, const T3 &max_val)
{
    while (true) {
        auto user_input_str = input(prompt);

        try
        {
            auto user_input = to_int(user_input_str);
            if (in(user_input, range_ee(min_val, max_val)))
                return user_input;
        }
        catch (const ValueError&)
        {
            continue;
        }
    }
}

auto play_game()
{
    print(u"Welcome to Mastermind."_S);
    print(u"You will need to guess a random code."_S);
    print(u"For each guess, you will receive a hint."_S);
    print(u"In this hint, X denotes a correct letter, and O a letter in the original string but in a different position."_S);
    print();

    auto number_of_letters = safe_int_input(u"Select a number of possible letters for the code (2-20): "_S, 2, 20);
    auto code_length = safe_int_input(u"Select a length for the code (4-10): "_S, 4, 10);

    auto letters = u"ABCDEFGHIJKLMNOPQRST"_S[range_el(0, number_of_letters)];
    auto code = u""_S;
    for (auto i : range_el(0, code_length))
        code &= randomns::choice(letters);
    Array<String> guesses;

    while (true) {
        print();
        auto guess = input(u"Enter a guess of length #. (#.): "_S.format(code_length, letters)).uppercase();

        if (guess.len() != code_length || any_map(guess, [&letters](const auto &_char_){return !in(_char_, letters);}))
            continue;
        else if (guess == code) {
            print(u"\nYour guess "_S & guess & u" was correct!"_S);
            break;
        }
        else
            guesses.append(u"#.: #. => #."_S.format(guesses.len() + 1, create_array(guess).join(u" "_S), encode(code, guess).join(u" "_S)));

        for (auto &&i_guess : guesses) {
            print(u"------------------------------------"_S);
            print(i_guess);
        }
        print(u"------------------------------------"_S);
    }
}

struct CodeBlock1
{
    CodeBlock1()
    {
        play_game();
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Matrix-exponentiation_operator#Python
def matrix_mul(m1, m2):
    assert(len(m1[0]) == len(m2))
    r = [[0] * len(m2[0]) for i in range(len(m1))]
    for j in range(len(m1)):
        for i in range(len(m2[0])):
            s = 0
            for k in range(len(m2)):
                s += m1[j][k] * m2[k][i]
            r[j][i] = s
    return r

def identity(size):
    rsize = range(size)
    return [[int(i==j) for i in rsize] for j in rsize]

def matrixExp(m, pow):
    assert pow>=0 and int(pow)==pow, "Only non-negative, integer powers allowed"
    accumulator = identity(len(m))
    for i in range(pow):
        accumulator = matrix_mul(accumulator, m)
    return accumulator

def printtable(data):
    for row in data:
        print(' '.join('%-5s' % cell for cell in row))

m = [[3,2], [2,1]]
for i in range(5):
    print('\n%i:' % i)
    printtable( matrixExp(m, i) )

print("\n10:")
printtable( matrixExp(m, 10) )
===
F matrix_mul(m1, m2)
   assert(m1[0].len == m2.len)
   V r = [[0] * m2[0].len] * m1.len
   L(j) 0 .< m1.len
      L(i) 0 .< m2[0].len
         V s = 0
         L(k) 0 .< m2.len
            s += m1[j][k] * m2[k][i]
         r[j][i] = s
   R r

F identity(size)
   V rsize = 0 .< size
   R rsize.map(j -> @rsize.map(i -> Int(i == @j)))

F matrixExp(m, pow)
   assert(pow >= 0 & Int(pow) == pow, ‘Only non-negative, integer powers allowed’)
   V accumulator = identity(m.len)
   L(i) 0 .< pow
      accumulator = matrix_mul(accumulator, m)
   R accumulator

F printtable(data)
   L(row) data
      print(row.map(cell -> ‘#<5’.format(cell)).join(‘ ’))

V m = [[3, 2], [2, 1]]
L(i) 5
   print("\n#.:".format(i))
   printtable(matrixExp(m, i))

print("\n10:")
printtable(matrixExp(m, 10))
===
template <typename T1, typename T2> auto matrix_mul(const T1 &m1, const T2 &m2)
{
    assert(_get<0>(m1).len() == m2.len());
    auto r = create_array({create_array({0}) * _get<0>(m2).len()}) * m1.len();
    for (auto j : range_el(0, m1.len()))
        for (auto i : range_el(0, _get<0>(m2).len())) {
            auto s = 0;
            for (auto k : range_el(0, m2.len()))
                s += m1[j][k] * m2[k][i];
            r[j].set(i, s);
        }
    return r;
}

template <typename T1> auto identity(const T1 &size)
{
    auto rsize = range_el(0, size);
    return rsize.map([&rsize](const auto &j){return rsize.map([&j](const auto &i){return to_int(i == j);});});
}

template <typename T1, typename T2> auto matrixExp(const T1 &m, const T2 &pow)
{
    assert(pow >= 0 && to_int(pow) == pow, u"Only non-negative, integer powers allowed"_S);
    auto accumulator = identity(m.len());
    for (auto i : range_el(0, pow))
        accumulator = matrix_mul(accumulator, m);
    return accumulator;
}

template <typename T1> auto printtable(const T1 &data)
{
    for (auto &&row : data)
        print(row.map([](const auto &cell){return u"#<5"_S.format(cell);}).join(u" "_S));
}

auto m = create_array({create_array({3, 2}), create_array({2, 1})});

struct CodeBlock1
{
    CodeBlock1()
    {
        for (int i = 0; i < 5; i++) {
            print(u"\n#.:"_S.format(i));
            printtable(matrixExp(m, i));
        }

        print(u"\n10:"_S);
        printtable(matrixExp(m, 10));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Matrix_multiplication#Nim
def matrix_mul(m1, m2):
    assert(len(m1[0]) == len(m2))
    r = [[0.0] * len(m2[0]) for i in range(len(m1))]
    for j in range(len(m1)):
        for i in range(len(m2[0])):
            s = 0.0
            for k in range(len(m2)):
                s += m1[j][k] * m2[k][i]
            r[j][i] = s
    return r

def to_str(m):
    result = "(["
    for r in m:
        if len(result) > 2: result += "]\n ["
        for val in r: result += "%8.2f" % val
    return result + "])"

a = [[1.0,  1.0,  1.0,   1.0],
     [2.0,  4.0,  8.0,  16.0],
     [3.0,  9.0, 27.0,  81.0],
     [4.0, 16.0, 64.0, 256.0]]

b = [[    4.0, -3.0  ,  4/3.0,   -1/4.0],
     [-13/3.0, 19/4.0, -7/3.0,  11/24.0],
     [  3/2.0, -2.0  ,  7/6.0,   -1/4.0],
     [ -1/6.0,  1/4.0, -1/6.0,   1/24.0]]

print(to_str(a))
print(to_str(b))
print(to_str(matrix_mul(a, b)))
print(to_str(matrix_mul(b, a)))
===
F matrix_mul(m1, m2)
   assert(m1[0].len == m2.len)
   V r = [[0.0] * m2[0].len] * m1.len
   L(j) 0 .< m1.len
      L(i) 0 .< m2[0].len
         V s = 0.0
         L(k) 0 .< m2.len
            s += m1[j][k] * m2[k][i]
         r[j][i] = s
   R r

F to_str(m)
   V result = ‘([’
   L(r) m
      I result.len > 2
         result ‘’= "]\n ["
      L(val) r
         result ‘’= ‘#5.2’.format(val)
   R result‘])’

V a = [[1.0, 1.0, 1.0, 1.0], [2.0, 4.0, 8.0, 16.0], [3.0, 9.0, 27.0, 81.0], [4.0, 16.0, 64.0, 256.0]]

V b = [[4.0, -3.0, 4 / 3.0, -1 / 4.0], [-13 / 3.0, 19 / 4.0, -7 / 3.0, 11 / 24.0], [3 / 2.0, -2.0, 7 / 6.0, -1 / 4.0], [-1 / 6.0, 1 / 4.0, -1 / 6.0, 1 / 24.0]]

print(to_str(a))
print(to_str(b))
print(to_str(matrix_mul(a, b)))
print(to_str(matrix_mul(b, a)))
===
template <typename T1, typename T2> auto matrix_mul(const T1 &m1, const T2 &m2)
{
    assert(_get<0>(m1).len() == m2.len());
    auto r = create_array({create_array({0.0}) * _get<0>(m2).len()}) * m1.len();
    for (auto j : range_el(0, m1.len()))
        for (auto i : range_el(0, _get<0>(m2).len())) {
            auto s = 0.0;
            for (auto k : range_el(0, m2.len()))
                s += m1[j][k] * m2[k][i];
            r[j].set(i, s);
        }
    return r;
}

template <typename T1> auto to_str(const T1 &m)
{
    auto result = u"(["_S;
    for (auto &&r : m) {
        if (result.len() > 2)
            result &= u"]\n ["_S;
        for (auto &&val : r)
            result &= u"#5.2"_S.format(val);
    }
    return result & u"])"_S;
}

auto a = create_array({create_array({1.0, 1.0, 1.0, 1.0}), create_array({2.0, 4.0, 8.0, 16.0}), create_array({3.0, 9.0, 27.0, 81.0}), create_array({4.0, 16.0, 64.0, 256.0})});

auto b = create_array({create_array({4.0, -3.0, 4.0 / 3.0, -1 / 4.0}), create_array({-13 / 3.0, 19.0 / 4.0, -7 / 3.0, 11.0 / 24.0}), create_array({3.0 / 2.0, -2.0, 7.0 / 6.0, -1 / 4.0}), create_array({-1 / 6.0, 1.0 / 4.0, -1 / 6.0, 1.0 / 24.0})});

struct CodeBlock1
{
    CodeBlock1()
    {
        print(to_str(a));
        print(to_str(b));
        print(to_str(matrix_mul(a, b)));
        print(to_str(matrix_mul(b, a)));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Matrix_chain_multiplication#Nim
from typing import List

class Optimizer:
    dims : List[int]
    m : List[List[int]]
    s : List[List[int]]

    def __init__(self, dims):
        self.dims = dims

    def findMatrixChainOrder(self):
        n = len(self.dims) - 1
        self.m = [[0] * n for i in range(n)]
        self.s = [[0] * n for i in range(n)]

        for lg in range(1, n):
            for i in range(n - lg):
                j = i + lg
                self.m[i][j] = 0x7FFF_FFFF
                for k in range(i, j):
                    cost = self.m[i][k] + self.m[k+1][j] + self.dims[i] * self.dims[k+1] * self.dims[j+1]
                    if cost < self.m[i][j]:
                        self.m[i][j] = cost
                        self.s[i][j] = k

    def optimalChainOrder(self, i, j):
        if i == j:
            return str(chr(i + ord('A')))
        else:
            return '(' + self.optimalChainOrder(i, self.s[i][j]) \
                       + self.optimalChainOrder(self.s[i][j] + 1, j) + ')'

Dims1 = [5, 6, 3, 1]
Dims2 = [1, 5, 25, 30, 100, 70, 2, 1, 100, 250, 1, 1000, 2]
Dims3 = [1000, 1, 500, 12, 1, 700, 2500, 3, 2, 5, 14, 10]

for dims in [Dims1, Dims2, Dims3]:
    opt = Optimizer(dims)
    opt.findMatrixChainOrder()
    print("Dims: ", dims)
    print("Order:", opt.optimalChainOrder(0, len(dims) - 2))
    print("Cost: ", opt.m[0][len(dims) - 2])
    print("")
===
T Optimizer
   [Int] dims
   [[Int]] m
   [[Int]] s

   F (dims)
      .dims = dims

   F findMatrixChainOrder()
      V n = .dims.len - 1
      .m = [[0] * n] * n
      .s = [[0] * n] * n

      L(lg) 1 .< n
         L(i) 0 .< n - lg
            V j = i + lg
            .m[i][j] = 7FFF'FFFF
            L(k) i .< j
               V cost = .m[i][k] + .m[k + 1][j] + .dims[i] * .dims[k + 1] * .dims[j + 1]
               I cost < .m[i][j]
                  .m[i][j] = cost
                  .s[i][j] = k

   F optimalChainOrder(i, j)
      I i == j
         R String(Char(code' i + ‘A’.code))
      E
         R ‘(’(.optimalChainOrder(i, .s[i][j]))‘’.optimalChainOrder(.s[i][j] + 1, j)‘)’

V Dims1 = [5, 6, 3, 1]
V Dims2 = [1, 5, 25, 30, 100, 70, 2, 1, 100, 250, 1, 1000, 2]
V Dims3 = [1000, 1, 500, 12, 1, 700, 2500, 3, 2, 5, 14, 10]

L(dims) [Dims1, Dims2, Dims3]
   V opt = Optimizer(dims)
   opt.findMatrixChainOrder()
   print(‘Dims:  ’dims)
   print(‘Order: ’opt.optimalChainOrder(0, dims.len - 2))
   print(‘Cost:  ’opt.m[0][dims.len - 2])
   print(‘’)
===
class Optimizer
{
public:
    Array<int> dims;
    Array<Array<int>> m;
    Array<Array<int>> s;

    template <typename T1> Optimizer(const T1 &dims) :
        dims(dims)
    {
    }

    auto findMatrixChainOrder()
    {
        auto n = dims.len() - 1;
        m = create_array({create_array({0}) * n}) * n;
        s = create_array({create_array({0}) * n}) * n;

        for (auto lg : range_el(1, n))
            for (auto i : range_el(0, n - lg)) {
                auto j = i + lg;
                m[i].set(j, 0x7FFF'FFFF);
                for (auto k : range_el(i, j)) {
                    auto cost = m[i][k] + m[k + 1][j] + dims[i] * dims[k + 1] * dims[j + 1];
                    if (cost < m[i][j]) {
                        m[i].set(j, cost);
                        s[i].set(j, k);
                    }
                }
            }
    }

    template <typename T1, typename T2> auto optimalChainOrder(const T1 &i, const T2 &j)
    {
        if (i == j)
            return String(Char(i + u'A'_C.code));
        else
            return u"("_S & (optimalChainOrder(i, s[i][j])) & optimalChainOrder(s[i][j] + 1, j) & u")"_S;
    }
};

auto Dims1 = create_array({5, 6, 3, 1});
auto Dims2 = create_array({1, 5, 25, 30, 100, 70, 2, 1, 100, 250, 1, 1000, 2});
auto Dims3 = create_array({1000, 1, 500, 12, 1, 700, 2500, 3, 2, 5, 14, 10});

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&dims : create_array({Dims1, Dims2, Dims3})) {
            auto opt = Optimizer(dims);
            opt.findMatrixChainOrder();
            print(u"Dims:  "_S & dims);
            print(u"Order: "_S & opt.optimalChainOrder(0, dims.len() - 2));
            print(u"Cost:  "_S & _get<0>(opt.m)[dims.len() - 2]);
            print(u""_S);
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Maximum_difference_between_adjacent_elements_of_list#Python
def maxDeltas(ns):
    pairs = [
        (abs(a - b), (a, b)) for a, b
        in zip(ns, ns[1:])
    ]
    delta = max(pairs, key=lambda ab: ab[0])[0]

    return [
        ab for ab in pairs
        if delta == ab[0]
    ]

maxPairs = maxDeltas([
    float(1), 8, 2, -3, 0, 1, 1, -2.3, 0,
    5.5, 8, 6, 2, 9, 11, 10, 3
])

for ab in maxPairs:
    print(ab)
===
F maxDeltas(ns)
   V pairs = zip(ns, ns[1..]).map((a, b) -> (abs(a - b), (a, b)))
   V delta = max(pairs, key' ab -> ab[0])[0]

   R pairs.filter(ab -> @delta == ab[0])

V maxPairs = maxDeltas([Float(1), 8, 2, -3, 0, 1, 1, -2.3, 0, 5.5, 8, 6, 2, 9, 11, 10, 3])

L(ab) maxPairs
   print(ab)
===
template <typename T1> auto maxDeltas(const T1 &ns)
{
    auto pairs = zip(ns, ns[range_ei(1)]).map([](const auto &a, const auto &b){return make_tuple(abs(a - b), make_tuple(a, b));});
    auto delta = _get<0>(max_with_key(pairs, [](const auto &ab){return _get<0>(ab);}));

    return pairs.filter([&delta](const auto &ab){return delta == _get<0>(ab);});
}

auto maxPairs = maxDeltas(create_array<double>({to_float(1), 8, 2, -3, 0, 1, 1, -2.3, 0, 5.5, 8, 6, 2, 9, 11, 10, 3}));

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&ab : maxPairs)
            print(ab);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Mayan_numerals#Nim
UL = "╔"
UC = "╦"
UR = "╗"
LL = "╚"
LC = "╩"
LR = "╝"
HB = "═"
VB = "║"

Mayan = ["    ",
         " ∙  ",
         " ∙∙ ",
         "∙∙∙ ",
         "∙∙∙∙"]

M0 = " @  "
M5 = "────"

def toBase20(n):
    result = [n % 20]
    n //= 20
    while n != 0:
        result += [n % 20]
        n //= 20
    return result[::-1]

def toMayanNumeral(d):
    result = [Mayan[0], Mayan[0], Mayan[0], Mayan[0]]
    if d == 0:
        result[3] = M0
        return result

    for i in range(3, -1, -1):
        if d >= 5:
            result[i] = M5
            d -= 5
        else:
            result[i] = Mayan[d]
            break

    return result

def draw(mayans):
    idx = len(mayans) - 1

    print(UL, end = '')
    for i in range(idx + 1):
        for j in range(4):
            print(HB, end = '')
        if i < idx:
            print(UC, end = '')
        else:
            print(UR)

    for i in range(1, 5):
        print(VB, end = '')
        for j in range(idx + 1):
            print(mayans[j][i-1] + VB, end = '')
        print()

    print(LL, end = '')
    for i in range(idx + 1):
        for j in range(4):
            print(HB, end = '')
        if i < idx:
            print(LC, end = '')
        else:
            print(LR)

for n in [4005, 8017, 326205, 886205, 1081439556]:
    print("Converting", n, "to Mayan:")
    digits = toBase20(n)
    mayans = list(map(lambda d: toMayanNumeral(d), digits))
    draw(mayans)
    print()
===
V UL = ‘╔’
V UC = ‘╦’
V UR = ‘╗’
V LL = ‘╚’
V LC = ‘╩’
V LR = ‘╝’
V HB = ‘═’
V VB = ‘║’

V Mayan = [‘    ’, ‘ ∙  ’, ‘ ∙∙ ’, ‘∙∙∙ ’, ‘∙∙∙∙’]

V M0 = ‘ @  ’
V M5 = ‘────’

F toBase20(=n)
   V result = [n % 20]
   n I/= 20
   L n != 0
      result [+]= n % 20
      n I/= 20
   R reversed(result)

F toMayanNumeral(=d)
   V result = [Mayan[0], Mayan[0], Mayan[0], Mayan[0]]
   I d == 0
      result[3] = :M0
      R result

   L(i) (3 .< -1).step(-1)
      I d >= 5
         result[i] = :M5
         d -= 5
      E
         result[i] = Mayan[d]
         L.break

   R result

F draw(mayans)
   V idx = mayans.len - 1

   print(:UL, end' ‘’)
   L(i) 0 .. idx
      L(j) 4
         print(:HB, end' ‘’)
      I i < idx
         print(:UC, end' ‘’)
      E
         print(:UR)

   L(i) 1..4
      print(:VB, end' ‘’)
      L(j) 0 .. idx
         print(mayans[j][i - 1]‘’:VB, end' ‘’)
      print()

   print(:LL, end' ‘’)
   L(i) 0 .. idx
      L(j) 4
         print(:HB, end' ‘’)
      I i < idx
         print(:LC, end' ‘’)
      E
         print(:LR)

L(n) [4005, 8017, 326205, 886205, 1081439556]
   print(‘Converting ’n‘ to Mayan:’)
   V digits = toBase20(n)
   V mayans = digits.map(d -> toMayanNumeral(d))
   draw(mayans)
   print()
===
auto UL = u"╔"_S;
auto UC = u"╦"_S;
auto UR = u"╗"_S;
auto LL = u"╚"_S;
auto LC = u"╩"_S;
auto LR = u"╝"_S;
auto HB = u"═"_S;
auto VB = u"║"_S;

auto Mayan = create_array({u"    "_S, u" ∙  "_S, u" ∙∙ "_S, u"∙∙∙ "_S, u"∙∙∙∙"_S});

auto M0 = u" @  "_S;
auto M5 = u"────"_S;

template <typename T1> auto toBase20(T1 n)
{
    auto result = create_array({mod(n, 20)});
    n = idiv(n, 20);
    while (n != 0) {
        result.append(mod(n, 20));
        n = idiv(n, 20);
    }
    return reversed(result);
}

template <typename T1> auto toMayanNumeral(T1 d)
{
    auto result = create_array({_get<0>(Mayan), _get<0>(Mayan), _get<0>(Mayan), _get<0>(Mayan)});
    if (d == 0) {
        _set<3>(result, ::M0);
        return result;
    }

    for (auto i : range_el(3, -1).step(-1))
        if (d >= 5) {
            result.set(i, ::M5);
            d -= 5;
        }
        else {
            result.set(i, Mayan[d]);
            break;
        }

    return result;
}

template <typename T1> auto draw(const T1 &mayans)
{
    auto idx = mayans.len() - 1;

    print(::UL, u""_S);
    for (auto i : range_ee(0, idx)) {
        for (int j = 0; j < 4; j++)
            print(::HB, u""_S);
        if (i < idx)
            print(::UC, u""_S);
        else
            print(::UR);
    }

    for (auto i : range_ee(1, 4)) {
        print(::VB, u""_S);
        for (auto j : range_ee(0, idx))
            print(mayans[j][i - 1] & ::VB, u""_S);
        print();
    }

    print(::LL, u""_S);
    for (auto i : range_ee(0, idx)) {
        for (int j = 0; j < 4; j++)
            print(::HB, u""_S);
        if (i < idx)
            print(::LC, u""_S);
        else
            print(::LR);
    }
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&n : create_array({4005, 8017, 326205, 886205, 1081439556})) {
            print(u"Converting "_S & n & u" to Mayan:"_S);
            auto digits = toBase20(n);
            auto mayans = digits.map([](const auto &d){return toMayanNumeral(d);});
            draw(mayans);
            print();
        }
    }
} code_block_1;