# https://www.rosettacode.org/wiki/Arrays#Python
from typing import List

array : List[int] = []
array.append(1)
array.append(3)
array[0] = 2
print(array[0]) # retrieve first element in an array
print(array[-1]) # retrieve last element in an array
print(array.pop())  # pop last item in an array
print(array.pop(0)) # pop first item in an array

size = 10
myArray = [0] * size # create single-dimensional array
width = 3
height = 4
myArray2 = [[0]* width] * height # create array of arrays
===
[Int] array
array.append(1)
array.append(3)
array[0] = 2
print(array[0])
print(array.last)
print(array.pop())
print(array.pop(0))

V size = 10
V myArray = [0] * size
V width = 3
V height = 4
V myArray2 = [[0] * width] * height
===
Array<int> array;

struct CodeBlock1
{
    CodeBlock1()
    {
        array.append(1);
        array.append(3);
        _set<0>(array, 2);
        print(_get<0>(array));
        print(array.last());
        print(array.pop());
        print(array.pop(0));
    }
} code_block_1;

auto size = 10;
auto myArray = create_array({0}) * size;
auto width = 3;
auto height = 4;
auto myArray2 = create_array({create_array({0}) * width}) * height;


# https://www.rosettacode.org/wiki/A*_search_algorithm#Python
def AStarSearch(start, end, barriers):
    def heuristic(start, goal):
        #Use Chebyshev distance heuristic if we can move one square either
        #adjacent or diagonal
        D = 1
        D2 = 1
        dx = abs(start[0] - goal[0])
        dy = abs(start[1] - goal[1])
        return D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)

    def get_vertex_neighbours(pos):
        n : List[Tuple[int, int]] = []
        #Moves allow link a chess king
        for dx, dy in [(1,0),(-1,0),(0,1),(0,-1),(1,1),(-1,1),(1,-1),(-1,-1)]:
            x2 = pos[0] + dx
            y2 = pos[1] + dy
            if x2 < 0 or x2 > 7 or y2 < 0 or y2 > 7:
                continue
            n.append((x2, y2))
        return n

    def move_cost(a, b):
        for barrier in barriers:
            if b in barrier:
                return 100 #Extremely high cost to enter barrier squares
        return 1 #Normal movement cost

    G : Dict[Tuple[int, int], int] = {} #Actual movement cost to each position from the start position
    f : Dict[Tuple[int, int], int] = {} #Estimated movement cost of start to end going via this position

    #Initialize starting values
    G[start] = 0
    f[start] = heuristic(start, end)

    closedVertices = set() # Tuple[int, int]
    openVertices = set([start])
    cameFrom : Dict[Tuple[int, int], Tuple[int, int]] = {}

    while len(openVertices) > 0:
        #Get the vertex in the open list with the lowest f score
        current : Optional[Tuple[int, int]] = None
        currentFscore = 0
        for pos in openVertices:
            if current is None or f[pos] < currentFscore:
                currentFscore = f[pos]
                current = pos

        #Check if we have reached the goal
        if current == end:
            #Retrace our route backward
            path = [current]
            while current in cameFrom:
                current = cameFrom[current]
                path.append(current)
            path.reverse()
            return (path, f[end]) #Done!

        #Mark the current vertex as closed
        openVertices.remove(current)
        closedVertices.add(current)

        #Update scores for vertices near the current position
        for neighbour in get_vertex_neighbours(current):
            if neighbour in closedVertices:
                continue #We have already processed this node exhaustively
            candidateG = G[current] + move_cost(current, neighbour)

            if neighbour not in openVertices:
                openVertices.add(neighbour) #Discovered a new vertex
            elif candidateG >= G[neighbour]:
                continue #This G score is worse than previously found

            #Adopt this G score
            cameFrom[neighbour] = current
            G[neighbour] = candidateG
            H = heuristic(neighbour, end)
            f[neighbour] = G[neighbour] + H

    raise RuntimeError("A* failed to find a solution")

(result, cost) = AStarSearch((0,0), (7,7), [[(2,4),(2,5),(2,6),(3,6),(4,6),(5,6),(5,5),(5,4),(5,3),(5,2),(4,2),(3,2)]])
print ("route", result)
print ("cost", cost)
===
F AStarSearch(start, end, barriers)
   F heuristic(start, goal)
      V D = 1
      V D2 = 1
      V dx = abs(start[0] - goal[0])
      V dy = abs(start[1] - goal[1])
      R D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)

   F get_vertex_neighbours(pos)
      [(Int, Int)] n
      L(dx, dy) [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, 1), (1, -1), (-1, -1)]
         V x2 = pos[0] + dx
         V y2 = pos[1] + dy
         I x2 < 0 | x2 > 7 | y2 < 0 | y2 > 7
            L.continue
         n.append((x2, y2))
      R n

   F move_cost(a, b)
      L(barrier) @barriers
         I b C barrier
            R 100
      R 1

   [(Int, Int) = Int] G
   [(Int, Int) = Int] f

   G[start] = 0
   f[start] = heuristic(start, end)

   V closedVertices = Set[(Int, Int)]()
   V openVertices = Set([start])
   [(Int, Int) = (Int, Int)] cameFrom

   L openVertices.len > 0
      (Int, Int)? current
      V currentFscore = 0
      L(pos) openVertices
         I current == N | f[pos] < currentFscore
            currentFscore = f[pos]
            current = pos

      I current == end
         V path = [current]
         L current C cameFrom
            current = cameFrom[current]
            path.append(current)
         path.reverse()
         R (path, f[end])

      openVertices.remove(current)
      closedVertices.add(current)

      L(neighbour) get_vertex_neighbours(current)
         I neighbour C closedVertices
            L.continue
         V candidateG = G[current] + move_cost(current, neighbour)

         I neighbour !C openVertices
            openVertices.add(neighbour)
         E I candidateG >= G[neighbour]
            L.continue

         cameFrom[neighbour] = current
         G[neighbour] = candidateG
         V H = heuristic(neighbour, end)
         f[neighbour] = G[neighbour] + H

   X RuntimeError(‘A* failed to find a solution’)

V (result, cost) = AStarSearch((0, 0), (7, 7), [[(2, 4), (2, 5), (2, 6), (3, 6), (4, 6), (5, 6), (5, 5), (5, 4), (5, 3), (5, 2), (4, 2), (3, 2)]])
print(‘route ’result)
print(‘cost ’cost)
===
template <typename T1, typename T2, typename T3> auto AStarSearch(const T1 &start, const T2 &end, const T3 &barriers)
{
    auto heuristic = [](const auto &start, const auto &goal)
    {
        auto D = 1;
        auto D2 = 1;
        auto dx = abs(_get<0>(start) - _get<0>(goal));
        auto dy = abs(_get<1>(start) - _get<1>(goal));
        return D * (dx + dy) + (D2 - 2 * D) * min(dx, dy);
    };

    auto get_vertex_neighbours = [](const auto &pos)
    {
        Array<ivec2> n;
        for (auto &&[dx, dy] : create_array({make_tuple(1, 0), make_tuple(-1, 0), make_tuple(0, 1), make_tuple(0, -1), make_tuple(1, 1), make_tuple(-1, 1), make_tuple(1, -1), make_tuple(-1, -1)})) {
            auto x2 = _get<0>(pos) + dx;
            auto y2 = _get<1>(pos) + dy;
            if (x2 < 0 || x2 > 7 || y2 < 0 || y2 > 7)
                continue;
            n.append(make_tuple(x2, y2));
        }
        return n;
    };

    auto move_cost = [&barriers](const auto &a, const auto &b)
    {
        for (auto &&barrier : barriers)
            if (in(b, barrier))
                return 100;
        return 1;
    };

    Dict<ivec2, int> G;
    Dict<ivec2, int> f;

    G.set(start, 0);
    f.set(start, heuristic(start, end));

    auto closedVertices = Set<ivec2>();
    auto openVertices = create_set({start});
    Dict<ivec2, ivec2> cameFrom;

    while (openVertices.len() > 0) {
        Nullable<ivec2> current;
        auto currentFscore = 0;
        for (auto &&pos : openVertices)
            if (current == nullptr || f[pos] < currentFscore) {
                currentFscore = f[pos];
                current = pos;
            }

        if (*current == end) {
            auto path = create_array({*current});
            while (in(*current, cameFrom)) {
                current = cameFrom[*current];
                path.append(*current);
            }
            path.reverse();
            return make_tuple(path, f[end]);
        }

        openVertices.remove(*current);
        closedVertices.add(*current);

        for (auto &&neighbour : get_vertex_neighbours(*current)) {
            if (in(neighbour, closedVertices))
                continue;
            auto candidateG = G[*current] + move_cost(*current, neighbour);

            if (!in(neighbour, openVertices))
                openVertices.add(neighbour);
            else if (candidateG >= G[neighbour])
                continue;

            cameFrom.set(neighbour, *current);
            G.set(neighbour, candidateG);
            auto H = heuristic(neighbour, end);
            f.set(neighbour, G[neighbour] + H);
        }
    }

    throw RuntimeError(u"A* failed to find a solution"_S);
}
auto [result, cost] = AStarSearch(make_tuple(0, 0), make_tuple(7, 7), create_array({create_array({make_tuple(2, 4), make_tuple(2, 5), make_tuple(2, 6), make_tuple(3, 6), make_tuple(4, 6), make_tuple(5, 6), make_tuple(5, 5), make_tuple(5, 4), make_tuple(5, 3), make_tuple(5, 2), make_tuple(4, 2), make_tuple(3, 2)})}));

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"route "_S & result);
        print(u"cost "_S & cost);
    }
} code_block_1;