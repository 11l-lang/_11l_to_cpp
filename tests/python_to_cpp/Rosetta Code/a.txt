# https://www.rosettacode.org/wiki/Arrays#Python
from typing import List

array : List[int] = []
array.append(1)
array.append(3)
array[0] = 2
print(array[0]) # retrieve first element in an array
print(array[-1]) # retrieve last element in an array
print(array.pop())  # pop last item in an array
print(array.pop(0)) # pop first item in an array

size = 10
myArray = [0] * size # create single-dimensional array
width = 3
height = 4
myArray2 = [[0]* width] * height # create array of arrays
===
[Int] array
array.append(1)
array.append(3)
array[0] = 2
print(array[0])
print(array.last)
print(array.pop())
print(array.pop(0))

V size = 10
V myArray = [0] * size
V width = 3
V height = 4
V myArray2 = [[0] * width] * height
===
Array<int> array;

struct CodeBlock1
{
    CodeBlock1()
    {
        array.append(1);
        array.append(3);
        _set<0>(array, 2);
        print(_get<0>(array));
        print(array.last());
        print(array.pop());
        print(array.pop(0));
    }
} code_block_1;

auto size = 10;
auto myArray = create_array({0}) * size;
auto width = 3;
auto height = 4;
auto myArray2 = create_array({create_array({0}) * width}) * height;


# https://www.rosettacode.org/wiki/A*_search_algorithm#Python
def AStarSearch(start, end, barriers):
    def heuristic(start, goal):
        #Use Chebyshev distance heuristic if we can move one square either
        #adjacent or diagonal
        D = 1
        D2 = 1
        dx = abs(start[0] - goal[0])
        dy = abs(start[1] - goal[1])
        return D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)

    def get_vertex_neighbours(pos):
        n : List[Tuple[int, int]] = []
        #Moves allow link a chess king
        for dx, dy in [(1,0),(-1,0),(0,1),(0,-1),(1,1),(-1,1),(1,-1),(-1,-1)]:
            x2 = pos[0] + dx
            y2 = pos[1] + dy
            if x2 < 0 or x2 > 7 or y2 < 0 or y2 > 7:
                continue
            n.append((x2, y2))
        return n

    def move_cost(a, b):
        for barrier in barriers:
            if b in barrier:
                return 100 #Extremely high cost to enter barrier squares
        return 1 #Normal movement cost

    G : Dict[Tuple[int, int], int] = {} #Actual movement cost to each position from the start position
    f : Dict[Tuple[int, int], int] = {} #Estimated movement cost of start to end going via this position

    #Initialize starting values
    G[start] = 0
    f[start] = heuristic(start, end)

    closedVertices = set() # Tuple[int, int]
    openVertices = set([start])
    cameFrom : Dict[Tuple[int, int], Tuple[int, int]] = {}

    while len(openVertices) > 0:
        #Get the vertex in the open list with the lowest f score
        current : Optional[Tuple[int, int]] = None
        currentFscore = 0
        for pos in openVertices:
            if current is None or f[pos] < currentFscore:
                currentFscore = f[pos]
                current = pos

        #Check if we have reached the goal
        if current == end:
            #Retrace our route backward
            path = [current]
            while current in cameFrom:
                current = cameFrom[current]
                path.append(current)
            path.reverse()
            return (path, f[end]) #Done!

        #Mark the current vertex as closed
        openVertices.remove(current)
        closedVertices.add(current)

        #Update scores for vertices near the current position
        for neighbour in get_vertex_neighbours(current):
            if neighbour in closedVertices:
                continue #We have already processed this node exhaustively
            candidateG = G[current] + move_cost(current, neighbour)

            if neighbour not in openVertices:
                openVertices.add(neighbour) #Discovered a new vertex
            elif candidateG >= G[neighbour]:
                continue #This G score is worse than previously found

            #Adopt this G score
            cameFrom[neighbour] = current
            G[neighbour] = candidateG
            H = heuristic(neighbour, end)
            f[neighbour] = G[neighbour] + H

    raise RuntimeError("A* failed to find a solution")

(result, cost) = AStarSearch((0,0), (7,7), [[(2,4),(2,5),(2,6),(3,6),(4,6),(5,6),(5,5),(5,4),(5,3),(5,2),(4,2),(3,2)]])
print ("route", result)
print ("cost", cost)
===
F AStarSearch(start, end, barriers)
   F heuristic(start, goal)
      V D = 1
      V D2 = 1
      V dx = abs(start[0] - goal[0])
      V dy = abs(start[1] - goal[1])
      R D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)

   F get_vertex_neighbours(pos)
      [(Int, Int)] n
      L(dx, dy) [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, 1), (1, -1), (-1, -1)]
         V x2 = pos[0] + dx
         V y2 = pos[1] + dy
         I x2 < 0 | x2 > 7 | y2 < 0 | y2 > 7
            L.continue
         n.append((x2, y2))
      R n

   F move_cost(a, b)
      L(barrier) @barriers
         I b C barrier
            R 100
      R 1

   [(Int, Int) = Int] G
   [(Int, Int) = Int] f

   G[start] = 0
   f[start] = heuristic(start, end)

   V closedVertices = Set[(Int, Int)]()
   V openVertices = Set([start])
   [(Int, Int) = (Int, Int)] cameFrom

   L openVertices.len > 0
      (Int, Int)? current
      V currentFscore = 0
      L(pos) openVertices
         I current == N | f[pos] < currentFscore
            currentFscore = f[pos]
            current = pos

      I current == end
         V path = [current]
         L current C cameFrom
            current = cameFrom[current]
            path.append(current)
         path.reverse()
         R (path, f[end])

      openVertices.remove(current)
      closedVertices.add(current)

      L(neighbour) get_vertex_neighbours(current)
         I neighbour C closedVertices
            L.continue
         V candidateG = G[current] + move_cost(current, neighbour)

         I neighbour !C openVertices
            openVertices.add(neighbour)
         E I candidateG >= G[neighbour]
            L.continue

         cameFrom[neighbour] = current
         G[neighbour] = candidateG
         V H = heuristic(neighbour, end)
         f[neighbour] = G[neighbour] + H

   X RuntimeError(‘A* failed to find a solution’)

V (result, cost) = AStarSearch((0, 0), (7, 7), [[(2, 4), (2, 5), (2, 6), (3, 6), (4, 6), (5, 6), (5, 5), (5, 4), (5, 3), (5, 2), (4, 2), (3, 2)]])
print(‘route ’result)
print(‘cost ’cost)
===
template <typename T1, typename T2, typename T3> auto AStarSearch(const T1 &start, const T2 &end, const T3 &barriers)
{
    auto heuristic = [](const auto &start, const auto &goal)
    {
        auto D = 1;
        auto D2 = 1;
        auto dx = abs(_get<0>(start) - _get<0>(goal));
        auto dy = abs(_get<1>(start) - _get<1>(goal));
        return D * (dx + dy) + (D2 - 2 * D) * min(dx, dy);
    };

    auto get_vertex_neighbours = [](const auto &pos)
    {
        Array<ivec2> n;
        for (auto &&[dx, dy] : create_array({make_tuple(1, 0), make_tuple(-1, 0), make_tuple(0, 1), make_tuple(0, -1), make_tuple(1, 1), make_tuple(-1, 1), make_tuple(1, -1), make_tuple(-1, -1)})) {
            auto x2 = _get<0>(pos) + dx;
            auto y2 = _get<1>(pos) + dy;
            if (x2 < 0 || x2 > 7 || y2 < 0 || y2 > 7)
                continue;
            n.append(make_tuple(x2, y2));
        }
        return n;
    };

    auto move_cost = [&barriers](const auto &a, const auto &b)
    {
        for (auto &&barrier : barriers)
            if (in(b, barrier))
                return 100;
        return 1;
    };

    Dict<ivec2, int> G;
    Dict<ivec2, int> f;

    G.set(start, 0);
    f.set(start, heuristic(start, end));

    auto closedVertices = Set<ivec2>();
    auto openVertices = create_set({start});
    Dict<ivec2, ivec2> cameFrom;

    while (openVertices.len() > 0) {
        Nullable<ivec2> current;
        auto currentFscore = 0;
        for (auto &&pos : openVertices)
            if (current == nullptr || f[pos] < currentFscore) {
                currentFscore = f[pos];
                current = pos;
            }

        if (*current == end) {
            auto path = create_array({*current});
            while (in(*current, cameFrom)) {
                current = cameFrom[*current];
                path.append(*current);
            }
            path.reverse();
            return make_tuple(path, f[end]);
        }

        openVertices.remove(*current);
        closedVertices.add(*current);

        for (auto &&neighbour : get_vertex_neighbours(*current)) {
            if (in(neighbour, closedVertices))
                continue;
            auto candidateG = G[*current] + move_cost(*current, neighbour);

            if (!in(neighbour, openVertices))
                openVertices.add(neighbour);
            else if (candidateG >= G[neighbour])
                continue;

            cameFrom.set(neighbour, *current);
            G.set(neighbour, candidateG);
            auto H = heuristic(neighbour, end);
            f.set(neighbour, G[neighbour] + H);
        }
    }

    throw RuntimeError(u"A* failed to find a solution"_S);
}

auto [result, cost] = AStarSearch(make_tuple(0, 0), make_tuple(7, 7), create_array({create_array({make_tuple(2, 4), make_tuple(2, 5), make_tuple(2, 6), make_tuple(3, 6), make_tuple(4, 6), make_tuple(5, 6), make_tuple(5, 5), make_tuple(5, 4), make_tuple(5, 3), make_tuple(5, 2), make_tuple(4, 2), make_tuple(3, 2)})}));

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"route "_S & result);
        print(u"cost "_S & cost);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Abbreviations,_automatic#Python
def shortest_abbreviation_length(line, list_size):
    words = line.split(' ')
    word_count = len(words)
    # Can't give true answer with unexpected number of entries
    if word_count != list_size:
        raise ValueError('Not enough entries, expected {} found {}'.format(list_size, word_count))

    # Find the small slice length that gives list_size unique values
    abbreviation_length = 1
    #abbreviations = set()
    while True:
        abbreviations = {word[:abbreviation_length] for word in words}
        if len(abbreviations) == list_size:
            return abbreviation_length
        abbreviation_length += 1
        #abbreviations.clear()

def automatic_abbreviations(filename, words_per_line):
    for line in open(filename, encoding = 'utf-8').read().split("\n"):
        if len(line) > 0:
            length = shortest_abbreviation_length(line, words_per_line)
            print('{:2} {}'.format(length, line))
        else:
            print()

automatic_abbreviations('daysOfWeek.txt', 7)
===
F shortest_abbreviation_length(line, list_size)
   V words = line.split(‘ ’)
   V word_count = words.len
   I word_count != list_size
      X ValueError(‘Not enough entries, expected #. found #.’.format(list_size, word_count))

   V abbreviation_length = 1
   L
      V abbreviations = Set(words.map(word -> word[0 .< @abbreviation_length]))
      I abbreviations.len == list_size
         R abbreviation_length
      abbreviation_length++

F automatic_abbreviations(filename, words_per_line)
   L(line) File(filename, encoding' ‘utf-8’).read().split("\n")
      I line.len > 0
         V length = shortest_abbreviation_length(line, words_per_line)
         print(‘#2 #.’.format(length, line))
      E
         print()

automatic_abbreviations(‘daysOfWeek.txt’, 7)
===
template <typename T1, typename T2> auto shortest_abbreviation_length(const T1 &line, const T2 &list_size)
{
    auto words = line.split(u" "_S);
    auto word_count = words.len();
    if (word_count != list_size)
        throw ValueError(u"Not enough entries, expected #. found #."_S.format(list_size, word_count));

    auto abbreviation_length = 1;
    while (true) {
        auto abbreviations = create_set(words.map([&abbreviation_length](const auto &word){return word[range_el(0, abbreviation_length)];}));
        if (abbreviations.len() == list_size)
            return abbreviation_length;
        abbreviation_length++;
    }
}

template <typename T1, typename T2> auto automatic_abbreviations(const T1 &filename, const T2 &words_per_line)
{
    for (auto &&line : File(filename, u"r"_S, u"utf-8"_S).read().split(u"\n"_S))
        if (line.len() > 0) {
            auto length = shortest_abbreviation_length(line, words_per_line);
            print(u"#2 #."_S.format(length, line));
        }
        else
            print();
}

struct CodeBlock1
{
    CodeBlock1()
    {
        automatic_abbreviations(u"daysOfWeek.txt"_S, 7);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Abbreviations,_easy#Python
from typing import Dict

command_table_text = \
"""Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress COpy
COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find
NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput
Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO
MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT
READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT
RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer Type Up"""

user_words = "riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin"

def find_abbreviations_length(command_table_text):
    """ find the minimal abbreviation length for each word by counting capital letters.
        a word that does not have capital letters gets it's full length as the minimum.
    """
    command_table : Dict[str, int] = dict()
    for word in command_table_text.split():
        abbr_len = sum(1 for c in word if c.isupper())
        if abbr_len == 0:
            abbr_len = len(word)
        command_table[word] = abbr_len
    return command_table

def find_abbreviations(command_table):
    """ for each command insert all possible abbreviations"""
    abbreviations : Dict[str, str] = dict()
    for command, min_abbr_len in command_table.items():
        for l in range(min_abbr_len, len(command)+1):
            abbr = command[:l].lower()
            abbreviations[abbr] = command.upper()
    return abbreviations

def parse_user_string(user_string, abbreviations):
    user_words = [word.lower() for word in user_string.split()]
    commands = [abbreviations.get(user_word, "*error*") for user_word in user_words]
    return " ".join(commands)

command_table = find_abbreviations_length(command_table_text)
abbreviations_table = find_abbreviations(command_table)

full_words = parse_user_string(user_words, abbreviations_table)

print("user words:", user_words)
print("full words:", full_words)
===
V command_table_text = ‘Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress COpy
COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find
NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput
Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO
MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT
READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT
RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer Type Up’

V user_words = ‘riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin’

F find_abbreviations_length(command_table_text)
   ‘ find the minimal abbreviation length for each word by counting capital letters.
        a word that does not have capital letters gets it's full length as the minimum.
    ’
   [String = Int] command_table
   L(word) command_table_text.split_py()
      V abbr_len = sum(word.filter(c -> c.is_uppercase()).map(c -> 1))
      I abbr_len == 0
         abbr_len = word.len
      command_table[word] = abbr_len
   R command_table

F find_abbreviations(command_table)
   ‘ for each command insert all possible abbreviations’
   [String = String] abbreviations
   L(command, min_abbr_len) command_table
      L(l) min_abbr_len .. command.len
         V abbr = command[0 .< l].lowercase()
         abbreviations[abbr] = command.uppercase()
   R abbreviations

F parse_user_string(user_string, abbreviations)
   V user_words = user_string.split_py().map(word -> word.lowercase())
   V commands = user_words.map(user_word -> @abbreviations.get(user_word, ‘*error*’))
   R commands.join(‘ ’)

V command_table = find_abbreviations_length(command_table_text)
V abbreviations_table = find_abbreviations(command_table)

V full_words = parse_user_string(user_words, abbreviations_table)

print(‘user words: ’user_words)
print(‘full words: ’full_words)
===
auto command_table_text = uR"(Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress COpy
COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find
NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput
Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO
MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT
READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT
RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer Type Up)"_S;

auto user_words = u"riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin"_S;

template <typename T1> auto find_abbreviations_length(const T1 &command_table_text)
{
    uR"( find the minimal abbreviation length for each word by counting capital letters.
        a word that does not have capital letters gets it's full length as the minimum.
    )"_S;
    Dict<String, int> command_table;
    for (auto &&word : command_table_text.split_py()) {
        auto abbr_len = sum_map(word.filter([](const auto &c){return c.is_uppercase();}), [](const auto &c){return 1;});
        if (abbr_len == 0)
            abbr_len = word.len();
        command_table.set(word, abbr_len);
    }
    return command_table;
}

template <typename T1> auto find_abbreviations(const T1 &command_table)
{
    u" for each command insert all possible abbreviations"_S;
    Dict<String, String> abbreviations;
    for (auto &&[command, min_abbr_len] : command_table)
        for (auto l : range_ee(min_abbr_len, command.len())) {
            auto abbr = command[range_el(0, l)].lowercase();
            abbreviations.set(abbr, command.uppercase());
        }
    return abbreviations;
}

template <typename T1, typename T2> auto parse_user_string(const T1 &user_string, const T2 &abbreviations)
{
    auto user_words = user_string.split_py().map([](const auto &word){return word.lowercase();});
    auto commands = user_words.map([&abbreviations](const auto &user_word){return abbreviations.get(user_word, u"*error*"_S);});
    return commands.join(u" "_S);
}

auto command_table = find_abbreviations_length(command_table_text);
auto abbreviations_table = find_abbreviations(command_table);

auto full_words = parse_user_string(user_words, abbreviations_table);

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"user words: "_S & user_words);
        print(u"full words: "_S & full_words);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Abbreviations,_simple#Python
from typing import Dict, Optional

command_table_text = """add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3
   compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate
   3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2
   forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load
   locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2
   msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3
   refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left
   2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1"""

user_words = "riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin"

def find_abbreviations_length(command_table_text):
    """ find the minimal abbreviation length for each word.
        a word that does not have minimum abbreviation length specified
        gets it's full lengths as the minimum.
    """
    command_table : Dict[str, int] = dict()
    input_list = command_table_text.split()
    i = 0

    word = ''
    while i < len(input_list) or word != '':
        if word == '':
            word = input_list[i]
            i += 1
        abbr_len = input_list[i] if i < len(input_list) else str(len(word))
        i += 1
        try:
            command_table[word] = int(abbr_len)
            word = ''
        except ValueError:
            command_table[word] = len(word)
            word = abbr_len
    return command_table

def find_abbreviations(command_table):
    """ for each command insert all possible abbreviations"""
    abbreviations : Dict[str, str] = dict()
    for command, min_abbr_len in command_table.items():
        for l in range(min_abbr_len, len(command)+1):
            abbr = command[:l].lower()
            abbreviations[abbr] = command.upper()
    return abbreviations

def parse_user_string(user_string, abbreviations):
    user_words = [word.lower() for word in user_string.split()]
    commands = [abbreviations.get(user_word, "*error*") for user_word in user_words]
    return " ".join(commands)

command_table = find_abbreviations_length(command_table_text)
abbreviations_table = find_abbreviations(command_table)

full_words = parse_user_string(user_words, abbreviations_table)

print("user words:", user_words)
print("full words:", full_words)
===
V command_table_text = ‘add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3
   compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate
   3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2
   forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load
   locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2
   msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3
   refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left
   2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1’

V user_words = ‘riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin’

F find_abbreviations_length(command_table_text)
   ‘ find the minimal abbreviation length for each word.
        a word that does not have minimum abbreviation length specified
        gets it's full lengths as the minimum.
    ’
   [String = Int] command_table
   V input_list = command_table_text.split_py()
   V i = 0

   V word = ‘’
   L i < input_list.len | word != ‘’
      I word == ‘’
         word = input_list[i]
         i++
      V abbr_len = I i < input_list.len {input_list[i]} E String(word.len)
      i++
      X.try
         command_table[word] = Int(abbr_len)
         word = ‘’
      X.catch ValueError
         command_table[word] = word.len
         word = abbr_len
   R command_table

F find_abbreviations(command_table)
   ‘ for each command insert all possible abbreviations’
   [String = String] abbreviations
   L(command, min_abbr_len) command_table
      L(l) min_abbr_len .. command.len
         V abbr = command[0 .< l].lowercase()
         abbreviations[abbr] = command.uppercase()
   R abbreviations

F parse_user_string(user_string, abbreviations)
   V user_words = user_string.split_py().map(word -> word.lowercase())
   V commands = user_words.map(user_word -> @abbreviations.get(user_word, ‘*error*’))
   R commands.join(‘ ’)

V command_table = find_abbreviations_length(command_table_text)
V abbreviations_table = find_abbreviations(command_table)

V full_words = parse_user_string(user_words, abbreviations_table)

print(‘user words: ’user_words)
print(‘full words: ’full_words)
===
auto command_table_text = uR"(add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3
   compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate
   3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2
   forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load
   locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2
   msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3
   refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left
   2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1)"_S;

auto user_words = u"riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin"_S;

template <typename T1> auto find_abbreviations_length(const T1 &command_table_text)
{
    uR"( find the minimal abbreviation length for each word.
        a word that does not have minimum abbreviation length specified
        gets it's full lengths as the minimum.
    )"_S;
    Dict<String, int> command_table;
    auto input_list = command_table_text.split_py();
    auto i = 0;

    auto word = u""_S;
    while (i < input_list.len() || word != u"") {
        if (word == u"") {
            word = input_list[i];
            i++;
        }
        auto abbr_len = i < input_list.len() ? input_list[i] : String(word.len());
        i++;
        try
        {
            command_table.set(word, to_int(abbr_len));
            word = u""_S;
        }
        catch (const ValueError&)
        {
            command_table.set(word, word.len());
            word = abbr_len;
        }
    }
    return command_table;
}

template <typename T1> auto find_abbreviations(const T1 &command_table)
{
    u" for each command insert all possible abbreviations"_S;
    Dict<String, String> abbreviations;
    for (auto &&[command, min_abbr_len] : command_table)
        for (auto l : range_ee(min_abbr_len, command.len())) {
            auto abbr = command[range_el(0, l)].lowercase();
            abbreviations.set(abbr, command.uppercase());
        }
    return abbreviations;
}

template <typename T1, typename T2> auto parse_user_string(const T1 &user_string, const T2 &abbreviations)
{
    auto user_words = user_string.split_py().map([](const auto &word){return word.lowercase();});
    auto commands = user_words.map([&abbreviations](const auto &user_word){return abbreviations.get(user_word, u"*error*"_S);});
    return commands.join(u" "_S);
}

auto command_table = find_abbreviations_length(command_table_text);
auto abbreviations_table = find_abbreviations(command_table);

auto full_words = parse_user_string(user_words, abbreviations_table);

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"user words: "_S & user_words);
        print(u"full words: "_S & full_words);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/ABC_words#Python
for ln in open('unixdict.txt').read().split("\n"):
    a = ln.find("a")
    if a != -1:
        b = ln.find("b")
        if a < b and b < ln.find("c"):
            print(ln)
===
L(ln) File(‘unixdict.txt’).read().split("\n")
   V a = ln.findi(‘a’)
   I a != -1
      V b = ln.findi(‘b’)
      I a < b & b < ln.findi(‘c’)
         print(ln)
===
struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&ln : File(u"unixdict.txt"_S).read().split(u"\n"_S)) {
            auto a = ln.findi(u"a"_S);
            if (a != -1) {
                auto b = ln.findi(u"b"_S);
                if (a < b && b < ln.findi(u"c"_S))
                    print(ln);
            }
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Abelian_sandpile_model
Byte = int

grid = [[0] * 10 for i in range(10)]
grid[5][5] = 64

print('Before:')
for row in grid:
    print(''.join('%3d' % c for c in row))

def simulate(grid : list):
    while True:
        changed = False
        for ii, arr in enumerate(grid):
            for jj, val in enumerate(arr):
                if val > 3:
                    grid[ii][jj] -= 4
                    if ii > 0:
                        grid[ii - 1][jj] += 1
                    if ii < len(grid)-1:
                        grid[ii + 1][jj] += 1
                    if jj > 0:
                        grid[ii][jj - 1] += 1
                    if jj < len(grid)-1:
                        grid[ii][jj + 1] += 1
                    changed = True
        if not changed:
            break

simulate(grid)

print("\nAfter:")
for row in grid:
    print(''.join('%3d' % c for c in row))

grid = [[0] * 65 for i in range(65)]
grid[32][32] = 64*64

simulate(grid)

ppm = open('sand_pile.ppm', 'wb')
ppm.write(("P6\n%d %d\n255\n" % (len(grid), len(grid))).encode())
colors = [[Byte(0),   0,   0],
          [Byte(255), 0,   0],
          [Byte(0), 255,   0],
          [Byte(0),   0, 255]]
for row in grid:
    for c in row:
        ppm.write(bytes(colors[c]))
===
V grid = [[0] * 10] * 10
grid[5][5] = 64

print(‘Before:’)
L(row) grid
   print(row.map(c -> ‘#3’.format(c)).join(‘’))

F simulate(&grid)
   L
      V changed = 0B
      L(arr) grid
         V ii = L.index
         L(val) arr
            V jj = L.index
            I val > 3
               grid[ii][jj] -= 4
               I ii > 0
                  grid[ii - 1][jj]++
               I ii < grid.len - 1
                  grid[ii + 1][jj]++
               I jj > 0
                  grid[ii][jj - 1]++
               I jj < grid.len - 1
                  grid[ii][jj + 1]++
               changed = 1B
      I !changed
         L.break

simulate(&grid)

print("\nAfter:")
L(row) grid
   print(row.map(c -> ‘#3’.format(c)).join(‘’))

grid = [[0] * 65] * 65
grid[32][32] = 64 * 64

simulate(&grid)

V ppm = File(‘sand_pile.ppm’, ‘w’)
ppm.write_bytes(("P6\n#. #.\n255\n".format(grid.len, grid.len)).encode())
V colors = [[Byte(0), 0, 0], [Byte(255), 0, 0], [Byte(0), 255, 0], [Byte(0), 0, 255]]
L(row) grid
   L(c) row
      ppm.write_bytes(colors[c])
===
auto grid = create_array({create_array({0}) * 10}) * 10;

struct CodeBlock1
{
    CodeBlock1()
    {
        _set<5>(_get<5>(grid), 64);

        print(u"Before:"_S);
        for (auto &&row : grid)
            print(row.map([](const auto &c){return u"#3"_S.format(c);}).join(u""_S));
    }
} code_block_1;

template <typename T1> auto simulate(T1 &grid)
{
    while (true) {
        auto changed = false;
        {int Lindex = 0;
        for (auto &&arr : grid) {
            auto ii = Lindex;
            {int Lindex = 0;
            for (auto &&val : arr) {
                auto jj = Lindex;
                if (val > 3) {
                    grid[ii][jj] -= 4;
                    if (ii > 0)
                        grid[ii - 1][jj]++;
                    if (ii < grid.len() - 1)
                        grid[ii + 1][jj]++;
                    if (jj > 0)
                        grid[ii][jj - 1]++;
                    if (jj < grid.len() - 1)
                        grid[ii][jj + 1]++;
                    changed = true;
                }
                Lindex++;
            }}
            Lindex++;
        }}
        if (!changed)
            break;
    }
}

struct CodeBlock2
{
    CodeBlock2()
    {
        simulate(grid);

        print(u"\nAfter:"_S);
        for (auto &&row : grid)
            print(row.map([](const auto &c){return u"#3"_S.format(c);}).join(u""_S));

        grid = create_array({create_array({0}) * 65}) * 65;
        _set<32>(_get<32>(grid), 64 * 64);

        simulate(grid);
    }
} code_block_2;

auto ppm = File(u"sand_pile.ppm"_S, u"w"_S);

struct CodeBlock3
{
    CodeBlock3()
    {
        ppm.write_bytes((u"P6\n#. #.\n255\n"_S.format(grid.len(), grid.len())).encode());
    }
} code_block_3;

auto colors = create_array({create_array<Byte>({Byte(0), 0, 0}), create_array<Byte>({Byte(255), 0, 0}), create_array<Byte>({Byte(0), 255, 0}), create_array<Byte>({Byte(0), 0, 255})});

struct CodeBlock4
{
    CodeBlock4()
    {
        for (auto &&row : grid)
            for (auto &&c : row)
                ppm.write_bytes(colors[c]);
    }
} code_block_4;


# https://www.rosettacode.org/wiki/Abelian_sandpile_model/Identity#Python
from itertools import product
import collections
from typing import Set, Tuple

def ref(obj):
    return obj

class Sandpile:
    def __init__(self, gridtext):
        array = [int(x) for x in gridtext.split()]
        self.grid : DefaultDict[Tuple[int, int], int] = collections.defaultdict(int)
        for i, x in enumerate(array):
            self.grid[(i // 3, i % 3)] = x

    _border : Set[Tuple[int, int]] = set((r, c)
                  for r, c in product(range(-1, 4), range(-1, 4))
                  if not 0 <= r <= 2 or not 0 <= c <= 2
                  )
    _cell_coords = list(product(range(3), range(3)))

    def topple(self):
        g = ref(self.grid)
        for r, c in self._cell_coords:
            if g[(r, c)] >= 4:
                g[(r - 1, c)] += 1
                g[(r + 1, c)] += 1
                g[(r, c - 1)] += 1
                g[(r, c + 1)] += 1
                g[(r, c)] -= 4
                return True
        return False

    def stabilise(self):
        while self.topple():
            pass
        # Remove extraneous grid border
        for row_col in self._border.intersection(set(self.grid.keys())):
            del self.grid[row_col]

    #__pos__ = stabilise     # +s == s.stabilise()

    def __eq__(self, other):
        return all(self.grid[row_col] == other.grid[row_col]
                   for row_col in self._cell_coords)

    def __add__(self, other):
        ans = Sandpile("")
        for row_col in self._cell_coords:
            ans.grid[row_col] = self.grid[row_col] + other.grid[row_col]
        ans.stabilise()
        return ans

    def __str__(self):
        txt : List[str] = []
        for row in range(3):
            txt.append(' '.join(str(self.grid[(row, col)])
                                for col in range(3)))
        return '\n'.join(txt)

unstable = Sandpile("""4 3 3
                       3 1 2
                       0 2 3""")
s1 = Sandpile("""1 2 0
                 2 1 1
                 0 1 3""")
s2 = Sandpile("""2 1 3
                 1 0 1
                 0 1 0""")
s3 = Sandpile("3 3 3  3 3 3  3 3 3")
s3_id = Sandpile("2 1 2  1 0 1  2 1 2")

print(unstable)
print()
unstable.stabilise()
print(unstable)
print()
print(s1 + s2)
print()
print(s2 + s1)
print()
print(s1 + s2 == s2 + s1)
print()
print(s3 + s3_id)
print()
print(s3 + s3_id == s3)
print()
print(s3_id + s3_id)
print()
print(s3_id + s3_id == s3_id)
===
T Sandpile
   DefaultDict[(Int, Int), Int] grid
   F (gridtext)
      V array = gridtext.split_py().map(x -> Int(x))
      L(x) array
         V i = L.index
         .grid[(i I/ 3, i % 3)] = x

   Set[(Int, Int)] _border = Set(cart_product(-1 .< 4, -1 .< 4).filter((r, c) -> !(r C 0..2) | !(c C 0..2)))
   _cell_coords = cart_product(0.<3, 0.<3)

   F topple()
      V& g = .grid
      L(r, c) ._cell_coords
         I g[(r, c)] >= 4
            g[(r - 1, c)]++
            g[(r + 1, c)]++
            g[(r, c - 1)]++
            g[(r, c + 1)]++
            g[(r, c)] -= 4
            R 1B
      R 0B

   F stabilise()
      L .topple()
      {
      }
      L(row_col) ._border.intersection(Set(.grid.keys()))
         .grid.pop(row_col)

   F ==(other)
      R all(._cell_coords.map(row_col -> @.grid[row_col] == @other.grid[row_col]))

   F +(other)
      V ans = Sandpile(‘’)
      L(row_col) ._cell_coords
         ans.grid[row_col] = .grid[row_col] + other.grid[row_col]
      ans.stabilise()
      R ans

   F String()
      [String] txt
      L(row) 3
         txt.append((0.<3).map(col -> String(@.grid[(@row, col)])).join(‘ ’))
      R txt.join("\n")

V unstable = Sandpile(‘4 3 3
                       3 1 2
                       0 2 3’)
V s1 = Sandpile(‘1 2 0
                 2 1 1
                 0 1 3’)
V s2 = Sandpile(‘2 1 3
                 1 0 1
                 0 1 0’)
V s3 = Sandpile(‘3 3 3  3 3 3  3 3 3’)
V s3_id = Sandpile(‘2 1 2  1 0 1  2 1 2’)

print(unstable)
print()
unstable.stabilise()
print(unstable)
print()
print(s1 + s2)
print()
print(s2 + s1)
print()
print(s1 + s2 == s2 + s1)
print()
print(s3 + s3_id)
print()
print(s3 + s3_id == s3)
print()
print(s3_id + s3_id)
print()
print(s3_id + s3_id == s3_id)
===
class Sandpile
{
public:
    DefaultDict<ivec2, int> grid;
    template <typename T1> Sandpile(const T1 &gridtext)
    {
        auto array = gridtext.split_py().map([](const auto &x){return to_int(x);});
        {int Lindex = 0;
        for (auto &&x : array) {
            auto i = Lindex;
            grid.set(make_tuple(idiv(i, 3), mod(i, 3)), x);
            Lindex++;
        }}
    }

    Set<ivec2> _border = create_set(cart_product(range_el(-1, 4), range_el(-1, 4)).filter([](const auto &r, const auto &c){return !(in(r, range_ee(0, 2))) || !(in(c, range_ee(0, 2)));}));
    decltype(cart_product(range_el(0, 3), range_el(0, 3))) _cell_coords = cart_product(range_el(0, 3), range_el(0, 3));

    auto topple()
    {
        auto& g = grid;
        for (auto &&[r, c] : _cell_coords)
            if (g[make_tuple(r, c)] >= 4) {
                g[make_tuple(r - 1, c)]++;
                g[make_tuple(r + 1, c)]++;
                g[make_tuple(r, c - 1)]++;
                g[make_tuple(r, c + 1)]++;
                g[make_tuple(r, c)] -= 4;
                return true;
            }
        return false;
    }

    auto stabilise()
    {
        while (topple()) {
        }

        for (auto &&row_col : _border.intersection(create_set(grid.keys())))
            grid.pop(row_col);
    }

    template <typename T1> auto operator==(const T1 &other) const
    {
        return all_map(_cell_coords, [&other, this](const auto &row_col){return grid[row_col] == other.grid[row_col];});
    }

    template <typename T1> auto operator+(const T1 &other) const
    {
        auto ans = Sandpile(u""_S);
        for (auto &&row_col : _cell_coords)
            ans.grid.set(row_col, grid[row_col] + other.grid[row_col]);
        ans.stabilise();
        return ans;
    }
    template <typename Ty> auto &operator+=(const Ty &t)
    {
        *this = *this + t;
        return *this;
    }

    operator String() const
    {
        Array<String> txt;
        for (int row = 0; row < 3; row++)
            txt.append(range_el(0, 3).map([&row, this](const auto &col){return String(grid[make_tuple(row, col)]);}).join(u" "_S));
        return txt.join(u"\n"_S);
    }
};

auto unstable = Sandpile(uR"(4 3 3
                       3 1 2
                       0 2 3)"_S);
auto s1 = Sandpile(uR"(1 2 0
                 2 1 1
                 0 1 3)"_S);
auto s2 = Sandpile(uR"(2 1 3
                 1 0 1
                 0 1 0)"_S);
auto s3 = Sandpile(u"3 3 3  3 3 3  3 3 3"_S);
auto s3_id = Sandpile(u"2 1 2  1 0 1  2 1 2"_S);

struct CodeBlock1
{
    CodeBlock1()
    {
        print(unstable);
        print();
        unstable.stabilise();
        print(unstable);
        print();
        print(s1 + s2);
        print();
        print(s2 + s1);
        print();
        print(s1 + s2 == s2 + s1);
        print();
        print(s3 + s3_id);
        print();
        print(s3 + s3_id == s3);
        print();
        print(s3_id + s3_id);
        print();
        print(s3_id + s3_id == s3_id);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Abstract_type
class AbstractQueue:
    def enqueue(self, item : int) -> None:
        raise NotImplementedError()

class PrintQueue(AbstractQueue):
    def enqueue(self, item : int):
        print(item)
===
T AbstractQueue
   F.virtual.abstract enqueue(Int item) -> N

T PrintQueue(AbstractQueue)
   F.virtual.assign enqueue(Int item) -> N
      print(item)
===
class AbstractQueue
{
public:
    virtual void enqueue(const int &item) = 0;
};

class PrintQueue : public AbstractQueue
{
public:
    virtual void enqueue(const int &item) override
    {
        print(item);
    }
};


# https://www.rosettacode.org/wiki/Abundant_odd_numbers#Python
oddNumber  = 1
aCount  = 0
dSum  = 0

import math

def divisorSum(n):
    sum = 1
    i = int(math.sqrt(n)+1)

    for d in range (2, i):
        if n % d == 0:
            sum += d
            otherD = n // d
            if otherD != d:
                sum += otherD
    return sum

print ("The first 25 abundant odd numbers:")
while aCount  < 25:
    dSum  = divisorSum(oddNumber )
    if dSum  > oddNumber :
        aCount  += 1
        print("{0:5} proper divisor sum: {1}". format(oddNumber ,dSum ))
    oddNumber  += 2

while aCount  < 1000:
    dSum  = divisorSum(oddNumber )
    if dSum  > oddNumber :
        aCount  += 1
    oddNumber  += 2
print ("\n1000th abundant odd number:")
print ("    ",(oddNumber - 2)," proper divisor sum: ",dSum)

oddNumber  = 1000000001
found  = False
while not found :
    dSum  = divisorSum(oddNumber )
    if dSum  > oddNumber :
        found  = True
        print ("\nFirst abundant odd number > 1 000 000 000:")
        print ("    ",oddNumber," proper divisor sum: ",dSum)
    oddNumber  += 2
===
V oddNumber = 1
V aCount = 0
V dSum = 0

F divisorSum(n)
   V sum = 1
   V i = Int(sqrt(n) + 1)

   L(d) 2 .< i
      I n % d == 0
         sum += d
         V otherD = n I/ d
         I otherD != d
            sum += otherD
   R sum

print(‘The first 25 abundant odd numbers:’)
L aCount < 25
   dSum = divisorSum(oddNumber)
   I dSum > oddNumber
      aCount++
      print(‘#5 proper divisor sum: #.’.format(oddNumber, dSum))
   oddNumber += 2

L aCount < 1000
   dSum = divisorSum(oddNumber)
   I dSum > oddNumber
      aCount++
   oddNumber += 2
print("\n1000th abundant odd number:")
print(‘     ’(oddNumber - 2)‘  proper divisor sum:  ’dSum)

oddNumber = 1000000001
V found = 0B
L !found
   dSum = divisorSum(oddNumber)
   I dSum > oddNumber
      found = 1B
      print("\nFirst abundant odd number > 1 000 000 000:")
      print(‘     ’oddNumber‘  proper divisor sum:  ’dSum)
   oddNumber += 2
===
auto oddNumber = 1;
auto aCount = 0;
auto dSum = 0;

template <typename T1> auto divisorSum(const T1 &n)
{
    auto sum = 1;
    auto i = to_int(sqrt(n) + 1);

    for (auto d : range_el(2, i))
        if (mod(n, d) == 0) {
            sum += d;
            auto otherD = idiv(n, d);
            if (otherD != d)
                sum += otherD;
        }
    return sum;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"The first 25 abundant odd numbers:"_S);
        while (aCount < 25) {
            dSum = divisorSum(oddNumber);
            if (dSum > oddNumber) {
                aCount++;
                print(u"#5 proper divisor sum: #."_S.format(oddNumber, dSum));
            }
            oddNumber += 2;
        }

        while (aCount < 1000) {
            dSum = divisorSum(oddNumber);
            if (dSum > oddNumber)
                aCount++;
            oddNumber += 2;
        }
        print(u"\n1000th abundant odd number:"_S);
        print(u"     "_S & (oddNumber - 2) & u"  proper divisor sum:  "_S & dSum);

        oddNumber = 1000000001;
    }
} code_block_1;

auto found = false;

struct CodeBlock2
{
    CodeBlock2()
    {
        while (!found) {
            dSum = divisorSum(oddNumber);
            if (dSum > oddNumber) {
                found = true;
                print(u"\nFirst abundant odd number > 1 000 000 000:"_S);
                print(u"     "_S & oddNumber & u"  proper divisor sum:  "_S & dSum);
            }
            oddNumber += 2;
        }
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Accumulator_factory
def accumulator(n):
    class Accumulator:
        s : float
        def __init__(self, n : float):
            self.s = n
        def __call__(self, n : float):
            self.s += n
            return self.s
    return Accumulator(n)

x = accumulator(1)
print(x(5))
print(x(2.3))

x2 = accumulator(3)
print(x2(5))
print(x2(3.3))
print(x2(0))
===
F accumulator(n)
   T Accumulator
      Float s
      F (Float n)
         .s = n
      F ()(Float n)
         .s += n
         R .s
   R Accumulator(n)

V x = accumulator(1)
print(x(5))
print(x(2.3))

V x2 = accumulator(3)
print(x2(5))
print(x2(3.3))
print(x2(0))
===
template <typename T1> auto accumulator(const T1 &n)
{
    class Accumulator
    {
    public:
        double s;
        Accumulator(const double n) :
            s(n)
        {
        }
        auto operator()(const double n)
        {
            s += n;
            return s;
        }
    };
    return Accumulator(n);
}

auto x = accumulator(1);

struct CodeBlock1
{
    CodeBlock1()
    {
        print(x(5));
        print(x(2.3));
    }
} code_block_1;

auto x2 = accumulator(3);

struct CodeBlock2
{
    CodeBlock2()
    {
        print(x2(5));
        print(x2(3.3));
        print(x2(0));
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Ackermann_function#Python
def ack2(m, n) -> int:
   return (n + 1)   if m == 0 else (
          (n + 2)   if m == 1 else (
          (2*n + 3) if m == 2 else (
          (8*(2**n - 1) + 5) if m == 3 else (
          ack2(m-1, 1) if n == 0 else ack2(m-1, ack2(m, n-1))))))

print(ack2(0,0))
print(ack2(3,4))
print(ack2(4,1))
===
F ack2(m, n) -> Int
   R I m == 0 {(n + 1)} E (I m == 1 {(n + 2)} E (I m == 2 {(2 * n + 3)} E (I m == 3 {(8 * (2 ^ n - 1) + 5)} E (I n == 0 {ack2(m - 1, 1)} E ack2(m - 1, ack2(m, n - 1))))))

print(ack2(0, 0))
print(ack2(3, 4))
print(ack2(4, 1))
===
template <typename T1, typename T2> int ack2(const T1 &m, const T2 &n)
{
    return m == 0 ? (n + 1) : (m == 1 ? (n + 2) : (m == 2 ? (2 * n + 3) : (m == 3 ? (8 * (pow(2, n) - 1) + 5) : (n == 0 ? ack2(m - 1, 1) : ack2(m - 1, ack2(m, n - 1))))));
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(ack2(0, 0));
        print(ack2(3, 4));
        print(ack2(4, 1));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Addition_chains#Python
# Slow BigInt (if there is `x * BigInt(2)**(best_len - pos) < n` instead of `x<<(best_len - pos) < n`)
def bauer(n):
    chain = [0]*n
    in_chain = [False]*(n + 1)
    best : List[int] = []
    best_len = n
    cnt = 0

    def extend_chain(x : int, pos : int) -> None:
        nonlocal best, best_len, cnt

        if best_len - pos < 32 and x < n >> (best_len - pos):
            return

        chain[pos] = x
        in_chain[x] = True
        pos += 1

        if in_chain[n - x]:  # found solution
            if pos == best_len:
                cnt += 1
            else:
                best = chain[:pos]
                best_len = pos
                cnt = 1
        elif pos < best_len:
            for i in range(pos - 1, -1, -1):
                c = x + chain[i]
                if c < n:
                    extend_chain(c, pos)

        in_chain[x] = False

    extend_chain(1, 0)
    return (best + [n], cnt)

for n in [7, 14, 21, 29, 32, 42, 64, 47, 79, 191, 382, 379]:
    (best, cnt) = bauer(n)
    print('L({}) = {}, count of minimum chain: {}\ne.g.: {}\n'.format(n, len(best) - 1, cnt, best))
===
F bauer(n)
   V chain = [0] * n
   V in_chain = [0B] * (n + 1)
   [Int] best
   V best_len = n
   V cnt = 0

   F extend_chain(Int x, Int =pos) -> N

      I @best_len - pos < 32 & x < @n >> (@best_len - pos)
         R

      @chain[pos] = x
      @in_chain[x] = 1B
      pos++

      I @in_chain[@n - x]
         I pos == @best_len
            @cnt++
         E
            @best = @chain[0 .< pos]
            @best_len = pos
            @cnt = 1
      E I pos < @best_len
         L(i) (pos - 1 .< -1).step(-1)
            V c = x + @chain[i]
            I c < @n
               @extend_chain(c, pos)

      @in_chain[x] = 0B

   extend_chain(1, 0)
   R (best [+] [n], cnt)

L(n) [7, 14, 21, 29, 32, 42, 64, 47, 79, 191, 382, 379]
   V (best, cnt) = bauer(n)
   print("L(#.) = #., count of minimum chain: #.\ne.g.: #.\n".format(n, best.len - 1, cnt, best))
===
template <typename T1> auto bauer(const T1 &n)
{
    auto chain = create_array({0}) * n;
    auto in_chain = create_array({false}) * (n + 1);
    Array<int> best;
    auto best_len = n;
    auto cnt = 0;

    std::function<void(int, int)> extend_chain = [&best, &best_len, &chain, &cnt, &extend_chain, &in_chain, &n](const int x, int pos)
    {

        if (best_len - pos < 32 && x < n >> (best_len - pos))
            return;

        chain.set(pos, x);
        in_chain.set(x, true);
        pos++;

        if (in_chain[n - x]) {
            if (pos == best_len)
                cnt++;
            else {
                best = chain[range_el(0, pos)];
                best_len = pos;
                cnt = 1;
            }
        }
        else if (pos < best_len)
            for (auto i : range_el(pos - 1, -1).step(-1)) {
                auto c = x + chain[i];
                if (c < n)
                    extend_chain(c, pos);
            }

        in_chain.set(x, false);
    };

    extend_chain(1, 0);
    return make_tuple(best + create_array({n}), cnt);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&n : create_array({7, 14, 21, 29, 32, 42, 64, 47, 79, 191, 382, 379})) {
            auto [best, cnt] = bauer(n);
            print(u"L(#.) = #., count of minimum chain: #.\ne.g.: #.\n"_S.format(n, best.len() - 1, cnt, best));
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/AKS_test_for_primes#Python
BigInt = int

def expand_x_1(p):
    ex = [BigInt(1)]
    for i in range(p):
        ex.append(ex[-1] * -(p-i) // (i+1))
    return ex[::-1]

def aks_test(p):
    if p < 2: return False
    ex = expand_x_1(p)
    ex[0] += 1
    return not any(mult % p != 0 for mult in ex[0:-1])

print('# p: (x-1)^p for small p')
for p in range(12):
    print('%3i: %s' % (p, ' '.join('%s%i%s' % ('+' * (e>=0), e, ('x^%i' % n) if n else '')
                                   for n,e in enumerate(expand_x_1(p)))))

print('\n# small primes using the aks test')
print([p for p in range(101) if aks_test(p)])
===
F expand_x_1(p)
   V ex = [BigInt(1)]
   L(i) 0 .< p
      ex.append(ex.last * -(p - i) I/ (i + 1))
   R reversed(ex)

F aks_test(p)
   I p < 2
      R 0B
   V ex = expand_x_1(p)
   ex[0]++
   R !any(ex[0 .< (len)-1].map(mult -> mult % @p != 0))

print(‘# p: (x-1)^p for small p’)
L(p) 12
   print(‘#3: #.’.format(p, enumerate(expand_x_1(p)).map((n, e) -> ‘#.#.#.’.format(‘+’ * (e >= 0), e, I n {(‘x^#.’.format(n))} E ‘’)).join(‘ ’)))

print("\n# small primes using the aks test")
print((0.<101).filter(p -> aks_test(p)))
===
template <typename T1> auto expand_x_1(const T1 &p)
{
    auto ex = create_array({BigInt(1)});
    for (auto i : range_el(0, p))
        ex.append(idiv(ex.last() * -(p - i), (i + 1)));
    return reversed(ex);
}

template <typename T1> auto aks_test(const T1 &p)
{
    if (p < 2)
        return false;
    auto ex = expand_x_1(p);
    _get<0>(ex)++;
    return !any_map(ex[range_e_llen(0,  - 1)], [&p](const auto &mult){return mod(mult, p) != 0;});
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"# p: (x-1)^p for small p"_S);
        for (int p = 0; p < 12; p++)
            print(u"#3: #."_S.format(p, enumerate(expand_x_1(p)).map([](const auto &n, const auto &e){return u"#.#.#."_S.format(u"+"_S * (e >= 0), e, n ? (u"x^#."_S.format(n)) : u""_S);}).join(u" "_S)));

        print(u"\n# small primes using the aks test"_S);
        print(range_el(0, 101).filter([](const auto &p){return aks_test(p);}));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Aliquot_sequence_classifications#Python
def pdsum(n):
    return sum(x for x in range(1, (n + 1) // 2 + 1) if n % x == 0 and n != x)

def aliquot(n, maxlen=16, maxterm=2**30):
    if n == 0:
        return ('terminating', [0])
    s = [n]
    slen = 1
    new = n
    while slen <= maxlen and new < maxterm:
        new = pdsum(s[-1])
        if new in s:
            if s[0] == new:
                if slen == 1:
                    return ('perfect', s)
                elif slen == 2:
                    return ('amicable', s)
                else:
                    return ('sociable of length %i' % slen, s)
            elif s[-1] == new:
                return ('aspiring', s)
            else:
                return ('cyclic back to %i' % new, s)
        elif new == 0:
            return ('terminating', s + [0])
        else:
            s.append(new)
            slen += 1
    else:
        return ('non-terminating', s)

for n in range(1, 11):
    (cls, seq) = aliquot(n)
    print('%s: %s' % (cls, seq))
print()
for n in [11, 12, 28, 496, 220, 1184,  12496, 1264460, 790, 909, 562, 1064, 1488]:#, 15355717786080]:
    (cls, seq) = aliquot(n)
    print('%s: %s' % (cls, seq))
===
F pdsum(n)
   R sum((1 .. (n + 1) I/ 2).filter(x -> @n % x == 0 & @n != x))

F aliquot(n, maxlen = 16, maxterm = 2 ^ 30)
   I n == 0
      R (‘terminating’, [0])
   V s = [n]
   V slen = 1
   V new = n
   L slen <= maxlen & new < maxterm
      new = pdsum(s.last)
      I new C s
         I s[0] == new
            I slen == 1
               R (‘perfect’, s)
            E I slen == 2
               R (‘amicable’, s)
            E
               R (‘sociable of length #.’.format(slen), s)
         E I s.last == new
            R (‘aspiring’, s)
         E
            R (‘cyclic back to #.’.format(new), s)
      E I new == 0
         R (‘terminating’, s [+] [0])
      E
         s.append(new)
         slen++
   L.was_no_break
      R (‘non-terminating’, s)

L(n) 1..10
   V (cls, seq) = aliquot(n)
   print(‘#.: #.’.format(cls, seq))
print()
L(n) [11, 12, 28, 496, 220, 1184, 12496, 1264460, 790, 909, 562, 1064, 1488]
   V (cls, seq) = aliquot(n)
   print(‘#.: #.’.format(cls, seq))
===
template <typename T1> auto pdsum(const T1 &n)
{
    return sum(range_ee(1, idiv((n + 1), 2)).filter([&n](const auto &x){return mod(n, x) == 0 && n != x;}));
}

template <typename T1, typename T2 = decltype(16), typename T3 = decltype(pow(2, 30))> auto aliquot(const T1 &n, const T2 &maxlen = 16, const T3 &maxterm = pow(2, 30))
{
    if (n == 0)
        return make_tuple(u"terminating"_S, create_array({0}));
    auto s = create_array({n});
    auto slen = 1;
    auto _new_ = n;
    while (slen <= maxlen && _new_ < maxterm) {
        _new_ = pdsum(s.last());
        if (in(_new_, s)) {
            if (_get<0>(s) == _new_) {
                if (slen == 1)
                    return make_tuple(u"perfect"_S, s);
                else if (slen == 2)
                    return make_tuple(u"amicable"_S, s);
                else
                    return make_tuple(u"sociable of length #."_S.format(slen), s);
            }
            else if (s.last() == _new_)
                return make_tuple(u"aspiring"_S, s);
            else
                return make_tuple(u"cyclic back to #."_S.format(_new_), s);
        }
        else if (_new_ == 0)
            return make_tuple(u"terminating"_S, s + create_array({0}));
        else {
            s.append(_new_);
            slen++;
        }
    }
    return make_tuple(u"non-terminating"_S, s);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto n : range_ee(1, 10)) {
            auto [cls, seq] = aliquot(n);
            print(u"#.: #."_S.format(cls, seq));
        }
        print();
        for (auto &&n : create_array({11, 12, 28, 496, 220, 1184, 12496, 1264460, 790, 909, 562, 1064, 1488})) {
            auto [cls, seq] = aliquot(n);
            print(u"#.: #."_S.format(cls, seq));
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Angles_(geometric),_normalization_and_conversion#Nim
import math

values = [float(-2), -1, 0, 1, 2, 6.2831853, 16, 57.2957795, 359, 399, 6399, 1000000]

def normd(x): return math.fmod(x, 360)
def normg(x): return math.fmod(x, 400)
def normm(x): return math.fmod(x, 6400)
def normr(x): return math.fmod(x, (2 * math.pi))

def d2g(x): return normd(x) * 10 / 9
def d2m(x): return normd(x) * 160 / 9
def d2r(x): return normd(x) * math.pi / 180

def g2d(x): return normg(x) * 9 / 10
def g2m(x): return normg(x) * 16
def g2r(x): return normg(x) * math.pi / 200

def m2d(x): return normm(x) * 9 / 160
def m2g(x): return normm(x) / 16
def m2r(x): return normm(x) * math.pi / 3200

def r2d(x): return normr(x) * 180 / math.pi
def r2g(x): return normr(x) * 200 / math.pi
def r2m(x): return normr(x) * 3200 / math.pi

print("       Degrees        Normalized         Gradians          Mils            Radians")
print("───────────────────────────────────────────────────────────────────────────────────")
for val in values:
    print('{:15.7f}  {:15.7f}  {:15.7f}  {:15.7f}  {:15.7f}'.format(val, normd(val), d2g(val), d2m(val), d2r(val)))

print()
print("      Gradians        Normalized         Degrees           Mils            Radians")
print("───────────────────────────────────────────────────────────────────────────────────")
for val in values:
    print('{:15.7f}  {:15.7f}  {:15.7f}  {:15.7f}  {:15.7f}'.format(val, normg(val), g2d(val), g2m(val), g2r(val)))

print()
print("        Mils          Normalized         Degrees         Gradians          Radians")
print("───────────────────────────────────────────────────────────────────────────────────")
for val in values:
    print('{:15.7f}  {:15.7f}  {:15.7f}  {:15.7f}  {:15.7f}'.format(val, normm(val), m2d(val), m2g(val), m2r(val)))

print()
print("       Radians        Normalized         Degrees         Gradians          Mils")
print("───────────────────────────────────────────────────────────────────────────────────")
for val in values:
    print('{:15.7f}  {:15.7f}  {:15.7f}  {:15.7f}  {:15.7f}'.format(val, normr(val), r2d(val), r2g(val), r2m(val)))
===
V values = [Float(-2), -1, 0, 1, 2, 6.2831853, 16, 57.2957795, 359, 399, 6399, 1000000]

F normd(x)
   R fmod(x, 360)
F normg(x)
   R fmod(x, 400)
F normm(x)
   R fmod(x, 6400)
F normr(x)
   R fmod(x, (2 * math:pi))

F d2g(x)
   R normd(x) * 10 / 9
F d2m(x)
   R normd(x) * 160 / 9
F d2r(x)
   R normd(x) * math:pi / 180

F g2d(x)
   R normg(x) * 9 / 10
F g2m(x)
   R normg(x) * 16
F g2r(x)
   R normg(x) * math:pi / 200

F m2d(x)
   R normm(x) * 9 / 160
F m2g(x)
   R normm(x) / 16
F m2r(x)
   R normm(x) * math:pi / 3200

F r2d(x)
   R normr(x) * 180 / math:pi
F r2g(x)
   R normr(x) * 200 / math:pi
F r2m(x)
   R normr(x) * 3200 / math:pi

print(‘       Degrees        Normalized         Gradians          Mils            Radians’)
print(‘───────────────────────────────────────────────────────────────────────────────────’)
L(val) values
   print(‘#7.7  #7.7  #7.7  #7.7  #7.7’.format(val, normd(val), d2g(val), d2m(val), d2r(val)))

print()
print(‘      Gradians        Normalized         Degrees           Mils            Radians’)
print(‘───────────────────────────────────────────────────────────────────────────────────’)
L(val) values
   print(‘#7.7  #7.7  #7.7  #7.7  #7.7’.format(val, normg(val), g2d(val), g2m(val), g2r(val)))

print()
print(‘        Mils          Normalized         Degrees         Gradians          Radians’)
print(‘───────────────────────────────────────────────────────────────────────────────────’)
L(val) values
   print(‘#7.7  #7.7  #7.7  #7.7  #7.7’.format(val, normm(val), m2d(val), m2g(val), m2r(val)))

print()
print(‘       Radians        Normalized         Degrees         Gradians          Mils’)
print(‘───────────────────────────────────────────────────────────────────────────────────’)
L(val) values
   print(‘#7.7  #7.7  #7.7  #7.7  #7.7’.format(val, normr(val), r2d(val), r2g(val), r2m(val)))
===
auto values = create_array<double>({to_float(-2), -1, 0, 1, 2, 6.2831853, 16, 57.2957795, 359, 399, 6399, 1000000});

template <typename T1> auto normd(const T1 &x)
{
    return fmod(x, 360);
}
template <typename T1> auto normg(const T1 &x)
{
    return fmod(x, 400);
}
template <typename T1> auto normm(const T1 &x)
{
    return fmod(x, 6400);
}
template <typename T1> auto normr(const T1 &x)
{
    return fmod(x, (2 * math::pi));
}

template <typename T1> auto d2g(const T1 &x)
{
    return normd(x) * 10 / 9.0;
}
template <typename T1> auto d2m(const T1 &x)
{
    return normd(x) * 160 / 9.0;
}
template <typename T1> auto d2r(const T1 &x)
{
    return normd(x) * math::pi / 180.0;
}

template <typename T1> auto g2d(const T1 &x)
{
    return normg(x) * 9 / 10.0;
}
template <typename T1> auto g2m(const T1 &x)
{
    return normg(x) * 16;
}
template <typename T1> auto g2r(const T1 &x)
{
    return normg(x) * math::pi / 200.0;
}

template <typename T1> auto m2d(const T1 &x)
{
    return normm(x) * 9 / 160.0;
}
template <typename T1> auto m2g(const T1 &x)
{
    return normm(x) / 16.0;
}
template <typename T1> auto m2r(const T1 &x)
{
    return normm(x) * math::pi / 3200.0;
}

template <typename T1> auto r2d(const T1 &x)
{
    return normr(x) * 180 / math::pi;
}
template <typename T1> auto r2g(const T1 &x)
{
    return normr(x) * 200 / math::pi;
}
template <typename T1> auto r2m(const T1 &x)
{
    return normr(x) * 3200 / math::pi;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"       Degrees        Normalized         Gradians          Mils            Radians"_S);
        print(u"───────────────────────────────────────────────────────────────────────────────────"_S);
        for (auto &&val : values)
            print(u"#7.7  #7.7  #7.7  #7.7  #7.7"_S.format(val, normd(val), d2g(val), d2m(val), d2r(val)));

        print();
        print(u"      Gradians        Normalized         Degrees           Mils            Radians"_S);
        print(u"───────────────────────────────────────────────────────────────────────────────────"_S);
        for (auto &&val : values)
            print(u"#7.7  #7.7  #7.7  #7.7  #7.7"_S.format(val, normg(val), g2d(val), g2m(val), g2r(val)));

        print();
        print(u"        Mils          Normalized         Degrees         Gradians          Radians"_S);
        print(u"───────────────────────────────────────────────────────────────────────────────────"_S);
        for (auto &&val : values)
            print(u"#7.7  #7.7  #7.7  #7.7  #7.7"_S.format(val, normm(val), m2d(val), m2g(val), m2r(val)));

        print();
        print(u"       Radians        Normalized         Degrees         Gradians          Mils"_S);
        print(u"───────────────────────────────────────────────────────────────────────────────────"_S);
        for (auto &&val : values)
            print(u"#7.7  #7.7  #7.7  #7.7  #7.7"_S.format(val, normr(val), r2d(val), r2g(val), r2m(val)));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Apply_a_digital_filter_(direct_form_II_transposed)#Nim
def apply_filter(a, b, signal):
    result = [0.0] * len(signal)
    for i in range(len(signal)):
        tmp = 0.0
        for j in range(min(i + 1, len(b))):
            tmp += b[j] * signal[i - j]
        for j in range(1, min(i + 1, len(a))):
            tmp -= a[j] * result[i - j]
        tmp /= a[0]
        result[i] = tmp
    return result

a = [1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17]
b = [0.16666667, 0.5, 0.5, 0.16666667]

signal = [-0.917843918645,  0.141984778794, 1.20536903482,   0.190286794412,
          -0.662370894973, -1.00700480494, -0.404707073677,  0.800482325044,
           0.743500089861,  1.01090520172,  0.741527555207,  0.277841675195,
           0.400833448236, -0.2085993586,  -0.172842103641, -0.134316096293,
           0.0259303398477, 0.490105989562, 0.549391221511,  0.9047198589]

result = apply_filter(a, b, signal)
for i, r in enumerate(result):
    print('%11.8f' % r, end = '')
    print(', ' if (i + 1) % 5 != 0 else "\n", end = '')
===
F apply_filter(a, b, signal)
   V result = [0.0] * signal.len
   L(i) 0 .< signal.len
      V tmp = 0.0
      L(j) 0 .< min(i + 1, b.len)
         tmp += b[j] * signal[i - j]
      L(j) 1 .< min(i + 1, a.len)
         tmp -= a[j] * result[i - j]
      tmp /= a[0]
      result[i] = tmp
   R result

V a = [1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17]
V b = [0.16666667, 0.5, 0.5, 0.16666667]

V signal = [-0.917843918645, 0.141984778794, 1.20536903482, 0.190286794412, -0.662370894973, -1.00700480494, -0.404707073677, 0.800482325044, 0.743500089861, 1.01090520172, 0.741527555207, 0.277841675195, 0.400833448236, -0.2085993586, -0.172842103641, -0.134316096293, 0.0259303398477, 0.490105989562, 0.549391221511, 0.9047198589]

V result = apply_filter(a, b, signal)
L(r) result
   V i = L.index
   print(‘#2.8’.format(r), end' ‘’)
   print(I (i + 1) % 5 != 0 {‘, ’} E "\n", end' ‘’)
===
template <typename T1, typename T2, typename T3> auto apply_filter(const T1 &a, const T2 &b, const T3 &signal)
{
    auto result = create_array({0.0}) * signal.len();
    for (auto i : range_el(0, signal.len())) {
        auto tmp = 0.0;
        for (auto j : range_el(0, min(i + 1, b.len())))
            tmp += b[j] * signal[i - j];
        for (auto j : range_el(1, min(i + 1, a.len())))
            tmp -= a[j] * result[i - j];
        tmp /= _get<0>(a);
        result.set(i, tmp);
    }
    return result;
}

auto a = create_array({1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17});
auto b = create_array({0.16666667, 0.5, 0.5, 0.16666667});

auto signal = create_array({-0.917843918645, 0.141984778794, 1.20536903482, 0.190286794412, -0.662370894973, -1.00700480494, -0.404707073677, 0.800482325044, 0.743500089861, 1.01090520172, 0.741527555207, 0.277841675195, 0.400833448236, -0.2085993586, -0.172842103641, -0.134316096293, 0.0259303398477, 0.490105989562, 0.549391221511, 0.9047198589});

auto result = apply_filter(a, b, signal);

struct CodeBlock1
{
    CodeBlock1()
    {
        {int Lindex = 0;
        for (auto &&r : result) {
            auto i = Lindex;
            print(u"#2.8"_S.format(r), u""_S);
            print(mod((i + 1), 5) != 0 ? u", "_S : u"\n"_S, u""_S);
            Lindex++;
        }}
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Arbitrary-precision_integers_(included)#Python
BigInt = int
y = str( BigInt(5)**4**3**2 )
print("5^4^3^2 = %s...%s and has %i digits" % (y[:20], y[-20:], len(y)))
===
V y = String(BigInt(5) ^ 4 ^ 3 ^ 2)
print(‘5^4^3^2 = #....#. and has #. digits’.format(y[0.<20], y[(len)-20 ..], y.len))
===
auto y = String(pow(BigInt(5), pow(4, square(3))));

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"5^4^3^2 = #....#. and has #. digits"_S.format(y[range_el(0, 20)], y[range_elen_i( - 20)], y.len()));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Arithmetic_coding/As_a_generalized_change_of_radix#Python
import collections
BigInt = int

def cumulative_freq(freq):
    cf : Dict[int, int] = {}
    total = 0
    for b in range(256):
        if b in freq:
            cf[b] = total
            total += freq[b]
    return cf

def arithmethic_coding(bytes, radix):

    # The frequency characters
    freq : DefaultDict[int, int] = collections.defaultdict(int)
    for b in bytes:
        freq[ord(b)] += 1

    # The cumulative frequency table
    cf = cumulative_freq(freq)

    # Base
    base : BigInt = len(bytes)

    # Lower bound
    lower : BigInt = 0

    # Product of all frequencies
    pf : BigInt = 1

    # Each term is multiplied by the product of the
    # frequencies of all previously occurring symbols
    for b in bytes:
        lower = lower*base + cf[ord(b)]*pf
        pf *= freq[ord(b)]

    # Upper bound
    upper = lower+pf

    power : BigInt = 0
    while True:
        pf //= radix
        if pf==0: break
        power += 1

    enc = (upper-1) // BigInt(radix)**power
    return (enc, power, freq)

def arithmethic_decoding(enc, radix, power, freq):

    # Multiply enc by radix^power
    enc *= radix**power

    # Base
    base = sum(freq.values())

    # Create the cumulative frequency table
    cf = cumulative_freq(freq)

    # Create the dictionary
    dict : Dict[int, int] = {}
    for k,v in cf.items():
        dict[v] = k

    # Fill the gaps in the dictionary
    lchar : Optional[int] = None
    for i in range(base):
        if i in dict:
            lchar = dict[i]
        elif lchar is not None:
            dict[i] = lchar

    # Decode the input number
    decoded = ''#bytearray()
    for i in range(base-1, -1, -1):
        power = BigInt(base)**i
        div = enc//power

        c  = dict[int(div)]
        fv = freq[c]
        cv = cf[c]

        rem = (enc - power*cv) // fv

        enc = rem
        decoded += chr(c)

    # Return the decoded output
    return decoded#bytes(decoded)

radix = 10      # can be any integer greater or equal with 2

for str in 'DABDDB DABDDBBDDBA ABRACADABRA TOBEORNOTTOBEORTOBEORNOT'.split(' '):
    (enc, power, freq) = arithmethic_coding(str, radix)
    dec = arithmethic_decoding(enc, radix, power, freq)

    print("%-25s=> %19s * %d^%s" % (str, enc, radix, power))

    if str != dec:
        raise RuntimeError("\tHowever that is incorrect!")
===
F cumulative_freq(freq)
   [Int = Int] cf
   V total = 0
   L(b) 256
      I b C freq
         cf[b] = total
         total += freq[b]
   R cf

F arithmethic_coding(bytes, radix)

   DefaultDict[Int, Int] freq
   L(b) bytes
      freq[b.code]++

   V cf = cumulative_freq(freq)

   BigInt base = bytes.len

   BigInt lower = 0

   BigInt pf = 1

   L(b) bytes
      lower = lower * base + cf[b.code] * pf
      pf *= freq[b.code]

   V upper = lower + pf

   BigInt power = 0
   L
      pf I/= radix
      I pf == 0
         L.break
      power++

   V enc = (upper - 1) I/ BigInt(radix) ^ power
   R (enc, power, freq)

F arithmethic_decoding(=enc, radix, =power, freq)

   enc *= radix ^ power

   V base = sum(freq.values())

   V cf = cumulative_freq(freq)

   [Int = Int] dict
   L(k, v) cf
      dict[v] = k

   Int? lchar
   L(i) 0 .< base
      I i C dict
         lchar = dict[i]
      E I lchar != N
         dict[i] = lchar

   V decoded = ‘’
   L(i) (base - 1 .< -1).step(-1)
      power = BigInt(base) ^ i
      V div = enc I/ power

      V c = dict[Int(div)]
      V fv = freq[c]
      V cv = cf[c]

      V rem = (enc - power * cv) I/ fv

      enc = rem
      decoded ‘’= Char(code' c)

   R decoded

V radix = 10

L(str) ‘DABDDB DABDDBBDDBA ABRACADABRA TOBEORNOTTOBEORTOBEORNOT’.split(‘ ’)
   V (enc, power, freq) = arithmethic_coding(str, radix)
   V dec = arithmethic_decoding(enc, radix, power, freq)

   print(‘#<25=> #19 * #.^#.’.format(str, enc, radix, power))

   I str != dec
      X RuntimeError("\tHowever that is incorrect!")
===
template <typename T1> auto cumulative_freq(const T1 &freq)
{
    Dict<int, int> cf;
    auto total = 0;
    for (int b = 0; b < 256; b++)
        if (in(b, freq)) {
            cf.set(b, total);
            total += freq[b];
        }
    return cf;
}

template <typename T1, typename T2> auto arithmethic_coding(const T1 &bytes, const T2 &radix)
{

    DefaultDict<int, int> freq;
    for (auto &&b : bytes)
        freq[b.code]++;

    auto cf = cumulative_freq(freq);

    BigInt base = bytes.len();

    BigInt lower = 0;

    BigInt pf = 1;

    for (auto &&b : bytes) {
        lower = lower * base + cf[b.code] * pf;
        pf *= freq[b.code];
    }

    auto upper = lower + pf;

    BigInt power = 0;
    while (true) {
        pf = idiv(pf, radix);
        if (pf == 0)
            break;
        power++;
    }

    auto enc = idiv((upper - 1), pow(BigInt(radix), power));
    return make_tuple(enc, power, freq);
}

template <typename T1, typename T2, typename T3, typename T4> auto arithmethic_decoding(T1 enc, const T2 &radix, T3 power, const T4 &freq)
{

    enc *= pow(radix, power);

    auto base = sum(freq.values());

    auto cf = cumulative_freq(freq);

    Dict<int, int> dict;
    for (auto &&[k, v] : cf)
        dict.set(v, k);

    Nullable<int> lchar;
    for (auto i : range_el(0, base))
        if (in(i, dict))
            lchar = dict[i];
        else if (lchar != nullptr)
            dict.set(i, *lchar);

    auto decoded = u""_S;
    for (auto i : range_el(base - 1, -1).step(-1)) {
        power = pow(BigInt(base), i);
        auto div = idiv(enc, power);

        auto c = dict[to_int(div)];
        auto fv = freq[c];
        auto cv = cf[c];

        auto rem = idiv((enc - power * cv), fv);

        enc = rem;
        decoded &= Char(c);
    }

    return decoded;
}

auto radix = 10;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&str : u"DABDDB DABDDBBDDBA ABRACADABRA TOBEORNOTTOBEORTOBEORNOT"_S.split(u" "_S)) {
            auto [enc, power, freq] = arithmethic_coding(str, radix);
            auto dec = arithmethic_decoding(enc, radix, power, freq);

            print(u"#<25=> #19 * #.^#."_S.format(str, enc, radix, power));

            if (str != dec)
                throw RuntimeError(u"\tHowever that is incorrect!"_S);
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Associative_array/Merging#Python
base = {"name":"Rocket Skates", "price":"12.75", "color":"yellow"}
update = {"price":"15.25", "color":"red", "year":"1974"}

result = base.copy()
result.update(update)

print(result)
===
V base = [‘name’ = ‘Rocket Skates’, ‘price’ = ‘12.75’, ‘color’ = ‘yellow’]
V update = [‘price’ = ‘15.25’, ‘color’ = ‘red’, ‘year’ = ‘1974’]

V result = base.copy()
result.update(update)

print(result)
===
auto base = create_dict(dict_of(u"name"_S, u"Rocket Skates"_S)(u"price"_S, u"12.75"_S)(u"color"_S, u"yellow"_S));
auto update = create_dict(dict_of(u"price"_S, u"15.25"_S)(u"color"_S, u"red"_S)(u"year"_S, u"1974"_S));

auto result = base.copy();

struct CodeBlock1
{
    CodeBlock1()
    {
        result.update(update);

        print(result);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Attractive_numbers#Python
import math
from typing import List

def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(math.sqrt(n)) + 1):
        if n % i == 0:
            return False
    return True

def get_pfct(n):
    i = 2; factors : List[int] = []
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
            factors.append(i)
    if n > 1:
        factors.append(n)
    return len(factors)

pool : List[int] = []

for each in range(0,121):
    pool.append(get_pfct(each))

r : List[int] = []
for i,each in enumerate(pool):
    if is_prime(each):
        r.append(i)

print(','.join(map(str, r)))
===
F is_prime(n)
   I n < 2
      R 0B
   L(i) 2 .. Int(sqrt(n))
      I n % i == 0
         R 0B
   R 1B

F get_pfct(=n)
   V i = 2
   [Int] factors
   L i * i <= n
      I n % i
         i++
      E
         n I/= i
         factors.append(i)
   I n > 1
      factors.append(n)
   R factors.len

[Int] pool

L(each) 0..120
   pool.append(get_pfct(each))

[Int] r
L(each) pool
   V i = L.index
   I is_prime(each)
      r.append(i)

print(r.map(String).join(‘,’))
===
template <typename T1> auto is_prime(const T1 &n)
{
    if (n < 2)
        return false;
    for (auto i : range_ee(2, to_int(sqrt(n))))
        if (mod(n, i) == 0)
            return false;
    return true;
}

template <typename T1> auto get_pfct(T1 n)
{
    auto i = 2;
    Array<int> factors;
    while (i * i <= n)
        if (mod(n, i))
            i++;
        else {
            n = idiv(n, i);
            factors.append(i);
        }
    if (n > 1)
        factors.append(n);
    return factors.len();
}

Array<int> pool;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto each : range_ee(0, 120))
            pool.append(get_pfct(each));
    }
} code_block_1;

Array<int> r;

struct CodeBlock2
{
    CodeBlock2()
    {
        {int Lindex = 0;
        for (auto &&each : pool) {
            auto i = Lindex;
            if (is_prime(each))
                r.append(i);
            Lindex++;
        }}

        print(r.map([](const auto &x){return String(x);}).join(u","_S));
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Average_loop_length#Python
import math
import random

def ffactorial(n):
    result = 1.0
    for i in range(2, n + 1):
        result *= i
    return result

MAX_N = 20
TIMES = 1000000

def analytical(n):
    return sum(ffactorial(n) / pow(float(n), float(i)) / ffactorial(n - i) for i in range(1, n+1))

def test(n, times):
    count = 0
    for i in range(times):
        (x, bits) = (1, 0)
        while (bits & x) == 0:
            count += 1
            bits |= x
            x = 1 << random.randrange(n)
    return float(count) / times

print(" n      avg     exp.    diff\n-------------------------------")
for n in range(1, MAX_N+1):
    avg = test(n, TIMES)
    theory = analytical(n)
    diff = (avg / theory - 1) * 100
    print("%2d %8.4f %8.4f %6.3f%%" % (n, avg, theory, diff))
===
F ffactorial(n)
   V result = 1.0
   L(i) 2 .. n
      result *= i
   R result

V MAX_N = 20
V TIMES = 1000000

F analytical(n)
   R sum((1 .. n).map(i -> ffactorial(@n) / pow(Float(@n), Float(i)) / ffactorial(@n - i)))

F test(n, times)
   V count = 0
   L(i) 0 .< times
      V (x, bits) = (1, 0)
      L (bits [&] x) == 0
         count++
         bits [|]= x
         x = 1 << random:(n)
   R Float(count) / times

print(" n      avg     exp.    diff\n-------------------------------")
L(n) 1 .. MAX_N
   V avg = test(n, TIMES)
   V theory = analytical(n)
   V diff = (avg / theory - 1) * 100
   print(‘#2 #3.4 #3.4 #2.3%’.format(n, avg, theory, diff))
===
template <typename T1> auto ffactorial(const T1 &n)
{
    auto result = 1.0;
    for (auto i : range_ee(2, n))
        result *= i;
    return result;
}

auto MAX_N = 20;
auto TIMES = 1000000;

template <typename T1> auto analytical(const T1 &n)
{
    return sum_map(range_ee(1, n), [&n](const auto &i){return ffactorial(n) / pow(to_float(n), to_float(i)) / ffactorial(n - i);});
}

template <typename T1, typename T2> auto test(const T1 &n, const T2 &times)
{
    auto count = 0;
    for (auto i : range_el(0, times)) {
        auto [x, bits] = make_tuple(1, 0);
        while ((bits & x) == 0) {
            count++;
            bits |= x;
            x = 1 << randomns::_(n);
        }
    }
    return to_float(count) / times;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u" n      avg     exp.    diff\n-------------------------------"_S);
        for (auto n : range_ee(1, MAX_N)) {
            auto avg = test(n, TIMES);
            auto theory = analytical(n);
            auto diff = (avg / theory - 1) * 100;
            print(u"#2 #3.4 #3.4 #2.3%"_S.format(n, avg, theory, diff));
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Add_and_sort_square_numbers_in_ascending_order_from_three_lists
from typing import List
import math

lists = [[3,4,34,25,9,12,36,56,36], [2,8,81,169,34,55,76,49,7], [75,121,75,144,35,16,46,35]]
squares : List[int] = []

def is_square(x):
    return int(math.sqrt(x)) ** 2 == x

for l in lists:
    for x in l:
        if is_square(x):
            squares.append(x)

squares.sort()
print(squares)
===
V lists = [[3, 4, 34, 25, 9, 12, 36, 56, 36], [2, 8, 81, 169, 34, 55, 76, 49, 7], [75, 121, 75, 144, 35, 16, 46, 35]]
[Int] squares

F is_square(x)
   R Int(sqrt(x)) ^ 2 == x

L(l) lists
   L(x) l
      I is_square(x)
         squares.append(x)

squares.sort()
print(squares)
===
auto lists = create_array({create_array({3, 4, 34, 25, 9, 12, 36, 56, 36}), create_array({2, 8, 81, 169, 34, 55, 76, 49, 7}), create_array({75, 121, 75, 144, 35, 16, 46, 35})});
Array<int> squares;

template <typename T1> auto is_square(const T1 &x)
{
    return square(to_int(sqrt(x))) == x;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&l : lists)
            for (auto &&x : l)
                if (is_square(x))
                    squares.append(x);

        squares.sort();
        print(squares);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Additive_primes#Python
import math

def is_prime(a):
    if a == 2: return True
    if a < 2 or a % 2 == 0: return False
    for i in range(3, int(math.sqrt(a)) + 1, 2):
        if a % i == 0:
            return False
    return True

def digit_sum(n):
    sum = 0
    while n > 0:
        sum += n % 10
        n //= 10
    return sum

additive_primes = 0
for i in range(2, 500):
    if is_prime(i) and is_prime(digit_sum(i)):
        additive_primes += 1
        print(i, end=" ")
print(f"\nFound {additive_primes} additive primes less than 500")
===
F is_prime(a)
   I a == 2
      R 1B
   I a < 2 | a % 2 == 0
      R 0B
   L(i) (3 .. Int(sqrt(a))).step(2)
      I a % i == 0
         R 0B
   R 1B

F digit_sum(=n)
   V sum = 0
   L n > 0
      sum += n % 10
      n I/= 10
   R sum

V additive_primes = 0
L(i) 2..499
   I is_prime(i) & is_prime(digit_sum(i))
      additive_primes++
      print(i, end' ‘ ’)
print("\nFound "additive_primes‘ additive primes less than 500’)
===
template <typename T1> auto is_prime(const T1 &a)
{
    if (a == 2)
        return true;
    if (a < 2 || mod(a, 2) == 0)
        return false;
    for (auto i : range_ee(3, to_int(sqrt(a))).step(2))
        if (mod(a, i) == 0)
            return false;
    return true;
}

template <typename T1> auto digit_sum(T1 n)
{
    auto sum = 0;
    while (n > 0) {
        sum += mod(n, 10);
        n = idiv(n, 10);
    }
    return sum;
}

auto additive_primes = 0;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto i : range_ee(2, 499))
            if (is_prime(i) && is_prime(digit_sum(i))) {
                additive_primes++;
                print(i, u" "_S);
            }
        print(u"\nFound "_S & additive_primes & u" additive primes less than 500"_S);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/ADFGVX_cipher#Nim
import random, collections
Char = str

adfgvx = "ADFGVX"

def encrypt(plainText, polybius, key):
    s = ''
    for ch in plainText:
        for r in range(6):
            for c in range(6):
                if polybius[r][c] == ch:
                    s += adfgvx[r] + adfgvx[c]

    cols = collections.defaultdict(str) # Char
    for i, ch in enumerate(s):
        cols[key[i % len(key)]] += str(ch)

    result = ''
    for k in sorted(cols.keys()):
        if len(result) != 0:
            result += ' '
        result += cols[k]
    return result

def decrypt(cipherText, polybius, key):
    skey = sorted(key)
    cols = [''] * len(key)
    idx = 0
    for col in cipherText.split(' '):
        cols[key.find(skey[idx])] = col
        idx += 1

    s = ''
    for i in range(len(key)):
        for col in cols:
            if i < len(col): s += col[i]

    result = ''
    for i in range(0, len(s) - 1, 2):
        r = adfgvx.find(s[i])
        c = adfgvx.find(s[i+1])
        result += polybius[r][c]
    return result

polybius = [[Char("\0")] * 6 for i in range(6)]
alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
random.shuffle(alphabet)
for r in range(6):
    for c in range(6):
        polybius[r][c] = alphabet[6 * r + c]

print("6 x 6 Polybius square:\n")
print('  | A D F G V X')
print('---------------')
for i, row in enumerate(polybius):
    print(adfgvx[i], '|', ' '.join(row))

words = [w for w in open('unixdict.txt').read().split("\n") if len(w) == 9 and len(w) == len(set(list(w)))]
key = random.choice(words).upper()
print("\nThe key is", key)

PlainText = "ATTACKAT1200AM"
print("\nPlaintext :", PlainText)

cipherText = encrypt(PlainText, polybius, key)
print("\nEncrypted :", cipherText)

plainText = decrypt(cipherText, polybius, key)
print("\nDecrypted :", plainText)
===
V adfgvx = ‘ADFGVX’

F encrypt(plainText, polybius, key)
   V s = ‘’
   L(ch) plainText
      L(r) 6
         L(c) 6
            I polybius[r][c] == ch
               s ‘’= :adfgvx[r]‘’:adfgvx[c]

   V cols = DefaultDict[Char, String]()
   L(ch) s
      V i = L.index
      cols[key[i % key.len]] ‘’= String(ch)

   V result = ‘’
   L(k) sorted(cols.keys())
      I !result.empty
         result ‘’= ‘ ’
      result ‘’= cols[k]
   R result

F decrypt(cipherText, polybius, key)
   V skey = sorted(key)
   V cols = [‘’] * key.len
   V idx = 0
   L(col) cipherText.split(‘ ’)
      cols[key.findi(skey[idx])] = col
      idx++

   V s = ‘’
   L(i) 0 .< key.len
      L(col) cols
         I i < col.len
            s ‘’= col[i]

   V result = ‘’
   L(i) (0 .< s.len - 1).step(2)
      V r = :adfgvx.findi(s[i])
      V c = :adfgvx.findi(s[i + 1])
      result ‘’= polybius[r][c]
   R result

V polybius = [[Char("\0")] * 6] * 6
V alphabet = ‘ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789’
random:shuffle(&alphabet)
L(r) 6
   L(c) 6
      polybius[r][c] = alphabet[6 * r + c]

print("6 x 6 Polybius square:\n")
print(‘  | A D F G V X’)
print(‘---------------’)
L(row) polybius
   V i = L.index
   print(adfgvx[i]‘ | ’row.join(‘ ’))

V words = File(‘unixdict.txt’).read().split("\n").filter(w -> w.len == 9 & w.len == Set(Array(w)).len)
V key = random:choice(words).uppercase()
print("\nThe key is "key)

V PlainText = ‘ATTACKAT1200AM’
print("\nPlaintext : "PlainText)

V cipherText = encrypt(PlainText, polybius, key)
print("\nEncrypted : "cipherText)

V plainText = decrypt(cipherText, polybius, key)
print("\nDecrypted : "plainText)
===
auto adfgvx = u"ADFGVX"_S;

template <typename T1, typename T2, typename T3> auto encrypt(const T1 &plainText, const T2 &polybius, const T3 &key)
{
    auto s = u""_S;
    for (auto &&ch : plainText)
        for (int r = 0; r < 6; r++)
            for (int c = 0; c < 6; c++)
                if (polybius[r][c] == ch)
                    s &= ::adfgvx[r] & ::adfgvx[c];

    auto cols = DefaultDict<Char, String>();
    {int Lindex = 0;
    for (auto &&ch : s) {
        auto i = Lindex;
        cols[key[mod(i, key.len())]] &= String(ch);
        Lindex++;
    }}

    auto result = u""_S;
    for (auto &&k : sorted(cols.keys())) {
        if (!result.empty())
            result &= u" "_S;
        result &= cols[k];
    }
    return result;
}

template <typename T1, typename T2, typename T3> auto decrypt(const T1 &cipherText, const T2 &polybius, const T3 &key)
{
    auto skey = sorted(key);
    auto cols = create_array({u""_S}) * key.len();
    auto idx = 0;
    for (auto &&col : cipherText.split(u" "_S)) {
        cols.set(key.findi(skey[idx]), col);
        idx++;
    }

    auto s = u""_S;
    for (auto i : range_el(0, key.len()))
        for (auto &&col : cols)
            if (i < col.len())
                s &= col[i];

    auto result = u""_S;
    for (auto i : range_el(0, s.len() - 1).step(2)) {
        auto r = ::adfgvx.findi(s[i]);
        auto c = ::adfgvx.findi(s[i + 1]);
        result &= polybius[r][c];
    }
    return result;
}

auto polybius = create_array({create_array({u'\0'_C}) * 6}) * 6;
auto alphabet = u"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"_S;

struct CodeBlock1
{
    CodeBlock1()
    {
        randomns::shuffle(alphabet);
        for (int r = 0; r < 6; r++)
            for (int c = 0; c < 6; c++)
                polybius[r].set(c, alphabet[6 * r + c]);

        print(u"6 x 6 Polybius square:\n"_S);
        print(u"  | A D F G V X"_S);
        print(u"---------------"_S);
        {int Lindex = 0;
        for (auto &&row : polybius) {
            auto i = Lindex;
            print(adfgvx[i] & u" | "_S & row.join(u" "_S));
            Lindex++;
        }}
    }
} code_block_1;

auto words = File(u"unixdict.txt"_S).read().split(u"\n"_S).filter([](const auto &w){return w.len() == 9 && w.len() == create_set(create_array(w)).len();});
auto key = randomns::choice(words).uppercase();

struct CodeBlock2
{
    CodeBlock2()
    {
        print(u"\nThe key is "_S & key);
    }
} code_block_2;

auto PlainText = u"ATTACKAT1200AM"_S;

struct CodeBlock3
{
    CodeBlock3()
    {
        print(u"\nPlaintext : "_S & PlainText);
    }
} code_block_3;

auto cipherText = encrypt(PlainText, polybius, key);

struct CodeBlock4
{
    CodeBlock4()
    {
        print(u"\nEncrypted : "_S & cipherText);
    }
} code_block_4;

auto plainText = decrypt(cipherText, polybius, key);

struct CodeBlock5
{
    CodeBlock5()
    {
        print(u"\nDecrypted : "_S & plainText);
    }
} code_block_5;


# https://www.rosettacode.org/wiki/Air_mass#Python
import math

DEG = 0.017453292519943295769236907684886127134  # degrees to radians
RE = 6371000                                     # Earth radius in meters
dd = 0.001      # integrate in this fraction of the distance already covered
FIN = 10000000  # integrate only to a height of 10000km, effectively infinity

def rho(a):
    """ the density of air as a function of height above sea level """
    return math.exp(-a / 8500.0)

def height(a : float, z, d):
    """
    a = altitude of observer
    z = zenith angle (in degrees)
    d = distance along line of sight
    """
    return math.sqrt((RE + a)**2 + d**2 - 2 * d * (RE + a) * math.cos((180 - z) * DEG)) - RE

def column_density(a, z):
    """ integrates density along the line of sight """
    (dsum, d) = (0.0, 0.0)
    while d < FIN:
        delta = max(dd, (dd)*d)  # adaptive step size to avoid it taking forever:
        dsum += rho(height(a, z, d + 0.5 * delta)) * delta
        d += delta
    return dsum

def airmass(a, z):
    return column_density(a, z) / column_density(a, 0)

print('Angle           0 m          13700 m\n', '-' * 36)
for z in range(0, 91, 5):
    print(f"{z:3}      {airmass(0, z):12.7f}    {airmass(13700, z):12.7f}")
===
V DEG = 0.017453292519943295769236907684886127134
V RE = 6371000
V dd = 0.001
V FIN = 10000000

F rho(a)
   ‘ the density of air as a function of height above sea level ’
   R exp(-a / 8500.0)

F height(Float a; z, d)
   ‘
    a = altitude of observer
    z = zenith angle (in degrees)
    d = distance along line of sight
    ’
   R sqrt((:RE + a) ^ 2 + d ^ 2 - 2 * d * (:RE + a) * cos((180 - z) * :DEG)) - :RE

F column_density(a, z)
   ‘ integrates density along the line of sight ’
   V (dsum, d) = (0.0, 0.0)
   L d < :FIN
      V delta = max(:dd, (:dd) * d)
      dsum += rho(height(a, z, d + 0.5 * delta)) * delta
      d += delta
   R dsum

F airmass(a, z)
   R column_density(a, z) / column_density(a, 0)

print("Angle           0 m          13700 m\n "(‘-’ * 36))
L(z) (0.<91).step(5)
   print(f:‘{z:3}      {airmass(0, z):12.7}    {airmass(13700, z):12.7}’)
===
auto DEG = 0.017453292519943295769236907684886127134;
auto RE = 6371000;
auto dd = 0.001;
auto FIN = 10000000;

template <typename T1> auto rho(const T1 &a)
{
    u" the density of air as a function of height above sea level "_S;
    return exp(-a / 8500.0);
}

template <typename T2, typename T3> auto height(const double a, const T2 &z, const T3 &d)
{
    uR"(
    a = altitude of observer
    z = zenith angle (in degrees)
    d = distance along line of sight
    )"_S;
    return sqrt(square((::RE + a)) + square(d) - 2 * d * (::RE + a) * cos((180 - z) * ::DEG)) - ::RE;
}

template <typename T1, typename T2> auto column_density(const T1 &a, const T2 &z)
{
    u" integrates density along the line of sight "_S;
    auto [dsum, d] = make_tuple(0.0, 0.0);
    while (d < ::FIN) {
        auto delta = max(::dd, (::dd) * d);
        dsum += rho(height(a, z, d + 0.5 * delta)) * delta;
        d += delta;
    }
    return dsum;
}

template <typename T1, typename T2> auto airmass(const T1 &a, const T2 &z)
{
    return column_density(a, z) / column_density(a, 0);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"Angle           0 m          13700 m\n "_S & (u"-"_S * 36));
        for (auto z : range_el(0, 91).step(5))
            print(u"#3      #4.7    #4.7"_S.format(z, airmass(0, z), airmass(13700, z)));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Append_numbers_at_same_position_in_strings
list1 = [1, 2, 3, 4, 5, 6, 7, 8, 9]
list2 = [10, 11, 12, 13, 14, 15, 16, 17, 18]
list3 = [19, 20, 21, 22, 23, 24, 25, 26, 27]

print([
    f'{str(n1)}{n2}{n3}' for n1, n2, n3
    in zip(list1, list2, list3)
])
===
V list1 = [1, 2, 3, 4, 5, 6, 7, 8, 9]
V list2 = [10, 11, 12, 13, 14, 15, 16, 17, 18]
V list3 = [19, 20, 21, 22, 23, 24, 25, 26, 27]

print(zip(list1, list2, list3).map((n1, n2, n3) -> String(n1)‘’n2‘’n3))
===
auto list1 = create_array({1, 2, 3, 4, 5, 6, 7, 8, 9});
auto list2 = create_array({10, 11, 12, 13, 14, 15, 16, 17, 18});
auto list3 = create_array({19, 20, 21, 22, 23, 24, 25, 26, 27});

struct CodeBlock1
{
    CodeBlock1()
    {
        print(zip(list1, list2, list3).map([](const auto &n1, const auto &n2, const auto &n3){return String(n1) & n2 & n3;}));
    }
} code_block_1;