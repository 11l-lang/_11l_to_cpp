# https://www.rosettacode.org/wiki/Determine_if_two_triangles_overlap#D
from typing import Tuple

class Triangle:
    p1 : Tuple[float, float]
    p2 : Tuple[float, float]
    p3 : Tuple[float, float]

    def __init__(self, p1, p2, p3):
        self.p1 = p1
        self.p2 = p2
        self.p3 = p3

    def __str__(self):
        return 'Triangle: %s, %s, %s' % (self.p1, self.p2, self.p3)

    def det2D(self): # const
        return self.p1[0] *(self.p2[1] - self.p3[1]) \
             + self.p2[0] *(self.p3[1] - self.p1[1]) \
             + self.p3[0] *(self.p1[1] - self.p2[1])

def checkTriWinding(t : "Triangle", allowReversed):
    detTri = t.det2D()
    if detTri < 0.0:
        assert allowReversed, "Triangle has wrong winding direction"
        (t.p2, t.p3) = (t.p3, t.p2)

def boundaryCollideChk(t : Triangle, eps : float):
    return t.det2D() < eps

def boundaryDoesntCollideChk(t : Triangle, eps : float):
    return t.det2D() <= eps

def triTri2D(t1 : "Triangle", t2 : "Triangle", eps = 0.0, allowReversed = False, onBoundary = True):
    # Triangles must be expressed anti-clockwise
    checkTriWinding(t1, allowReversed)
    checkTriWinding(t2, allowReversed)
    # 'onBoundary' determines whether points on boundary are considered as colliding or not
    chkEdge = boundaryCollideChk if onBoundary else boundaryDoesntCollideChk
    lp1 = [t1.p1, t1.p2, t1.p3]
    lp2 = [t2.p1, t2.p2, t2.p3]

    # for each edge E of t1
    for i in range(3):
        j = (i + 1) % 3
        # Check all points of t2 lay on the external side of edge E.
        # If they do, the triangles do not overlap.
        if chkEdge(Triangle(lp1[i], lp1[j], lp2[0]), eps) and \
           chkEdge(Triangle(lp1[i], lp1[j], lp2[1]), eps) and \
           chkEdge(Triangle(lp1[i], lp1[j], lp2[2]), eps):
            return False

    # for each edge E of t2
    for i in range(3):
        j = (i + 1) % 3
        # Check all points of t1 lay on the external side of edge E.
        # If they do, the triangles do not overlap.
        if chkEdge(Triangle(lp2[i], lp2[j], lp1[0]), eps) and \
           chkEdge(Triangle(lp2[i], lp2[j], lp1[1]), eps) and \
           chkEdge(Triangle(lp2[i], lp2[j], lp1[2]), eps):
            return False

    # The triangles overlap
    return True

def overlap(t1 : "Triangle", t2 : "Triangle", eps = 0.0, allowReversed = False, onBoundary = True):
    if triTri2D(t1, t2, eps, allowReversed, onBoundary):
        print('overlap')
    else:
        print('do not overlap')

t1 = Triangle((0.0, 0.0), (5.0, 0.0), (0.0, 5.0))
t2 = Triangle((0.0, 0.0), (5.0, 0.0), (0.0, 6.0))
print(t1, " and\n", t2, sep = '')
overlap(t1, t2)
print()

# need to allow reversed for this pair to avoid exception
t1 = Triangle((0.0, 0.0), (0.0, 5.0), (5.0, 0.0))
t2 = t1
print(t1, " and\n", t2, sep = '')
overlap(t1, t2, 0.0, True)
print()

t1 = Triangle((0.0, 0.0), (5.0, 0.0), (0.0, 5.0))
t2 = Triangle((-10.0, 0.0), (-5.0, 0.0), (-1.0, 6.0))
print(t1, " and\n", t2, sep = '')
overlap(t1, t2)
print()

t1.p3 = (2.5, 5.0)
t2 = Triangle((0.0, 4.0), (2.5, -1.0), (5.0, 4.0))
print(t1, " and\n", t2, sep = '')
overlap(t1, t2)
print()

t1 = Triangle((0.0, 0.0), (1.0, 1.0), (0.0, 2.0))
t2 = Triangle((2.0, 1.0), (3.0, 0.0), (3.0, 2.0))
print(t1, " and\n", t2, sep = '')
overlap(t1, t2)
print()

t2 = Triangle((2.0, 1.0), (3.0, -2.0), (3.0, 4.0))
print(t1, " and\n", t2, sep = '')
overlap(t1, t2)
print()

t1 = Triangle((0.0, 0.0), (1.0, 0.0), (0.0, 1.0))
t2 = Triangle((1.0, 0.0), (2.0, 0.0), (1.0, 1.1))
print(t1, " and\n", t2, sep = '')
print("which have only a single corner in contact, if boundary points collide")
overlap(t1, t2)
print()

print(t1, " and\n", t2, sep = '')
print("which have only a single corner in contact, if boundary points do not collide")
overlap(t1, t2, 0.0, False, False)
===
T Triangle
   (Float, Float) p1
   (Float, Float) p2
   (Float, Float) p3

   F (p1, p2, p3)
      .p1 = p1
      .p2 = p2
      .p3 = p3

   F String()
      R ‘Triangle: #., #., #.’.format(.p1, .p2, .p3)

   F.const det2D()
      R .p1[0] * (.p2[1] - .p3[1]) + .p2[0] * (.p3[1] - .p1[1]) + .p3[0] * (.p1[1] - .p2[1])

F checkTriWinding(Triangle &t; allowReversed)
   V detTri = t.det2D()
   I detTri < 0.0
      assert(allowReversed, ‘Triangle has wrong winding direction’)
      swap(&t.p2, &t.p3)

F boundaryCollideChk(Triangle t, Float eps)
   R t.det2D() < eps

F boundaryDoesntCollideChk(Triangle t, Float eps)
   R t.det2D() <= eps

F triTri2D(Triangle &t1, Triangle &t2; eps = 0.0, allowReversed = 0B, onBoundary = 1B)
   checkTriWinding(&t1, allowReversed)
   checkTriWinding(&t2, allowReversed)
   V chkEdge = I onBoundary {:boundaryCollideChk} E :boundaryDoesntCollideChk
   V lp1 = [t1.p1, t1.p2, t1.p3]
   V lp2 = [t2.p1, t2.p2, t2.p3]

   L(i) 3
      V j = (i + 1) % 3
      I chkEdge(Triangle(lp1[i], lp1[j], lp2[0]), eps) & chkEdge(Triangle(lp1[i], lp1[j], lp2[1]), eps) & chkEdge(Triangle(lp1[i], lp1[j], lp2[2]), eps)
         R 0B

   L(i) 3
      V j = (i + 1) % 3
      I chkEdge(Triangle(lp2[i], lp2[j], lp1[0]), eps) & chkEdge(Triangle(lp2[i], lp2[j], lp1[1]), eps) & chkEdge(Triangle(lp2[i], lp2[j], lp1[2]), eps)
         R 0B

   R 1B

F overlap(Triangle &t1, Triangle &t2; eps = 0.0, allowReversed = 0B, onBoundary = 1B)
   I triTri2D(&t1, &t2, eps, allowReversed, onBoundary)
      print(‘overlap’)
   E
      print(‘do not overlap’)

V t1 = Triangle((0.0, 0.0), (5.0, 0.0), (0.0, 5.0))
V t2 = Triangle((0.0, 0.0), (5.0, 0.0), (0.0, 6.0))
print(t1" and\n"t2)
overlap(&t1, &t2)
print()

t1 = Triangle((0.0, 0.0), (0.0, 5.0), (5.0, 0.0))
t2 = t1
print(t1" and\n"t2)
overlap(&t1, &t2, 0.0, 1B)
print()

t1 = Triangle((0.0, 0.0), (5.0, 0.0), (0.0, 5.0))
t2 = Triangle((-10.0, 0.0), (-5.0, 0.0), (-1.0, 6.0))
print(t1" and\n"t2)
overlap(&t1, &t2)
print()

t1.p3 = (2.5, 5.0)
t2 = Triangle((0.0, 4.0), (2.5, -1.0), (5.0, 4.0))
print(t1" and\n"t2)
overlap(&t1, &t2)
print()

t1 = Triangle((0.0, 0.0), (1.0, 1.0), (0.0, 2.0))
t2 = Triangle((2.0, 1.0), (3.0, 0.0), (3.0, 2.0))
print(t1" and\n"t2)
overlap(&t1, &t2)
print()

t2 = Triangle((2.0, 1.0), (3.0, -2.0), (3.0, 4.0))
print(t1" and\n"t2)
overlap(&t1, &t2)
print()

t1 = Triangle((0.0, 0.0), (1.0, 0.0), (0.0, 1.0))
t2 = Triangle((1.0, 0.0), (2.0, 0.0), (1.0, 1.1))
print(t1" and\n"t2)
print(‘which have only a single corner in contact, if boundary points collide’)
overlap(&t1, &t2)
print()

print(t1" and\n"t2)
print(‘which have only a single corner in contact, if boundary points do not collide’)
overlap(&t1, &t2, 0.0, 0B, 0B)
===
class Triangle
{
public:
    dvec2 p1;
    dvec2 p2;
    dvec2 p3;

    template <typename T1, typename T2, typename T3> Triangle(const T1 &p1, const T2 &p2, const T3 &p3) :
        p1(p1),
        p2(p2),
        p3(p3)
    {
    }

    operator String() const
    {
        return u"Triangle: #., #., #."_S.format(p1, p2, p3);
    }

    auto det2D() const
    {
        return _get<0>(p1) * (_get<1>(p2) - _get<1>(p3)) + _get<0>(p2) * (_get<1>(p3) - _get<1>(p1)) + _get<0>(p3) * (_get<1>(p1) - _get<1>(p2));
    }
};

template <typename T2> auto checkTriWinding(Triangle &t, const T2 &allowReversed)
{
    auto detTri = t.det2D();
    if (detTri < 0.0) {
        assert(allowReversed, u"Triangle has wrong winding direction"_S);
        swap(t.p2, t.p3);
    }
}

auto boundaryCollideChk(const Triangle &t, const double eps)
{
    return t.det2D() < eps;
}

auto boundaryDoesntCollideChk(const Triangle &t, const double eps)
{
    return t.det2D() <= eps;
}

template <typename T3 = decltype(0.0), typename T4 = decltype(false), typename T5 = decltype(true)> auto triTri2D(Triangle &t1, Triangle &t2, const T3 &eps = 0.0, const T4 &allowReversed = false, const T5 &onBoundary = true)
{
    checkTriWinding(t1, allowReversed);
    checkTriWinding(t2, allowReversed);
    auto chkEdge = onBoundary ? ::boundaryCollideChk : ::boundaryDoesntCollideChk;
    auto lp1 = create_array({t1.p1, t1.p2, t1.p3});
    auto lp2 = create_array({t2.p1, t2.p2, t2.p3});

    for (int i = 0; i < 3; i++) {
        auto j = mod((i + 1), 3);
        if (chkEdge(Triangle(lp1[i], lp1[j], _get<0>(lp2)), eps) && chkEdge(Triangle(lp1[i], lp1[j], _get<1>(lp2)), eps) && chkEdge(Triangle(lp1[i], lp1[j], _get<2>(lp2)), eps))
            return false;
    }

    for (int i = 0; i < 3; i++) {
        auto j = mod((i + 1), 3);
        if (chkEdge(Triangle(lp2[i], lp2[j], _get<0>(lp1)), eps) && chkEdge(Triangle(lp2[i], lp2[j], _get<1>(lp1)), eps) && chkEdge(Triangle(lp2[i], lp2[j], _get<2>(lp1)), eps))
            return false;
    }

    return true;
}

template <typename T3 = decltype(0.0), typename T4 = decltype(false), typename T5 = decltype(true)> auto overlap(Triangle &t1, Triangle &t2, const T3 &eps = 0.0, const T4 &allowReversed = false, const T5 &onBoundary = true)
{
    if (triTri2D(t1, t2, eps, allowReversed, onBoundary))
        print(u"overlap"_S);
    else
        print(u"do not overlap"_S);
}

auto t1 = Triangle(make_tuple(0.0, 0.0), make_tuple(5.0, 0.0), make_tuple(0.0, 5.0));
auto t2 = Triangle(make_tuple(0.0, 0.0), make_tuple(5.0, 0.0), make_tuple(0.0, 6.0));

struct CodeBlock1
{
    CodeBlock1()
    {
        print(t1 & u" and\n"_S & t2);
        overlap(t1, t2);
        print();

        t1 = Triangle(make_tuple(0.0, 0.0), make_tuple(0.0, 5.0), make_tuple(5.0, 0.0));
        t2 = t1;
        print(t1 & u" and\n"_S & t2);
        overlap(t1, t2, 0.0, true);
        print();

        t1 = Triangle(make_tuple(0.0, 0.0), make_tuple(5.0, 0.0), make_tuple(0.0, 5.0));
        t2 = Triangle(make_tuple(-10.0, 0.0), make_tuple(-5.0, 0.0), make_tuple(-1.0, 6.0));
        print(t1 & u" and\n"_S & t2);
        overlap(t1, t2);
        print();

        t1.p3 = make_tuple(2.5, 5.0);
        t2 = Triangle(make_tuple(0.0, 4.0), make_tuple(2.5, -1.0), make_tuple(5.0, 4.0));
        print(t1 & u" and\n"_S & t2);
        overlap(t1, t2);
        print();

        t1 = Triangle(make_tuple(0.0, 0.0), make_tuple(1.0, 1.0), make_tuple(0.0, 2.0));
        t2 = Triangle(make_tuple(2.0, 1.0), make_tuple(3.0, 0.0), make_tuple(3.0, 2.0));
        print(t1 & u" and\n"_S & t2);
        overlap(t1, t2);
        print();

        t2 = Triangle(make_tuple(2.0, 1.0), make_tuple(3.0, -2.0), make_tuple(3.0, 4.0));
        print(t1 & u" and\n"_S & t2);
        overlap(t1, t2);
        print();

        t1 = Triangle(make_tuple(0.0, 0.0), make_tuple(1.0, 0.0), make_tuple(0.0, 1.0));
        t2 = Triangle(make_tuple(1.0, 0.0), make_tuple(2.0, 0.0), make_tuple(1.0, 1.1));
        print(t1 & u" and\n"_S & t2);
        print(u"which have only a single corner in contact, if boundary points collide"_S);
        overlap(t1, t2);
        print();

        print(t1 & u" and\n"_S & t2);
        print(u"which have only a single corner in contact, if boundary points do not collide"_S);
        overlap(t1, t2, 0.0, false, false);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Dijkstra%27s_algorithm#Python
import collections
from typing import NamedTuple, List, Set
from copy import copy

class Edge(NamedTuple):
    start : str
    end : str
    cost : int

class Graph:
    edges : List[Edge]
    vertices : Set[str]

    def __init__(self, edges):
        self.edges = [Edge(s, e, c) for s, e, c in edges]
        # print(dir(self.edges[0]))
        self.vertices = {e.start for e in self.edges}.union({e.end for e in self.edges})

    def dijkstra(self, source, dest):
        assert source in self.vertices
        dist = {vertex: float('inf') for vertex in self.vertices}
        previous = {vertex: '' for vertex in self.vertices}
        dist[source] = 0
        q = copy(self.vertices)
        def create_list():
            l : List[Tuple[str, int]] = []
            return l
        neighbours = {vertex: create_list() for vertex in self.vertices}
        for start, end, cost in self.edges:
            neighbours[start].append((end, cost))
        #pp(neighbours)

        while len(q) != 0:
            # pp(q)
            u = min(q, key=lambda vertex: dist[vertex])
            q.remove(u)
            if dist[u] == float('inf') or u == dest:
                break
            for v, cost in neighbours[u]:
                alt = dist[u] + cost
                if alt < dist[v]:                                  # Relax (u,v,a)
                    dist[v] = alt
                    previous[v] = u
        #pp(previous)
        s = collections.deque() # str
        u = dest
        while previous[u] != '':
            s.appendleft(u)
            u = previous[u]
        s.appendleft(u)
        return s

graph = Graph([("a", "b", 7),  ("a", "c", 9),  ("a", "f", 14), ("b", "c", 10),
               ("b", "d", 15), ("c", "d", 11), ("c", "f", 2),  ("d", "e", 6),
               ("e", "f", 9)])
print(graph.dijkstra("a", "e"))
===
T Edge
   String start
   String end
   Int cost
   F (start, end, cost)
      .start = start
      .end = end
      .cost = cost

T Graph
   [Edge] edges
   Set[String] vertices

   F (edges)
      .edges = edges.map((s, e, c) -> Edge(s, e, c))
      .vertices = Set(.edges.map(e -> e.start)).union(Set(.edges.map(e -> e.end)))

   F dijkstra(source, dest)
      assert(source C .vertices)
      V dist = Dict(.vertices, vertex -> (vertex, Float.infinity))
      V previous = Dict(.vertices, vertex -> (vertex, ‘’))
      dist[source] = 0
      V q = copy(.vertices)
      F create_list()
         [(String, Int)] l
         R l
      V neighbours = Dict(.vertices, vertex -> (vertex, @create_list()))
      L(start, end, cost) .edges
         neighbours[start].append((end, cost))

      L !q.empty
         V u = min(q, key' vertex -> @dist[vertex])
         q.remove(u)
         I dist[u] == Float.infinity | u == dest
            L.break
         L(v, cost) neighbours[u]
            V alt = dist[u] + cost
            I alt < dist[v]
               dist[v] = alt
               previous[v] = u
      V s = Deque[String]()
      V u = dest
      L previous[u] != ‘’
         s.append_left(u)
         u = previous[u]
      s.append_left(u)
      R s

V graph = Graph([(‘a’, ‘b’, 7), (‘a’, ‘c’, 9), (‘a’, ‘f’, 14), (‘b’, ‘c’, 10), (‘b’, ‘d’, 15), (‘c’, ‘d’, 11), (‘c’, ‘f’, 2), (‘d’, ‘e’, 6), (‘e’, ‘f’, 9)])
print(graph.dijkstra(‘a’, ‘e’))
===
class Edge
{
public:
    String start;
    String end;
    int cost;
    template <typename T1, typename T2, typename T3> Edge(const T1 &start, const T2 &end, const T3 &cost) :
        start(start),
        end(end),
        cost(cost)
    {
    }
};

class Graph
{
public:
    Array<Edge> edges;
    Set<String> vertices;

    template <typename T1> Graph(const T1 &edges)
    {
        this->edges = edges.map([](const auto &s, const auto &e, const auto &c){return Edge(s, e, c);});
        vertices = create_set(this->edges.map([](const auto &e){return e.start;})).set_union(create_set(this->edges.map([](const auto &e){return e.end;})));
    }

    template <typename T1, typename T2> auto dijkstra(const T1 &source, const T2 &dest)
    {
        assert(in(source, vertices));
        auto dist = create_dict(vertices, [](const auto &vertex){return make_tuple(vertex, std::numeric_limits<double>::infinity());});
        auto previous = create_dict(vertices, [](const auto &vertex){return make_tuple(vertex, u""_S);});
        dist.set(source, 0);
        auto q = copy(vertices);
        auto create_list = []()
        {
            Array<Tuple<String, int>> l;
            return l;
        };
        auto neighbours = create_dict(vertices, [&create_list](const auto &vertex){return make_tuple(vertex, create_list());});
        for (auto &&[start, end, cost] : edges)
            neighbours[start].append(make_tuple(end, cost));

        while (!q.empty()) {
            auto u = min_with_key(q, [&dist](const auto &vertex){return dist[vertex];});
            q.remove(u);
            if (dist[u] == std::numeric_limits<double>::infinity() || u == dest)
                break;
            for (auto &&[v, cost] : neighbours[u]) {
                auto alt = dist[u] + cost;
                if (alt < dist[v]) {
                    dist.set(v, alt);
                    previous.set(v, u);
                }
            }
        }
        auto s = Deque<String>();
        auto u = dest;
        while (previous[u] != u"") {
            s.append_left(u);
            u = previous[u];
        }
        s.append_left(u);
        return s;
    }
};

auto graph = Graph(create_array({make_tuple(u"a"_S, u"b"_S, 7), make_tuple(u"a"_S, u"c"_S, 9), make_tuple(u"a"_S, u"f"_S, 14), make_tuple(u"b"_S, u"c"_S, 10), make_tuple(u"b"_S, u"d"_S, 15), make_tuple(u"c"_S, u"d"_S, 11), make_tuple(u"c"_S, u"f"_S, 2), make_tuple(u"d"_S, u"e"_S, 6), make_tuple(u"e"_S, u"f"_S, 9)}));

struct CodeBlock1
{
    CodeBlock1()
    {
        print(graph.dijkstra(u"a"_S, u"e"_S));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Days_between_dates
import datetime

def parse_date(date):
    return datetime.datetime.strptime(date, '%Y-%m-%d')

date1 = parse_date('2019-01-01')
date2 = parse_date('2019-09-30')
print((date2 - date1).days)
===
F parse_date(date)
   R time:strptime(date, ‘%Y-%m-%d’)

V date1 = parse_date(‘2019-01-01’)
V date2 = parse_date(‘2019-09-30’)
print((date2 - date1).days())
===
template <typename T1> auto parse_date(const T1 &date)
{
    return timens::strptime(date, u"%Y-%m-%d"_S);
}

auto date1 = parse_date(u"2019-01-01"_S);
auto date2 = parse_date(u"2019-09-30"_S);

struct CodeBlock1
{
    CodeBlock1()
    {
        print((date2 - date1).days());
    }
} code_block_1;


# https://www.rosettacode.org/wiki/De_Bruijn_sequences#D
Byte = int

digits = "0123456789"

def deBruijn(k, n):
    alphabet = digits[:k]
    a = [Byte(0)] * (k * n)
    seq : List[Byte] = []

    def db(t : int, p : int) -> None:
        if t > n:
            if n % p == 0:
                seq.extend(a[1:p + 1])
        else:
            a[t] = a[t - p]
            db(t + 1, p)
            j = a[t - p] + 1
            while j < k:
                a[t] = j & 0xFF
                db(t + 1, t)
                j += 1

    db(1, 1)
    buf = ''
    for i in seq:
        buf += alphabet[i]

    return buf + buf[0 : n - 1]

def validate(db):
    found = [0] * 10_000
    errs : List[str] = []

    for i in range(len(db) - 3):
        s = db[i : i + 4]
        if s.isdigit():
            found[int(s)] += 1

    for i in range(10_000):
        if found[i] == 0:
            errs += ["    PIN number %04d missing" % i]
        elif found[i] > 1:
            errs += ["    PIN number %04d occurs %d times" % (i, found[i])]

    if len(errs) == 0:
        print("  No errors found")
    else:
        pl = "" if len(errs) == 1 else "s"
        print("  " + str(len(errs)) + " error" + pl + " found:")
        for err in errs:
            print(err)

db = deBruijn(10, 4)

print("The length of the de Bruijn sequence is", len(db))
print("\nThe first 130 digits of the de Bruijn sequence are:", db[:130])
print("\nThe last 130 digits of the de Bruijn sequence are:", db[-130:])

print("\nValidating the deBruijn sequence:")
validate(db)

print("\nValidating the reversed deBruijn sequence:")
validate(db[::-1])

db = db[:4443] + '.' + db[4444:] # db[4443] = '.'
print("\nValidating the overlaid deBruijn sequence:")
validate(db)
===
V digits = ‘0123456789’

F deBruijn(k, n)
   V alphabet = :digits[0 .< k]
   V a = [Byte(0)] * (k * n)
   [Byte] seq

   F db(Int t, Int p) -> Void
      I t > @n
         I @n % p == 0
            @seq.extend(@a[1 .< p + 1])
      E
         @a[t] = @a[t - p]
         @db(t + 1, p)
         V j = @a[t - p] + 1
         L j < @k
            @a[t] = j [&] F'F
            @db(t + 1, t)
            j++

   db(1, 1)
   V buf = ‘’
   L(i) seq
      buf ‘’= alphabet[i]

   R buf‘’buf[0 .< n - 1]

F validate(db)
   V found = [0] * 10'000
   [String] errs

   L(i) 0 .< db.len - 3
      V s = db[i .< i + 4]
      I s.is_digit()
         found[Int(s)]++

   L(i) 10'000
      I found[i] == 0
         errs [+]= ‘    PIN number #04 missing’.format(i)
      E I found[i] > 1
         errs [+]= ‘    PIN number #04 occurs #. times’.format(i, found[i])

   I errs.empty
      print(‘  No errors found’)
   E
      V pl = I errs.len == 1 {‘’} E ‘s’
      print(‘  ’String(errs.len)‘ error’pl‘ found:’)
      L(err) errs
         print(err)

V db = deBruijn(10, 4)

print(‘The length of the de Bruijn sequence is ’db.len)
print("\nThe first 130 digits of the de Bruijn sequence are: "db[0.<130])
print("\nThe last 130 digits of the de Bruijn sequence are: "db[(len)-130 ..])

print("\nValidating the deBruijn sequence:")
validate(db)

print("\nValidating the reversed deBruijn sequence:")
validate(reversed(db))

db = db[0.<4443]‘.’db[4444..]
print("\nValidating the overlaid deBruijn sequence:")
validate(db)
===
auto digits = u"0123456789"_S;

template <typename T1, typename T2> auto deBruijn(const T1 &k, const T2 &n)
{
    auto alphabet = ::digits[range_el(0, k)];
    auto a = create_array({Byte(0)}) * (k * n);
    Array<Byte> seq;

    std::function<void(int, int)> db = [&a, &db, &k, &n, &seq](const int t, const int p) -> void
    {
        if (t > n) {
            if (mod(n, p) == 0)
                seq.extend(a[range_el(1, p + 1)]);
        }
        else {
            a.set(t, a[t - p]);
            db(t + 1, p);
            auto j = a[t - p] + 1;
            while (j < k) {
                a.set(t, j & 0xFF);
                db(t + 1, t);
                j++;
            }
        }
    };

    db(1, 1);
    auto buf = u""_S;
    for (auto &&i : seq)
        buf &= alphabet[i];

    return buf & buf[range_el(0, n - 1)];
}

template <typename T1> auto validate(const T1 &db)
{
    auto found = create_array({0}) * 10'000;
    Array<String> errs;

    for (auto i : range_el(0, db.len() - 3)) {
        auto s = db[range_el(i, i + 4)];
        if (s.is_digit())
            found[to_int(s)]++;
    }

    for (int i = 0; i < 10'000; i++)
        if (found[i] == 0)
            errs.append(u"    PIN number #04 missing"_S.format(i));
        else if (found[i] > 1)
            errs.append(u"    PIN number #04 occurs #. times"_S.format(i, found[i]));

    if (errs.empty())
        print(u"  No errors found"_S);
    else {
        auto pl = errs.len() == 1 ? u""_S : u"s"_S;
        print(u"  "_S & String(errs.len()) & u" error"_S & pl & u" found:"_S);
        for (auto &&err : errs)
            print(err);
    }
}

auto db = deBruijn(10, 4);

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"The length of the de Bruijn sequence is "_S & db.len());
        print(u"\nThe first 130 digits of the de Bruijn sequence are: "_S & db[range_el(0, 130)]);
        print(u"\nThe last 130 digits of the de Bruijn sequence are: "_S & db[range_elen_i( - 130)]);

        print(u"\nValidating the deBruijn sequence:"_S);
        validate(db);

        print(u"\nValidating the reversed deBruijn sequence:"_S);
        validate(reversed(db));

        db = db[range_el(0, 4443)] & u"."_S & db[range_ei(4444)];
        print(u"\nValidating the overlaid deBruijn sequence:"_S);
        validate(db);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Deal_cards_for_FreeCell#Python
import sys

def randomGenerator(seed, n):
    r : List[int] = []
    max_int32 = 0x7FFF_FFFF#(1 << 31) - 1
    seed = seed & max_int32

    while len(r) < n:
        seed = (seed * 214013 + 2531011) & max_int32
        r += [seed >> 16]

    return r

def deal(seed):
    nc = 52
    cards = list(range(nc - 1, -1, -1))
    rnd = randomGenerator(seed, nc)
    for i, r in enumerate(rnd):
        j = (nc - 1) - r % (nc - i)
        (cards[i], cards[j]) = (cards[j], cards[i])
    return cards

def show(cards):
    l = ["A23456789TJQK"[int(c/4)] + "CDHS"[c%4] for c in cards]
    for i in range(0, len(cards), 8):
        print(" ".join(l[i : i+8]))

if __name__ == '__main__':
    seed = int(sys.argv[1]) if len(sys.argv) == 2 else 11982
    print("Hand {}".format(seed))
    deck = deal(seed)
    show(deck)
===
F randomGenerator(=seed, n)
   [Int] r
   V max_int32 = 7FFF'FFFF
   seed = seed [&] max_int32

   L r.len < n
      seed = (seed * 214013 + 2531011) [&] max_int32
      r [+]= seed >> 16

   R r

F deal(seed)
   V nc = 52
   V cards = Array((nc - 1 .< -1).step(-1))
   V rnd = randomGenerator(seed, nc)
   L(r) rnd
      V i = L.index
      V j = (nc - 1) - r % (nc - i)
      swap(&cards[i], &cards[j])
   R cards

F show(cards)
   V l = cards.map(c -> ‘A23456789TJQK’[Int(c / 4)]‘CDHS’[c % 4])
   L(i) (0 .< cards.len).step(8)
      print((l[i .< i + 8]).join(‘ ’))

:start:
V seed = I :argv.len == 2 {Int(:argv[1])} E 11982
print(‘Hand #.’.format(seed))
V deck = deal(seed)
show(deck)
===
Array<String> argv;

template <typename T1, typename T2> auto randomGenerator(T1 seed, const T2 &n)
{
    Array<int> r;
    auto max_int32 = 0x7FFF'FFFF;
    seed = seed & max_int32;

    while (r.len() < n) {
        seed = (seed * 214013 + 2531011) & max_int32;
        r.append(seed >> 16);
    }

    return r;
}

template <typename T1> auto deal(const T1 &seed)
{
    auto nc = 52;
    auto cards = create_array(range_el(nc - 1, -1).step(-1));
    auto rnd = randomGenerator(seed, nc);
    {int Lindex = 0;
    for (auto &&r : rnd) {
        auto i = Lindex;
        auto j = (nc - 1) - mod(r, (nc - i));
        swap(cards[i], cards[j]);
        Lindex++;
    }}
    return cards;
}

template <typename T1> auto show(const T1 &cards)
{
    auto l = cards.map([](const auto &c){return u"A23456789TJQK"_S[to_int(c / 4.0)] & u"CDHS"_S[mod(c, 4)];});
    for (auto i : range_el(0, cards.len()).step(8))
        print((l[range_el(i, i + 8)]).join(u" "_S));
}

int MAIN_WITH_ARGV()
{
    INIT_ARGV();

    auto seed = ::argv.len() == 2 ? to_int(_get<1>(::argv)) : 11982;
    print(u"Hand #."_S.format(seed));
    auto deck = deal(seed);
    show(deck);
}


# https://www.rosettacode.org/wiki/Death_Star#Python
import math
from typing import NamedTuple

class Sphere(NamedTuple):
    cx : float
    cy : float
    cz : float
    r  : float

class V3(NamedTuple):
    x : float
    y : float
    z : float

def normalize(xyz : V3):
    (x, y, z) = xyz
    len = math.sqrt(x**2 + y**2 + z**2)
    return V3(x / len, y / len, z / len)

def dot(v1, v2):
    d = v1.x*v2.x + v1.y*v2.y + v1.z*v2.z
    return -d if d < 0 else 0.0

def hit_sphere(sph, x0, y0):
    x = x0 - sph.cx
    y = y0 - sph.cy
    zsq = sph.r ** 2 - (x ** 2 + y ** 2)
    if zsq < 0:
        return (False, 0.0, 0.0)
    szsq = math.sqrt(zsq)
    return (True, sph.cz - szsq, sph.cz + szsq)

def draw_sphere(k, ambient, light):
    shades = ".:!*oe&#%@"
    pos = Sphere(20.0, 20.0, 0.0, 20.0)
    neg = Sphere(1.0, 1.0, -6.0, 20.0)

    for i in range(math.floor(pos.cy - pos.r),
                    math.ceil(pos.cy + pos.r) + 1):
        y = i + 0.5
        for j in range(math.floor(pos.cx - 2 * pos.r),
                        math.ceil(pos.cx + 2 * pos.r) + 1):
            x = (j - pos.cx) / 2.0 + 0.5 + pos.cx

            (h, zb1, zb2) = hit_sphere(pos, x, y)
            hit_result : int
            zs2 : float
            if not h:
                hit_result = 0
            else:
                (h, zs1, zs2) = hit_sphere(neg, x, y)
                if not h:
                    hit_result = 1
                elif zs1 > zb1:
                    hit_result = 1
                elif zs2 > zb2:
                    hit_result = 0
                elif zs2 > zb1:
                    hit_result = 2
                else:
                    hit_result = 1

            vec = V3(0, 0, 0)
            if hit_result == 0:
                print(' ', end = '')
                continue
            elif hit_result == 1:
                vec = V3(x - pos.cx, y - pos.cy, zb1 - pos.cz)
            elif hit_result == 2:
                vec = V3(neg.cx-x, neg.cy-y, neg.cz-zs2)
            vec = normalize(vec)

            b = dot(light, vec) ** k + ambient
            intensity = int((1 - b) * len(shades))
            intensity = min(len(shades), max(0, intensity))
            print(shades[intensity], end = '')
        print()

light = normalize(V3(-50, 30, 50))
draw_sphere(2, 0.5, light)
===
T Sphere
   Float cx
   Float cy
   Float cz
   Float r
   F (cx, cy, cz, r)
      .cx = cx
      .cy = cy
      .cz = cz
      .r = r

T V3
   Float x
   Float y
   Float z
   F (x, y, z)
      .x = x
      .y = y
      .z = z

F normalize(V3 xyz)
   V (x, y, z) = xyz
   V len = sqrt(x ^ 2 + y ^ 2 + z ^ 2)
   R V3(x / len, y / len, z / len)

F dot(v1, v2)
   V d = v1.x * v2.x + v1.y * v2.y + v1.z * v2.z
   R I d < 0 {-d} E 0.0

F hit_sphere(sph, x0, y0)
   V x = x0 - sph.cx
   V y = y0 - sph.cy
   V zsq = sph.r ^ 2 - (x ^ 2 + y ^ 2)
   I zsq < 0
      R (0B, 0.0, 0.0)
   V szsq = sqrt(zsq)
   R (1B, sph.cz - szsq, sph.cz + szsq)

F draw_sphere(k, ambient, light)
   V shades = ‘.:!*oe&#%@’
   V pos = Sphere(20.0, 20.0, 0.0, 20.0)
   V neg = Sphere(1.0, 1.0, -6.0, 20.0)

   L(i) floori(pos.cy - pos.r) .. ceili(pos.cy + pos.r)
      V y = i + 0.5
      L(j) floori(pos.cx - 2 * pos.r) .. ceili(pos.cx + 2 * pos.r)
         V x = (j - pos.cx) / 2.0 + 0.5 + pos.cx

         V (h, zb1, zb2) = hit_sphere(pos, x, y)
         Int hit_result
         Float zs2
         I !h
            hit_result = 0
         E
            (h, V zs1, zs2) = hit_sphere(neg, x, y)
            I !h
               hit_result = 1
            E I zs1 > zb1
               hit_result = 1
            E I zs2 > zb2
               hit_result = 0
            E I zs2 > zb1
               hit_result = 2
            E
               hit_result = 1

         V vec = V3(0, 0, 0)
         I hit_result == 0
            print(‘ ’, end' ‘’)
            L.continue
         E I hit_result == 1
            vec = V3(x - pos.cx, y - pos.cy, zb1 - pos.cz)
         E I hit_result == 2
            vec = V3(neg.cx - x, neg.cy - y, neg.cz - zs2)
         vec = normalize(vec)

         V b = dot(light, vec) ^ k + ambient
         V intensity = Int((1 - b) * shades.len)
         intensity = min(shades.len, max(0, intensity))
         print(shades[intensity], end' ‘’)
      print()

V light = normalize(V3(-50, 30, 50))
draw_sphere(2, 0.5, light)
===
class Sphere
{
public:
    double cx;
    double cy;
    double cz;
    double r;
    template <typename T1, typename T2, typename T3, typename T4> Sphere(const T1 &cx, const T2 &cy, const T3 &cz, const T4 &r) :
        cx(cx),
        cy(cy),
        cz(cz),
        r(r)
    {
    }
};

class V3
{
public:
    double x;
    double y;
    double z;
    template <typename T1, typename T2, typename T3> V3(const T1 &x, const T2 &y, const T3 &z) :
        x(x),
        y(y),
        z(z)
    {
    }
};

auto normalize(const V3 &xyz)
{
    auto [x, y, z] = xyz;
    auto len = sqrt(square(x) + square(y) + square(z));
    return V3(x / len, y / len, z / len);
}

template <typename T1, typename T2> auto dot(const T1 &v1, const T2 &v2)
{
    auto d = v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
    return d < 0 ? -d : 0.0;
}

template <typename T1, typename T2, typename T3> auto hit_sphere(const T1 &sph, const T2 &x0, const T3 &_y0_)
{
    auto x = x0 - sph.cx;
    auto y = _y0_ - sph.cy;
    auto zsq = square(sph.r) - (square(x) + square(y));
    if (zsq < 0)
        return make_tuple(false, 0.0, 0.0);
    auto szsq = sqrt(zsq);
    return make_tuple(true, sph.cz - szsq, sph.cz + szsq);
}

template <typename T1, typename T2, typename T3> auto draw_sphere(const T1 &k, const T2 &ambient, const T3 &light)
{
    auto shades = u".:!*oe&#%@"_S;
    auto pos = Sphere(20.0, 20.0, 0.0, 20.0);
    auto neg = Sphere(1.0, 1.0, -6.0, 20.0);

    for (auto i : range_ee(floori(pos.cy - pos.r), ceili(pos.cy + pos.r))) {
        auto y = i + 0.5;
        for (auto j : range_ee(floori(pos.cx - 2 * pos.r), ceili(pos.cx + 2 * pos.r))) {
            auto x = (j - pos.cx) / 2.0 + 0.5 + pos.cx;

            auto [h, zb1, zb2] = hit_sphere(pos, x, y);
            int hit_result;
            double zs2;
            if (!h)
                hit_result = 0;
            else {
                TUPLE_ELEMENT_T(1, hit_sphere(neg, x, y)) zs1;
                assign_from_tuple(h, zs1, zs2, hit_sphere(neg, x, y));
                if (!h)
                    hit_result = 1;
                else if (zs1 > zb1)
                    hit_result = 1;
                else if (zs2 > zb2)
                    hit_result = 0;
                else if (zs2 > zb1)
                    hit_result = 2;
                else
                    hit_result = 1;
            }

            auto vec = V3(0, 0, 0);
            if (hit_result == 0) {
                print(u" "_S, u""_S);
                continue;
            }
            else if (hit_result == 1)
                vec = V3(x - pos.cx, y - pos.cy, zb1 - pos.cz);
            else if (hit_result == 2)
                vec = V3(neg.cx - x, neg.cy - y, neg.cz - zs2);
            vec = normalize(vec);

            auto b = pow(dot(light, vec), k) + ambient;
            auto intensity = to_int((1 - b) * shades.len());
            intensity = min(shades.len(), max(0, intensity));
            print(shades[intensity], u""_S);
        }
        print();
    }
}

auto light = normalize(V3(-50, 30, 50));

struct CodeBlock1
{
    CodeBlock1()
    {
        draw_sphere(2, 0.5, light);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Decimal_floating_point_number_to_binary#Kotlin
import math

def decToBin(d):
    whole  = math.floor(d)
    binary = bin(whole)[2:] + "."
    dd = d - whole
    while dd > 0.0:
        r = dd * 2.0
        if r >= 1.0:
            binary += "1"
            dd = r - 1
        else:
            binary += "0"
            dd = r
    return binary

def binToDec(s):
    num = int(s.replace(".", ""), base = 2)
    den = int("1" + s.split('.')[1].replace("1", "0"), base = 2)
    return float(num) / den

d = 23.34375
print(str(d) + "\t => " + decToBin(d))
s = "1011.11101"
print(s + "\t => " + str(binToDec(s)))
===
F decToBin(d)
   V whole = floori(d)
   V binary = bin(whole)‘.’
   V dd = d - whole
   L dd > 0.0
      V r = dd * 2.0
      I r >= 1.0
         binary ‘’= ‘1’
         dd = r - 1
      E
         binary ‘’= ‘0’
         dd = r
   R binary

F binToDec(s)
   V num = Int(s.replace(‘.’, ‘’), radix' 2)
   V den = Int(‘1’s.split(‘.’)[1].replace(‘1’, ‘0’), radix' 2)
   R Float(num) / den

V d = 23.34375
print(String(d)"\t => "decToBin(d))
V s = ‘1011.11101’
print(s"\t => "String(binToDec(s)))
===
template <typename T1> auto decToBin(const T1 &d)
{
    auto whole = floori(d);
    auto binary = bin(whole) & u"."_S;
    auto dd = d - whole;
    while (dd > 0.0) {
        auto r = dd * 2.0;
        if (r >= 1.0) {
            binary &= u"1"_S;
            dd = r - 1;
        }
        else {
            binary &= u"0"_S;
            dd = r;
        }
    }
    return binary;
}

template <typename T1> auto binToDec(const T1 &s)
{
    auto num = to_int(s.replace(u"."_S, u""_S), 2);
    auto den = to_int(u"1"_S & _get<1>(s.split(u"."_S)).replace(u"1"_S, u"0"_S), 2);
    return to_float(num) / den;
}

auto d = 23.34375;

struct CodeBlock1
{
    CodeBlock1()
    {
        print(String(d) & u"\t => "_S & decToBin(d));
    }
} code_block_1;

auto s = u"1011.11101"_S;

struct CodeBlock2
{
    CodeBlock2()
    {
        print(s & u"\t => "_S & String(binToDec(s)));
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Decision_tables#Kotlin
from typing import List

conditions = [
    ("Printer prints"                   , "NNNNYYYY"),
    ("A red light is flashing"          , "YYNNYYNN"),
    ("Printer is recognized by computer", "NYNYNYNY")]

actions = [
    ("Check the power cable"               , "NNYNNNNN"),
    ("Check the printer-computer cable"    , "YNYNNNNN"),
    ("Ensure printer software is installed", "YNYNYNYN"),
    ("Check/replace ink"                   , "YYNNNYNN"),
    ("Check for paper jam"                 , "NYNYNNNN")]

nr = len(conditions[0][1])
np = 7
print("Please answer the following questions with a y or n:")

answers : List[bool] = []
for condition in conditions:
    inp = ''
    while True:
        inp = input('  ' + condition[0] + ' ? ').upper()
        if inp in ('Y', 'N'):
            break
    answers.append(inp == 'Y')

print("\nRecommended action(s):")
for r in range(nr):
    for c in range(len(conditions)):
        yn = 'Y' if answers[c] else 'N'
        if conditions[c][1][r] != yn:
            break # `L(r).continue`
    else:
        if r == np:
            print("  None (no problem detected)")
        else:
            for action in actions:
                if action[1][r] == 'Y':
                    print('  ' + action[0])
        break
===
V conditions = [(‘Printer prints’, ‘NNNNYYYY’), (‘A red light is flashing’, ‘YYNNYYNN’), (‘Printer is recognized by computer’, ‘NYNYNYNY’)]

V actions = [(‘Check the power cable’, ‘NNYNNNNN’), (‘Check the printer-computer cable’, ‘YNYNNNNN’), (‘Ensure printer software is installed’, ‘YNYNYNYN’), (‘Check/replace ink’, ‘YYNNNYNN’), (‘Check for paper jam’, ‘NYNYNNNN’)]

V nr = conditions[0][1].len
V np = 7
print(‘Please answer the following questions with a y or n:’)

[Bool] answers
L(condition) conditions
   V inp = ‘’
   L
      inp = input(‘  ’condition[0]‘ ? ’).uppercase()
      I inp C (‘Y’, ‘N’)
         L.break
   answers.append(inp == ‘Y’)

print("\nRecommended action(s):")
L(r) 0 .< nr
   L(c) 0 .< conditions.len
      V yn = I answers[c] {‘Y’} E ‘N’
      I conditions[c][1][r] != yn
         L.break
   L.was_no_break
      I r == np
         print(‘  None (no problem detected)’)
      E
         L(action) actions
            I action[1][r] == ‘Y’
               print(‘  ’action[0])
      L.break
===
auto conditions = create_array({make_tuple(u"Printer prints"_S, u"NNNNYYYY"_S), make_tuple(u"A red light is flashing"_S, u"YYNNYYNN"_S), make_tuple(u"Printer is recognized by computer"_S, u"NYNYNYNY"_S)});

auto actions = create_array({make_tuple(u"Check the power cable"_S, u"NNYNNNNN"_S), make_tuple(u"Check the printer-computer cable"_S, u"YNYNNNNN"_S), make_tuple(u"Ensure printer software is installed"_S, u"YNYNYNYN"_S), make_tuple(u"Check/replace ink"_S, u"YYNNNYNN"_S), make_tuple(u"Check for paper jam"_S, u"NYNYNNNN"_S)});

auto nr = _get<1>(_get<0>(conditions)).len();
auto np = 7;

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"Please answer the following questions with a y or n:"_S);
    }
} code_block_1;

Array<char> answers;

struct CodeBlock2
{
    CodeBlock2()
    {
        for (auto &&condition : conditions) {
            auto inp = u""_S;
            while (true) {
                inp = input(u"  "_S & _get<0>(condition) & u" ? "_S).uppercase();
                if (in(inp, make_tuple(u"Y"_S, u"N"_S)))
                    break;
            }
            answers.append(inp == u'Y');
        }

        print(u"\nRecommended action(s):"_S);
        for (auto r : range_el(0, nr)) {
            for (auto c : range_el(0, conditions.len())) {
                auto _yn_ = answers[c] ? u'Y'_C : u'N'_C;
                if (_get<1>(conditions[c])[r] != _yn_)
                    goto break_;
            }
            if (r == np)
                print(u"  None (no problem detected)"_S);
            else
                for (auto &&action : actions)
                    if (_get<1>(action)[r] == u'Y')
                        print(u"  "_S & _get<0>(action));
            break;
            break_:;
        }
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Deming%27s_Funnel#Python
import math

dxs = [-0.533, 0.27, 0.859, -0.043, -0.205, -0.127, -0.071, 0.275, 1.251,
       -0.231, -0.401, 0.269, 0.491, 0.951, 1.15, 0.001, -0.382, 0.161, 0.915,
       2.08, -2.337, 0.034, -0.126, 0.014, 0.709, 0.129, -1.093, -0.483, -1.193,
       0.02, -0.051, 0.047, -0.095, 0.695, 0.34, -0.182, 0.287, 0.213, -0.423,
       -0.021, -0.134, 1.798, 0.021, -1.099, -0.361, 1.636, -1.134, 1.315, 0.201,
       0.034, 0.097, -0.17, 0.054, -0.553, -0.024, -0.181, -0.7, -0.361, -0.789,
       0.279, -0.174, -0.009, -0.323, -0.658, 0.348, -0.528, 0.881, 0.021, -0.853,
       0.157, 0.648, 1.774, -1.043, 0.051, 0.021, 0.247, -0.31, 0.171, 0.0, 0.106,
       0.024, -0.386, 0.962, 0.765, -0.125, -0.289, 0.521, 0.017, 0.281, -0.749,
       -0.149, -2.436, -0.909, 0.394, -0.113, -0.598, 0.443, -0.521, -0.799,
       0.087]

dys = [0.136, 0.717, 0.459, -0.225, 1.392, 0.385, 0.121, -0.395, 0.49, -0.682,
       -0.065, 0.242, -0.288, 0.658, 0.459, 0.0, 0.426, 0.205, -0.765, -2.188,
       -0.742, -0.01, 0.089, 0.208, 0.585, 0.633, -0.444, -0.351, -1.087, 0.199,
       0.701, 0.096, -0.025, -0.868, 1.051, 0.157, 0.216, 0.162, 0.249, -0.007,
       0.009, 0.508, -0.79, 0.723, 0.881, -0.508, 0.393, -0.226, 0.71, 0.038,
       -0.217, 0.831, 0.48, 0.407, 0.447, -0.295, 1.126, 0.38, 0.549, -0.445,
       -0.046, 0.428, -0.074, 0.217, -0.822, 0.491, 1.347, -0.141, 1.23, -0.044,
       0.079, 0.219, 0.698, 0.275, 0.056, 0.031, 0.421, 0.064, 0.721, 0.104,
       -0.729, 0.65, -1.103, 0.154, -1.72, 0.051, -0.385, 0.477, 1.537, -0.901,
       0.939, -0.411, 0.341, -0.411, 0.106, 0.224, -0.947, -1.424, -0.542, -1.032]

def funnel(dxs, rule):
    x = 0.0
    rxs : List[float] = []
    for dx in dxs:
        rxs.append(x + dx)
        x = rule(x, dx)
    return rxs

def mean(xs): return sum(xs) / len(xs)

def stddev(xs):
    m = mean(xs)
    return math.sqrt(sum((x-m)**2 for x in xs) / len(xs))

def experiment(label, rule):
    (rxs, rys) = (funnel(dxs, rule), funnel(dys, rule))
    print(label)
    print('Mean x, y    : %.4f, %.4f' % (mean(rxs), mean(rys)))
    print('Std dev x, y : %.4f, %.4f' % (stddev(rxs), stddev(rys)))
    print()

experiment('Rule 1:', lambda z, dz: 0)
experiment('Rule 2:', lambda z, dz: -dz)
experiment('Rule 3:', lambda z, dz: -(z+dz))
experiment('Rule 4:', lambda z, dz: z+dz)
===
V dxs = [-0.533, 0.27, 0.859, -0.043, -0.205, -0.127, -0.071, 0.275, 1.251, -0.231, -0.401, 0.269, 0.491, 0.951, 1.15, 0.001, -0.382, 0.161, 0.915, 2.08, -2.337, 0.034, -0.126, 0.014, 0.709, 0.129, -1.093, -0.483, -1.193, 0.02, -0.051, 0.047, -0.095, 0.695, 0.34, -0.182, 0.287, 0.213, -0.423, -0.021, -0.134, 1.798, 0.021, -1.099, -0.361, 1.636, -1.134, 1.315, 0.201, 0.034, 0.097, -0.17, 0.054, -0.553, -0.024, -0.181, -0.7, -0.361, -0.789, 0.279, -0.174, -0.009, -0.323, -0.658, 0.348, -0.528, 0.881, 0.021, -0.853, 0.157, 0.648, 1.774, -1.043, 0.051, 0.021, 0.247, -0.31, 0.171, 0.0, 0.106, 0.024, -0.386, 0.962, 0.765, -0.125, -0.289, 0.521, 0.017, 0.281, -0.749, -0.149, -2.436, -0.909, 0.394, -0.113, -0.598, 0.443, -0.521, -0.799, 0.087]

V dys = [0.136, 0.717, 0.459, -0.225, 1.392, 0.385, 0.121, -0.395, 0.49, -0.682, -0.065, 0.242, -0.288, 0.658, 0.459, 0.0, 0.426, 0.205, -0.765, -2.188, -0.742, -0.01, 0.089, 0.208, 0.585, 0.633, -0.444, -0.351, -1.087, 0.199, 0.701, 0.096, -0.025, -0.868, 1.051, 0.157, 0.216, 0.162, 0.249, -0.007, 0.009, 0.508, -0.79, 0.723, 0.881, -0.508, 0.393, -0.226, 0.71, 0.038, -0.217, 0.831, 0.48, 0.407, 0.447, -0.295, 1.126, 0.38, 0.549, -0.445, -0.046, 0.428, -0.074, 0.217, -0.822, 0.491, 1.347, -0.141, 1.23, -0.044, 0.079, 0.219, 0.698, 0.275, 0.056, 0.031, 0.421, 0.064, 0.721, 0.104, -0.729, 0.65, -1.103, 0.154, -1.72, 0.051, -0.385, 0.477, 1.537, -0.901, 0.939, -0.411, 0.341, -0.411, 0.106, 0.224, -0.947, -1.424, -0.542, -1.032]

F funnel(dxs, rule)
   V x = 0.0
   [Float] rxs
   L(dx) dxs
      rxs.append(x + dx)
      x = rule(x, dx)
   R rxs

F mean(xs)
   R sum(xs) / xs.len

F stddev(xs)
   V m = mean(xs)
   R sqrt(sum(xs.map(x -> (x - @m) ^ 2)) / xs.len)

F experiment(label, rule)
   V (rxs, rys) = (funnel(:dxs, rule), funnel(:dys, rule))
   print(label)
   print(‘Mean x, y    : #.4, #.4’.format(mean(rxs), mean(rys)))
   print(‘Std dev x, y : #.4, #.4’.format(stddev(rxs), stddev(rys)))
   print()

experiment(‘Rule 1:’, (z, dz) -> 0)
experiment(‘Rule 2:’, (z, dz) -> -dz)
experiment(‘Rule 3:’, (z, dz) -> -(z + dz))
experiment(‘Rule 4:’, (z, dz) -> z + dz)
===
auto dxs = create_array({-0.533, 0.27, 0.859, -0.043, -0.205, -0.127, -0.071, 0.275, 1.251, -0.231, -0.401, 0.269, 0.491, 0.951, 1.15, 0.001, -0.382, 0.161, 0.915, 2.08, -2.337, 0.034, -0.126, 0.014, 0.709, 0.129, -1.093, -0.483, -1.193, 0.02, -0.051, 0.047, -0.095, 0.695, 0.34, -0.182, 0.287, 0.213, -0.423, -0.021, -0.134, 1.798, 0.021, -1.099, -0.361, 1.636, -1.134, 1.315, 0.201, 0.034, 0.097, -0.17, 0.054, -0.553, -0.024, -0.181, -0.7, -0.361, -0.789, 0.279, -0.174, -0.009, -0.323, -0.658, 0.348, -0.528, 0.881, 0.021, -0.853, 0.157, 0.648, 1.774, -1.043, 0.051, 0.021, 0.247, -0.31, 0.171, 0.0, 0.106, 0.024, -0.386, 0.962, 0.765, -0.125, -0.289, 0.521, 0.017, 0.281, -0.749, -0.149, -2.436, -0.909, 0.394, -0.113, -0.598, 0.443, -0.521, -0.799, 0.087});

auto dys = create_array({0.136, 0.717, 0.459, -0.225, 1.392, 0.385, 0.121, -0.395, 0.49, -0.682, -0.065, 0.242, -0.288, 0.658, 0.459, 0.0, 0.426, 0.205, -0.765, -2.188, -0.742, -0.01, 0.089, 0.208, 0.585, 0.633, -0.444, -0.351, -1.087, 0.199, 0.701, 0.096, -0.025, -0.868, 1.051, 0.157, 0.216, 0.162, 0.249, -0.007, 0.009, 0.508, -0.79, 0.723, 0.881, -0.508, 0.393, -0.226, 0.71, 0.038, -0.217, 0.831, 0.48, 0.407, 0.447, -0.295, 1.126, 0.38, 0.549, -0.445, -0.046, 0.428, -0.074, 0.217, -0.822, 0.491, 1.347, -0.141, 1.23, -0.044, 0.079, 0.219, 0.698, 0.275, 0.056, 0.031, 0.421, 0.064, 0.721, 0.104, -0.729, 0.65, -1.103, 0.154, -1.72, 0.051, -0.385, 0.477, 1.537, -0.901, 0.939, -0.411, 0.341, -0.411, 0.106, 0.224, -0.947, -1.424, -0.542, -1.032});

template <typename T1, typename T2> auto funnel(const T1 &dxs, const T2 &rule)
{
    auto x = 0.0;
    Array<double> rxs;
    for (auto &&dx : dxs) {
        rxs.append(x + dx);
        x = rule(x, dx);
    }
    return rxs;
}

template <typename T1> auto mean(const T1 &xs)
{
    return sum(xs) / xs.len();
}

template <typename T1> auto stddev(const T1 &xs)
{
    auto m = mean(xs);
    return sqrt(sum_map(xs, [&m](const auto &x){return square((x - m));}) / xs.len());
}

template <typename T1, typename T2> auto experiment(const T1 &label, const T2 &rule)
{
    auto [rxs, rys] = make_tuple(funnel(::dxs, rule), funnel(::dys, rule));
    print(label);
    print(u"Mean x, y    : #.4, #.4"_S.format(mean(rxs), mean(rys)));
    print(u"Std dev x, y : #.4, #.4"_S.format(stddev(rxs), stddev(rys)));
    print();
}

struct CodeBlock1
{
    CodeBlock1()
    {
        experiment(u"Rule 1:"_S, [](const auto &z, const auto &dz){return 0;});
        experiment(u"Rule 2:"_S, [](const auto &z, const auto &dz){return -dz;});
        experiment(u"Rule 3:"_S, [](const auto &z, const auto &dz){return -(z + dz);});
        experiment(u"Rule 4:"_S, [](const auto &z, const auto &dz){return z + dz;});
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Determinant_and_permanent#Nim
def s_permutations(seq):
    items = [[0] * 0]
    for j in seq:
        new_items : List[List[int]] = []
        for i, item in enumerate(items):
            if i % 2:
                # step up
                new_items += [item[:i] + [j] + item[i:]
                              for i in range(len(item) + 1)]
            else:
                # step down
                new_items += [item[:i] + [j] + item[i:]
                              for i in range(len(item), -1, -1)]
        items = new_items

    return [(item, -1 if i % 2 else 1)
            for i, item in enumerate(items)]

def det(a):
    result = 0.0
    for sigma, sign in s_permutations(list(range(len(a)))):
        x = float(sign)
        for i in range(len(a)):
            x *= a[i][sigma[i]]
        result += x
    return result

def perm(a):
    result = 0.0
    for sigma, sign in s_permutations(list(range(len(a)))):
        x = 1.0
        for i in range(len(a)):
            x *= a[i][sigma[i]]
        result += x
    return result

a = [ [1.0, 2.0]
    , [3.0, 4.0]
    ]
b = [ [float( 1),  2,  3,  4]
    , [float( 4),  5,  6,  7]
    , [float( 7),  8,  9, 10]
    , [float(10), 11, 12, 13]
    ]
c = [ [float( 0),  1,  2,  3,  4]
    , [float( 5),  6,  7,  8,  9]
    , [float(10), 11, 12, 13, 14]
    , [float(15), 16, 17, 18, 19]
    , [float(20), 21, 22, 23, 24]
    ]

print("perm:", perm(a), "det:", det(a))
print("perm:", perm(b), "det:", det(b))
print("perm:", perm(c), "det:", det(c))
===
F s_permutations(seq)
   V items = [[Int]()]
   L(j) seq
      [[Int]] new_items
      L(item) items
         V i = L.index
         I i % 2
            new_items [+]= (0 .. item.len).map(i -> @item[0 .< i] [+] [@j] [+] @item[i ..])
         E
            new_items [+]= (item.len .< -1).step(-1).map(i -> @item[0 .< i] [+] [@j] [+] @item[i ..])
      items = new_items

   R enumerate(items).map((i, item) -> (item, I i % 2 {-1} E 1))

F det(a)
   V result = 0.0
   L(sigma, _sign_) s_permutations(Array(0 .< a.len))
      V x = Float(_sign_)
      L(i) 0 .< a.len
         x *= a[i][sigma[i]]
      result += x
   R result

F perm(a)
   V result = 0.0
   L(sigma, _sign_) s_permutations(Array(0 .< a.len))
      V x = 1.0
      L(i) 0 .< a.len
         x *= a[i][sigma[i]]
      result += x
   R result

V a = [[1.0, 2.0], [3.0, 4.0]]
V b = [[Float(1), 2, 3, 4], [Float(4), 5, 6, 7], [Float(7), 8, 9, 10], [Float(10), 11, 12, 13]]
V c = [[Float(0), 1, 2, 3, 4], [Float(5), 6, 7, 8, 9], [Float(10), 11, 12, 13, 14], [Float(15), 16, 17, 18, 19], [Float(20), 21, 22, 23, 24]]

print(‘perm: ’perm(a)‘ det: ’det(a))
print(‘perm: ’perm(b)‘ det: ’det(b))
print(‘perm: ’perm(c)‘ det: ’det(c))
===
template <typename T1> auto s_permutations(const T1 &seq)
{
    auto items = create_array({Array<int>()});
    for (auto &&j : seq) {
        Array<Array<int>> new_items;
        {int Lindex = 0;
        for (auto &&item : items) {
            auto i = Lindex;
            if (mod(i, 2))
                new_items.append(range_ee(0, item.len()).map([&item, &j](const auto &i){return item[range_el(0, i)] + create_array({j}) + item[range_ei(i)];}));
            else
                new_items.append(range_el(item.len(), -1).step(-1).map([&item, &j](const auto &i){return item[range_el(0, i)] + create_array({j}) + item[range_ei(i)];}));
            Lindex++;
        }}
        items = new_items;
    }

    return enumerate(items).map([](const auto &i, const auto &item){return make_tuple(item, mod(i, 2) ? -1 : 1);});
}

template <typename T1> auto det(const T1 &a)
{
    auto result = 0.0;
    for (auto &&[sigma, _sign_] : s_permutations(create_array(range_el(0, a.len())))) {
        auto x = to_float(_sign_);
        for (auto i : range_el(0, a.len()))
            x *= a[i][sigma[i]];
        result += x;
    }
    return result;
}

template <typename T1> auto perm(const T1 &a)
{
    auto result = 0.0;
    for (auto &&[sigma, _sign_] : s_permutations(create_array(range_el(0, a.len())))) {
        auto x = 1.0;
        for (auto i : range_el(0, a.len()))
            x *= a[i][sigma[i]];
        result += x;
    }
    return result;
}

auto a = create_array({create_array({1.0, 2.0}), create_array({3.0, 4.0})});
auto b = create_array({create_array<double>({to_float(1), 2, 3, 4}), create_array<double>({to_float(4), 5, 6, 7}), create_array<double>({to_float(7), 8, 9, 10}), create_array<double>({to_float(10), 11, 12, 13})});
auto c = create_array({create_array<double>({to_float(0), 1, 2, 3, 4}), create_array<double>({to_float(5), 6, 7, 8, 9}), create_array<double>({to_float(10), 11, 12, 13, 14}), create_array<double>({to_float(15), 16, 17, 18, 19}), create_array<double>({to_float(20), 21, 22, 23, 24})});

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"perm: "_S & perm(a) & u" det: "_S & det(a));
        print(u"perm: "_S & perm(b) & u" det: "_S & det(b));
        print(u"perm: "_S & perm(c) & u" det: "_S & det(c));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Determine_if_a_string_has_all_the_same_characters#Kotlin
from _11l import *

def analyze(s):
    print('Examining [%s] which has a length of %d:' % (s, len(s)))
    if len(s) > 1:
        b = s[0]
        for i, c in enumerate(s):
            if c != b:
                print('    Not all characters in the string are the same.')
                print("    '" + c + "' (0x" + hexu(ord(c)) + ') is different at position ' + str(i))
                return

    print('    All characters in the string are the same.')

strs = ['', '   ', '2', '333', '.55', 'tttTTT', '4444 444k']
for s in strs:
    analyze(s)
===
F analyze(s)
   print(‘Examining [#.] which has a length of #.:’.format(s, s.len))
   I s.len > 1
      V b = s[0]
      L(c) s
         V i = L.index
         I c != b
            print(‘    Not all characters in the string are the same.’)
            print(‘    '’c‘' (0x’hex(c.code)‘) is different at position ’String(i))
            R

   print(‘    All characters in the string are the same.’)

V strs = [‘’, ‘   ’, ‘2’, ‘333’, ‘.55’, ‘tttTTT’, ‘4444 444k’]
L(s) strs
   analyze(s)
===
template <typename T1> auto analyze(const T1 &s)
{
    print(u"Examining [#.] which has a length of #.:"_S.format(s, s.len()));
    if (s.len() > 1) {
        auto b = _get<0>(s);
        {int Lindex = 0;
        for (auto &&c : s) {
            auto i = Lindex;
            if (c != b) {
                print(u"    Not all characters in the string are the same."_S);
                print(u"    '"_S & c & u"' (0x"_S & hex(c.code) & u") is different at position "_S & String(i));
                return;
            }
            Lindex++;
        }}
    }

    print(u"    All characters in the string are the same."_S);
}

auto strs = create_array({u""_S, u"   "_S, u"2"_S, u"333"_S, u".55"_S, u"tttTTT"_S, u"4444 444k"_S});

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&s : strs)
            analyze(s);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Determine_if_a_string_has_all_unique_characters#Kotlin
from _11l import *

def processString(input):
    charMap : Dict[Char, int] = {}
    dup = Char("\0")
    index = 0
    pos1 = -1
    pos2 = -1
    for key in input:
        index += 1
        if key in charMap:
            dup = key
            pos1 = charMap[key]
            pos2 = index
            break
        charMap[key] = index
    unique = "yes" if dup == Char("\0") else "no"
    diff = "" if dup == Char("\0") else "'" + dup + "'"
    hexs = "" if dup == Char("\0") else hexu(ord(dup))
    position = "" if dup == Char("\0") else str(pos1) + " " + str(pos2)
    print("%-40s  %-6d  %-10s  %-8s  %-3s  %-5s" % (input, len(input), unique, diff, hexs, position))

print("%-40s  %2s  %10s  %8s  %s  %s" % ("String", "Length", "All Unique", "1st Diff", "Hex", "Positions"))
print("%-40s  %2s  %10s  %8s  %s  %s" % ("------------------------", "------", "----------", "--------", "---", "---------"))
for s in ["", ".", "abcABC", "XYZ ZYX", "1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ"]:
    processString(s)
===
F processString(input)
   [Char = Int] charMap
   V dup = Char("\0")
   V index = 0
   V pos1 = -1
   V pos2 = -1
   L(key) input
      index++
      I key C charMap
         dup = key
         pos1 = charMap[key]
         pos2 = index
         L.break
      charMap[key] = index
   V unique = I dup == Char("\0") {‘yes’} E ‘no’
   V diff = I dup == Char("\0") {‘’} E ‘'’dup‘'’
   V hexs = I dup == Char("\0") {‘’} E hex(dup.code)
   V position = I dup == Char("\0") {‘’} E String(pos1)‘ ’String(pos2)
   print(‘#<40  #<6  #<10  #<8  #<3  #<5’.format(input, input.len, unique, diff, hexs, position))

print(‘#<40  #2  #10  #8  #.  #.’.format(‘String’, ‘Length’, ‘All Unique’, ‘1st Diff’, ‘Hex’, ‘Positions’))
print(‘#<40  #2  #10  #8  #.  #.’.format(‘------------------------’, ‘------’, ‘----------’, ‘--------’, ‘---’, ‘---------’))
L(s) [‘’, ‘.’, ‘abcABC’, ‘XYZ ZYX’, ‘1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ’]
   processString(s)
===
template <typename T1> auto processString(const T1 &input)
{
    Dict<Char, int> charMap;
    auto dup = u'\0'_C;
    auto index = 0;
    auto pos1 = -1;
    auto pos2 = -1;
    for (auto &&key : input) {
        index++;
        if (in(key, charMap)) {
            dup = key;
            pos1 = charMap[key];
            pos2 = index;
            break;
        }
        charMap.set(key, index);
    }
    auto unique = dup == u'\0'_C ? u"yes"_S : u"no"_S;
    auto diff = dup == u'\0'_C ? u""_S : u"'"_S & dup & u"'"_S;
    auto hexs = dup == u'\0'_C ? u""_S : hex(dup.code);
    auto position = dup == u'\0'_C ? u""_S : String(pos1) & u" "_S & String(pos2);
    print(u"#<40  #<6  #<10  #<8  #<3  #<5"_S.format(input, input.len(), unique, diff, hexs, position));
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"#<40  #2  #10  #8  #.  #."_S.format(u"String"_S, u"Length"_S, u"All Unique"_S, u"1st Diff"_S, u"Hex"_S, u"Positions"_S));
        print(u"#<40  #2  #10  #8  #.  #."_S.format(u"------------------------"_S, u"------"_S, u"----------"_S, u"--------"_S, u"---"_S, u"---------"_S));
        for (auto &&s : create_array({u""_S, u"."_S, u"abcABC"_S, u"XYZ ZYX"_S, u"1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ"_S}))
            processString(s);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Determine_if_a_string_is_collapsible#Kotlin
Char = str

def collapse(s):
    cs = ''
    last = Char("\0")
    for c in s:
        if c != last:
            cs += c
            last = c
    return cs

strings = [
    "",
    '"If I were two-faced, would I be wearing this one?" --- Abraham Lincoln ',
    "..1111111111111111111111111111111111111111111111111111111111111117777888",
    "I never give 'em hell, I just tell the truth, and they think it's hell. ",
    "                                                   ---  Harry S Truman  ",
    "The better the 4-wheel drive, the further you'll be from help when ya get stuck!",
    "headmistressship",
    "aardvark"
]

for s in strings:
    c = collapse(s)
    print("original  : length = " + str(len(s)) + ", string = <<<" + s + ">>>")
    print("collapsed : length = " + str(len(c)) + ", string = <<<" + c + ">>>")
    print()
===
F collapse(s)
   V cs = ‘’
   V last = Char("\0")
   L(c) s
      I c != last
         cs ‘’= c
         last = c
   R cs

V strings = [‘’, ‘"If I were two-faced, would I be wearing this one?" --- Abraham Lincoln ’, ‘..1111111111111111111111111111111111111111111111111111111111111117777888’, ‘I never give 'em hell, I just tell the truth, and they think it's hell. ’, ‘                                                   ---  Harry S Truman  ’, ‘The better the 4-wheel drive, the further you'll be from help when ya get stuck!’, ‘headmistressship’, ‘aardvark’]

L(s) strings
   V c = collapse(s)
   print(‘original  : length = ’String(s.len)‘, string = <<<’s‘>>>’)
   print(‘collapsed : length = ’String(c.len)‘, string = <<<’c‘>>>’)
   print()
===
template <typename T1> auto collapse(const T1 &s)
{
    auto cs = u""_S;
    auto last = u'\0'_C;
    for (auto &&c : s)
        if (c != last) {
            cs &= c;
            last = c;
        }
    return cs;
}

auto strings = create_array({u""_S, u"\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln "_S, u"..1111111111111111111111111111111111111111111111111111111111111117777888"_S, u"I never give 'em hell, I just tell the truth, and they think it's hell. "_S, u"                                                   ---  Harry S Truman  "_S, u"The better the 4-wheel drive, the further you'll be from help when ya get stuck!"_S, u"headmistressship"_S, u"aardvark"_S});

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&s : strings) {
            auto c = collapse(s);
            print(u"original  : length = "_S & String(s.len()) & u", string = <<<"_S & s & u">>>"_S);
            print(u"collapsed : length = "_S & String(c.len()) & u", string = <<<"_S & c & u">>>"_S);
            print();
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Determine_if_a_string_is_squeezable#Java
def squeeze(input, include):
    s = ''
    for i in range(len(input)):
        if i == 0 or input[i - 1] != input[i] or (input[i - 1] == input[i] and input[i] != include):
            s += input[i]
    return s

testStrings = [
    "",
    '"If I were two-faced, would I be wearing this one?" --- Abraham Lincoln ',
    "..1111111111111111111111111111111111111111111111111111111111111117777888",
    "I never give 'em hell, I just tell the truth, and they think it's hell. ",
    "                                                    --- Harry S Truman  ",
    "122333444455555666666777777788888888999999999",
    "The better the 4-wheel drive, the further you'll be from help when ya get stuck!",
    "headmistressship"
]

testChar = [
    " ",
    "-",
    "7",
    ".",
    " -r",
    "5",
    "e",
    "s"
]

for testNum in range(len(testStrings)):
    s = testStrings[testNum]
    for c in testChar[testNum]:
        result = squeeze(s, c)
        print("use: '%s'\nold:  %2d <<<%s>>>\nnew:  %2d <<<%s>>>\n" % (c, len(s), s, len(result), result))
===
F squeeze(input, include)
   V s = ‘’
   L(i) 0 .< input.len
      I i == 0 | input[i - 1] != input[i] | (input[i - 1] == input[i] & input[i] != include)
         s ‘’= input[i]
   R s

V testStrings = [‘’, ‘"If I were two-faced, would I be wearing this one?" --- Abraham Lincoln ’, ‘..1111111111111111111111111111111111111111111111111111111111111117777888’, ‘I never give 'em hell, I just tell the truth, and they think it's hell. ’, ‘                                                    --- Harry S Truman  ’, ‘122333444455555666666777777788888888999999999’, ‘The better the 4-wheel drive, the further you'll be from help when ya get stuck!’, ‘headmistressship’]

V testChar = [‘ ’, ‘-’, ‘7’, ‘.’, ‘ -r’, ‘5’, ‘e’, ‘s’]

L(testNum) 0 .< testStrings.len
   V s = testStrings[testNum]
   L(c) testChar[testNum]
      V result = squeeze(s, c)
      print("use: '#.'\nold:  #2 <<<#.>>>\nnew:  #2 <<<#.>>>\n".format(c, s.len, s, result.len, result))
===
template <typename T1, typename T2> auto squeeze(const T1 &input, const T2 &include)
{
    auto s = u""_S;
    for (auto i : range_el(0, input.len()))
        if (i == 0 || input[i - 1] != input[i] || (input[i - 1] == input[i] && input[i] != include))
            s &= input[i];
    return s;
}

auto testStrings = create_array({u""_S, u"\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln "_S, u"..1111111111111111111111111111111111111111111111111111111111111117777888"_S, u"I never give 'em hell, I just tell the truth, and they think it's hell. "_S, u"                                                    --- Harry S Truman  "_S, u"122333444455555666666777777788888888999999999"_S, u"The better the 4-wheel drive, the further you'll be from help when ya get stuck!"_S, u"headmistressship"_S});

auto testChar = create_array({u" "_S, u"-"_S, u"7"_S, u"."_S, u" -r"_S, u"5"_S, u"e"_S, u"s"_S});

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto testNum : range_el(0, testStrings.len())) {
            auto s = testStrings[testNum];
            for (auto &&c : testChar[testNum]) {
                auto result = squeeze(s, c);
                print(u"use: '#.'\nold:  #2 <<<#.>>>\nnew:  #2 <<<#.>>>\n"_S.format(c, s.len(), s, result.len(), result));
            }
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Dinesman%27s_multiple-dwelling_problem#Nim
from _11l import *

BAKER = 0
COOPER = 1
FLETCHER = 2
MILLER = 3
SMITH = 4
names = ['Baker', 'Cooper', 'Fletcher', 'Miller', 'Smith']

floors = list(range(1, 6))

while True:
    if floors[BAKER] != 5 and \
           floors[COOPER] != 1 and \
           floors[FLETCHER] not in (1, 5) and \
           floors[MILLER] > floors[COOPER] and \
           abs(floors[SMITH] - floors[FLETCHER]) != 1 and \
           abs(floors[FLETCHER] - floors[COOPER]) != 1:
       for person, floor in enumerate(floors):
           print(names[person], "lives on floor", floor)
       break

    if not next_permutation(floors):
        print("No solution found.")
        break
===
V BAKER = 0
V COOPER = 1
V FLETCHER = 2
V MILLER = 3
V SMITH = 4
V names = [‘Baker’, ‘Cooper’, ‘Fletcher’, ‘Miller’, ‘Smith’]

V floors = Array(1..5)

L
   I floors[BAKER] != 5 & floors[COOPER] != 1 & floors[FLETCHER] !C (1, 5) & floors[MILLER] > floors[COOPER] & abs(floors[SMITH] - floors[FLETCHER]) != 1 & abs(floors[FLETCHER] - floors[COOPER]) != 1
      L(floor) floors
         V person = L.index
         print(names[person]‘ lives on floor ’floor)
      L.break

   I !floors.next_permutation()
      print(‘No solution found.’)
      L.break
===
auto BAKER = 0;
auto COOPER = 1;
auto FLETCHER = 2;
auto MILLER = 3;
auto SMITH = 4;
auto names = create_array({u"Baker"_S, u"Cooper"_S, u"Fletcher"_S, u"Miller"_S, u"Smith"_S});

auto floors = create_array(range_ee(1, 5));

struct CodeBlock1
{
    CodeBlock1()
    {
        while (true) {
            if (floors[BAKER] != 5 && floors[COOPER] != 1 && !in(floors[FLETCHER], make_tuple(1, 5)) && floors[MILLER] > floors[COOPER] && abs(floors[SMITH] - floors[FLETCHER]) != 1 && abs(floors[FLETCHER] - floors[COOPER]) != 1) {
                {int Lindex = 0;
                for (auto &&floor : floors) {
                    auto person = Lindex;
                    print(names[person] & u" lives on floor "_S & floor);
                    Lindex++;
                }}
                break;
            }

            if (!floors.next_permutation()) {
                print(u"No solution found."_S);
                break;
            }
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Distribution_of_0_Digits_in_factorial_series#Python
BigInt = int

def facpropzeros(n, verbose = True):
    proportions = [0.0] * n
    (fac, psum) = (BigInt(1), 0.0)
    for i in range(n):
        fac *= i + 1
        d = str(fac)
        psum += sum(map(lambda x: int(x == '0'), d)) / float(len(d))
        proportions[i] = psum / (i + 1)

    if verbose:
        print("The mean proportion of 0 in factorials from 1 to {} is {}.".format(n, psum / n))

    return proportions

for n in [100, 1000, 10000]:
    facpropzeros(n)
===
F facpropzeros(n, verbose = 1B)
   V proportions = [0.0] * n
   V (fac, psum) = (BigInt(1), 0.0)
   L(i) 0 .< n
      fac *= i + 1
      V d = String(fac)
      psum += sum(d.map(x -> Int(x == ‘0’))) / Float(d.len)
      proportions[i] = psum / (i + 1)

   I verbose
      print(‘The mean proportion of 0 in factorials from 1 to #. is #..’.format(n, psum / n))

   R proportions

L(n) [100, 1000, 10000]
   facpropzeros(n)
===
template <typename T1, typename T2 = decltype(true)> auto facpropzeros(const T1 &n, const T2 &verbose = true)
{
    auto proportions = create_array({0.0}) * n;
    auto [fac, psum] = make_tuple(BigInt(1), 0.0);
    for (auto i : range_el(0, n)) {
        fac *= i + 1;
        auto d = String(fac);
        psum += sum_map(d, [](const auto &x){return to_int(x == u'0');}) / to_float(d.len());
        proportions.set(i, psum / (i + 1));
    }

    if (verbose)
        print(u"The mean proportion of 0 in factorials from 1 to #. is #.."_S.format(n, psum / n));

    return proportions;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&n : create_array({100, 1000, 10000}))
            facpropzeros(n);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Distribution_of_0_Digits_in_factorial_series#Base_1000_version_3
def zinit():
    zc = [0] * 999
    for x in range(1, 10):
        zc[x - 1] = 2        # 00x
        zc[10 * x - 1] = 2   # 0x0
        zc[100 * x - 1] = 2  # x00
        for y in range(10, 100, 10):
            zc[y + x - 1] = 1           # 0yx
            zc[10 * y + x - 1] = 1      # y0x
            zc[10 * (y + x) - 1] = 1    # yx0

    return zc

def meanfactorialdigits():
    zc = zinit()
    rfs = [1]
    (total, trail, first) = (0.0, 1, 0)
    for f in range(2, 50000):
        (carry, d999, zeroes) = (0, 0, (trail - 1) * 3)
        (j, l) = (trail, len(rfs))
        while j <= l or carry != 0:
            if j <= l:
                carry = rfs[j-1] * f + carry

            d999 = carry % 1000
            if j <= l:
                rfs[j-1] = d999
            else:
                rfs.append(d999)

            zeroes += 3 if d999 == 0 else zc[d999-1]
            carry //= 1000
            j += 1

        while rfs[trail-1] == 0:
            trail += 1

        # d999 is a quick correction for length and zeros
        d999 = rfs[-1]
        d999 = 0 if d999 >= 100 else 2 if d999 < 10 else 1

        zeroes -= d999
        digits = len(rfs) * 3 - d999
        total += float(zeroes) / digits
        ratio = total / f
        if f in [100, 1000, 10000]:
            print("The mean proportion of zero digits in factorials to {} is {}".format(f, ratio))

        if ratio >= 0.16:
            first = 0
        elif first == 0:
            first = f

    print("The mean proportion dips permanently below 0.16 at {}.".format(first))

meanfactorialdigits()
===
F zinit()
   V zc = [0] * 999
   L(x) 1..9
      zc[x - 1] = 2
      zc[10 * x - 1] = 2
      zc[100 * x - 1] = 2
      L(y) (10.<100).step(10)
         zc[y + x - 1] = 1
         zc[10 * y + x - 1] = 1
         zc[10 * (y + x) - 1] = 1

   R zc

F meanfactorialdigits()
   V zc = zinit()
   V rfs = [1]
   V (total, trail, first) = (0.0, 1, 0)
   L(f) 2..49999
      V (carry, d999, zeroes) = (0, 0, (trail - 1) * 3)
      V (j, l) = (trail, rfs.len)
      L j <= l | carry != 0
         I j <= l
            carry = rfs[j - 1] * f + carry

         d999 = carry % 1000
         I j <= l
            rfs[j - 1] = d999
         E
            rfs.append(d999)

         zeroes += I d999 == 0 {3} E zc[d999 - 1]
         carry I/= 1000
         j++

      L rfs[trail - 1] == 0
         trail++

      d999 = rfs.last
      d999 = I d999 >= 100 {0} E I d999 < 10 {2} E 1

      zeroes -= d999
      V digits = rfs.len * 3 - d999
      total += Float(zeroes) / digits
      V ratio = total / f
      I f C [100, 1000, 10000]
         print(‘The mean proportion of zero digits in factorials to #. is #.’.format(f, ratio))

      I ratio >= 0.16
         first = 0
      E I first == 0
         first = f

   print(‘The mean proportion dips permanently below 0.16 at #..’.format(first))

meanfactorialdigits()
===
auto zinit()
{
    auto zc = create_array({0}) * 999;
    for (auto x : range_ee(1, 9)) {
        zc.set(x - 1, 2);
        zc.set(10 * x - 1, 2);
        zc.set(100 * x - 1, 2);
        for (auto y : range_el(10, 100).step(10)) {
            zc.set(y + x - 1, 1);
            zc.set(10 * y + x - 1, 1);
            zc.set(10 * (y + x) - 1, 1);
        }
    }

    return zc;
}

auto meanfactorialdigits()
{
    auto zc = zinit();
    auto rfs = create_array({1});
    auto [total, trail, first] = make_tuple(0.0, 1, 0);
    for (auto f : range_ee(2, 49999)) {
        auto [carry, d999, zeroes] = make_tuple(0, 0, (trail - 1) * 3);
        auto [j, l] = make_tuple(trail, rfs.len());
        while (j <= l || carry != 0) {
            if (j <= l)
                carry = rfs[j - 1] * f + carry;

            d999 = mod(carry, 1000);
            if (j <= l)
                rfs.set(j - 1, d999);
            else
                rfs.append(d999);

            zeroes += d999 == 0 ? 3 : zc[d999 - 1];
            carry = idiv(carry, 1000);
            j++;
        }

        while (rfs[trail - 1] == 0)
            trail++;

        d999 = rfs.last();
        d999 = d999 >= 100 ? 0 : d999 < 10 ? 2 : 1;

        zeroes -= d999;
        auto digits = rfs.len() * 3 - d999;
        total += to_float(zeroes) / digits;
        auto ratio = total / f;
        if (in(f, create_array({100, 1000, 10000})))
            print(u"The mean proportion of zero digits in factorials to #. is #."_S.format(f, ratio));

        if (ratio >= 0.16)
            first = 0;
        else if (first == 0)
            first = f;
    }

    print(u"The mean proportion dips permanently below 0.16 at #.."_S.format(first));
}

struct CodeBlock1
{
    CodeBlock1()
    {
        meanfactorialdigits();
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Doomsday_rule#Python
def isleap(year):
    return year%4==0 and (year%100!=0 or year%400==0)

def weekday(year, month, day):
    days = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday",
            "Friday", "Saturday"]
    dooms = [
        [3, 7, 7, 4, 2, 6, 4, 1, 5, 3, 7, 5],
        [4, 1, 7, 4, 2, 6, 4, 1, 5, 3, 7, 5]
    ]

    c = year // 100
    r = year % 100
    s = r // 12
    t = r % 12
    c_anchor = (5 * (c % 4) + 2) % 7
    doomsday = (s + t + (t // 4) + c_anchor) % 7
    anchorday = dooms[isleap(year)][month - 1]
    weekday = (doomsday + day - anchorday + 7) % 7
    return days[weekday]

for year, month, day in [(1800, 1, 6), (1875, 3, 29), (1915, 12, 7),
         (1970, 12, 23), (2043, 5, 14), (2077, 2, 12), (2101, 4, 2)]:
    print('%d-%02d-%02d -> %s' % (year, month, day, weekday(year, month, day)))
===
F isleap(year)
   R year % 4 == 0 & (year % 100 != 0 | year % 400 == 0)

F weekday(year, month, day)
   V days = [‘Sunday’, ‘Monday’, ‘Tuesday’, ‘Wednesday’, ‘Thursday’, ‘Friday’, ‘Saturday’]
   V dooms = [[3, 7, 7, 4, 2, 6, 4, 1, 5, 3, 7, 5], [4, 1, 7, 4, 2, 6, 4, 1, 5, 3, 7, 5]]

   V c = year I/ 100
   V r = year % 100
   V s = r I/ 12
   V t = r % 12
   V c_anchor = (5 * (c % 4) + 2) % 7
   V doomsday = (s + t + (t I/ 4) + c_anchor) % 7
   V anchorday = dooms[isleap(year)][month - 1]
   V weekday = (doomsday + day - anchorday + 7) % 7
   R days[weekday]

L(year, month, day) [(1800, 1, 6), (1875, 3, 29), (1915, 12, 7), (1970, 12, 23), (2043, 5, 14), (2077, 2, 12), (2101, 4, 2)]
   print(‘#.-#02-#02 -> #.’.format(year, month, day, weekday(year, month, day)))
===
template <typename T1> auto isleap(const T1 &year)
{
    return mod(year, 4) == 0 && (mod(year, 100) != 0 || mod(year, 400) == 0);
}

template <typename T1, typename T2, typename T3> auto weekday(const T1 &year, const T2 &month, const T3 &day)
{
    auto days = create_array({u"Sunday"_S, u"Monday"_S, u"Tuesday"_S, u"Wednesday"_S, u"Thursday"_S, u"Friday"_S, u"Saturday"_S});
    auto dooms = create_array({create_array({3, 7, 7, 4, 2, 6, 4, 1, 5, 3, 7, 5}), create_array({4, 1, 7, 4, 2, 6, 4, 1, 5, 3, 7, 5})});

    auto c = idiv(year, 100);
    auto r = mod(year, 100);
    auto s = idiv(r, 12);
    auto t = mod(r, 12);
    auto c_anchor = mod((5 * (mod(c, 4)) + 2), 7);
    auto doomsday = mod((s + t + (idiv(t, 4)) + c_anchor), 7);
    auto anchorday = dooms[isleap(year)][month - 1];
    auto weekday = mod((doomsday + day - anchorday + 7), 7);
    return days[weekday];
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&[year, month, day] : create_array({make_tuple(1800, 1, 6), make_tuple(1875, 3, 29), make_tuple(1915, 12, 7), make_tuple(1970, 12, 23), make_tuple(2043, 5, 14), make_tuple(2077, 2, 12), make_tuple(2101, 4, 2)}))
            print(u"#.-#02-#02 -> #."_S.format(year, month, day, weekday(year, month, day)));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Draw_a_cuboid#Nim
def cline(n, x, y, cde : str):
    print(str(cde[0]).rjust(n + 1) + cde[1] * (9*x-1) + cde[0] + (str(cde[2]).rjust(y+1) if len(cde) > 2 else ''))

def cuboid(x, y, z):
    cline(y+1, x, 0, "+-")
    for i in range(1, y + 1):
        cline(y-i+1, x, i-1, "/ |")
    cline(0, x, y, "+-|")
    for i in range(4*z-y-3 + 1):
        cline(0, x, y, "| |")
    cline(0, x, y, "| +")
    for i in range(y-1, -1, -1):
        cline(0, x, i, "| /")
    cline(0, x, 0, "+-\n")

cuboid(2, 3, 4)
cuboid(1, 1, 1)
cuboid(6, 2, 1)
===
F cline(n, x, y, String cde)
   print(String(cde[0]).rjust(n + 1)‘’cde[1] * (9 * x - 1)‘’cde[0]‘’(I cde.len > 2 {String(cde[2]).rjust(y + 1)} E ‘’))

F cuboid(x, y, z)
   cline(y + 1, x, 0, ‘+-’)
   L(i) 1 .. y
      cline(y - i + 1, x, i - 1, ‘/ |’)
   cline(0, x, y, ‘+-|’)
   L(i) 0 .. 4 * z - y - 3
      cline(0, x, y, ‘| |’)
   cline(0, x, y, ‘| +’)
   L(i) (y - 1 .< -1).step(-1)
      cline(0, x, i, ‘| /’)
   cline(0, x, 0, "+-\n")

cuboid(2, 3, 4)
cuboid(1, 1, 1)
cuboid(6, 2, 1)
===
template <typename T1, typename T2, typename T3> auto cline(const T1 &n, const T2 &x, const T3 &y, const String &cde)
{
    print(String(_get<0>(cde)).rjust(n + 1) & _get<1>(cde) * (9 * x - 1) & _get<0>(cde) & (cde.len() > 2 ? String(_get<2>(cde)).rjust(y + 1) : u""_S));
}

template <typename T1, typename T2, typename T3> auto cuboid(const T1 &x, const T2 &y, const T3 &z)
{
    cline(y + 1, x, 0, u"+-"_S);
    for (auto i : range_ee(1, y))
        cline(y - i + 1, x, i - 1, u"/ |"_S);
    cline(0, x, y, u"+-|"_S);
    for (auto i : range_ee(0, 4 * z - y - 3))
        cline(0, x, y, u"| |"_S);
    cline(0, x, y, u"| +"_S);
    for (auto i : range_el(y - 1, -1).step(-1))
        cline(0, x, i, u"| /"_S);
    cline(0, x, 0, u"+-\n"_S);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        cuboid(2, 3, 4);
        cuboid(1, 1, 1);
        cuboid(6, 2, 1);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Draw_a_sphere#Python
from typing import Tuple
import math

shades = ['.',':','!','*','o','e','&','#','%','@']

def normalize(v : Tuple[float, float, float]):
    len = math.sqrt(v[0]**2 + v[1]**2 + v[2]**2)
    return (v[0]/len, v[1]/len, v[2]/len)

def dot(x,y):
    d = x[0]*y[0] + x[1]*y[1] + x[2]*y[2]
    return -d if d < 0 else 0

def draw_sphere(r, k, ambient, light):
    for i in range(math.floor(-r),math.ceil(r)+1):
        x = i + 0.5
        line = ''

        for j in range(math.floor(-2*r),math.ceil(2*r)+1):
            y = j/2 + 0.5
            if x*x + y*y <= r*r:
                vec = normalize((x,y,math.sqrt(r*r - x*x - y*y)))
                b = dot(light,vec)**k + ambient
                intensity = int((1-b)*(len(shades)-1))
                line += shades[intensity] if 0 <= intensity < len(shades) else shades[0]
            else:
                line += ' '

        print(line)

light = normalize((30.0,30.0,-50.0))
draw_sphere(20,4,0.1, light)
draw_sphere(10,2,0.4, light)
===
V shades = [‘.’, ‘:’, ‘!’, ‘*’, ‘o’, ‘e’, ‘&’, ‘#’, ‘%’, ‘@’]

F normalize((Float, Float, Float) v)
   V len = sqrt(v[0] ^ 2 + v[1] ^ 2 + v[2] ^ 2)
   R (v[0] / len, v[1] / len, v[2] / len)

F dot(x, y)
   V d = x[0] * y[0] + x[1] * y[1] + x[2] * y[2]
   R I d < 0 {-d} E 0

F draw_sphere(r, k, ambient, light)
   L(i) floori(-r) .. ceili(r)
      V x = i + 0.5
      V line = ‘’

      L(j) floori(-2 * r) .. ceili(2 * r)
         V y = j / 2 + 0.5
         I x * x + y * y <= r * r
            V vec = normalize((x, y, sqrt(r * r - x * x - y * y)))
            V b = dot(light, vec) ^ k + ambient
            V intensity = Int((1 - b) * (:shades.len - 1))
            line ‘’= I intensity C 0 .< :shades.len {:shades[intensity]} E :shades[0]
         E
            line ‘’= ‘ ’

      print(line)

V light = normalize((30.0, 30.0, -50.0))
draw_sphere(20, 4, 0.1, light)
draw_sphere(10, 2, 0.4, light)
===
auto shades = create_array({u'.'_C, u':'_C, u'!'_C, u'*'_C, u'o'_C, u'e'_C, u'&'_C, u'#'_C, u'%'_C, u'@'_C});

auto normalize(const dvec3 &v)
{
    auto len = sqrt(square(_get<0>(v)) + square(_get<1>(v)) + square(_get<2>(v)));
    return make_tuple(_get<0>(v) / len, _get<1>(v) / len, _get<2>(v) / len);
}

template <typename T1, typename T2> auto dot(const T1 &x, const T2 &y)
{
    auto d = _get<0>(x) * _get<0>(y) + _get<1>(x) * _get<1>(y) + _get<2>(x) * _get<2>(y);
    return d < 0 ? -d : 0;
}

template <typename T1, typename T2, typename T3, typename T4> auto draw_sphere(const T1 &r, const T2 &k, const T3 &ambient, const T4 &light)
{
    for (auto i : range_ee(floori(-r), ceili(r))) {
        auto x = i + 0.5;
        auto line = u""_S;

        for (auto j : range_ee(floori(-2 * r), ceili(2 * r))) {
            auto y = j / 2.0 + 0.5;
            if (x * x + y * y <= r * r) {
                auto vec = normalize(make_tuple(x, y, sqrt(r * r - x * x - y * y)));
                auto b = pow(dot(light, vec), k) + ambient;
                auto intensity = to_int((1 - b) * (::shades.len() - 1));
                line &= in(intensity, range_el(0, ::shades.len())) ? ::shades[intensity] : _get<0>(::shades);
            }
            else
                line &= u" "_S;
        }

        print(line);
    }
}

auto light = normalize(make_tuple(30.0, 30.0, -50.0));

struct CodeBlock1
{
    CodeBlock1()
    {
        draw_sphere(20, 4, 0.1, light);
        draw_sphere(10, 2, 0.4, light);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Dutch_national_flag_problem#Python:_Construct_from_ball_counts
colours_in_order = 'Red White Blue'.split(' ')

def dutch_flag_sort3(items):
    r : List[str] = []
    for colour in colours_in_order:
        r.extend([colour] * items.count(colour))
    return r

balls = ['Red', 'Red', 'Blue', 'Blue', 'Blue', 'Red', 'Red', 'Red', 'White', 'Blue']
print("Original Ball order:", balls)
sorted_balls = dutch_flag_sort3(balls)
print("Sorted Ball Order:", sorted_balls)
===
V colours_in_order = ‘Red White Blue’.split(‘ ’)

F dutch_flag_sort3(items)
   [String] r
   L(colour) :colours_in_order
      r.extend([colour] * items.count(colour))
   R r

V balls = [‘Red’, ‘Red’, ‘Blue’, ‘Blue’, ‘Blue’, ‘Red’, ‘Red’, ‘Red’, ‘White’, ‘Blue’]
print(‘Original Ball order: ’balls)
V sorted_balls = dutch_flag_sort3(balls)
print(‘Sorted Ball Order: ’sorted_balls)
===
auto colours_in_order = u"Red White Blue"_S.split(u" "_S);

template <typename T1> auto dutch_flag_sort3(const T1 &items)
{
    Array<String> r;
    for (auto &&colour : ::colours_in_order)
        r.extend(create_array({colour}) * items.count(colour));
    return r;
}

auto balls = create_array({u"Red"_S, u"Red"_S, u"Blue"_S, u"Blue"_S, u"Blue"_S, u"Red"_S, u"Red"_S, u"Red"_S, u"White"_S, u"Blue"_S});

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"Original Ball order: "_S & balls);
    }
} code_block_1;

auto sorted_balls = dutch_flag_sort3(balls);

struct CodeBlock2
{
    CodeBlock2()
    {
        print(u"Sorted Ball Order: "_S & sorted_balls);
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Dating_agency#Python
sailors = ['Adrian', 'Caspian', 'Dune', 'Finn', 'Fisher', 'Heron', 'Kai',
           'Ray', 'Sailor', 'Tao']

ladies = ['Ariel', 'Bertha', 'Blue', 'Cali', 'Catalina', 'Gale', 'Hannah',
           'Isla', 'Marina', 'Shelly']

def isnicegirl(s):
    return int(ord(s[0])) % 2 == 0

def islovable(slady, ssailor):
    return int(ord(slady[-1])) % 2 == int(ord(ssailor[-1])) % 2

for lady in ladies:
    if isnicegirl(lady):
        print("Dating service should offer a date with", lady)
        for sailor in sailors:
            if islovable(lady, sailor):
                print("    Sailor", sailor, "should take an offer to date her.")
    else:
        print("Dating service should NOT offer a date with", lady)
===
V sailors = [‘Adrian’, ‘Caspian’, ‘Dune’, ‘Finn’, ‘Fisher’, ‘Heron’, ‘Kai’, ‘Ray’, ‘Sailor’, ‘Tao’]

V ladies = [‘Ariel’, ‘Bertha’, ‘Blue’, ‘Cali’, ‘Catalina’, ‘Gale’, ‘Hannah’, ‘Isla’, ‘Marina’, ‘Shelly’]

F isnicegirl(s)
   R Int(s[0].code) % 2 == 0

F islovable(slady, ssailor)
   R Int(slady.last.code) % 2 == Int(ssailor.last.code) % 2

L(lady) ladies
   I isnicegirl(lady)
      print(‘Dating service should offer a date with ’lady)
      L(sailor) sailors
         I islovable(lady, sailor)
            print(‘    Sailor ’sailor‘ should take an offer to date her.’)
   E
      print(‘Dating service should NOT offer a date with ’lady)
===
auto sailors = create_array({u"Adrian"_S, u"Caspian"_S, u"Dune"_S, u"Finn"_S, u"Fisher"_S, u"Heron"_S, u"Kai"_S, u"Ray"_S, u"Sailor"_S, u"Tao"_S});

auto ladies = create_array({u"Ariel"_S, u"Bertha"_S, u"Blue"_S, u"Cali"_S, u"Catalina"_S, u"Gale"_S, u"Hannah"_S, u"Isla"_S, u"Marina"_S, u"Shelly"_S});

template <typename T1> auto isnicegirl(const T1 &s)
{
    return mod(to_int(_get<0>(s).code), 2) == 0;
}

template <typename T1, typename T2> auto islovable(const T1 &slady, const T2 &ssailor)
{
    return mod(to_int(slady.last().code), 2) == mod(to_int(ssailor.last().code), 2);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&lady : ladies)
            if (isnicegirl(lady)) {
                print(u"Dating service should offer a date with "_S & lady);
                for (auto &&sailor : sailors)
                    if (islovable(lady, sailor))
                        print(u"    Sailor "_S & sailor & u" should take an offer to date her."_S);
            }
            else
                print(u"Dating service should NOT offer a date with "_S & lady);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Day_of_the_week_of_Christmas_and_New_Year#Python
import datetime

weekDays = ["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"]
thisXMas  = datetime.date(2021,12,25)
thisXMasDay = int(thisXMas.strftime('%w'))
thisXMasDayAsString = weekDays[thisXMasDay]
print("This year's Christmas is on a", thisXMasDayAsString)

nextNewYear = datetime.date(2022,1,1)
nextNewYearDay = int(nextNewYear.strftime('%w'))
nextNewYearDayAsString = weekDays[nextNewYearDay]
print("Next new year is on a", nextNewYearDayAsString)
===
V weekDays = [‘Sunday’, ‘Monday’, ‘Tuesday’, ‘Wednesday’, ‘Thursday’, ‘Friday’, ‘Saturday’]
V thisXMas = Time(2021, 12, 25)
V thisXMasDay = Int(thisXMas.strftime(‘%w’))
V thisXMasDayAsString = weekDays[thisXMasDay]
print(‘This year's Christmas is on a ’thisXMasDayAsString)

V nextNewYear = Time(2022, 1, 1)
V nextNewYearDay = Int(nextNewYear.strftime(‘%w’))
V nextNewYearDayAsString = weekDays[nextNewYearDay]
print(‘Next new year is on a ’nextNewYearDayAsString)
===
auto weekDays = create_array({u"Sunday"_S, u"Monday"_S, u"Tuesday"_S, u"Wednesday"_S, u"Thursday"_S, u"Friday"_S, u"Saturday"_S});
auto thisXMas = Time(2021, 12, 25);
auto thisXMasDay = to_int(thisXMas.strftime(u"%w"_S));
auto thisXMasDayAsString = weekDays[thisXMasDay];

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"This year's Christmas is on a "_S & thisXMasDayAsString);
    }
} code_block_1;

auto nextNewYear = Time(2022, 1, 1);
auto nextNewYearDay = to_int(nextNewYear.strftime(u"%w"_S));
auto nextNewYearDayAsString = weekDays[nextNewYearDay];

struct CodeBlock2
{
    CodeBlock2()
    {
        print(u"Next new year is on a "_S & nextNewYearDayAsString);
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Determine_sentence_type#Go
Char = str

def sentenceType(s):
    if len(s) == 0:
        return ''

    types : List[Char] = []
    for c in s:
        if c == '?':
            types.append(Char('Q'))
        elif c == '!':
            types.append(Char('E'))
        elif c == '.':
            types.append(Char('S'))

    if s[-1] not in "?!.":
        types.append(Char('N'))

    return '|'.join(types)

s = "hi there, how are you today? I'd like to present to you the washing machine 9001. You have been nominated to win one of these! Just make sure you don't break it"
print(sentenceType(s))
===
F sentenceType(s)
   I s.empty
      R ‘’

   [Char] types
   L(c) s
      I c == ‘?’
         types.append(Char(‘Q’))
      E I c == ‘!’
         types.append(Char(‘E’))
      E I c == ‘.’
         types.append(Char(‘S’))

   I s.last !C ‘?!.’
      types.append(Char(‘N’))

   R types.join(‘|’)

V s = ‘hi there, how are you today? I'd like to present to you the washing machine 9001. You have been nominated to win one of these! Just make sure you don't break it’
print(sentenceType(s))
===
template <typename T1> auto sentenceType(const T1 &s)
{
    if (s.empty())
        return u""_S;

    Array<Char> types;
    for (auto &&c : s)
        if (c == u'?')
            types.append(u'Q'_C);
        else if (c == u'!')
            types.append(u'E'_C);
        else if (c == u'.')
            types.append(u'S'_C);

    if (!in(s.last(), u"?!."_S))
        types.append(u'N'_C);

    return types.join(u"|"_S);
}

auto s = u"hi there, how are you today? I'd like to present to you the washing machine 9001. You have been nominated to win one of these! Just make sure you don't break it"_S;

struct CodeBlock1
{
    CodeBlock1()
    {
        print(sentenceType(s));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Digit_fifth_powers
def fifth_power_digit_sum(n):
    return sum(int(c)**5 for c in str(n))

print(sum(i for i in range(2, 1000000) if i == fifth_power_digit_sum(i)))
===
F fifth_power_digit_sum(n)
   R sum(String(n).map(c -> Int(c) ^ 5))

print(sum((2..999999).filter(i -> i == fifth_power_digit_sum(i))))
===
template <typename T1> auto fifth_power_digit_sum(const T1 &n)
{
    return sum_map(String(n), [](const auto &c){return pow(to_int(c), 5);});
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(sum(range_ee(2, 999999).filter([](const auto &i){return i == fifth_power_digit_sum(i);})));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Distinct_power_numbers#Python
from itertools import product

print(sorted(list(set(a**b for a,b in product(range(2,6), range(2,6))))))
===
print(sorted(Array(Set(cart_product(2..5, 2..5).map((a, b) -> a ^ b)))))
===
struct CodeBlock1
{
    CodeBlock1()
    {
        print(sorted(create_array(create_set(cart_product(range_ee(2, 5), range_ee(2, 5)).map([](const auto &a, const auto &b){return pow(a, b);})))));
    }
} code_block_1;


# https://rosettacode.org/wiki/De_Polignac_numbers#C++
import math, itertools

def is_prime(p):
    if p < 2 or p % 2 == 0:
        return p == 2
    for i in range(3, int(math.sqrt(p)) + 1, 2):
        if p % i == 0:
            return False
    return True

def is_depolignac_number(n):
    p = 1
    while p < n:
        if is_prime(n - p):
            return False
        p <<= 1
    return True

print('First 50 de Polignac numbers:')
count = 0
for n in itertools.count(1, 2):
    if is_depolignac_number(n):
        count += 1
        if count <= 50:
            print(f'{n:5,}', end = "\n" if count % 10 == 0 else ' ')
        elif count == 1000:
            print(f"\nOne thousandth: {n:,}")
        elif count == 10000:
            print(f"\nTen thousandth: {n:,}")
            break
===
F is_prime(p)
   I p < 2 | p % 2 == 0
      R p == 2
   L(i) (3 .. Int(sqrt(p))).step(2)
      I p % i == 0
         R 0B
   R 1B

F is_depolignac_number(n)
   V p = 1
   L p < n
      I is_prime(n - p)
         R 0B
      p <<= 1
   R 1B

print(‘First 50 de Polignac numbers:’)
V count = 0
L(n) (1..).step(2)
   I is_depolignac_number(n)
      count++
      I count <= 50
         print(f:‘{commatize(n):5}’, end' I count % 10 == 0 {"\n"} E ‘ ’)
      E I count == 1000
         print(f:"\nOne thousandth: {commatize(n)}")
      E I count == 10000
         print(f:"\nTen thousandth: {commatize(n)}")
         L.break
===
template <typename T1> auto is_prime(const T1 &p)
{
    if (p < 2 || mod(p, 2) == 0)
        return p == 2;
    for (auto i : range_ee(3, to_int(sqrt(p))).step(2))
        if (mod(p, i) == 0)
            return false;
    return true;
}

template <typename T1> auto is_depolignac_number(const T1 &n)
{
    auto p = 1;
    while (p < n) {
        if (is_prime(n - p))
            return false;
        p <<= 1;
    }
    return true;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"First 50 de Polignac numbers:"_S);
    }
} code_block_1;

auto count = 0;

struct CodeBlock2
{
    CodeBlock2()
    {
        for (auto n : range_ei(1).step(2))
            if (is_depolignac_number(n)) {
                count++;
                if (count <= 50)
                    print(u"#5"_S.format(commatize(n)), mod(count, 10) == 0 ? u'\n'_C : u' '_C);
                else if (count == 1000)
                    print(u"\nOne thousandth: #."_S.format(commatize(n)));
                else if (count == 10000) {
                    print(u"\nTen thousandth: #."_S.format(commatize(n)));
                    break;
                }
            }
    }
} code_block_2;


# https://rosettacode.org/wiki/Descending_primes#C#
import math

def is_prime(p):
    if p < 2 or p % 2 == 0:
        return p == 2
    for i in range(3, int(math.sqrt(p)) + 1, 2):
        if p % i == 0:
            return False
    return True

c = 0
ps = [1, 2, 3, 4, 5, 6, 7, 8, 9]
nxt = [0] * 128

while True:
    nc = 0
    for a in ps:
        if is_prime(a):
            c += 1
            print('%8d' % a, end = "\n" if c % 5 == 0 else ' ')
        b = a * 10
        l = a % 10 + b
        b += 1
        while b < l:
            nxt[nc] = b
            nc += 1
            b += 1

    if nc > 1:
        ps = nxt[:nc]
    else:
        break

print(f"\n{c} descending primes found")
===
F is_prime(p)
   I p < 2 | p % 2 == 0
      R p == 2
   L(i) (3 .. Int(sqrt(p))).step(2)
      I p % i == 0
         R 0B
   R 1B

V c = 0
V ps = [1, 2, 3, 4, 5, 6, 7, 8, 9]
V nxt = [0] * 128

L
   V nc = 0
   L(a) ps
      I is_prime(a)
         c++
         print(‘#8’.format(a), end' I c % 5 == 0 {"\n"} E ‘ ’)
      V b = a * 10
      V l = a % 10 + b
      b++
      L b < l
         nxt[nc] = b
         nc++
         b++

   I nc > 1
      ps = nxt[0 .< nc]
   E
      L.break

print("\n"c‘ descending primes found’)
===
template <typename T1> auto is_prime(const T1 &p)
{
    if (p < 2 || mod(p, 2) == 0)
        return p == 2;
    for (auto i : range_ee(3, to_int(sqrt(p))).step(2))
        if (mod(p, i) == 0)
            return false;
    return true;
}

auto c = 0;
auto ps = create_array({1, 2, 3, 4, 5, 6, 7, 8, 9});
auto nxt = create_array({0}) * 128;

struct CodeBlock1
{
    CodeBlock1()
    {
        while (true) {
            auto nc = 0;
            for (auto &&a : ps) {
                if (is_prime(a)) {
                    c++;
                    print(u"#8"_S.format(a), mod(c, 5) == 0 ? u'\n'_C : u' '_C);
                }
                auto b = a * 10;
                auto l = mod(a, 10) + b;
                b++;
                while (b < l) {
                    nxt.set(nc, b);
                    nc++;
                    b++;
                }
            }

            if (nc > 1)
                ps = nxt[range_el(0, nc)];
            else
                break;
        }

        print(u"\n"_S & c & u" descending primes found"_S);
    }
} code_block_1;


# https://rosettacode.org/wiki/Descending_primes
import math
from typing import List

def is_prime(p):
    if p < 2 or p % 2 == 0:
        return p == 2
    for i in range(3, int(math.sqrt(p)) + 1, 2):
        if p % i == 0:
            return False
    return True

descending_primes : List[int] = []

for n in range(1, 2**9):
    s = ''
    for i in range(8, -1, -1):
        if n & (1 << i) != 0:
            s += str(i + 1)
    if is_prime(int(s)):
        descending_primes.append(int(s))

for c, n in enumerate(sorted(descending_primes)):
    print('%8d' % n, end = "\n" if (c + 1) % 5 == 0 else ' ')

print(f"\n{len(descending_primes)} descending primes found")
===
F is_prime(p)
   I p < 2 | p % 2 == 0
      R p == 2
   L(i) (3 .. Int(sqrt(p))).step(2)
      I p % i == 0
         R 0B
   R 1B

[Int] descending_primes

L(n) 1 .< 2 ^ 9
   V s = ‘’
   L(i) (8 .< -1).step(-1)
      I n [&] (1 << i) != 0
         s ‘’= String(i + 1)
   I is_prime(Int(s))
      descending_primes.append(Int(s))

L(n) sorted(descending_primes)
   V c = L.index
   print(‘#8’.format(n), end' I (c + 1) % 5 == 0 {"\n"} E ‘ ’)

print("\n"descending_primes.len‘ descending primes found’)
===
template <typename T1> auto is_prime(const T1 &p)
{
    if (p < 2 || mod(p, 2) == 0)
        return p == 2;
    for (auto i : range_ee(3, to_int(sqrt(p))).step(2))
        if (mod(p, i) == 0)
            return false;
    return true;
}

Array<int> descending_primes;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto n : range_el(1, pow(2, 9))) {
            auto s = u""_S;
            for (auto i : range_el(8, -1).step(-1))
                if ((n & (1 << i)) != 0)
                    s &= String(i + 1);
            if (is_prime(to_int(s)))
                descending_primes.append(to_int(s));
        }
        {int Lindex = 0;

        for (auto &&n : sorted(descending_primes)) {
            auto c = Lindex;
            print(u"#8"_S.format(n), mod((c + 1), 5) == 0 ? u'\n'_C : u' '_C);
            Lindex++;
        }}

        print(u"\n"_S & descending_primes.len() & u" descending primes found"_S);
    }
} code_block_1;


# https://rosettacode.org/wiki/Disarium_numbers#Python
def is_disarium(n):
    digitos = len(str(n))
    suma = 0
    x = n
    while x != 0:
        suma += (x % 10) ** digitos
        digitos -= 1
        x //= 10
    if suma == n:
        return True
    else:
        return False

limite = 19
cont = 0
n = 0
print("The first",limite,"Disarium numbers are:")
while cont < limite:
    if is_disarium(n):
        print(n, end = " ")
        cont += 1
    n += 1
===
F is_disarium(n)
   V digitos = String(n).len
   V suma = 0
   V x = n
   L x != 0
      suma += (x % 10) ^ digitos
      digitos--
      x I/= 10
   I suma == n
      R 1B
   E
      R 0B

V limite = 19
V cont = 0
V n = 0
print(‘The first ’limite‘ Disarium numbers are:’)
L cont < limite
   I is_disarium(n)
      print(n, end' ‘ ’)
      cont++
   n++
===
template <typename T1> auto is_disarium(const T1 &n)
{
    auto digitos = String(n).len();
    auto suma = 0;
    auto x = n;
    while (x != 0) {
        suma += pow((mod(x, 10)), digitos);
        digitos--;
        x = idiv(x, 10);
    }
    if (suma == n)
        return true;
    else
        return false;
}

auto limite = 19;
auto cont = 0;
auto n = 0;

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"The first "_S & limite & u" Disarium numbers are:"_S);
        while (cont < limite) {
            if (is_disarium(n)) {
                print(n, u" "_S);
                cont++;
            }
            n++;
        }
    }
} code_block_1;