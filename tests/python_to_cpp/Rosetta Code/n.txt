# https://www.rosettacode.org/wiki/N%27th#Python
_suffix = ['th', 'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th']

def nth(n):
    return "%i'%s" % (n, _suffix[n%10] if n % 100 <= 10 or n % 100 > 20 else 'th')

for j in range(0, 1001, 250):
    print(*(nth(i) for i in list(range(j, j+25))))
===
V _suffix = [‘th’, ‘st’, ‘nd’, ‘rd’, ‘th’, ‘th’, ‘th’, ‘th’, ‘th’, ‘th’]

F nth(n)
   R ‘#.'#.’.format(n, I n % 100 <= 10 | n % 100 > 20 {:_suffix[n % 10]} E ‘th’)

L(j) (0.<1001).step(250)
   print_elements((Array(j .< j + 25).map(i -> nth(i))))
===
auto _suffix = create_array({u"th"_S, u"st"_S, u"nd"_S, u"rd"_S, u"th"_S, u"th"_S, u"th"_S, u"th"_S, u"th"_S, u"th"_S});

template <typename T1> auto nth(const T1 &n)
{
    return u"#.'#."_S.format(n, mod(n, 100) <= 10 || mod(n, 100) > 20 ? ::_suffix[mod(n, 10)] : u"th"_S);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto j : range_el(0, 1001).step(250))
            print_elements((create_array(range_el(j, j + 25)).map([](const auto &i){return nth(i);})));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Narcissistic_decimal_number#Python
import itertools

def narcissists(m):
    result : List[int] = []
    for digits in itertools.count(0):
        digitpowers = [i**digits for i in range(10)]
        for n in range(int(10**(digits-1)), 10**digits):
            (div, digitpsum) = (n, 0)
            while div != 0:
                (div, mod) = divmod(div, 10)
                digitpsum += digitpowers[mod]
            if n == digitpsum:
                result += [n]
                if len(result) == m:
                    return result

for i, n in enumerate(narcissists(25), 1):
    print(n, end = ' ')
    if i % 5 == 0: print()
===
F narcissists(m)
   [Int] result
   L(digits) 0..
      V digitpowers = (0.<10).map(i -> i ^ @digits)
      L(n) Int(10 ^ (digits - 1)) .< 10 ^ digits
         V (div, digitpsum) = (n, 0)
         L div != 0
            (div, V mod) = divmod(div, 10)
            digitpsum += digitpowers[mod]
         I n == digitpsum
            result [+]= n
            I result.len == m
               R result

L(n) narcissists(25)
   V i = L.index + 1
   print(n, end' ‘ ’)
   I i % 5 == 0
      print()
===
template <typename T1> auto narcissists(const T1 &m)
{
    Array<int> result;
    for (auto digits : range_ei(0)) {
        auto digitpowers = range_el(0, 10).map([&digits](const auto &i){return pow(i, digits);});
        for (auto n : range_el(to_int(pow(10, (digits - 1))), pow(10, digits))) {
            auto [div, digitpsum] = make_tuple(n, 0);
            while (div != 0) {
                TUPLE_ELEMENT_T(1, divmod(div, 10)) mod;
                assign_from_tuple(div, mod, divmod(div, 10));
                digitpsum += digitpowers[mod];
            }
            if (n == digitpsum) {
                result.append(n);
                if (result.len() == m)
                    return result;
            }
        }
    }
}

struct CodeBlock1
{
    CodeBlock1()
    {
        {int Lindex = 0;

        for (auto &&n : narcissists(25)) {
            auto i = Lindex + 1;
            print(n, u" "_S);
            if (mod(i, 5) == 0)
                print();
            Lindex++;
        }}
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Negative_base_numbers#Python
def encode_neg_base(n, b): #Converts from decimal
    if n == 0:
        return "0"
    out : List[int] = []
    while n != 0:
        (n, rem) = divmod(n, b)
        if rem < 0:
            n += 1
            rem -= b
        out.append(rem)
    return "".join(map(str, out[::-1]))

def decode_neg_base(nstr, b): #Converts to decimal
    if nstr == "0":
        return 0

    total = 0
    for i, ch in enumerate(nstr[::-1]):
        total += int(ch) * b**i
    return total

print ("Encode 10 as negabinary (expect 11110)")
result = encode_neg_base(10, -2)
print (result)
if decode_neg_base(result, -2) == 10: print ("Converted back to decimal")
else: print ("Error converting back to decimal")

print ("Encode 146 as negaternary (expect 21102)")
result = encode_neg_base(146, -3)
print (result)
if decode_neg_base(result, -3) == 146: print ("Converted back to decimal")
else: print ("Error converting back to decimal")

print ("Encode 15 as negadecimal (expect 195)")
result = encode_neg_base(15, -10)
print (result)
if decode_neg_base(result, -10) == 15: print ("Converted back to decimal")
else: print ("Error converting back to decimal")
===
F encode_neg_base(=n, b)
   I n == 0
      R ‘0’
   [Int] out
   L n != 0
      (n, V rem) = divmod(n, b)
      I rem < 0
         n++
         rem -= b
      out.append(rem)
   R reversed(out).map(String).join(‘’)

F decode_neg_base(nstr, b)
   I nstr == ‘0’
      R 0

   V total = 0
   L(ch) reversed(nstr)
      V i = L.index
      total += Int(ch) * b ^ i
   R total

print(‘Encode 10 as negabinary (expect 11110)’)
V result = encode_neg_base(10, -2)
print(result)
I decode_neg_base(result, -2) == 10
   print(‘Converted back to decimal’)
E
   print(‘Error converting back to decimal’)

print(‘Encode 146 as negaternary (expect 21102)’)
result = encode_neg_base(146, -3)
print(result)
I decode_neg_base(result, -3) == 146
   print(‘Converted back to decimal’)
E
   print(‘Error converting back to decimal’)

print(‘Encode 15 as negadecimal (expect 195)’)
result = encode_neg_base(15, -10)
print(result)
I decode_neg_base(result, -10) == 15
   print(‘Converted back to decimal’)
E
   print(‘Error converting back to decimal’)
===
template <typename T1, typename T2> auto encode_neg_base(T1 n, const T2 &b)
{
    if (n == 0)
        return u"0"_S;
    Array<int> out;
    while (n != 0) {
        TUPLE_ELEMENT_T(1, divmod(n, b)) rem;
        assign_from_tuple(n, rem, divmod(n, b));
        if (rem < 0) {
            n++;
            rem -= b;
        }
        out.append(rem);
    }
    return reversed(out).map([](const auto &x){return String(x);}).join(u""_S);
}

template <typename T1, typename T2> auto decode_neg_base(const T1 &nstr, const T2 &b)
{
    if (nstr == u'0')
        return 0;

    auto total = 0;
    {int Lindex = 0;
    for (auto &&ch : reversed(nstr)) {
        auto i = Lindex;
        total += to_int(ch) * pow(b, i);
        Lindex++;
    }}
    return total;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"Encode 10 as negabinary (expect 11110)"_S);
    }
} code_block_1;

auto result = encode_neg_base(10, -2);

struct CodeBlock2
{
    CodeBlock2()
    {
        print(result);
        if (decode_neg_base(result, -2) == 10)
            print(u"Converted back to decimal"_S);
        else
            print(u"Error converting back to decimal"_S);

        print(u"Encode 146 as negaternary (expect 21102)"_S);
        result = encode_neg_base(146, -3);
        print(result);
        if (decode_neg_base(result, -3) == 146)
            print(u"Converted back to decimal"_S);
        else
            print(u"Error converting back to decimal"_S);

        print(u"Encode 15 as negadecimal (expect 195)"_S);
        result = encode_neg_base(15, -10);
        print(result);
        if (decode_neg_base(result, -10) == 15)
            print(u"Converted back to decimal"_S);
        else
            print(u"Error converting back to decimal"_S);
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Nested_function#Python
def makeList(separator):
    counter = 1

    def makeItem(item):
        nonlocal counter
        result = str(counter) + separator + '' + item + "\n"
        counter += 1
        return result

    return makeItem("first") + '' + makeItem("second") + '' + makeItem("third")

print(makeList(". "))
===
F makeList(separator)
   V counter = 1

   F makeItem(item)
      V result = String(@counter)‘’@separator‘’item"\n"
      @counter++
      R result

   R makeItem(‘first’)‘’makeItem(‘second’)‘’makeItem(‘third’)

print(makeList(‘. ’))
===
template <typename T1> auto makeList(const T1 &separator)
{
    auto counter = 1;

    auto makeItem = [&counter, &separator](const auto &item)
    {
        auto result = String(counter) & separator & item & u"\n"_S;
        counter++;
        return result;
    };

    return makeItem(u"first"_S) & makeItem(u"second"_S) & makeItem(u"third"_S);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(makeList(u". "_S));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Nim_game#Python
tokens = 12

def getTokens(curTokens) -> None:
    global tokens

    print("How many tokens would you like to take? ", end='')
    take = int(input())

    if take < 1 or take > 3:
        print("Number must be between 1 and 3.\n")
        getTokens(curTokens)
        return

    tokens = curTokens - take
    print('You take %i tokens.' % take)
    print('%i tokens remaining.\n' % tokens)

def compTurn(curTokens):
    global tokens

    take = curTokens % 4
    tokens = curTokens - take
    print('Computer takes %i tokens.' % take)
    print('%i tokens remaining.\n' % tokens)

while tokens > 0:
    getTokens(tokens)
    compTurn(tokens)

print("Computer wins!")
===
V tokens = 12

F getTokens(curTokens) -> Void

   print(‘How many tokens would you like to take? ’, end' ‘’)
   V take = Int(input())

   I take < 1 | take > 3
      print("Number must be between 1 and 3.\n")
      getTokens(curTokens)
      R

   :tokens = curTokens - take
   print(‘You take #. tokens.’.format(take))
   print("#. tokens remaining.\n".format(:tokens))

F compTurn(curTokens)

   V take = curTokens % 4
   :tokens = curTokens - take
   print(‘Computer takes #. tokens.’.format(take))
   print("#. tokens remaining.\n".format(:tokens))

L tokens > 0
   getTokens(tokens)
   compTurn(tokens)

print(‘Computer wins!’)
===
auto tokens = 12;

template <typename T1> void getTokens(const T1 &curTokens)
{

    print(u"How many tokens would you like to take? "_S, u""_S);
    auto take = to_int(input());

    if (take < 1 || take > 3) {
        print(u"Number must be between 1 and 3.\n"_S);
        getTokens(curTokens);
        return;
    }

    ::tokens = curTokens - take;
    print(u"You take #. tokens."_S.format(take));
    print(u"#. tokens remaining.\n"_S.format(::tokens));
}

template <typename T1> auto compTurn(const T1 &curTokens)
{

    auto take = mod(curTokens, 4);
    ::tokens = curTokens - take;
    print(u"Computer takes #. tokens."_S.format(take));
    print(u"#. tokens remaining.\n"_S.format(::tokens));
}

struct CodeBlock1
{
    CodeBlock1()
    {
        while (tokens > 0) {
            getTokens(tokens);
            compTurn(tokens);
        }

        print(u"Computer wins!"_S);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Non-continuous_subsequences#Python
def ncsub(seq, s=0):
    if len(seq) == 0:
        r : List[List[int]] = []
        if s >= 3:
            l : List[int] = []
            r.append(l)
        return r
    else:
        x = seq[:1]
        xs = seq[1:]
        p2 = s % 2
        p1 = not p2
        return [x + ys for ys in ncsub(xs, s + p1)] + ncsub(xs, s + p2)

print(ncsub(list(range(1, 4))))
print(ncsub(list(range(1, 5))))
print(ncsub(list(range(1, 6))))
===
F ncsub(seq, s = 0)
   I seq.empty
      [[Int]] r
      I s >= 3
         [Int] l
         r.append(l)
      R r
   E
      V x = seq[0.<1]
      V xs = seq[1..]
      V p2 = s % 2
      V p1 = !p2
      R ncsub(xs, s + p1).map(ys -> @x + ys) [+] ncsub(xs, s + p2)

print(ncsub(Array(1..3)))
print(ncsub(Array(1..4)))
print(ncsub(Array(1..5)))
===
template <typename T1, typename T2 = decltype(0)> auto ncsub(const T1 &seq, const T2 &s = 0)
{
    if (seq.empty()) {
        Array<Array<int>> r;
        if (s >= 3) {
            Array<int> l;
            r.append(l);
        }
        return r;
    }
    else {
        auto x = seq[range_el(0, 1)];
        auto xs = seq[range_ei(1)];
        auto p2 = mod(s, 2);
        auto p1 = !p2;
        return ncsub(xs, s + p1).map([&x](const auto &ys){return x + ys;}) + ncsub(xs, s + p2);
    }
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(ncsub(create_array(range_ee(1, 3))));
        print(ncsub(create_array(range_ee(1, 4))));
        print(ncsub(create_array(range_ee(1, 5))));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Non-decimal_radices/Input#Python
s = '100'
for base in range(2,21):
    print("String '%s' in base %i is %i in base 10"
        % (s, base, int(s, base)))
===
V s = ‘100’
L(base) 2..20
   print(‘String '#.' in base #. is #. in base 10’.format(s, base, Int(s, radix' base)))
===
auto s = u"100"_S;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto base : range_ee(2, 20))
            print(u"String '#.' in base #. is #. in base 10"_S.format(s, base, to_int(s, base)));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Nth_root#Nim
def nthroot(a, n):
    result = a
    x = a / n
    while abs(result-x) > 10e-15:
        x = result
        result = (1.0/n) * (((n-1)*x) + (a / pow(x, n-1)))
    return result

print(nthroot(34.0, 5))
print(nthroot(42.0, 10))
print(nthroot(5.0, 2))
===
F nthroot(a, n)
   V result = a
   V x = a / n
   L abs(result - x) > 10e-15
      x = result
      result = (1.0 / n) * (((n - 1) * x) + (a / pow(x, n - 1)))
   R result

print(nthroot(34.0, 5))
print(nthroot(42.0, 10))
print(nthroot(5.0, 2))
===
template <typename T1, typename T2> auto nthroot(const T1 &a, const T2 &n)
{
    auto result = a;
    auto x = a / n;
    while (abs(result - x) > 10e-15) {
        x = result;
        result = (1.0 / n) * (((n - 1) * x) + (a / pow(x, n - 1)));
    }
    return result;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(nthroot(34.0, 5));
        print(nthroot(42.0, 10));
        print(nthroot(5.0, 2));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Number_reversal_game#Python
data = list('139275486')
trials = 0

while data != sorted(data):
    trials += 1
    flip = int(input("#%2i: LIST: '%s' Flip how many?: " % (trials, ' '.join(data))))
    data[:flip] = reversed(data[:flip])

print('\nYou took %i attempts to put the digits in order!' % trials)
===
V data = Array(‘139275486’)
V trials = 0

L data != sorted(data)
   trials++
   V flip = Int(input(‘###2: LIST: '#.' Flip how many?: ’.format(trials, data.join(‘ ’))))
   data.reverse_range(0 .< flip)

print("\nYou took #. attempts to put the digits in order!".format(trials))
===
auto data = create_array(u"139275486"_S);
auto trials = 0;

struct CodeBlock1
{
    CodeBlock1()
    {
        while (data != sorted(data)) {
            trials++;
            auto flip = to_int(input(u"###2: LIST: '#.' Flip how many?: "_S.format(trials, data.join(u" "_S))));
            data.reverse_range(range_el(0, flip));
        }

        print(u"\nYou took #. attempts to put the digits in order!"_S.format(trials));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Numbers_with_equal_rises_and_falls#Python
def riseEqFall(num):
    """Check whether a number belongs to sequence A296712."""
    height = 0
    d1 = num % 10
    num //= 10
    while num != 0:
        d2 = num % 10
        height += (d1<d2) - (d1>d2)
        d1 = d2
        num //= 10
    return height == 0

num = 0
def nextNum():
    global num
    while True:
        num += 1
        if riseEqFall(num):
            break
    return num

print('The first 200 numbers are:')
for i in range(200):
    print(nextNum(), end = ' ')
print()

for i in range(10_000_000 - 200 - 1):
    nextNum()
print('The 10,000,000th number is:', nextNum())
===
F riseEqFall(=num)
   ‘Check whether a number belongs to sequence A296712.’
   V height = 0
   V d1 = num % 10
   num I/= 10
   L num != 0
      V d2 = num % 10
      height += (d1 < d2) - (d1 > d2)
      d1 = d2
      num I/= 10
   R height == 0

V num = 0
F nextNum()
   L
      :num++
      I riseEqFall(:num)
         L.break
   R :num

print(‘The first 200 numbers are:’)
L(i) 200
   print(nextNum(), end' ‘ ’)
print()

L(i) 0 .< 10'000'000 - 200 - 1
   nextNum()
print(‘The 10,000,000th number is: ’nextNum())
===
template <typename T1> auto riseEqFall(T1 num)
{
    u"Check whether a number belongs to sequence A296712."_S;
    auto height = 0;
    auto d1 = mod(num, 10);
    num = idiv(num, 10);
    while (num != 0) {
        auto d2 = mod(num, 10);
        height += (d1 < d2) - (d1 > d2);
        d1 = d2;
        num = idiv(num, 10);
    }
    return height == 0;
}

auto num = 0;
auto nextNum()
{
    while (true) {
        ::num++;
        if (riseEqFall(::num))
            break;
    }
    return ::num;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"The first 200 numbers are:"_S);
        for (int i = 0; i < 200; i++)
            print(nextNum(), u" "_S);
        print();

        for (auto i : range_el(0, 10'000'000 - 200 - 1))
            nextNum();
        print(u"The 10,000,000th number is: "_S & nextNum());
    }
} code_block_1;


# https://www.rosettacode.org/wiki/NYSIIS#Python
import re

_vowels = 'AEIOU'

def replace_at(text : str, position, fromlist, tolist):
    for f, t in zip(fromlist, tolist):
        if text[position:position+len(f)] == f:
            return text[:position] + t + text[position+len(f):]
    return text

def replace_end(text : str, fromlist, tolist):
    for f, t in zip(fromlist, tolist):
        if text.endswith(f):
            return text[:-len(f)] + t
    return text

def nysiis(name : str):
    name = re.sub(r'\W', '', name).upper()
    name = replace_at(name, 0, ['MAC', 'KN', 'K', 'PH', 'PF', 'SCH'],
                               ['MCC', 'N',  'C', 'FF', 'FF', 'SSS'])
    name = replace_end(name, ['EE', 'IE', 'DT', 'RT', 'RD', 'NT', 'ND'],
                             ['Y',  'Y',  'D',  'D',  'D',  'D',  'D'])
    key = str(name[0])
    key1 = ''
    i = 1
    while i < len(name):
        #print(i, name, key1, key)
        (n_1, n) = (name[i-1], name[i])
        n1_ = name[i+1] if i+1 < len(name) else ''
        name = replace_at(name, i, ['EV'] + list(map(str, list(_vowels))), ['AF'] + [str('A')]*5)
        name = replace_at(name, i, [str('Q'), 'Z', 'M'], [str('G'), 'S', 'N'])
        name = replace_at(name, i, ['KN', 'K'], [str('N'), 'C'])
        name = replace_at(name, i, ['SCH', 'PH'], ['SSS', 'FF'])
        if n == 'H' and (n_1 not in _vowels or n1_ not in _vowels):
            name = name[:i] + n_1 + name[i+1:]
        if n == 'W' and n_1 in _vowels:
            name = name[:i] + 'A' + name[i+1:]
        if key != '' and key[-1] != name[i]:
            key += name[i]
        i += 1
    key = replace_end(key, ['S', 'AY', 'A'], ['', 'Y', ''])
    return key1 + key

names = ['Bishop', 'Carlson', 'Carr', 'Chapman', 'Franklin',
         'Greene', 'Harper', 'Jacobs', 'Larson', 'Lawrence',
         'Lawson', 'Louis, XVI', 'Lynch', 'Mackenzie', 'Matthews',
         'McCormack', 'McDaniel', 'McDonald', 'Mclaughlin', 'Morrison',
         "O'Banion", "O'Brien", 'Richards', 'Silva', 'Watkins',
         'Wheeler', 'Willis', 'brown, sr', 'browne, III', 'browne, IV',
         'knight', 'mitchell', "o'daniel"]
for name in names:
    print('%15s: %s' % (name, nysiis(name)))
===
V _vowels = ‘AEIOU’

F replace_at(String text; position, fromlist, tolist)
   L(f, t) zip(fromlist, tolist)
      I text[position .< position + f.len] == f
         R text[0 .< position]‘’t‘’text[position + f.len ..]
   R text

F replace_end(String text; fromlist, tolist)
   L(f, t) zip(fromlist, tolist)
      I text.ends_with(f)
         R text[0 .< (len)-f.len]‘’t
   R text

F nysiis(String =name)
   name = name.replace(re:‘\W’, ‘’).uppercase()
   name = replace_at(name, 0, [‘MAC’, ‘KN’, ‘K’, ‘PH’, ‘PF’, ‘SCH’], [‘MCC’, ‘N’, ‘C’, ‘FF’, ‘FF’, ‘SSS’])
   name = replace_end(name, [‘EE’, ‘IE’, ‘DT’, ‘RT’, ‘RD’, ‘NT’, ‘ND’], [‘Y’, ‘Y’, ‘D’, ‘D’, ‘D’, ‘D’, ‘D’])
   V key = String(name[0])
   V key1 = ‘’
   V i = 1
   L i < name.len
      V (n_1, n) = (name[i - 1], name[i])
      V n1_ = I i + 1 < name.len {name[i + 1]} E ‘’
      name = replace_at(name, i, [‘EV’] [+] Array(:_vowels).map(String), [‘AF’] [+] [String(‘A’)] * 5)
      name = replace_at(name, i, [String(‘Q’), ‘Z’, ‘M’], [String(‘G’), ‘S’, ‘N’])
      name = replace_at(name, i, [‘KN’, ‘K’], [String(‘N’), ‘C’])
      name = replace_at(name, i, [‘SCH’, ‘PH’], [‘SSS’, ‘FF’])
      I n == ‘H’ & (n_1 !C :_vowels | n1_ !C :_vowels)
         name = name[0 .< i]‘’n_1‘’name[i + 1 ..]
      I n == ‘W’ & n_1 C :_vowels
         name = name[0 .< i]‘A’name[i + 1 ..]
      I key != ‘’ & key.last != name[i]
         key ‘’= name[i]
      i++
   key = replace_end(key, [‘S’, ‘AY’, ‘A’], [‘’, ‘Y’, ‘’])
   R key1‘’key

V names = [‘Bishop’, ‘Carlson’, ‘Carr’, ‘Chapman’, ‘Franklin’, ‘Greene’, ‘Harper’, ‘Jacobs’, ‘Larson’, ‘Lawrence’, ‘Lawson’, ‘Louis, XVI’, ‘Lynch’, ‘Mackenzie’, ‘Matthews’, ‘McCormack’, ‘McDaniel’, ‘McDonald’, ‘Mclaughlin’, ‘Morrison’, ‘O'Banion’, ‘O'Brien’, ‘Richards’, ‘Silva’, ‘Watkins’, ‘Wheeler’, ‘Willis’, ‘brown, sr’, ‘browne, III’, ‘browne, IV’, ‘knight’, ‘mitchell’, ‘o'daniel’]
L(name) names
   print(‘#15: #.’.format(name, nysiis(name)))
===
auto _vowels = u"AEIOU"_S;

template <typename T2, typename T3, typename T4> auto replace_at(const String &text, const T2 &position, const T3 &fromlist, const T4 &tolist)
{
    for (auto &&[f, t] : zip(fromlist, tolist))
        if (text[range_el(position, position + f.len())] == f)
            return text[range_el(0, position)] & t & text[range_ei(position + f.len())];
    return text;
}

template <typename T2, typename T3> auto replace_end(const String &text, const T2 &fromlist, const T3 &tolist)
{
    for (auto &&[f, t] : zip(fromlist, tolist))
        if (text.ends_with(f))
            return text[range_e_llen(0,  - f.len())] & t;
    return text;
}

auto nysiis(String name)
{
    name = name.replace(re::_(uR"(\W)"_S), u""_S).uppercase();
    name = replace_at(name, 0, create_array({u"MAC"_S, u"KN"_S, u"K"_S, u"PH"_S, u"PF"_S, u"SCH"_S}), create_array({u"MCC"_S, u"N"_S, u"C"_S, u"FF"_S, u"FF"_S, u"SSS"_S}));
    name = replace_end(name, create_array({u"EE"_S, u"IE"_S, u"DT"_S, u"RT"_S, u"RD"_S, u"NT"_S, u"ND"_S}), create_array({u'Y'_C, u'Y'_C, u'D'_C, u'D'_C, u'D'_C, u'D'_C, u'D'_C}));
    auto key = String(_get<0>(name));
    auto key1 = u""_S;
    auto i = 1;
    while (i < name.len()) {
        auto [n_1, n] = make_tuple(name[i - 1], name[i]);
        auto n1_ = i + 1 < name.len() ? name[i + 1] : u""_S;
        name = replace_at(name, i, create_array({u"EV"_S}) + create_array(::_vowels).map([](const auto &x){return String(x);}), create_array({u"AF"_S}) + create_array({u"A"_S}) * 5);
        name = replace_at(name, i, create_array<String>({u"Q"_S, u"Z"_S, u"M"_S}), create_array<String>({u"G"_S, u"S"_S, u"N"_S}));
        name = replace_at(name, i, create_array({u"KN"_S, u"K"_S}), create_array<String>({u"N"_S, u"C"_S}));
        name = replace_at(name, i, create_array({u"SCH"_S, u"PH"_S}), create_array({u"SSS"_S, u"FF"_S}));
        if (n == u'H' && (!in(n_1, ::_vowels) || !in(n1_, ::_vowels)))
            name = name[range_el(0, i)] & n_1 & name[range_ei(i + 1)];
        if (n == u'W' && in(n_1, ::_vowels))
            name = name[range_el(0, i)] & u"A"_S & name[range_ei(i + 1)];
        if (key != u"" && key.last() != name[i])
            key &= name[i];
        i++;
    }
    key = replace_end(key, create_array({u"S"_S, u"AY"_S, u"A"_S}), create_array({u""_S, u"Y"_S, u""_S}));
    return key1 & key;
}

auto names = create_array({u"Bishop"_S, u"Carlson"_S, u"Carr"_S, u"Chapman"_S, u"Franklin"_S, u"Greene"_S, u"Harper"_S, u"Jacobs"_S, u"Larson"_S, u"Lawrence"_S, u"Lawson"_S, u"Louis, XVI"_S, u"Lynch"_S, u"Mackenzie"_S, u"Matthews"_S, u"McCormack"_S, u"McDaniel"_S, u"McDonald"_S, u"Mclaughlin"_S, u"Morrison"_S, u"O'Banion"_S, u"O'Brien"_S, u"Richards"_S, u"Silva"_S, u"Watkins"_S, u"Wheeler"_S, u"Willis"_S, u"brown, sr"_S, u"browne, III"_S, u"browne, IV"_S, u"knight"_S, u"mitchell"_S, u"o'daniel"_S});

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&name : names)
            print(u"#15: #."_S.format(name, nysiis(name)));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Nonoblock#Python
from typing import List, Tuple
Char = str

def nonoblocks(blocks : List[int], cells : int) -> List[List[Tuple[int, int]]]:
    r : List[List[Tuple[int, int]]] = []
    if len(blocks) == 0 or blocks[0] == 0:
        r += [[(0, 0)]]
    else:
        assert sum(blocks) + len(blocks)-1 <= cells, \
            'Those blocks will not fit in those cells'
        (blength, brest) = (blocks[0], blocks[1:])      # Deal with the first block of length
        minspace4rest = sum(1+b for b in brest)     # The other blocks need space
        # Slide the start position from left to max RH index allowing for other blocks.
        for bpos in range(0, cells - minspace4rest - blength + 1):
            if len(brest) == 0:
                # No other blocks to the right so just yield this one.
                r += [[(bpos, blength)]]
            else:
                # More blocks to the right so create a *sub-problem* of placing
                # the brest blocks in the cells one space to the right of the RHS of
                # this block.
                offset = bpos + blength +1
                # recursive call to nonoblocks yields multiple sub-positions
                for subpos in nonoblocks(brest, cells - offset):
                    # Remove the offset from sub block positions
                    rest = [(offset + bp, bl) for bp, bl in subpos]
                    # Yield this block plus sub blocks positions
                    vec = [(bpos, blength)] + rest
                    r += [vec]
    return r

def pblock(vec, cells):
    'Prettyprints each run of blocks with a different letter A.. for each block of filled cells'
    vector = ['_'] * cells
    for ch, bp_bl in enumerate(vec, ord('A')):
        (bp, bl) = bp_bl
        for i in range(bp, bp + bl):
            vector[i] = chr(ch) if vector[i] == '_' else Char('?')
    return '|' + '|'.join(vector) + '|'

for blocks, cells in [
        ([2, 1], 5),
        ([0]*0, 5),
        ([8], 10),
        ([2, 3, 2, 3], 15),
       # ([4, 3], 10),
       # ([2, 1], 5),
       # ([3, 1], 10),
        #([2, 3], 5),
        ]:
    print('\nConfiguration:\n    %s # %i cells and %s blocks' % (pblock([(0, 0)]*0, cells), cells, blocks))
    print('  Possibilities:')
    nb = nonoblocks(blocks, cells)
    for vector in nb:
        print('   ', pblock(vector, cells))
    print('  A total of %i Possible configurations.' % len(nb))
===
F nonoblocks([Int] &blocks, Int cells) -> [[(Int, Int)]]
   [[(Int, Int)]] r
   I blocks.empty | blocks[0] == 0
      r [+]= [(0, 0)]
   E
      assert(sum(blocks) + blocks.len - 1 <= cells, ‘Those blocks will not fit in those cells’)
      V (blength, brest) = (blocks[0], blocks[1..])
      V minspace4rest = sum(brest.map(b -> 1 + b))
      L(bpos) 0 .. cells - minspace4rest - blength
         I brest.empty
            r [+]= [(bpos, blength)]
         E
            V offset = bpos + blength + 1
            L(subpos) nonoblocks(&brest, cells - offset)
               V rest = subpos.map((bp, bl) -> (@offset + bp, bl))
               V vec = [(bpos, blength)] [+] rest
               r [+]= vec
   R r

F pblock(vec, cells)
   ‘Prettyprints each run of blocks with a different letter A.. for each block of filled cells’
   V vector = [‘_’] * cells
   L(bp_bl) vec
      V ch = L.index + ‘A’.code
      V (bp, bl) = bp_bl
      L(i) bp .< bp + bl
         vector[i] = I vector[i] == ‘_’ {Char(code' ch)} E Char(‘?’)
   R ‘|’vector.join(‘|’)‘|’

L(blocks, cells) [([2, 1], 5), ([Int](), 5), ([8], 10), ([2, 3, 2, 3], 15)]
   print("\nConfiguration:\n    #. # #. cells and #. blocks".format(pblock([(0, 0)] * 0, cells), cells, blocks))
   print(‘  Possibilities:’)
   V nb = nonoblocks(&blocks, cells)
   L(vector) nb
      print(‘    ’pblock(vector, cells))
   print(‘  A total of #. Possible configurations.’.format(nb.len))
===
Array<Array<ivec2>> nonoblocks(Array<int> &blocks, const int cells)
{
    Array<Array<ivec2>> r;
    if (blocks.empty() || _get<0>(blocks) == 0)
        r.append(create_array({make_tuple(0, 0)}));
    else {
        assert(sum(blocks) + blocks.len() - 1 <= cells, u"Those blocks will not fit in those cells"_S);
        auto [blength, brest] = make_tuple(_get<0>(blocks), blocks[range_ei(1)]);
        auto minspace4rest = sum_map(brest, [](const auto &b){return 1 + b;});
        for (auto bpos : range_ee(0, cells - minspace4rest - blength))
            if (brest.empty())
                r.append(create_array({make_tuple(bpos, blength)}));
            else {
                auto offset = bpos + blength + 1;
                for (auto &&subpos : nonoblocks(brest, cells - offset)) {
                    auto rest = subpos.map([&offset](const auto &bp, const auto &bl){return make_tuple(offset + bp, bl);});
                    auto vec = create_array({make_tuple(bpos, blength)}) + rest;
                    r.append(vec);
                }
            }
    }
    return r;
}

template <typename T1, typename T2> auto pblock(const T1 &vec, const T2 &cells)
{
    u"Prettyprints each run of blocks with a different letter A.. for each block of filled cells"_S;
    auto vector = create_array({u'_'_C}) * cells;
    {int Lindex = 0;
    for (auto &&bp_bl : vec) {
        auto ch = Lindex + u'A'_C.code;
        auto [bp, bl] = bp_bl;
        for (auto i : range_el(bp, bp + bl))
            vector.set(i, vector[i] == u'_' ? Char(ch) : u'?'_C);
        Lindex++;
    }}
    return u"|"_S & vector.join(u"|"_S) & u"|"_S;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&[blocks, cells] : create_array({make_tuple(create_array({2, 1}), 5), make_tuple(Array<int>(), 5), make_tuple(create_array({8}), 10), make_tuple(create_array({2, 3, 2, 3}), 15)})) {
            print(u"\nConfiguration:\n    #. # #. cells and #. blocks"_S.format(pblock(create_array({make_tuple(0, 0)}) * 0, cells), cells, blocks));
            print(u"  Possibilities:"_S);
            auto nb = nonoblocks(blocks, cells);
            for (auto &&vector : nb)
                print(u"    "_S & pblock(vector, cells));
            print(u"  A total of #. Possible configurations."_S.format(nb.len()));
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Numerical_integration#Nim
from typing import Callable

def left_rect(f : Callable[[float], float], x : float, h : float) -> float:
  return f(x)

def mid_rect(f : Callable[[float], float], x : float, h : float) -> float:
  return f(x + h/2)

def right_rect(f : Callable[[float], float], x : float, h : float) -> float:
  return f(x+h)

def trapezium(f : Callable[[float], float], x : float, h : float) -> float:
  return (f(x) + f(x+h))/2.0

def simpson(f : Callable[[float], float], x : float, h : float) -> float:
  return (f(x) + 4*f(x + h/2) + f(x+h))/6.0

def cube(x : float) -> float:
  return x*x*x

def reciprocal(x : float) -> float:
  return 1/x

def identity(x : float) -> float:
  return x

def integrate(f, a, b, steps, meth):
   h = (b-a)/steps
   ival = h * sum(meth(f, a+i*h, h) for i in range(steps))
   return ival

for a, b, steps, func, func_name in [(0.0, 1.0, 100, cube, 'cube'),
                                     (1.0, 100.0, 1000, reciprocal, 'reciprocal'),
                                     (0.0, 5000.0, 5_000_000, identity, 'identity'),
                                     (0.0, 6000.0, 6_000_000, identity, 'identity')]:
    for rule, rule_name in [(left_rect,  'left_rect'),
                             (mid_rect,   'mid_rect'),
                           (right_rect, 'right_rect'),
                            (trapezium,  'trapezium'),
                              (simpson,    'simpson')]:
        print('%s integrated using %s\n  from %s to %s (%i steps) = %s' %
              (func_name, rule_name, a, b, steps, integrate(func, a, b, steps, rule)))
===
F left_rect((Float -> Float) f, Float x, Float h) -> Float
   R f(x)

F mid_rect((Float -> Float) f, Float x, Float h) -> Float
   R f(x + h / 2)

F right_rect((Float -> Float) f, Float x, Float h) -> Float
   R f(x + h)

F trapezium((Float -> Float) f, Float x, Float h) -> Float
   R (f(x) + f(x + h)) / 2.0

F simpson((Float -> Float) f, Float x, Float h) -> Float
   R (f(x) + 4 * f(x + h / 2) + f(x + h)) / 6.0

F cube(Float x) -> Float
   R x * x * x

F reciprocal(Float x) -> Float
   R 1 / x

F identity(Float x) -> Float
   R x

F integrate(f, a, b, steps, meth)
   V h = (b - a) / steps
   V ival = h * sum((0 .< steps).map(i -> @meth(@f, @a + i * @h, @h)))
   R ival

L(a, b, steps, func, func_name) [(0.0, 1.0, 100, cube, ‘cube’), (1.0, 100.0, 1000, reciprocal, ‘reciprocal’), (0.0, 5000.0, 5'000'000, identity, ‘identity’), (0.0, 6000.0, 6'000'000, identity, ‘identity’)]
   L(rule, rule_name) [(left_rect, ‘left_rect’), (mid_rect, ‘mid_rect’), (right_rect, ‘right_rect’), (trapezium, ‘trapezium’), (simpson, ‘simpson’)]
      print("#. integrated using #.\n  from #. to #. (#. steps) = #.".format(func_name, rule_name, a, b, steps, integrate(func, a, b, steps, rule)))
===
double left_rect(const std::function<double(const double)> &f, const double x, const double h)
{
    return f(x);
}

double mid_rect(const std::function<double(const double)> &f, const double x, const double h)
{
    return f(x + h / 2.0);
}

double right_rect(const std::function<double(const double)> &f, const double x, const double h)
{
    return f(x + h);
}

double trapezium(const std::function<double(const double)> &f, const double x, const double h)
{
    return (f(x) + f(x + h)) / 2.0;
}

double simpson(const std::function<double(const double)> &f, const double x, const double h)
{
    return (f(x) + 4 * f(x + h / 2.0) + f(x + h)) / 6.0;
}

double cube(const double x)
{
    return x * x * x;
}

double reciprocal(const double x)
{
    return 1.0 / x;
}

double identity(const double x)
{
    return x;
}

template <typename T1, typename T2, typename T3, typename T4, typename T5> auto integrate(const T1 &f, const T2 &a, const T3 &b, const T4 &steps, const T5 &meth)
{
    auto h = (b - a) / steps;
    auto ival = h * sum_map(range_el(0, steps), [&a, &f, &h, &meth](const auto &i){return meth(f, a + i * h, h);});
    return ival;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&[a, b, steps, func, func_name] : create_array({make_tuple(0.0, 1.0, 100, cube, u"cube"_S), make_tuple(1.0, 100.0, 1000, reciprocal, u"reciprocal"_S), make_tuple(0.0, 5000.0, 5'000'000, identity, u"identity"_S), make_tuple(0.0, 6000.0, 6'000'000, identity, u"identity"_S)}))
            for (auto &&[rule, rule_name] : create_array({make_tuple(left_rect, u"left_rect"_S), make_tuple(mid_rect, u"mid_rect"_S), make_tuple(right_rect, u"right_rect"_S), make_tuple(trapezium, u"trapezium"_S), make_tuple(simpson, u"simpson"_S)}))
                print(u"#. integrated using #.\n  from #. to #. (#. steps) = #."_S.format(func_name, rule_name, a, b, steps, integrate(func, a, b, steps, rule)));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/N-body_problem#Python
from typing import List
import math

class Vector:
    x : float
    y : float
    z : float

    def __init__(self, x, y, z):
        self.x = x
        self.y = y
        self.z = z

    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y, self.z + other.z)

    def __sub__(self, other):
        return Vector(self.x - other.x, self.y - other.y, self.z - other.z)

    def __mul__(self, other):
        return Vector(self.x * other, self.y * other, self.z * other)

    def __eq__(self, other):
        return self.x == other.x and self.y == other.y and self.z == other.z

    def __str__(self):
        return '({x}, {y}, {z})'.format(x=self.x, y=self.y, z=self.z)

    def abs(self):
        return math.sqrt(self.x*self.x + self.y*self.y + self.z*self.z)

origin = Vector(0, 0, 0)

class NBody:
    gc : float
    bodies : int
    timeSteps : int
    masses : List[float]
    positions : List[Vector]
    velocities : List[Vector]
    accelerations : List[Vector]

    def __init__(self, fileName):
        lines = open(fileName, "r").read().split("\n")
        gbt = lines[0].split(' ')
        self.gc = float(gbt[0])
        self.bodies = int(gbt[1])
        self.timeSteps = int(gbt[2])
        self.masses = [0.0 for i in range(self.bodies)]
        self.positions = [origin for i in range(self.bodies)]
        self.velocities = [origin for i in range(self.bodies)]
        self.accelerations = [origin for i in range(self.bodies)]
        for i in range(self.bodies):
            self.masses[i] = float(lines[i*3 + 1])
            self.positions[i] = self.__decompose(lines[i*3 + 2])
            self.velocities[i] = self.__decompose(lines[i*3 + 3])

        print("Contents of", fileName)
        for line in lines:
            print(line)
        print()
        print("Body   :      x          y          z    |", end=' ')
        print("     vx         vy         vz")

    def __decompose(self, line):
        xyz = line.split(' ')
        x = float(xyz[0])
        y = float(xyz[1])
        z = float(xyz[2])
        return Vector(x, y, z)

    def __computeAccelerations(self):
        for i in range(self.bodies):
            self.accelerations[i] = origin
            for j in range(self.bodies):
                if i != j:
                    temp = self.gc * self.masses[j] / math.pow((self.positions[i] - self.positions[j]).abs(), 3)
                    self.accelerations[i] += (self.positions[j] - self.positions[i]) * temp

    def __computePositions(self):
        for i in range(self.bodies):
            self.positions[i] += self.velocities[i] + self.accelerations[i] * 0.5

    def __computeVelocities(self):
        for i in range(self.bodies):
            self.velocities[i] += self.accelerations[i]

    def __resolveCollisions(self):
        for i in range(self.bodies):
            for j in range(self.bodies):
                if self.positions[i] == self.positions[j]:
                    (self.velocities[i], self.velocities[j]) = (self.velocities[j], self.velocities[i])

    def simulate(self):
        self.__computeAccelerations()
        self.__computePositions()
        self.__computeVelocities()
        self.__resolveCollisions()

    def printResults(self):
        for i in range(self.bodies):
            print("Body %d : %9.6f  %9.6f  %9.6f | %9.6f  %9.6f  %9.6f" % (i+1, self.positions[i].x, self.positions[i].y, self.positions[i].z, self.velocities[i].x, self.velocities[i].y, self.velocities[i].z))

nb = NBody("nbody.txt")
for i in range(nb.timeSteps):
    print("\nCycle %d" % (i + 1))
    nb.simulate()
    nb.printResults()
===
T Vector
   Float x
   Float y
   Float z

   F (x, y, z)
      .x = x
      .y = y
      .z = z

   F +(other)
      R Vector(.x + other.x, .y + other.y, .z + other.z)

   F -(other)
      R Vector(.x - other.x, .y - other.y, .z - other.z)

   F *(other)
      R Vector(.x * other, .y * other, .z * other)

   F ==(other)
      R .x == other.x & .y == other.y & .z == other.z

   F String()
      R ‘(#., #., #.)’.format(.x, .y, .z)

   F abs()
      R sqrt(.x * .x + .y * .y + .z * .z)

V origin = Vector(0, 0, 0)

T NBody
   Float gc
   Int bodies
   Int timeSteps
   [Float] masses
   [Vector] positions
   [Vector] velocities
   [Vector] accelerations

   F (fileName)
      V lines = File(fileName).read().split("\n")
      V gbt = lines[0].split(‘ ’)
      .gc = Float(gbt[0])
      .bodies = Int(gbt[1])
      .timeSteps = Int(gbt[2])
      .masses = (0 .< .bodies).map(i -> 0.0)
      .positions = (0 .< .bodies).map(i -> :origin)
      .velocities = (0 .< .bodies).map(i -> :origin)
      .accelerations = (0 .< .bodies).map(i -> :origin)
      L(i) 0 .< .bodies
         .masses[i] = Float(lines[i * 3 + 1])
         .positions[i] = .__decompose(lines[i * 3 + 2])
         .velocities[i] = .__decompose(lines[i * 3 + 3])

      print(‘Contents of ’fileName)
      L(line) lines
         print(line)
      print()
      print(‘Body   :      x          y          z    |’, end' ‘ ’)
      print(‘     vx         vy         vz’)

   F __decompose(line)
      V xyz = line.split(‘ ’)
      V x = Float(xyz[0])
      V y = Float(xyz[1])
      V z = Float(xyz[2])
      R Vector(x, y, z)

   F __computeAccelerations()
      L(i) 0 .< .bodies
         .accelerations[i] = :origin
         L(j) 0 .< .bodies
            I i != j
               V temp = .gc * .masses[j] / pow((.positions[i] - .positions[j]).abs(), 3)
               .accelerations[i] += (.positions[j] - .positions[i]) * temp

   F __computePositions()
      L(i) 0 .< .bodies
         .positions[i] += .velocities[i] + .accelerations[i] * 0.5

   F __computeVelocities()
      L(i) 0 .< .bodies
         .velocities[i] += .accelerations[i]

   F __resolveCollisions()
      L(i) 0 .< .bodies
         L(j) 0 .< .bodies
            I .positions[i] == .positions[j]
               swap(&.velocities[i], &.velocities[j])

   F simulate()
      .__computeAccelerations()
      .__computePositions()
      .__computeVelocities()
      .__resolveCollisions()

   F printResults()
      L(i) 0 .< .bodies
         print(‘Body #. : #2.6  #2.6  #2.6 | #2.6  #2.6  #2.6’.format(i + 1, .positions[i].x, .positions[i].y, .positions[i].z, .velocities[i].x, .velocities[i].y, .velocities[i].z))

V nb = NBody(‘nbody.txt’)
L(i) 0 .< nb.timeSteps
   print("\nCycle #.".format(i + 1))
   nb.simulate()
   nb.printResults()
===
class Vector
{
public:
    double x;
    double y;
    double z;

    template <typename T1, typename T2, typename T3> Vector(const T1 &x, const T2 &y, const T3 &z) :
        x(x),
        y(y),
        z(z)
    {
    }

    template <typename T1> auto operator+(const T1 &other) const
    {
        return Vector(x + other.x, y + other.y, z + other.z);
    }
    template <typename Ty> auto &operator+=(const Ty &t)
    {
        *this = *this + t;
        return *this;
    }

    template <typename T1> auto operator-(const T1 &other) const
    {
        return Vector(x - other.x, y - other.y, z - other.z);
    }
    template <typename Ty> auto &operator-=(const Ty &t)
    {
        *this = *this - t;
        return *this;
    }

    template <typename T1> auto operator*(const T1 &other) const
    {
        return Vector(x * other, y * other, z * other);
    }
    template <typename Ty> auto &operator*=(const Ty &t)
    {
        *this = *this * t;
        return *this;
    }

    template <typename T1> auto operator==(const T1 &other) const
    {
        return x == other.x && y == other.y && z == other.z;
    }

    operator String() const
    {
        return u"(#., #., #.)"_S.format(x, y, z);
    }

    auto abs()
    {
        return sqrt(x * x + y * y + z * z);
    }
};

auto origin = Vector(0, 0, 0);

class NBody
{
public:
    double gc;
    int bodies;
    int timeSteps;
    Array<double> masses;
    Array<Vector> positions;
    Array<Vector> velocities;
    Array<Vector> accelerations;

    template <typename T1> NBody(const T1 &fileName)
    {
        auto lines = File(fileName).read().split(u"\n"_S);
        auto gbt = _get<0>(lines).split(u" "_S);
        gc = to_float(_get<0>(gbt));
        bodies = to_int(_get<1>(gbt));
        timeSteps = to_int(_get<2>(gbt));
        masses = range_el(0, bodies).map([](const auto &i){return 0.0;});
        positions = range_el(0, bodies).map([](const auto &i){return ::origin;});
        velocities = range_el(0, bodies).map([](const auto &i){return ::origin;});
        accelerations = range_el(0, bodies).map([](const auto &i){return ::origin;});
        for (auto i : range_el(0, bodies)) {
            masses.set(i, to_float(lines[i * 3 + 1]));
            positions.set(i, __decompose(lines[i * 3 + 2]));
            velocities.set(i, __decompose(lines[i * 3 + 3]));
        }

        print(u"Contents of "_S & fileName);
        for (auto &&line : lines)
            print(line);
        print();
        print(u"Body   :      x          y          z    |"_S, u" "_S);
        print(u"     vx         vy         vz"_S);
    }

    template <typename T1> auto __decompose(const T1 &line)
    {
        auto xyz = line.split(u" "_S);
        auto x = to_float(_get<0>(xyz));
        auto y = to_float(_get<1>(xyz));
        auto z = to_float(_get<2>(xyz));
        return Vector(x, y, z);
    }

    auto __computeAccelerations()
    {
        for (auto i : range_el(0, bodies)) {
            accelerations.set(i, ::origin);
            for (auto j : range_el(0, bodies))
                if (i != j) {
                    auto temp = gc * masses[j] / pow((positions[i] - positions[j]).abs(), 3);
                    accelerations[i] += (positions[j] - positions[i]) * temp;
                }
        }
    }

    auto __computePositions()
    {
        for (auto i : range_el(0, bodies))
            positions[i] += velocities[i] + accelerations[i] * 0.5;
    }

    auto __computeVelocities()
    {
        for (auto i : range_el(0, bodies))
            velocities[i] += accelerations[i];
    }

    auto __resolveCollisions()
    {
        for (auto i : range_el(0, bodies))
            for (auto j : range_el(0, bodies))
                if (positions[i] == positions[j])
                    swap(velocities[i], velocities[j]);
    }

    auto simulate()
    {
        __computeAccelerations();
        __computePositions();
        __computeVelocities();
        __resolveCollisions();
    }

    auto printResults()
    {
        for (auto i : range_el(0, bodies))
            print(u"Body #. : #2.6  #2.6  #2.6 | #2.6  #2.6  #2.6"_S.format(i + 1, positions[i].x, positions[i].y, positions[i].z, velocities[i].x, velocities[i].y, velocities[i].z));
    }
};

auto nb = NBody(u"nbody.txt"_S);

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto i : range_el(0, nb.timeSteps)) {
            print(u"\nCycle #."_S.format(i + 1));
            nb.simulate();
            nb.printResults();
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/N-queens_problem#Nim
BoardSize = 8

def underAttack(col, queens):
    if col in queens: return True
    for i, x in enumerate(queens):
        if abs(col - x) == len(queens) - i:
            return True
    return False

def solve(n):
    result = [[0] * 0]
    newSolutions : List[List[int]] = []
    for row in range(1, n + 1):
        for solution in result:
            for i in range(1, BoardSize + 1):
                if not underAttack(i, solution):
                    newSolutions.append(solution + [i])
        (result, newSolutions) = (newSolutions, result)
        newSolutions.clear()
    return result

print('Solutions for a chessboard of size ' + str(BoardSize) + 'x' + str(BoardSize))
print()

for i, answer in enumerate(solve(BoardSize)):
    for row, col in enumerate(answer):
        if row > 0:
            print(' ', end = '')
        print(chr(ord('a') + row) + str(col), end = '')
    print(end = "\n" if i % 4 == 3 else '      ')
===
V BoardSize = 8

F underAttack(col, queens)
   I col C queens
      R 1B
   L(x) queens
      V i = L.index
      I abs(col - x) == queens.len - i
         R 1B
   R 0B

F solve(n)
   V result = [[Int]()]
   [[Int]] newSolutions
   L(row) 1 .. n
      L(solution) result
         L(i) 1 .. BoardSize
            I !underAttack(i, solution)
               newSolutions.append(solution [+] [i])
      swap(&result, &newSolutions)
      newSolutions.clear()
   R result

print(‘Solutions for a chessboard of size ’String(BoardSize)‘x’String(BoardSize))
print()

L(answer) solve(BoardSize)
   V i = L.index
   L(col) answer
      V row = L.index
      I row > 0
         print(‘ ’, end' ‘’)
      print(Char(code' ‘a’.code + row)‘’String(col), end' ‘’)
   print(end' I i % 4 == 3 {"\n"} E ‘      ’)
===
auto BoardSize = 8;

template <typename T1, typename T2> auto underAttack(const T1 &col, const T2 &queens)
{
    if (in(col, queens))
        return true;
    {int Lindex = 0;
    for (auto &&x : queens) {
        auto i = Lindex;
        if (abs(col - x) == queens.len() - i)
            return true;
        Lindex++;
    }}
    return false;
}

template <typename T1> auto solve(const T1 &n)
{
    auto result = create_array({Array<int>()});
    Array<Array<int>> newSolutions;
    for (auto row : range_ee(1, n)) {
        for (auto &&solution : result)
            for (auto i : range_ee(1, BoardSize))
                if (!underAttack(i, solution))
                    newSolutions.append(solution + create_array({i}));
        swap(result, newSolutions);
        newSolutions.clear();
    }
    return result;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"Solutions for a chessboard of size "_S & String(BoardSize) & u"x"_S & String(BoardSize));
        print();
        {int Lindex = 0;

        for (auto &&answer : solve(BoardSize)) {
            auto i = Lindex;
            {int Lindex = 0;
            for (auto &&col : answer) {
                auto row = Lindex;
                if (row > 0)
                    print(u" "_S, u""_S);
                print(Char(u'a'_C.code + row) & String(col), u""_S);
                Lindex++;
            }}
            print(u""_S, mod(i, 4) == 3 ? u"\n"_S : u"      "_S);
            Lindex++;
        }}
    }
} code_block_1;


# https://www.rosettacode.org/wiki/N-smooth_numbers#Python
primes = [2, 3, 5, 7, 11, 13, 17, 19, 23]

def isPrime(n):
    if n < 2:
        return False

    for i in primes:
        if n == i:
            return True
        if n % i == 0:
            return False
        if i * i > n:
            return True
    print("Oops,", n, " is too large")
    return False

def init():
    s = 24
    while s < 600:
        if isPrime(s - 1) and s - 1 > primes[-1]:
            primes.append(s - 1)
        if isPrime(s + 1) and s + 1 > primes[-1]:
            primes.append(s + 1)
        s += 6

def nsmooth(n, size):
    assert(2 <= n <= 521)
    assert(size >= 1)

    bn = n
    ok = False
    for prime in primes:
        if bn == prime:
            ok = True
            break
    assert ok, "must be a prime number"

    ns = [BigInt(0)] * size
    ns[0] = 1

    next : List[BigInt] = []
    for prime in primes:
        if prime > bn:
            break
        next.append(prime)

    indicies = [0] * len(next)
    for m in range(1, size):
        ns[m] = min(next)
        for i in range(0, len(indicies)):
            if ns[m] == next[i]:
                indicies[i] += 1
                next[i] = primes[i] * ns[indicies[i]]

    return ns

init()

for p in primes:
    if p >= 30:
        break
    print("The first", p, "-smooth numbers are:")
    print(nsmooth(p, 25))
    print()

for p in primes[1:]:
    if p >= 30:
        break
    print("The 3000 to 3202", p, "-smooth numbers are:")
    print(nsmooth(p, 3002)[2999:])
    print()

for p in [503, 509, 521]:
    print("The 30000 to 3019", p, "-smooth numbers are:")
    print(nsmooth(p, 30019)[29999:])
    print()
===
V primes = [2, 3, 5, 7, 11, 13, 17, 19, 23]

F isPrime(n)
   I n < 2
      R 0B

   L(i) :primes
      I n == i
         R 1B
      I n % i == 0
         R 0B
      I i * i > n
         R 1B
   print(‘Oops, ’n‘  is too large’)
   R 0B

F init()
   V s = 24
   L s < 600
      I isPrime(s - 1) & s - 1 > :primes.last
         :primes.append(s - 1)
      I isPrime(s + 1) & s + 1 > :primes.last
         :primes.append(s + 1)
      s += 6

F nsmooth(n, size)
   assert(n C 2..521)
   assert(size >= 1)

   V bn = n
   V ok = 0B
   L(prime) :primes
      I bn == prime
         ok = 1B
         L.break
   assert(ok, ‘must be a prime number’)

   V ns = [BigInt(0)] * size
   ns[0] = 1

   [BigInt] next
   L(prime) :primes
      I prime > bn
         L.break
      next.append(prime)

   V indicies = [0] * next.len
   L(m) 1 .< size
      ns[m] = min(next)
      L(i) 0 .< indicies.len
         I ns[m] == next[i]
            indicies[i]++
            next[i] = :primes[i] * ns[indicies[i]]

   R ns

init()

L(p) primes
   I p >= 30
      L.break
   print(‘The first ’p‘ -smooth numbers are:’)
   print(nsmooth(p, 25))
   print()

L(p) primes[1..]
   I p >= 30
      L.break
   print(‘The 3000 to 3202 ’p‘ -smooth numbers are:’)
   print(nsmooth(p, 3002)[2999..])
   print()

L(p) [503, 509, 521]
   print(‘The 30000 to 3019 ’p‘ -smooth numbers are:’)
   print(nsmooth(p, 30019)[29999..])
   print()
===
auto primes = create_array({2, 3, 5, 7, 11, 13, 17, 19, 23});

template <typename T1> auto isPrime(const T1 &n)
{
    if (n < 2)
        return false;

    for (auto &&i : ::primes) {
        if (n == i)
            return true;
        if (mod(n, i) == 0)
            return false;
        if (i * i > n)
            return true;
    }
    print(u"Oops, "_S & n & u"  is too large"_S);
    return false;
}

auto init()
{
    auto s = 24;
    while (s < 600) {
        if (isPrime(s - 1) && s - 1 > ::primes.last())
            ::primes.append(s - 1);
        if (isPrime(s + 1) && s + 1 > ::primes.last())
            ::primes.append(s + 1);
        s += 6;
    }
}

template <typename T1, typename T2> auto nsmooth(const T1 &n, const T2 &size)
{
    assert(in(n, range_ee(2, 521)));
    assert(size >= 1);

    auto bn = n;
    auto ok = false;
    for (auto &&prime : ::primes)
        if (bn == prime) {
            ok = true;
            break;
        }
    assert(ok, u"must be a prime number"_S);

    auto ns = create_array({BigInt(0)}) * size;
    _set<0>(ns, 1);

    Array<BigInt> next;
    for (auto &&prime : ::primes) {
        if (prime > bn)
            break;
        next.append(prime);
    }

    auto indicies = create_array({0}) * next.len();
    for (auto m : range_el(1, size)) {
        ns.set(m, min(next));
        for (auto i : range_el(0, indicies.len()))
            if (ns[m] == next[i]) {
                indicies[i]++;
                next.set(i, ::primes[i] * ns[indicies[i]]);
            }
    }

    return ns;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        init();

        for (auto &&p : primes) {
            if (p >= 30)
                break;
            print(u"The first "_S & p & u" -smooth numbers are:"_S);
            print(nsmooth(p, 25));
            print();
        }

        for (auto &&p : primes[range_ei(1)]) {
            if (p >= 30)
                break;
            print(u"The 3000 to 3202 "_S & p & u" -smooth numbers are:"_S);
            print(nsmooth(p, 3002)[range_ei(2999)]);
            print();
        }

        for (auto &&p : create_array({503, 509, 521})) {
            print(u"The 30000 to 3019 "_S & p & u" -smooth numbers are:"_S);
            print(nsmooth(p, 30019)[range_ei(29999)]);
            print();
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Names_to_numbers#Nim
import re
Int64 = int

Names = {"one":   Int64(1),
         "two":         2,
         "three":       3,
         "four":        4,
         "five":        5,
         "six":         6,
         "seven":       7,
         "eight":       8,
         "nine":        9,
         "ten":         10,
         "eleven":      11,
         "twelve":      12,
         "thirteen":    13,
         "fourteen":    14,
         "fifteen":     15,
         "sixteen":     16,
         "seventeen":   17,
         "eighteen":    18,
         "nineteen":    19,
         "twenty":      20,
         "thirty":      30,
         "forty":       40,
         "fifty":       50,
         "sixty":       60,
         "seventy":     70,
         "eighty":      80,
         "ninety":      90,
         "hundred":     100,
         "thousand":    1000,
         "million":     1000000,
         "billion":     1000000000,
         "trillion":    1000000000000,
         "quadrillion": 1000000000000000,
         "quintillion": 1000000000000000000}

Zeros = ["zero", "nought", "nil", "none", "nothing"]

def nameToNum(name):
    text = name.lower()
    isNegative = text.startswith("minus ")
    if isNegative: text = text[6:]
    if text.startswith("a"):
        text = "one" + text[1:]
    words = [w for w in re.split(",|-| and | ", text) if len(w) != 0]
    if len(words) == 1 and words[0] in Zeros:
        return Int64(0)

    multiplier = Int64(1)
    sum = Int64(0)
    for i in range(len(words) - 1, -1, -1):
        num = Names.get(words[i], 0)
        if num >= 1000:
            multiplier = num
            if i == 0: sum += multiplier
        elif num >= 100:
            multiplier *= 100
            if i == 0: sum += multiplier
        else:
            sum += num * multiplier

    return -sum if isNegative else sum

names = [
    "none",
    "one",
    "twenty-five",
    "minus one hundred and seventeen",
    "hundred and fifty-six",
    "minus two thousand two",
    "nine thousand, seven hundred, one",
    "minus six hundred and twenty six thousand, eight hundred and fourteen",
    "four million, seven hundred thousand, three hundred and eighty-six",
    "fifty-one billion, two hundred and fifty-two million, seventeen thousand, one hundred eighty-four",
    "two hundred and one billion, twenty-one million, two thousand and one",
    "minus three hundred trillion, nine million, four hundred and one thousand and thirty-one",
    "seventeen quadrillion, one hundred thirty-seven",
    "a quintillion, eight trillion and five",
    "minus nine quintillion, two hundred and twenty-three quadrillion, three hundred and seventy-two trillion, thirty-six billion, eight hundred and fifty-four million, seven hundred and seventy-five thousand, eight hundred and eight"]

for name in names:
    print('%20d' % nameToNum(name), '=', name)
===
V Names = [‘one’ = Int64(1), ‘two’ = 2, ‘three’ = 3, ‘four’ = 4, ‘five’ = 5, ‘six’ = 6, ‘seven’ = 7, ‘eight’ = 8, ‘nine’ = 9, ‘ten’ = 10, ‘eleven’ = 11, ‘twelve’ = 12, ‘thirteen’ = 13, ‘fourteen’ = 14, ‘fifteen’ = 15, ‘sixteen’ = 16, ‘seventeen’ = 17, ‘eighteen’ = 18, ‘nineteen’ = 19, ‘twenty’ = 20, ‘thirty’ = 30, ‘forty’ = 40, ‘fifty’ = 50, ‘sixty’ = 60, ‘seventy’ = 70, ‘eighty’ = 80, ‘ninety’ = 90, ‘hundred’ = 100, ‘thousand’ = 1000, ‘million’ = 1000000, ‘billion’ = 1000000000, ‘trillion’ = 1000000000000, ‘quadrillion’ = 1000000000000000, ‘quintillion’ = 1000000000000000000]

V Zeros = [‘zero’, ‘nought’, ‘nil’, ‘none’, ‘nothing’]

F nameToNum(name)
   V text = name.lowercase()
   V isNegative = text.starts_with(‘minus ’)
   I isNegative
      text = text[6..]
   I text.starts_with(‘a’)
      text = ‘one’text[1..]
   V words = text.split(re:‘,|-| and | ’).filter(w -> !w.empty)
   I words.len == 1 & words[0] C Zeros
      R Int64(0)

   V multiplier = Int64(1)
   V sum = Int64(0)
   L(i) (words.len - 1 .< -1).step(-1)
      V num = Names.get(words[i], 0)
      I num >= 1000
         multiplier = num
         I i == 0
            sum += multiplier
      E I num >= 100
         multiplier *= 100
         I i == 0
            sum += multiplier
      E
         sum += num * multiplier

   R I isNegative {-sum} E sum

V names = [‘none’, ‘one’, ‘twenty-five’, ‘minus one hundred and seventeen’, ‘hundred and fifty-six’, ‘minus two thousand two’, ‘nine thousand, seven hundred, one’, ‘minus six hundred and twenty six thousand, eight hundred and fourteen’, ‘four million, seven hundred thousand, three hundred and eighty-six’, ‘fifty-one billion, two hundred and fifty-two million, seventeen thousand, one hundred eighty-four’, ‘two hundred and one billion, twenty-one million, two thousand and one’, ‘minus three hundred trillion, nine million, four hundred and one thousand and thirty-one’, ‘seventeen quadrillion, one hundred thirty-seven’, ‘a quintillion, eight trillion and five’, ‘minus nine quintillion, two hundred and twenty-three quadrillion, three hundred and seventy-two trillion, thirty-six billion, eight hundred and fifty-four million, seven hundred and seventy-five thousand, eight hundred and eight’]

L(name) names
   print((‘#20’.format(nameToNum(name)))‘ = ’name)
===
auto Names = create_dict(dict_of(u"one"_S, to_int64(1))(u"two"_S, 2)(u"three"_S, 3)(u"four"_S, 4)(u"five"_S, 5)(u"six"_S, 6)(u"seven"_S, 7)(u"eight"_S, 8)(u"nine"_S, 9)(u"ten"_S, 10)(u"eleven"_S, 11)(u"twelve"_S, 12)(u"thirteen"_S, 13)(u"fourteen"_S, 14)(u"fifteen"_S, 15)(u"sixteen"_S, 16)(u"seventeen"_S, 17)(u"eighteen"_S, 18)(u"nineteen"_S, 19)(u"twenty"_S, 20)(u"thirty"_S, 30)(u"forty"_S, 40)(u"fifty"_S, 50)(u"sixty"_S, 60)(u"seventy"_S, 70)(u"eighty"_S, 80)(u"ninety"_S, 90)(u"hundred"_S, 100)(u"thousand"_S, 1000)(u"million"_S, 1000000)(u"billion"_S, 1000000000)(u"trillion"_S, 1000000000000)(u"quadrillion"_S, 1000000000000000)(u"quintillion"_S, 1000000000000000000));

auto Zeros = create_array({u"zero"_S, u"nought"_S, u"nil"_S, u"none"_S, u"nothing"_S});

template <typename T1> auto nameToNum(const T1 &name)
{
    auto text = name.lowercase();
    auto isNegative = text.starts_with(u"minus "_S);
    if (isNegative)
        text = text[range_ei(6)];
    if (text.starts_with(u"a"_S))
        text = u"one"_S & text[range_ei(1)];
    auto words = text.split(re::_(u",|-| and | "_S)).filter([](const auto &w){return !w.empty();});
    if (words.len() == 1 && in(_get<0>(words), Zeros))
        return to_int64(0);

    auto multiplier = to_int64(1);
    auto sum = to_int64(0);
    for (auto i : range_el(words.len() - 1, -1).step(-1)) {
        auto num = Names.get(words[i], 0);
        if (num >= 1000) {
            multiplier = num;
            if (i == 0)
                sum += multiplier;
        }
        else if (num >= 100) {
            multiplier *= 100;
            if (i == 0)
                sum += multiplier;
        }
        else
            sum += num * multiplier;
    }

    return isNegative ? -sum : sum;
}

auto names = create_array({u"none"_S, u"one"_S, u"twenty-five"_S, u"minus one hundred and seventeen"_S, u"hundred and fifty-six"_S, u"minus two thousand two"_S, u"nine thousand, seven hundred, one"_S, u"minus six hundred and twenty six thousand, eight hundred and fourteen"_S, u"four million, seven hundred thousand, three hundred and eighty-six"_S, u"fifty-one billion, two hundred and fifty-two million, seventeen thousand, one hundred eighty-four"_S, u"two hundred and one billion, twenty-one million, two thousand and one"_S, u"minus three hundred trillion, nine million, four hundred and one thousand and thirty-one"_S, u"seventeen quadrillion, one hundred thirty-seven"_S, u"a quintillion, eight trillion and five"_S, u"minus nine quintillion, two hundred and twenty-three quadrillion, three hundred and seventy-two trillion, thirty-six billion, eight hundred and fifty-four million, seven hundred and seventy-five thousand, eight hundred and eight"_S});

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&name : names)
            print((u"#20"_S.format(nameToNum(name))) & u" = "_S & name);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Nimber_arithmetic#Python
# Highest power of two that divides a given number.
def hpo2(n): return n & (-n)

# Base 2 logarithm of the highest power of 2 dividing a given number.
def lhpo2(n):
    q = 0
    m = hpo2(n)
    while m%2 == 0:
        m = m >> 1
        q += 1
    return q

def nimsum(x : int, y : int): return x ^ y

def nimprod(x : int, y : int):
    if x < 2 or y < 2:
        return x * y
    h = hpo2(x)
    if x > h:
        return nimprod(h, y) ^ nimprod(x^h, y) # break x into powers of 2
    if hpo2(y) < y:
        return nimprod(y, x) # break y into powers of 2 by flipping operands
    (xp, yp) = (lhpo2(x), lhpo2(y))
    comp = xp & yp
    if comp == 0:
        return x * y # no Fermat power in common
    h = hpo2(comp)
    # a Fermat number square is its sequimultiple
    return nimprod(nimprod(x>>h, y>>h), 3<<(h-1))

for f, op in ((nimsum, '+'), (nimprod, '*')):
    print('', op, '|', end='')
    for i in range(16):
        print('%3d' % i, end='')
    print("\n--- " + "-"*48)
    for i in range(16):
        print('%2d |' % i, end='')
        for j in range(16):
            print("%3d" % f(i,j), end='')
        print()
    print()

(a, b) = (21508, 42689)
print(a, '+', b, '=', nimsum(a,b))
print(a, '*', b, '=', nimprod(a,b))
===
F hpo2(n)
   R n [&] (-n)

F lhpo2(n)
   V q = 0
   V m = hpo2(n)
   L m % 2 == 0
      m = m >> 1
      q++
   R q

F nimsum(Int x, Int y)
   R x (+) y

F nimprod(Int x, Int y)
   I x < 2 | y < 2
      R x * y
   V h = hpo2(x)
   I x > h
      R nimprod(h, y) (+) nimprod(x (+) h, y)
   I hpo2(y) < y
      R nimprod(y, x)
   V (xp, yp) = (lhpo2(x), lhpo2(y))
   V comp = xp [&] yp
   I comp == 0
      R x * y
   h = hpo2(comp)
   R nimprod(nimprod(x >> h, y >> h), 3 << (h - 1))

L(f, op) ((nimsum, ‘+’), (nimprod, ‘*’))
   print(‘ ’op‘ |’, end' ‘’)
   L(i) 16
      print(‘#3’.format(i), end' ‘’)
   print("\n--- "(‘-’ * 48))
   L(i) 16
      print(‘#2 |’.format(i), end' ‘’)
      L(j) 16
         print(‘#3’.format(f(i, j)), end' ‘’)
      print()
   print()

V (a, b) = (21508, 42689)
print(a‘ + ’b‘ = ’nimsum(a, b))
print(a‘ * ’b‘ = ’nimprod(a, b))
===
template <typename T1> auto hpo2(const T1 &n)
{
    return n & (-n);
}

template <typename T1> auto lhpo2(const T1 &n)
{
    auto q = 0;
    auto m = hpo2(n);
    while (mod(m, 2) == 0) {
        m = m >> 1;
        q++;
    }
    return q;
}

auto nimsum(const int x, const int y)
{
    return x ^ y;
}

auto nimprod(const int x, const int y)
{
    if (x < 2 || y < 2)
        return x * y;
    auto h = hpo2(x);
    if (x > h)
        return nimprod(h, y) ^ nimprod(x ^ h, y);
    if (hpo2(y) < y)
        return nimprod(y, x);
    auto [xp, yp] = make_tuple(lhpo2(x), lhpo2(y));
    auto comp = xp & yp;
    if (comp == 0)
        return x * y;
    h = hpo2(comp);
    return nimprod(nimprod(x >> h, y >> h), 3 << (h - 1));
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&[f, op] : make_tuple(make_tuple(nimsum, u"+"_S), make_tuple(nimprod, u"*"_S))) {
            print(u" "_S & op & u" |"_S, u""_S);
            for (int i = 0; i < 16; i++)
                print(u"#3"_S.format(i), u""_S);
            print(u"\n--- "_S & (u"-"_S * 48));
            for (int i = 0; i < 16; i++) {
                print(u"#2 |"_S.format(i), u""_S);
                for (int j = 0; j < 16; j++)
                    print(u"#3"_S.format(f(i, j)), u""_S);
                print();
            }
            print();
        }
    }
} code_block_1;

auto [a, b] = make_tuple(21508, 42689);

struct CodeBlock2
{
    CodeBlock2()
    {
        print(a & u" + "_S & b & u" = "_S & nimsum(a, b));
        print(a & u" * "_S & b & u" = "_S & nimprod(a, b));
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Numbers_divisible_by_their_individual_digits,_but_not_by_the_product_of_their_digits.#Python
from _11l import *

def p(n):
    '''True if n is divisible by each of its digits,
       but not divisible by the product of those digits.
    '''
    digits = [int(c) for c in str(n)]
    return not 0 in digits and (
        0 != (n % product_of_a_seq(digits))
    ) and all(0 == n % d for d in digits)

def chunksOf(n):
    '''A series of lists of length n, subdividing the
       contents of xs. Where the length of xs is not evenly
       divible, the final list will be shorter than n.
    '''
    def go(xs):
        nonlocal n # =
        return (
            xs[i:n + i] for i in range(0, len(xs), n)
        )
    return go

xs = [
    str(n) for n in range(1, 1000)
    if p(n)
]
w = len(xs[-1])
print(len(xs), "matching numbers:\n")
print('\n'.join(
    ' '.join(cell.rjust(w, ' ') for cell in row)
    for row in chunksOf(10)(xs)
))
===
F p(n)
   ‘True if n is divisible by each of its digits,
       but not divisible by the product of those digits.
    ’
   V digits = String(n).map(c -> Int(c))
   R !(0 C digits) & (0 != (n % product(digits))) & all(digits.map(d -> 0 == @n % d))

F chunksOf(n)
   ‘A series of lists of length n, subdividing the
       contents of xs. Where the length of xs is not evenly
       divible, the final list will be shorter than n.
    ’
   F go(xs)
      R ((0 .< xs.len).step(@=n).map(i -> @xs[i .< @=n + i]))
   R go

V xs = (1..999).filter(n -> p(n)).map(n -> String(n))
V w = xs.last.len
print(xs.len" matching numbers:\n")
print(chunksOf(10)(xs).map(row -> row.map(cell -> cell.rjust(:w, ‘ ’)).join(‘ ’)).join("\n"))
===
template <typename T1> auto p(const T1 &n)
{
    uR"(True if n is divisible by each of its digits,
       but not divisible by the product of those digits.
    )"_S;
    auto digits = String(n).map([](const auto &c){return to_int(c);});
    return !(in(0, digits)) && (0 != (mod(n, product(digits)))) && all_map(digits, [&n](const auto &d){return 0 == mod(n, d);});
}

template <typename T1> auto chunksOf(const T1 &n)
{
    uR"(A series of lists of length n, subdividing the
       contents of xs. Where the length of xs is not evenly
       divible, the final list will be shorter than n.
    )"_S;
    auto go = [n](const auto &xs)
    {
        return (range_el(0, xs.len()).step(n).map([&xs, n](const auto &i){return xs[range_el(i, n + i)];}));
    };
    return go;
}

auto xs = range_ee(1, 999).filter([](const auto &n){return p(n);}).map([](const auto &n){return String(n);});
auto w = xs.last().len();

struct CodeBlock1
{
    CodeBlock1()
    {
        print(xs.len() & u" matching numbers:\n"_S);
        print(chunksOf(10)(xs).map([](const auto &row){return row.map([](const auto &cell){return cell.rjust(::w, u" "_S);}).join(u" "_S);}).join(u"\n"_S));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Numbers_in_base_10_that_are_palindromic_in_bases_2,_4,_and_16#Python
def reverse(n, base):
    r = 0
    while n > 0:
        r = r*base + n%base
        n = n//base
    return r

def palindrome(n, base):
    return n == reverse(n, base)

cnt = 0
for i in range(25000):
    if all(palindrome(i, base) for base in (2,4,16)):
        cnt += 1
        print("{:5}".format(i), end=" \n"[cnt % 12 == 0])

print()
===
F reverse(=n, base)
   V r = 0
   L n > 0
      r = r * base + n % base
      n = n I/ base
   R r

F palindrome(n, base)
   R n == reverse(n, base)

V cnt = 0
L(i) 25000
   I all((2, 4, 16).map(base -> palindrome(@i, base)))
      cnt++
      print(‘#5’.format(i), end' " \n"[cnt % 12 == 0])

print()
===
template <typename T1, typename T2> auto reverse(T1 n, const T2 &base)
{
    auto r = 0;
    while (n > 0) {
        r = r * base + mod(n, base);
        n = idiv(n, base);
    }
    return r;
}

template <typename T1, typename T2> auto palindrome(const T1 &n, const T2 &base)
{
    return n == reverse(n, base);
}

auto cnt = 0;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (int i = 0; i < 25000; i++)
            if (all_map(make_tuple(2, 4, 16), [&i](const auto &base){return palindrome(i, base);})) {
                cnt++;
                print(u"#5"_S.format(i), u" \n"_S[mod(cnt, 12) == 0]);
            }

        print();
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Numbers_which_binary_and_ternary_digit_sum_are_prime#Nim
import math

def is_prime(a):
    if a == 2: return True
    if a < 2 or a % 2 == 0: return False
    for i in range(3, int(math.sqrt(a)) + 1, 2):
        if a % i == 0:
            return False
    return True

def digit_sum(n, b):
    result = 0
    while n != 0:
        result += n % b
        n //= b
    return result

count = 0
for n in range(2, 200):
    if is_prime(digit_sum(n, 2)) and is_prime(digit_sum(n, 3)):
        count += 1
        print('%3d' % n, end = "\n" if count % 16 == 0 else ' ')
print()
print('Found', count, 'numbers.')
===
F is_prime(a)
   I a == 2
      R 1B
   I a < 2 | a % 2 == 0
      R 0B
   L(i) (3 .. Int(sqrt(a))).step(2)
      I a % i == 0
         R 0B
   R 1B

F digit_sum(=n, b)
   V result = 0
   L n != 0
      result += n % b
      n I/= b
   R result

V count = 0
L(n) 2..199
   I is_prime(digit_sum(n, 2)) & is_prime(digit_sum(n, 3))
      count++
      print(‘#3’.format(n), end' I count % 16 == 0 {"\n"} E ‘ ’)
print()
print(‘Found ’count‘ numbers.’)
===
template <typename T1> auto is_prime(const T1 &a)
{
    if (a == 2)
        return true;
    if (a < 2 || mod(a, 2) == 0)
        return false;
    for (auto i : range_ee(3, to_int(sqrt(a))).step(2))
        if (mod(a, i) == 0)
            return false;
    return true;
}

template <typename T1, typename T2> auto digit_sum(T1 n, const T2 &b)
{
    auto result = 0;
    while (n != 0) {
        result += mod(n, b);
        n = idiv(n, b);
    }
    return result;
}

auto count = 0;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto n : range_ee(2, 199))
            if (is_prime(digit_sum(n, 2)) && is_prime(digit_sum(n, 3))) {
                count++;
                print(u"#3"_S.format(n), mod(count, 16) == 0 ? u'\n'_C : u' '_C);
            }
        print();
        print(u"Found "_S & count & u" numbers."_S);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Numbers_with_same_digit_set_in_base_10_and_base_16#Python
from _11l import *

col = 0
for i in range(100000):
    if set(list(str(i))) == set(list(hexu(i))):
        col += 1
        print("{:7}".format(i), end='\n'[:int(col % 10 == 0)])
print()
===
V col = 0
L(i) 100000
   I Set(Array(String(i))) == Set(Array(hex(i)))
      col++
      print(‘#7’.format(i), end' "\n"[0 .< Int(col % 10 == 0)])
print()
===
auto col = 0;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (int i = 0; i < 100000; i++)
            if (create_set(create_array(String(i))) == create_set(create_array(hex(i)))) {
                col++;
                print(u"#7"_S.format(i), u"\n"_S[range_el(0, to_int(mod(col, 10) == 0))]);
            }
        print();
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Numerical_integration/Adaptive_Simpson%27s_method#Python
from typing import NamedTuple
import math

class Triple(NamedTuple):
    m : float
    fm : float
    simp : float

def _quad_simpsons_mem(f, a: float , fa: float, b: float, fb: float):
    '''
        Evaluates Simpson's Rule, also returning m and f(m) to reuse.
    '''
    m = a + (b - a) / 2
    fm = f(m)
    simp = abs(b - a) / 6 * (fa + 4*fm + fb)
    return Triple(m, fm, simp)

def _quad_asr(f, a: float, fa: float, b: float, fb: float, eps: float, whole: float, m: float, fm: float)->float:
    '''
        Efficient recursive implementation of adaptive Simpson's rule.
        Function values at the start, middle, end of the intervals are retained.
    '''
    lt = _quad_simpsons_mem(f, a, fa, m, fm)
    rt = _quad_simpsons_mem(f, m, fm, b, fb)
    delta = lt.simp + rt.simp - whole
    return (lt.simp + rt.simp + delta/15
        if (abs(delta) <= eps * 15) else
            _quad_asr(f, a, fa, m, fm, eps/2, lt.simp, lt.m, lt.fm) +
            _quad_asr(f, m, fm, b, fb, eps/2, rt.simp, rt.m, rt.fm)
    )

def quad_asr(f, a: float, b: float, eps: float)->float:
    '''
        Integrate f from a to b using ASR with max error of eps.
    '''
    fa = f(a)
    fb = f(b)
    t = _quad_simpsons_mem(f, a, fa, b, fb)
    return _quad_asr(f, a, fa, b, fb, eps, t.simp, t.m, t.fm)

(a, b) = (0.0, 1.0)
sinx = quad_asr(lambda x: math.sin(x), a, b, 1e-09)
print("Simpson's integration of sine from {} to {} = {}".format(a, b, sinx))
===
T Triple = (Float m, Float fm, Float simp)

F _quad_simpsons_mem(f, Float a, Float fa, Float b, Float fb)
   ‘
        Evaluates Simpson's Rule, also returning m and f(m) to reuse.
    ’
   V m = a + (b - a) / 2
   V fm = f(m)
   V simp = abs(b - a) / 6 * (fa + 4 * fm + fb)
   R Triple(m, fm, simp)

F _quad_asr(f, Float a, Float fa, Float b, Float fb, Float eps, Float whole, Float m, Float fm) -> Float
   ‘
        Efficient recursive implementation of adaptive Simpson's rule.
        Function values at the start, middle, end of the intervals are retained.
    ’
   V lt = _quad_simpsons_mem(f, a, fa, m, fm)
   V rt = _quad_simpsons_mem(f, m, fm, b, fb)
   V delta = lt.simp + rt.simp - whole
   R (I (abs(delta) <= eps * 15) {lt.simp + rt.simp + delta / 15} E _quad_asr(f, a, fa, m, fm, eps / 2, lt.simp, lt.m, lt.fm) + _quad_asr(f, m, fm, b, fb, eps / 2, rt.simp, rt.m, rt.fm))

F quad_asr(f, Float a, Float b, Float eps) -> Float
   ‘
        Integrate f from a to b using ASR with max error of eps.
    ’
   V fa = f(a)
   V fb = f(b)
   V t = _quad_simpsons_mem(f, a, fa, b, fb)
   R _quad_asr(f, a, fa, b, fb, eps, t.simp, t.m, t.fm)

V (a, b) = (0.0, 1.0)
V sinx = quad_asr(x -> sin(x), a, b, 1e-09)
print(‘Simpson's integration of sine from #. to #. = #.’.format(a, b, sinx))
===
class Triple
{
public:
    double m;
    double fm;
    double simp;

    Triple(const double &m, const double &fm, const double &simp) :
        m(m), fm(fm), simp(simp) {}
};

template <typename T1> auto _quad_simpsons_mem(const T1 &f, const double a, const double fa, const double b, const double fb)
{
    uR"(
        Evaluates Simpson's Rule, also returning m and f(m) to reuse.
    )"_S;
    auto m = a + (b - a) / 2.0;
    auto fm = f(m);
    auto simp = abs(b - a) / 6.0 * (fa + 4 * fm + fb);
    return Triple(m, fm, simp);
}

template <typename T1> double _quad_asr(const T1 &f, const double a, const double fa, const double b, const double fb, const double eps, const double whole, const double m, const double fm)
{
    uR"(
        Efficient recursive implementation of adaptive Simpson's rule.
        Function values at the start, middle, end of the intervals are retained.
    )"_S;
    auto lt = _quad_simpsons_mem(f, a, fa, m, fm);
    auto rt = _quad_simpsons_mem(f, m, fm, b, fb);
    auto delta = lt.simp + rt.simp - whole;
    return ((abs(delta) <= eps * 15) ? lt.simp + rt.simp + delta / 15.0 : _quad_asr(f, a, fa, m, fm, eps / 2.0, lt.simp, lt.m, lt.fm) + _quad_asr(f, m, fm, b, fb, eps / 2.0, rt.simp, rt.m, rt.fm));
}

template <typename T1> double quad_asr(const T1 &f, const double a, const double b, const double eps)
{
    uR"(
        Integrate f from a to b using ASR with max error of eps.
    )"_S;
    auto fa = f(a);
    auto fb = f(b);
    auto t = _quad_simpsons_mem(f, a, fa, b, fb);
    return _quad_asr(f, a, fa, b, fb, eps, t.simp, t.m, t.fm);
}

auto [a, b] = make_tuple(0.0, 1.0);
auto sinx = quad_asr([](const auto &x){return sin(x);}, a, b, 1e-09);

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"Simpson's integration of sine from #. to #. = #."_S.format(a, b, sinx));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Numerical_integration/Gauss-Legendre_Quadrature#Nim
import math

def legendreIn(x, n):
    def prev1(idx, pn1):
        return (2*idx - 1) * x * pn1
    def prev2(idx, pn2):
        return (idx-1) * pn2

    if n == 0:
        return 1.0
    elif n == 1:
        return x
    else:
        result = 0.0
        p1 = x
        p2 = 1.0
        for i in range(2, n + 1):
            result = (prev1(i, p1) - prev2(i, p2)) / i
            p2 = p1
            p1 = result
        return result

def deriveLegendreIn(x, n):
    def calcresult(curr, prev):
        return float(n) / (x**2 - 1) * (x * curr - prev)
    return calcresult(legendreIn(x, n), legendreIn(x, n-1))

def guess(n, i):
    return math.cos(math.pi * (i - 0.25) / (n + 0.5))

def nodes(n):
    result = [(0.0, 0.0)] * n
    def calc(x):
        return legendreIn(x, n) / deriveLegendreIn(x, n)

    for i in range(n):
        x = guess(n, i+1)
        x0 = x
        x -= calc(x)
        while abs(x-x0) > 1e-12:
            x0 = x
            x -= calc(x)

        result[i] = (x, 2 / ((1.0 - x**2) * (deriveLegendreIn(x, n))**2))

    return result

def integ(f, ns, p1, p2):
    def dist():
        return (p2 - p1) / 2
    def avg():
        return (p1 + p2) / 2
    result = dist()
    sum = 0.0
    thenodes = [0.0] * ns
    weights  = [0.0] * ns
    for i, nw in enumerate(nodes(ns)):
        sum += nw[1] * f(dist() * nw[0] + avg())
        thenodes[i] = nw[0]
        weights[i] = nw[1]

    print('   nodes:', end = '')
    for n in thenodes:
        print(' %6.5f' % n, end = '')
    print()
    print(' weights:', end = '')
    for w in weights:
        print(' %6.5f' % w, end = '')
    print()
    return result * sum

print('integral:', integ(lambda x: math.exp(x), 5, -3, 3))
===
F legendreIn(x, n)
   F prev1(idx, pn1)
      R (2 * idx - 1) * @x * pn1
   F prev2(idx, pn2)
      R (idx - 1) * pn2

   I n == 0
      R 1.0
   E I n == 1
      R x
   E
      V result = 0.0
      V p1 = x
      V p2 = 1.0
      L(i) 2 .. n
         result = (prev1(i, p1) - prev2(i, p2)) / i
         p2 = p1
         p1 = result
      R result

F deriveLegendreIn(x, n)
   F calcresult(curr, prev)
      R Float(@n) / (@x ^ 2 - 1) * (@x * curr - prev)
   R calcresult(legendreIn(x, n), legendreIn(x, n - 1))

F guess(n, i)
   R cos(math:pi * (i - 0.25) / (n + 0.5))

F nodes(n)
   V result = [(0.0, 0.0)] * n
   F calc(x)
      R legendreIn(x, @n) / deriveLegendreIn(x, @n)

   L(i) 0 .< n
      V x = guess(n, i + 1)
      V x0 = x
      x -= calc(x)
      L abs(x - x0) > 1e-12
         x0 = x
         x -= calc(x)

      result[i] = (x, 2 / ((1.0 - x ^ 2) * (deriveLegendreIn(x, n)) ^ 2))

   R result

F integ(f, ns, p1, p2)
   F dist()
      R (@p2 - @p1) / 2
   F avg()
      R (@p1 + @p2) / 2
   V result = dist()
   V sum = 0.0
   V thenodes = [0.0] * ns
   V weights = [0.0] * ns
   L(nw) nodes(ns)
      V i = L.index
      sum += nw[1] * f(dist() * nw[0] + avg())
      thenodes[i] = nw[0]
      weights[i] = nw[1]

   print(‘   nodes:’, end' ‘’)
   L(n) thenodes
      print(‘ #.5’.format(n), end' ‘’)
   print()
   print(‘ weights:’, end' ‘’)
   L(w) weights
      print(‘ #.5’.format(w), end' ‘’)
   print()
   R result * sum

print(‘integral: ’integ(x -> exp(x), 5, -3, 3))
===
template <typename T1, typename T2> auto legendreIn(const T1 &x, const T2 &n)
{
    auto prev1 = [&x](const auto &idx, const auto &pn1)
    {
        return (2 * idx - 1) * x * pn1;
    };
    auto prev2 = [](const auto &idx, const auto &pn2)
    {
        return (idx - 1) * pn2;
    };

    if (n == 0)
        return 1.0;
    else if (n == 1)
        return x;
    else {
        auto result = 0.0;
        auto p1 = x;
        auto p2 = 1.0;
        for (auto i : range_ee(2, n)) {
            result = (prev1(i, p1) - prev2(i, p2)) / i;
            p2 = p1;
            p1 = result;
        }
        return result;
    }
}

template <typename T1, typename T2> auto deriveLegendreIn(const T1 &x, const T2 &n)
{
    auto calcresult = [&n, &x](const auto &curr, const auto &prev)
    {
        return to_float(n) / (square(x) - 1) * (x * curr - prev);
    };
    return calcresult(legendreIn(x, n), legendreIn(x, n - 1));
}

template <typename T1, typename T2> auto guess(const T1 &n, const T2 &i)
{
    return cos(math::pi * (i - 0.25) / (n + 0.5));
}

template <typename T1> auto nodes(const T1 &n)
{
    auto result = create_array({make_tuple(0.0, 0.0)}) * n;
    auto calc = [&n](const auto &x)
    {
        return legendreIn(x, n) / deriveLegendreIn(x, n);
    };

    for (auto i : range_el(0, n)) {
        auto x = guess(n, i + 1);
        auto x0 = x;
        x -= calc(x);
        while (abs(x - x0) > 1e-12) {
            x0 = x;
            x -= calc(x);
        }

        result.set(i, make_tuple(x, 2.0 / ((1.0 - square(x)) * square((deriveLegendreIn(x, n))))));
    }

    return result;
}

template <typename T1, typename T2, typename T3, typename T4> auto integ(const T1 &f, const T2 &ns, const T3 &p1, const T4 &p2)
{
    auto dist = [&p1, &p2]()
    {
        return (p2 - p1) / 2.0;
    };
    auto avg = [&p1, &p2]()
    {
        return (p1 + p2) / 2.0;
    };
    auto result = dist();
    auto sum = 0.0;
    auto thenodes = create_array({0.0}) * ns;
    auto weights = create_array({0.0}) * ns;
    {int Lindex = 0;
    for (auto &&nw : nodes(ns)) {
        auto i = Lindex;
        sum += _get<1>(nw) * f(dist() * _get<0>(nw) + avg());
        thenodes.set(i, _get<0>(nw));
        weights.set(i, _get<1>(nw));
        Lindex++;
    }}

    print(u"   nodes:"_S, u""_S);
    for (auto &&n : thenodes)
        print(u" #.5"_S.format(n), u""_S);
    print();
    print(u" weights:"_S, u""_S);
    for (auto &&w : weights)
        print(u" #.5"_S.format(w), u""_S);
    print();
    return result * sum;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"integral: "_S & integ([](const auto &x){return exp(x);}, 5, -3, 3));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Numbers_in_base-16_representation_that_cannot_be_written_with_decimal_digits
from _11l import *

for n in range(1, 500):
    for c in hexu(n):
        if c.isdigit():
            break
    else:
        print(n, end = ' ')
===
L(n) 1..499
   L(c) hex(n)
      I c.is_digit()
         L.break
   L.was_no_break
      print(n, end' ‘ ’)
===
struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto n : range_ee(1, 499)) {
            for (auto &&c : hex(n))
                if (c.is_digit())
                    goto break_;
            print(n, u" "_S);
            break_:;
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Next_special_primes#FreeBASIC
import math

def is_prime(a):
    if a == 2: return True
    if a < 2 or a % 2 == 0: return False
    for i in range(3, int(math.sqrt(a)) + 1, 2):
        if a % i == 0:
            return False
    return True

p = 3
i = 2
print('2 3', end = ' ') # special case

while p + i < 1050:
    if is_prime(p + i):
        p += i
        print(p, end = ' ')
    i += 2
===
F is_prime(a)
   I a == 2
      R 1B
   I a < 2 | a % 2 == 0
      R 0B
   L(i) (3 .. Int(sqrt(a))).step(2)
      I a % i == 0
         R 0B
   R 1B

V p = 3
V i = 2
print(‘2 3’, end' ‘ ’)

L p + i < 1050
   I is_prime(p + i)
      p += i
      print(p, end' ‘ ’)
   i += 2
===
template <typename T1> auto is_prime(const T1 &a)
{
    if (a == 2)
        return true;
    if (a < 2 || mod(a, 2) == 0)
        return false;
    for (auto i : range_ee(3, to_int(sqrt(a))).step(2))
        if (mod(a, i) == 0)
            return false;
    return true;
}

auto p = 3;
auto i = 2;

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"2 3"_S, u" "_S);

        while (p + i < 1050) {
            if (is_prime(p + i)) {
                p += i;
                print(p, u" "_S);
            }
            i += 2;
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Nice_primes#C.2B.2B
import math

def is_prime(a):
    if a == 2: return True
    if a < 2 or a % 2 == 0: return False
    for i in range(3, int(math.sqrt(a)) + 1, 2):
        if a % i == 0:
            return False
    return True

def digital_root(n):
    return 1 + (n - 1) % 9

for n in range(501, 1000):
    if is_prime(digital_root(n)) and is_prime(n):
        print(n, end = ' ')
===
F is_prime(a)
   I a == 2
      R 1B
   I a < 2 | a % 2 == 0
      R 0B
   L(i) (3 .. Int(sqrt(a))).step(2)
      I a % i == 0
         R 0B
   R 1B

F digital_root(n)
   R 1 + (n - 1) % 9

L(n) 501..999
   I is_prime(digital_root(n)) & is_prime(n)
      print(n, end' ‘ ’)
===
template <typename T1> auto is_prime(const T1 &a)
{
    if (a == 2)
        return true;
    if (a < 2 || mod(a, 2) == 0)
        return false;
    for (auto i : range_ee(3, to_int(sqrt(a))).step(2))
        if (mod(a, i) == 0)
            return false;
    return true;
}

template <typename T1> auto digital_root(const T1 &n)
{
    return 1 + mod((n - 1), 9);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto n : range_ee(501, 999))
            if (is_prime(digital_root(n)) && is_prime(n))
                print(n, u" "_S);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Numbers_whose_count_of_divisors_is_prime#FreeBASIC
import math

def is_prime(a):
    if a == 2: return True
    if a < 2 or a % 2 == 0: return False
    for i in range(3, int(math.sqrt(a)) + 1, 2):
        if a % i == 0:
            return False
    return True

print('Numbers which count of divisors is prime are:')
row = 0

for n in range(1, 100000):
    num = 0
    for m in range(1, n + 1):
        if n % m == 0:
            num += 1
    if is_prime(num) and num != 2:
        print('%6d' % n, end = ' ')
        row += 1
        if row % 5 == 0:
            print()

print("\n\nFound", row, 'numbers')
===
F is_prime(a)
   I a == 2
      R 1B
   I a < 2 | a % 2 == 0
      R 0B
   L(i) (3 .. Int(sqrt(a))).step(2)
      I a % i == 0
         R 0B
   R 1B

print(‘Numbers which count of divisors is prime are:’)
V row = 0

L(n) 1..99999
   V num = 0
   L(m) 1 .. n
      I n % m == 0
         num++
   I is_prime(num) & num != 2
      print(‘#6’.format(n), end' ‘ ’)
      row++
      I row % 5 == 0
         print()

print("\n\nFound "row‘ numbers’)
===
template <typename T1> auto is_prime(const T1 &a)
{
    if (a == 2)
        return true;
    if (a < 2 || mod(a, 2) == 0)
        return false;
    for (auto i : range_ee(3, to_int(sqrt(a))).step(2))
        if (mod(a, i) == 0)
            return false;
    return true;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"Numbers which count of divisors is prime are:"_S);
    }
} code_block_1;

auto row = 0;

struct CodeBlock2
{
    CodeBlock2()
    {
        for (auto n : range_ee(1, 99999)) {
            auto num = 0;
            for (auto m : range_ee(1, n))
                if (mod(n, m) == 0)
                    num++;
            if (is_prime(num) && num != 2) {
                print(u"#6"_S.format(n), u" "_S);
                row++;
                if (mod(row, 5) == 0)
                    print();
            }
        }

        print(u"\n\nFound "_S & row & u" numbers"_S);
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Numbers_with_prime_digits_whose_sum_is_13#C
def primeDigitsSum13(n):
    sum = 0
    while n > 0:
        r = n % 10
        if r not in (2, 3, 5, 7):
            return False
        n //= 10
        sum += r
    return sum == 13

c = 0
for i in range(1, 1_000_000):
    if primeDigitsSum13(i):
        print('%6d' % i, end = ' ')
        c += 1
        if c == 11:
            c = 0
            print()
print()
===
F primeDigitsSum13(=n)
   V sum = 0
   L n > 0
      V r = n % 10
      I r !C (2, 3, 5, 7)
         R 0B
      n I/= 10
      sum += r
   R sum == 13

V c = 0
L(i) 1..999999
   I primeDigitsSum13(i)
      print(‘#6’.format(i), end' ‘ ’)
      c++
      I c == 11
         c = 0
         print()
print()
===
template <typename T1> auto primeDigitsSum13(T1 n)
{
    auto sum = 0;
    while (n > 0) {
        auto r = mod(n, 10);
        if (!in(r, make_tuple(2, 3, 5, 7)))
            return false;
        n = idiv(n, 10);
        sum += r;
    }
    return sum == 13;
}

auto c = 0;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto i : range_ee(1, 999999))
            if (primeDigitsSum13(i)) {
                print(u"#6"_S.format(i), u" "_S);
                c++;
                if (c == 11) {
                    c = 0;
                    print();
                }
            }
        print();
    }
} code_block_1;


# https://rosettacode.org/wiki/Neighbour_primes#Python
def isPrime(n):
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

print("p        q       pq+2")
print("-----------------------")
for p in range(2, 499):
    if not isPrime(p):
        continue
    q = p + 1
    while not isPrime(q):
        q += 1
    if not isPrime(2 + p*q):
        continue
    print(p, "\t", q, "\t", 2+p*q)
===
F isPrime(n)
   L(i) 2 .. Int(n ^ 0.5)
      I n % i == 0
         R 0B
   R 1B

print(‘p        q       pq+2’)
print(‘-----------------------’)
L(p) 2..498
   I !isPrime(p)
      L.continue
   V q = p + 1
   L !isPrime(q)
      q++
   I !isPrime(2 + p * q)
      L.continue
   print(p" \t "q" \t "(2 + p * q))
===
template <typename T1> auto isPrime(const T1 &n)
{
    for (auto i : range_ee(2, to_int(pow(n, 0.5))))
        if (mod(n, i) == 0)
            return false;
    return true;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"p        q       pq+2"_S);
        print(u"-----------------------"_S);
        for (auto p : range_ee(2, 498)) {
            if (!isPrime(p))
                continue;
            auto q = p + 1;
            while (!isPrime(q))
                q++;
            if (!isPrime(2 + p * q))
                continue;
            print(p & u" \t "_S & q & u" \t "_S & (2 + p * q));
        }
    }
} code_block_1;


# https://rosettacode.org/wiki/Numbers_which_are_the_cube_roots_of_the_product_of_their_proper_divisors
import math, itertools
Int64 = int

def product_of_proper_divisors(n):
    prod = Int64(1)
    for d in range(2, int(math.sqrt(n)+1)):
        if n % d == 0:
            prod *= d
            otherD = n // d
            if otherD != d:
                prod *= otherD
    return prod

print('First 50 numbers which are the cube roots of the products of their proper divisors:')
found = 0
for num in itertools.count(1):
    if Int64(num) ** 3 == product_of_proper_divisors(num):
        found += 1
        if found <= 50:
            print(f'{num:3}', end = "\n" if found % 10 == 0 else ' ')
        elif found in (500, 5000, 50000):
            print(f'{found:6,}th: {num:,}')
            if found == 50000:
                break
===
F product_of_proper_divisors(n)
   V prod = Int64(1)
   L(d) 2 .< Int(sqrt(n) + 1)
      I n % d == 0
         prod *= d
         V otherD = n I/ d
         I otherD != d
            prod *= otherD
   R prod

print(‘First 50 numbers which are the cube roots of the products of their proper divisors:’)
V found = 0
L(num) 1..
   I Int64(num) ^ 3 == product_of_proper_divisors(num)
      found++
      I found <= 50
         print(f:‘{num:3}’, end' I found % 10 == 0 {"\n"} E ‘ ’)
      E I found C (500, 5000, 50000)
         print(f:‘{commatize(found):6}th: {commatize(num)}’)
         I found == 50000
            L.break
===
template <typename T1> auto product_of_proper_divisors(const T1 &n)
{
    auto prod = to_int64(1);
    for (auto d : range_el(2, to_int(sqrt(n) + 1)))
        if (mod(n, d) == 0) {
            prod *= d;
            auto otherD = idiv(n, d);
            if (otherD != d)
                prod *= otherD;
        }
    return prod;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"First 50 numbers which are the cube roots of the products of their proper divisors:"_S);
    }
} code_block_1;

auto found = 0;

struct CodeBlock2
{
    CodeBlock2()
    {
        for (auto num : range_ei(1))
            if (cube(to_int64(num)) == product_of_proper_divisors(num)) {
                found++;
                if (found <= 50)
                    print(u"#3"_S.format(num), mod(found, 10) == 0 ? u'\n'_C : u' '_C);
                else if (in(found, make_tuple(500, 5000, 50000))) {
                    print(u"#6th: #."_S.format(commatize(found), commatize(num)));
                    if (found == 50000)
                        break;
                }
            }
    }
} code_block_2;