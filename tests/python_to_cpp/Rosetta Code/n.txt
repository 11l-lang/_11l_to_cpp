# https://www.rosettacode.org/wiki/N%27th#Python
_suffix = ['th', 'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th']

def nth(n):
    return "%i'%s" % (n, _suffix[n%10] if n % 100 <= 10 or n % 100 > 20 else 'th')

for j in range(0, 1001, 250):
    print(*(nth(i) for i in list(range(j, j+25))))
===
V _suffix = [‘th’, ‘st’, ‘nd’, ‘rd’, ‘th’, ‘th’, ‘th’, ‘th’, ‘th’, ‘th’]

F nth(n)
   R ‘#.'#.’.format(n, I n % 100 <= 10 | n % 100 > 20 {:_suffix[n % 10]} E ‘th’)

L(j) (0.<1001).step(250)
   print_elements((Array(j .< j + 25).map(i -> nth(i))))
===
auto _suffix = create_array({u"th"_S, u"st"_S, u"nd"_S, u"rd"_S, u"th"_S, u"th"_S, u"th"_S, u"th"_S, u"th"_S, u"th"_S});

template <typename T1> auto nth(const T1 &n)
{
    return u"#.'#."_S.format(n, mod(n, 100) <= 10 || mod(n, 100) > 20 ? ::_suffix[mod(n, 10)] : u"th"_S);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto j : range_el(0, 1001).step(250))
            print_elements((create_array(range_el(j, j + 25)).map([](const auto &i){return nth(i);})));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Narcissistic_decimal_number#Python
import itertools

def narcissists(m):
    result : List[int] = []
    for digits in itertools.count(0):
        digitpowers = [i**digits for i in range(10)]
        for n in range(int(10**(digits-1)), 10**digits):
            (div, digitpsum) = (n, 0)
            while div != 0:
                (div, mod) = divmod(div, 10)
                digitpsum += digitpowers[mod]
            if n == digitpsum:
                result += [n]
                if len(result) == m:
                    return result

for i, n in enumerate(narcissists(25), 1):
    print(n, end = ' ')
    if i % 5 == 0: print()
===
F narcissists(m)
   [Int] result
   L(digits) 0..
      V digitpowers = (0.<10).map(i -> i ^ @digits)
      L(n) Int(10 ^ (digits - 1)) .< 10 ^ digits
         V (div, digitpsum) = (n, 0)
         L div != 0
            (div, V mod) = divmod(div, 10)
            digitpsum += digitpowers[mod]
         I n == digitpsum
            result [+]= n
            I result.len == m
               R result

L(n) narcissists(25)
   V i = L.index + 1
   print(n, end' ‘ ’)
   I i % 5 == 0
      print()
===
template <typename T1> auto narcissists(const T1 &m)
{
    Array<int> result;
    for (auto digits : range_ei(0)) {
        auto digitpowers = range_el(0, 10).map([&digits](const auto &i){return pow(i, digits);});
        for (auto n : range_el(to_int(pow(10, (digits - 1))), pow(10, digits))) {
            auto [div, digitpsum] = make_tuple(n, 0);
            while (div != 0) {
                TUPLE_ELEMENT_T(1, divmod(div, 10)) mod;
                assign_from_tuple(div, mod, divmod(div, 10));
                digitpsum += digitpowers[mod];
            }
            if (n == digitpsum) {
                result.append(n);
                if (result.len() == m)
                    return result;
            }
        }
    }
}

struct CodeBlock1
{
    CodeBlock1()
    {
        {int Lindex = 0;

        for (auto &&n : narcissists(25)) {
            auto i = Lindex + 1;
            print(n, u" "_S);
            if (mod(i, 5) == 0)
                print();
            Lindex++;
        }}
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Negative_base_numbers#Python
def encode_neg_base(n, b): #Converts from decimal
    if n == 0:
        return "0"
    out : List[int] = []
    while n != 0:
        (n, rem) = divmod(n, b)
        if rem < 0:
            n += 1
            rem -= b
        out.append(rem)
    return "".join(map(str, out[::-1]))

def decode_neg_base(nstr, b): #Converts to decimal
    if nstr == "0":
        return 0

    total = 0
    for i, ch in enumerate(nstr[::-1]):
        total += int(ch) * b**i
    return total

print ("Encode 10 as negabinary (expect 11110)")
result = encode_neg_base(10, -2)
print (result)
if decode_neg_base(result, -2) == 10: print ("Converted back to decimal")
else: print ("Error converting back to decimal")

print ("Encode 146 as negaternary (expect 21102)")
result = encode_neg_base(146, -3)
print (result)
if decode_neg_base(result, -3) == 146: print ("Converted back to decimal")
else: print ("Error converting back to decimal")

print ("Encode 15 as negadecimal (expect 195)")
result = encode_neg_base(15, -10)
print (result)
if decode_neg_base(result, -10) == 15: print ("Converted back to decimal")
else: print ("Error converting back to decimal")
===
F encode_neg_base(=n, b)
   I n == 0
      R ‘0’
   [Int] out
   L n != 0
      (n, V rem) = divmod(n, b)
      I rem < 0
         n++
         rem -= b
      out.append(rem)
   R reversed(out).map(String).join(‘’)

F decode_neg_base(nstr, b)
   I nstr == ‘0’
      R 0

   V total = 0
   L(ch) reversed(nstr)
      V i = L.index
      total += Int(ch) * b ^ i
   R total

print(‘Encode 10 as negabinary (expect 11110)’)
V result = encode_neg_base(10, -2)
print(result)
I decode_neg_base(result, -2) == 10
   print(‘Converted back to decimal’)
E
   print(‘Error converting back to decimal’)

print(‘Encode 146 as negaternary (expect 21102)’)
result = encode_neg_base(146, -3)
print(result)
I decode_neg_base(result, -3) == 146
   print(‘Converted back to decimal’)
E
   print(‘Error converting back to decimal’)

print(‘Encode 15 as negadecimal (expect 195)’)
result = encode_neg_base(15, -10)
print(result)
I decode_neg_base(result, -10) == 15
   print(‘Converted back to decimal’)
E
   print(‘Error converting back to decimal’)
===
template <typename T1, typename T2> auto encode_neg_base(T1 n, const T2 &b)
{
    if (n == 0)
        return u"0"_S;
    Array<int> out;
    while (n != 0) {
        TUPLE_ELEMENT_T(1, divmod(n, b)) rem;
        assign_from_tuple(n, rem, divmod(n, b));
        if (rem < 0) {
            n++;
            rem -= b;
        }
        out.append(rem);
    }
    return reversed(out).map([](const auto &x){return String(x);}).join(u""_S);
}

template <typename T1, typename T2> auto decode_neg_base(const T1 &nstr, const T2 &b)
{
    if (nstr == u'0')
        return 0;

    auto total = 0;
    {int Lindex = 0;
    for (auto &&ch : reversed(nstr)) {
        auto i = Lindex;
        total += to_int(ch) * pow(b, i);
        Lindex++;
    }}
    return total;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"Encode 10 as negabinary (expect 11110)"_S);
    }
} code_block_1;

auto result = encode_neg_base(10, -2);

struct CodeBlock2
{
    CodeBlock2()
    {
        print(result);
        if (decode_neg_base(result, -2) == 10)
            print(u"Converted back to decimal"_S);
        else
            print(u"Error converting back to decimal"_S);

        print(u"Encode 146 as negaternary (expect 21102)"_S);
        result = encode_neg_base(146, -3);
        print(result);
        if (decode_neg_base(result, -3) == 146)
            print(u"Converted back to decimal"_S);
        else
            print(u"Error converting back to decimal"_S);

        print(u"Encode 15 as negadecimal (expect 195)"_S);
        result = encode_neg_base(15, -10);
        print(result);
        if (decode_neg_base(result, -10) == 15)
            print(u"Converted back to decimal"_S);
        else
            print(u"Error converting back to decimal"_S);
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Nested_function#Python
def makeList(separator):
    counter = 1

    def makeItem(item):
        nonlocal counter
        result = str(counter) + separator + '' + item + "\n"
        counter += 1
        return result

    return makeItem("first") + '' + makeItem("second") + '' + makeItem("third")

print(makeList(". "))
===
F makeList(separator)
   V counter = 1

   F makeItem(item)
      V result = String(@counter)‘’@separator‘’item"\n"
      @counter++
      R result

   R makeItem(‘first’)‘’makeItem(‘second’)‘’makeItem(‘third’)

print(makeList(‘. ’))
===
template <typename T1> auto makeList(const T1 &separator)
{
    auto counter = 1;

    auto makeItem = [&counter, &separator](const auto &item)
    {
        auto result = String(counter) & separator & item & u"\n"_S;
        counter++;
        return result;
    };

    return makeItem(u"first"_S) & makeItem(u"second"_S) & makeItem(u"third"_S);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(makeList(u". "_S));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Nim_game#Python
tokens = 12

def getTokens(curTokens) -> None:
    global tokens

    print("How many tokens would you like to take? ", end='')
    take = int(input())

    if take < 1 or take > 3:
        print("Number must be between 1 and 3.\n")
        getTokens(curTokens)
        return

    tokens = curTokens - take
    print('You take %i tokens.' % take)
    print('%i tokens remaining.\n' % tokens)

def compTurn(curTokens):
    global tokens

    take = curTokens % 4
    tokens = curTokens - take
    print('Computer takes %i tokens.' % take)
    print('%i tokens remaining.\n' % tokens)

while tokens > 0:
    getTokens(tokens)
    compTurn(tokens)

print("Computer wins!")
===
V tokens = 12

F getTokens(curTokens) -> N

   print(‘How many tokens would you like to take? ’, end' ‘’)
   V take = Int(input())

   I take < 1 | take > 3
      print("Number must be between 1 and 3.\n")
      getTokens(curTokens)
      R

   :tokens = curTokens - take
   print(‘You take #. tokens.’.format(take))
   print("#. tokens remaining.\n".format(:tokens))

F compTurn(curTokens)

   V take = curTokens % 4
   :tokens = curTokens - take
   print(‘Computer takes #. tokens.’.format(take))
   print("#. tokens remaining.\n".format(:tokens))

L tokens > 0
   getTokens(tokens)
   compTurn(tokens)

print(‘Computer wins!’)
===
auto tokens = 12;

template <typename T1> void getTokens(const T1 &curTokens)
{

    print(u"How many tokens would you like to take? "_S, u""_S);
    auto take = to_int(input());

    if (take < 1 || take > 3) {
        print(u"Number must be between 1 and 3.\n"_S);
        getTokens(curTokens);
        return;
    }

    ::tokens = curTokens - take;
    print(u"You take #. tokens."_S.format(take));
    print(u"#. tokens remaining.\n"_S.format(::tokens));
}

template <typename T1> auto compTurn(const T1 &curTokens)
{

    auto take = mod(curTokens, 4);
    ::tokens = curTokens - take;
    print(u"Computer takes #. tokens."_S.format(take));
    print(u"#. tokens remaining.\n"_S.format(::tokens));
}

struct CodeBlock1
{
    CodeBlock1()
    {
        while (tokens > 0) {
            getTokens(tokens);
            compTurn(tokens);
        }

        print(u"Computer wins!"_S);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Non-continuous_subsequences#Python
def ncsub(seq, s=0):
    if len(seq) == 0:
        r : List[List[int]] = []
        if s >= 3:
            l : List[int] = []
            r.append(l)
        return r
    else:
        x = seq[:1]
        xs = seq[1:]
        p2 = s % 2
        p1 = not p2
        return [x + ys for ys in ncsub(xs, s + p1)] + ncsub(xs, s + p2)

print(ncsub(list(range(1, 4))))
print(ncsub(list(range(1, 5))))
print(ncsub(list(range(1, 6))))
===
F ncsub(seq, s = 0)
   I seq.empty
      [[Int]] r
      I s >= 3
         [Int] l
         r.append(l)
      R r
   E
      V x = seq[0.<1]
      V xs = seq[1..]
      V p2 = s % 2
      V p1 = !p2
      R ncsub(xs, s + p1).map(ys -> @x + ys) [+] ncsub(xs, s + p2)

print(ncsub(Array(1..3)))
print(ncsub(Array(1..4)))
print(ncsub(Array(1..5)))
===
template <typename T1, typename T2 = decltype(0)> auto ncsub(const T1 &seq, const T2 &s = 0)
{
    if (seq.empty()) {
        Array<Array<int>> r;
        if (s >= 3) {
            Array<int> l;
            r.append(l);
        }
        return r;
    }
    else {
        auto x = seq[range_el(0, 1)];
        auto xs = seq[range_ei(1)];
        auto p2 = mod(s, 2);
        auto p1 = !p2;
        return ncsub(xs, s + p1).map([&x](const auto &ys){return x + ys;}) + ncsub(xs, s + p2);
    }
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(ncsub(create_array(range_ee(1, 3))));
        print(ncsub(create_array(range_ee(1, 4))));
        print(ncsub(create_array(range_ee(1, 5))));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Non-decimal_radices/Input#Python
s = '100'
for base in range(2,21):
    print("String '%s' in base %i is %i in base 10"
        % (s, base, int(s, base)))
===
V s = ‘100’
L(base) 2..20
   print(‘String '#.' in base #. is #. in base 10’.format(s, base, Int(s, radix' base)))
===
auto s = u"100"_S;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto base : range_ee(2, 20))
            print(u"String '#.' in base #. is #. in base 10"_S.format(s, base, to_int(s, base)));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Nth_root#Nim
def nthroot(a, n):
    result = a
    x = a / n
    while abs(result-x) > 10e-15:
        x = result
        result = (1.0/n) * (((n-1)*x) + (a / pow(x, n-1)))
    return result

print(nthroot(34.0, 5))
print(nthroot(42.0, 10))
print(nthroot(5.0, 2))
===
F nthroot(a, n)
   V result = a
   V x = a / n
   L abs(result - x) > 10e-15
      x = result
      result = (1.0 / n) * (((n - 1) * x) + (a / pow(x, n - 1)))
   R result

print(nthroot(34.0, 5))
print(nthroot(42.0, 10))
print(nthroot(5.0, 2))
===
template <typename T1, typename T2> auto nthroot(const T1 &a, const T2 &n)
{
    auto result = a;
    auto x = a / n;
    while (abs(result - x) > 10e-15) {
        x = result;
        result = (1.0 / n) * (((n - 1) * x) + (a / pow(x, n - 1)));
    }
    return result;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(nthroot(34.0, 5));
        print(nthroot(42.0, 10));
        print(nthroot(5.0, 2));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Number_reversal_game#Python
data = list('139275486')
trials = 0

while data != sorted(data):
    trials += 1
    flip = int(input("#%2i: LIST: '%s' Flip how many?: " % (trials, ' '.join(data))))
    data[:flip] = reversed(data[:flip])

print('\nYou took %i attempts to put the digits in order!' % trials)
===
V data = Array(‘139275486’)
V trials = 0

L data != sorted(data)
   trials++
   V flip = Int(input(‘###2: LIST: '#.' Flip how many?: ’.format(trials, data.join(‘ ’))))
   data.reverse_range(0 .< flip)

print("\nYou took #. attempts to put the digits in order!".format(trials))
===
auto data = create_array(u"139275486"_S);
auto trials = 0;

struct CodeBlock1
{
    CodeBlock1()
    {
        while (data != sorted(data)) {
            trials++;
            auto flip = to_int(input(u"###2: LIST: '#.' Flip how many?: "_S.format(trials, data.join(u" "_S))));
            data.reverse_range(range_el(0, flip));
        }

        print(u"\nYou took #. attempts to put the digits in order!"_S.format(trials));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Numbers_with_equal_rises_and_falls#Python
def riseEqFall(num):
    """Check whether a number belongs to sequence A296712."""
    height = 0
    d1 = num % 10
    num //= 10
    while num != 0:
        d2 = num % 10
        height += (d1<d2) - (d1>d2)
        d1 = d2
        num //= 10
    return height == 0

num = 0
def nextNum():
    global num
    while True:
        num += 1
        if riseEqFall(num):
            break
    return num

print('The first 200 numbers are:')
for i in range(200):
    print(nextNum(), end = ' ')
print()

for i in range(10_000_000 - 200 - 1):
    nextNum()
print('The 10,000,000th number is:', nextNum())
===
F riseEqFall(=num)
   ‘Check whether a number belongs to sequence A296712.’
   V height = 0
   V d1 = num % 10
   num I/= 10
   L num != 0
      V d2 = num % 10
      height += (d1 < d2) - (d1 > d2)
      d1 = d2
      num I/= 10
   R height == 0

V num = 0
F nextNum()
   L
      :num++
      I riseEqFall(:num)
         L.break
   R :num

print(‘The first 200 numbers are:’)
L(i) 200
   print(nextNum(), end' ‘ ’)
print()

L(i) 0 .< 10'000'000 - 200 - 1
   nextNum()
print(‘The 10,000,000th number is: ’nextNum())
===
template <typename T1> auto riseEqFall(T1 num)
{
    u"Check whether a number belongs to sequence A296712."_S;
    auto height = 0;
    auto d1 = mod(num, 10);
    num = idiv(num, 10);
    while (num != 0) {
        auto d2 = mod(num, 10);
        height += (d1 < d2) - (d1 > d2);
        d1 = d2;
        num = idiv(num, 10);
    }
    return height == 0;
}

auto num = 0;
auto nextNum()
{
    while (true) {
        ::num++;
        if (riseEqFall(::num))
            break;
    }
    return ::num;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"The first 200 numbers are:"_S);
        for (int i = 0; i < 200; i++)
            print(nextNum(), u" "_S);
        print();

        for (auto i : range_el(0, 10'000'000 - 200 - 1))
            nextNum();
        print(u"The 10,000,000th number is: "_S & nextNum());
    }
} code_block_1;


# https://www.rosettacode.org/wiki/NYSIIS#Python
import re

_vowels = 'AEIOU'

def replace_at(text : str, position, fromlist, tolist):
    for f, t in zip(fromlist, tolist):
        if text[position:position+len(f)] == f:
            return text[:position] + t + text[position+len(f):]
    return text

def replace_end(text : str, fromlist, tolist):
    for f, t in zip(fromlist, tolist):
        if text.endswith(f):
            return text[:-len(f)] + t
    return text

def nysiis(name : str):
    name = re.sub(r'\W', '', name).upper()
    name = replace_at(name, 0, ['MAC', 'KN', 'K', 'PH', 'PF', 'SCH'],
                               ['MCC', 'N',  'C', 'FF', 'FF', 'SSS'])
    name = replace_end(name, ['EE', 'IE', 'DT', 'RT', 'RD', 'NT', 'ND'],
                             ['Y',  'Y',  'D',  'D',  'D',  'D',  'D'])
    key = str(name[0])
    key1 = ''
    i = 1
    while i < len(name):
        #print(i, name, key1, key)
        (n_1, n) = (name[i-1], name[i])
        n1_ = name[i+1] if i+1 < len(name) else ''
        name = replace_at(name, i, ['EV'] + list(map(str, list(_vowels))), ['AF'] + [str('A')]*5)
        name = replace_at(name, i, [str('Q'), 'Z', 'M'], [str('G'), 'S', 'N'])
        name = replace_at(name, i, ['KN', 'K'], [str('N'), 'C'])
        name = replace_at(name, i, ['SCH', 'PH'], ['SSS', 'FF'])
        if n == 'H' and (n_1 not in _vowels or n1_ not in _vowels):
            name = name[:i] + n_1 + name[i+1:]
        if n == 'W' and n_1 in _vowels:
            name = name[:i] + 'A' + name[i+1:]
        if key != '' and key[-1] != name[i]:
            key += name[i]
        i += 1
    key = replace_end(key, ['S', 'AY', 'A'], ['', 'Y', ''])
    return key1 + key

names = ['Bishop', 'Carlson', 'Carr', 'Chapman', 'Franklin',
         'Greene', 'Harper', 'Jacobs', 'Larson', 'Lawrence',
         'Lawson', 'Louis, XVI', 'Lynch', 'Mackenzie', 'Matthews',
         'McCormack', 'McDaniel', 'McDonald', 'Mclaughlin', 'Morrison',
         "O'Banion", "O'Brien", 'Richards', 'Silva', 'Watkins',
         'Wheeler', 'Willis', 'brown, sr', 'browne, III', 'browne, IV',
         'knight', 'mitchell', "o'daniel"]
for name in names:
    print('%15s: %s' % (name, nysiis(name)))
===
V _vowels = ‘AEIOU’

F replace_at(String text; position, fromlist, tolist)
   L(f, t) zip(fromlist, tolist)
      I text[position .< position + f.len] == f
         R text[0 .< position]‘’t‘’text[position + f.len ..]
   R text

F replace_end(String text; fromlist, tolist)
   L(f, t) zip(fromlist, tolist)
      I text.ends_with(f)
         R text[0 .< (len)-f.len]‘’t
   R text

F nysiis(String =name)
   name = name.replace(re:‘\W’, ‘’).uppercase()
   name = replace_at(name, 0, [‘MAC’, ‘KN’, ‘K’, ‘PH’, ‘PF’, ‘SCH’], [‘MCC’, ‘N’, ‘C’, ‘FF’, ‘FF’, ‘SSS’])
   name = replace_end(name, [‘EE’, ‘IE’, ‘DT’, ‘RT’, ‘RD’, ‘NT’, ‘ND’], [‘Y’, ‘Y’, ‘D’, ‘D’, ‘D’, ‘D’, ‘D’])
   V key = String(name[0])
   V key1 = ‘’
   V i = 1
   L i < name.len
      V (n_1, n) = (name[i - 1], name[i])
      V n1_ = I i + 1 < name.len {name[i + 1]} E ‘’
      name = replace_at(name, i, [‘EV’] [+] Array(:_vowels).map(String), [‘AF’] [+] [String(‘A’)] * 5)
      name = replace_at(name, i, [String(‘Q’), ‘Z’, ‘M’], [String(‘G’), ‘S’, ‘N’])
      name = replace_at(name, i, [‘KN’, ‘K’], [String(‘N’), ‘C’])
      name = replace_at(name, i, [‘SCH’, ‘PH’], [‘SSS’, ‘FF’])
      I n == ‘H’ & (n_1 !C :_vowels | n1_ !C :_vowels)
         name = name[0 .< i]‘’n_1‘’name[i + 1 ..]
      I n == ‘W’ & n_1 C :_vowels
         name = name[0 .< i]‘A’name[i + 1 ..]
      I key != ‘’ & key.last != name[i]
         key ‘’= name[i]
      i++
   key = replace_end(key, [‘S’, ‘AY’, ‘A’], [‘’, ‘Y’, ‘’])
   R key1‘’key

V names = [‘Bishop’, ‘Carlson’, ‘Carr’, ‘Chapman’, ‘Franklin’, ‘Greene’, ‘Harper’, ‘Jacobs’, ‘Larson’, ‘Lawrence’, ‘Lawson’, ‘Louis, XVI’, ‘Lynch’, ‘Mackenzie’, ‘Matthews’, ‘McCormack’, ‘McDaniel’, ‘McDonald’, ‘Mclaughlin’, ‘Morrison’, ‘O'Banion’, ‘O'Brien’, ‘Richards’, ‘Silva’, ‘Watkins’, ‘Wheeler’, ‘Willis’, ‘brown, sr’, ‘browne, III’, ‘browne, IV’, ‘knight’, ‘mitchell’, ‘o'daniel’]
L(name) names
   print(‘#15: #.’.format(name, nysiis(name)))
===
auto _vowels = u"AEIOU"_S;

template <typename T2, typename T3, typename T4> auto replace_at(const String &text, const T2 &position, const T3 &fromlist, const T4 &tolist)
{
    for (auto &&[f, t] : zip(fromlist, tolist))
        if (text[range_el(position, position + f.len())] == f)
            return text[range_el(0, position)] & t & text[range_ei(position + f.len())];
    return text;
}

template <typename T2, typename T3> auto replace_end(const String &text, const T2 &fromlist, const T3 &tolist)
{
    for (auto &&[f, t] : zip(fromlist, tolist))
        if (text.ends_with(f))
            return text[range_e_llen(0,  - f.len())] & t;
    return text;
}

auto nysiis(String name)
{
    name = name.replace(re::_(uR"(\W)"_S), u""_S).uppercase();
    name = replace_at(name, 0, create_array({u"MAC"_S, u"KN"_S, u"K"_S, u"PH"_S, u"PF"_S, u"SCH"_S}), create_array({u"MCC"_S, u"N"_S, u"C"_S, u"FF"_S, u"FF"_S, u"SSS"_S}));
    name = replace_end(name, create_array({u"EE"_S, u"IE"_S, u"DT"_S, u"RT"_S, u"RD"_S, u"NT"_S, u"ND"_S}), create_array({u'Y'_C, u'Y'_C, u'D'_C, u'D'_C, u'D'_C, u'D'_C, u'D'_C}));
    auto key = String(_get<0>(name));
    auto key1 = u""_S;
    auto i = 1;
    while (i < name.len()) {
        auto [n_1, n] = make_tuple(name[i - 1], name[i]);
        auto n1_ = i + 1 < name.len() ? name[i + 1] : u""_S;
        name = replace_at(name, i, create_array({u"EV"_S}) + create_array(::_vowels).map([](const auto &x){return String(x);}), create_array({u"AF"_S}) + create_array({String(u"A"_S)}) * 5);
        name = replace_at(name, i, create_array<String>({String(u"Q"_S), u"Z"_S, u"M"_S}), create_array<String>({String(u"G"_S), u"S"_S, u"N"_S}));
        name = replace_at(name, i, create_array({u"KN"_S, u"K"_S}), create_array<String>({String(u"N"_S), u"C"_S}));
        name = replace_at(name, i, create_array({u"SCH"_S, u"PH"_S}), create_array({u"SSS"_S, u"FF"_S}));
        if (n == u'H' && (!in(n_1, ::_vowels) || !in(n1_, ::_vowels)))
            name = name[range_el(0, i)] & n_1 & name[range_ei(i + 1)];
        if (n == u'W' && in(n_1, ::_vowels))
            name = name[range_el(0, i)] & u"A"_S & name[range_ei(i + 1)];
        if (key != u"" && key.last() != name[i])
            key &= name[i];
        i++;
    }
    key = replace_end(key, create_array({u"S"_S, u"AY"_S, u"A"_S}), create_array({u""_S, u"Y"_S, u""_S}));
    return key1 & key;
}

auto names = create_array({u"Bishop"_S, u"Carlson"_S, u"Carr"_S, u"Chapman"_S, u"Franklin"_S, u"Greene"_S, u"Harper"_S, u"Jacobs"_S, u"Larson"_S, u"Lawrence"_S, u"Lawson"_S, u"Louis, XVI"_S, u"Lynch"_S, u"Mackenzie"_S, u"Matthews"_S, u"McCormack"_S, u"McDaniel"_S, u"McDonald"_S, u"Mclaughlin"_S, u"Morrison"_S, u"O'Banion"_S, u"O'Brien"_S, u"Richards"_S, u"Silva"_S, u"Watkins"_S, u"Wheeler"_S, u"Willis"_S, u"brown, sr"_S, u"browne, III"_S, u"browne, IV"_S, u"knight"_S, u"mitchell"_S, u"o'daniel"_S});

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&name : names)
            print(u"#15: #."_S.format(name, nysiis(name)));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Nonoblock#Python
from typing import List, Tuple
Char = str

def nonoblocks(blocks : List[int], cells : int) -> List[List[Tuple[int, int]]]:
    r : List[List[Tuple[int, int]]] = []
    if len(blocks) == 0 or blocks[0] == 0:
        r += [[(0, 0)]]
    else:
        assert sum(blocks) + len(blocks)-1 <= cells, \
            'Those blocks will not fit in those cells'
        (blength, brest) = (blocks[0], blocks[1:])      # Deal with the first block of length
        minspace4rest = sum(1+b for b in brest)     # The other blocks need space
        # Slide the start position from left to max RH index allowing for other blocks.
        for bpos in range(0, cells - minspace4rest - blength + 1):
            if len(brest) == 0:
                # No other blocks to the right so just yield this one.
                r += [[(bpos, blength)]]
            else:
                # More blocks to the right so create a *sub-problem* of placing
                # the brest blocks in the cells one space to the right of the RHS of
                # this block.
                offset = bpos + blength +1
                # recursive call to nonoblocks yields multiple sub-positions
                for subpos in nonoblocks(brest, cells - offset):
                    # Remove the offset from sub block positions
                    rest = [(offset + bp, bl) for bp, bl in subpos]
                    # Yield this block plus sub blocks positions
                    vec = [(bpos, blength)] + rest
                    r += [vec]
    return r

def pblock(vec, cells):
    'Prettyprints each run of blocks with a different letter A.. for each block of filled cells'
    vector = ['_'] * cells
    for ch, bp_bl in enumerate(vec, ord('A')):
        (bp, bl) = bp_bl
        for i in range(bp, bp + bl):
            vector[i] = chr(ch) if vector[i] == '_' else Char('?')
    return '|' + '|'.join(vector) + '|'

for blocks, cells in [
        ([2, 1], 5),
        ([0]*0, 5),
        ([8], 10),
        ([2, 3, 2, 3], 15),
       # ([4, 3], 10),
       # ([2, 1], 5),
       # ([3, 1], 10),
        #([2, 3], 5),
        ]:
    print('\nConfiguration:\n    %s # %i cells and %s blocks' % (pblock([(0, 0)]*0, cells), cells, blocks))
    print('  Possibilities:')
    nb = nonoblocks(blocks, cells)
    for vector in nb:
        print('   ', pblock(vector, cells))
    print('  A total of %i Possible configurations.' % len(nb))
===
F nonoblocks([Int] &blocks, Int cells) -> [[(Int, Int)]]
   [[(Int, Int)]] r
   I blocks.empty | blocks[0] == 0
      r [+]= [(0, 0)]
   E
      assert(sum(blocks) + blocks.len - 1 <= cells, ‘Those blocks will not fit in those cells’)
      V (blength, brest) = (blocks[0], blocks[1..])
      V minspace4rest = sum(brest.map(b -> 1 + b))
      L(bpos) 0 .. cells - minspace4rest - blength
         I brest.empty
            r [+]= [(bpos, blength)]
         E
            V offset = bpos + blength + 1
            L(subpos) nonoblocks(&brest, cells - offset)
               V rest = subpos.map((bp, bl) -> (@offset + bp, bl))
               V vec = [(bpos, blength)] [+] rest
               r [+]= vec
   R r

F pblock(vec, cells)
   ‘Prettyprints each run of blocks with a different letter A.. for each block of filled cells’
   V vector = [‘_’] * cells
   L(bp_bl) vec
      V ch = L.index + ‘A’.code
      V (bp, bl) = bp_bl
      L(i) bp .< bp + bl
         vector[i] = I vector[i] == ‘_’ {Char(code' ch)} E Char(‘?’)
   R ‘|’vector.join(‘|’)‘|’

L(blocks, cells) [([2, 1], 5), ([Int](), 5), ([8], 10), ([2, 3, 2, 3], 15)]
   print("\nConfiguration:\n    #. # #. cells and #. blocks".format(pblock([(0, 0)] * 0, cells), cells, blocks))
   print(‘  Possibilities:’)
   V nb = nonoblocks(&blocks, cells)
   L(vector) nb
      print(‘    ’pblock(vector, cells))
   print(‘  A total of #. Possible configurations.’.format(nb.len))
===
Array<Array<ivec2>> nonoblocks(Array<int> &blocks, const int cells)
{
    Array<Array<ivec2>> r;
    if (blocks.empty() || _get<0>(blocks) == 0)
        r.append(create_array({make_tuple(0, 0)}));
    else {
        assert(sum(blocks) + blocks.len() - 1 <= cells, u"Those blocks will not fit in those cells"_S);
        auto [blength, brest] = make_tuple(_get<0>(blocks), blocks[range_ei(1)]);
        auto minspace4rest = sum_map(brest, [](const auto &b){return 1 + b;});
        for (auto bpos : range_ee(0, cells - minspace4rest - blength))
            if (brest.empty())
                r.append(create_array({make_tuple(bpos, blength)}));
            else {
                auto offset = bpos + blength + 1;
                for (auto &&subpos : nonoblocks(brest, cells - offset)) {
                    auto rest = subpos.map([&offset](const auto &bp, const auto &bl){return make_tuple(offset + bp, bl);});
                    auto vec = create_array({make_tuple(bpos, blength)}) + rest;
                    r.append(vec);
                }
            }
    }
    return r;
}

template <typename T1, typename T2> auto pblock(const T1 &vec, const T2 &cells)
{
    u"Prettyprints each run of blocks with a different letter A.. for each block of filled cells"_S;
    auto vector = create_array({u'_'_C}) * cells;
    {int Lindex = 0;
    for (auto &&bp_bl : vec) {
        auto ch = Lindex + u'A'_C.code;
        auto [bp, bl] = bp_bl;
        for (auto i : range_el(bp, bp + bl))
            vector.set(i, vector[i] == u'_' ? Char(ch) : u'?'_C);
        Lindex++;
    }}
    return u"|"_S & vector.join(u"|"_S) & u"|"_S;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&[blocks, cells] : create_array({make_tuple(create_array({2, 1}), 5), make_tuple(Array<int>(), 5), make_tuple(create_array({8}), 10), make_tuple(create_array({2, 3, 2, 3}), 15)})) {
            print(u"\nConfiguration:\n    #. # #. cells and #. blocks"_S.format(pblock(create_array({make_tuple(0, 0)}) * 0, cells), cells, blocks));
            print(u"  Possibilities:"_S);
            auto nb = nonoblocks(blocks, cells);
            for (auto &&vector : nb)
                print(u"    "_S & pblock(vector, cells));
            print(u"  A total of #. Possible configurations."_S.format(nb.len()));
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Numerical_integration#Nim
from typing import Callable

def left_rect(f : Callable[[float], float], x : float, h : float) -> float:
  return f(x)

def mid_rect(f : Callable[[float], float], x : float, h : float) -> float:
  return f(x + h/2)

def right_rect(f : Callable[[float], float], x : float, h : float) -> float:
  return f(x+h)

def trapezium(f : Callable[[float], float], x : float, h : float) -> float:
  return (f(x) + f(x+h))/2.0

def simpson(f : Callable[[float], float], x : float, h : float) -> float:
  return (f(x) + 4*f(x + h/2) + f(x+h))/6.0

def cube(x : float) -> float:
  return x*x*x

def reciprocal(x : float) -> float:
  return 1/x

def identity(x : float) -> float:
  return x

def integrate(f, a, b, steps, meth):
   h = (b-a)/steps
   ival = h * sum(meth(f, a+i*h, h) for i in range(steps))
   return ival

for a, b, steps, func, func_name in [(0.0, 1.0, 100, cube, 'cube'),
                                     (1.0, 100.0, 1000, reciprocal, 'reciprocal'),
                                     (0.0, 5000.0, 5_000_000, identity, 'identity'),
                                     (0.0, 6000.0, 6_000_000, identity, 'identity')]:
    for rule, rule_name in [(left_rect,  'left_rect'),
                             (mid_rect,   'mid_rect'),
                           (right_rect, 'right_rect'),
                            (trapezium,  'trapezium'),
                              (simpson,    'simpson')]:
        print('%s integrated using %s\n  from %s to %s (%i steps) = %s' %
              (func_name, rule_name, a, b, steps, integrate(func, a, b, steps, rule)))
===
F left_rect((Float -> Float) f, Float x, Float h) -> Float
   R f(x)

F mid_rect((Float -> Float) f, Float x, Float h) -> Float
   R f(x + h / 2)

F right_rect((Float -> Float) f, Float x, Float h) -> Float
   R f(x + h)

F trapezium((Float -> Float) f, Float x, Float h) -> Float
   R (f(x) + f(x + h)) / 2.0

F simpson((Float -> Float) f, Float x, Float h) -> Float
   R (f(x) + 4 * f(x + h / 2) + f(x + h)) / 6.0

F cube(Float x) -> Float
   R x * x * x

F reciprocal(Float x) -> Float
   R 1 / x

F identity(Float x) -> Float
   R x

F integrate(f, a, b, steps, meth)
   V h = (b - a) / steps
   V ival = h * sum((0 .< steps).map(i -> @meth(@f, @a + i * @h, @h)))
   R ival

L(a, b, steps, func, func_name) [(0.0, 1.0, 100, cube, ‘cube’), (1.0, 100.0, 1000, reciprocal, ‘reciprocal’), (0.0, 5000.0, 5'000'000, identity, ‘identity’), (0.0, 6000.0, 6'000'000, identity, ‘identity’)]
   L(rule, rule_name) [(left_rect, ‘left_rect’), (mid_rect, ‘mid_rect’), (right_rect, ‘right_rect’), (trapezium, ‘trapezium’), (simpson, ‘simpson’)]
      print("#. integrated using #.\n  from #. to #. (#. steps) = #.".format(func_name, rule_name, a, b, steps, integrate(func, a, b, steps, rule)))
===
double left_rect(const std::function<double(const double)> &f, const double x, const double h)
{
    return f(x);
}

double mid_rect(const std::function<double(const double)> &f, const double x, const double h)
{
    return f(x + h / 2.0);
}

double right_rect(const std::function<double(const double)> &f, const double x, const double h)
{
    return f(x + h);
}

double trapezium(const std::function<double(const double)> &f, const double x, const double h)
{
    return (f(x) + f(x + h)) / 2.0;
}

double simpson(const std::function<double(const double)> &f, const double x, const double h)
{
    return (f(x) + 4 * f(x + h / 2.0) + f(x + h)) / 6.0;
}

double cube(const double x)
{
    return x * x * x;
}

double reciprocal(const double x)
{
    return 1.0 / x;
}

double identity(const double x)
{
    return x;
}

template <typename T1, typename T2, typename T3, typename T4, typename T5> auto integrate(const T1 &f, const T2 &a, const T3 &b, const T4 &steps, const T5 &meth)
{
    auto h = (b - a) / steps;
    auto ival = h * sum_map(range_el(0, steps), [&a, &f, &h, &meth](const auto &i){return meth(f, a + i * h, h);});
    return ival;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&[a, b, steps, func, func_name] : create_array({make_tuple(0.0, 1.0, 100, cube, u"cube"_S), make_tuple(1.0, 100.0, 1000, reciprocal, u"reciprocal"_S), make_tuple(0.0, 5000.0, 5'000'000, identity, u"identity"_S), make_tuple(0.0, 6000.0, 6'000'000, identity, u"identity"_S)}))
            for (auto &&[rule, rule_name] : create_array({make_tuple(left_rect, u"left_rect"_S), make_tuple(mid_rect, u"mid_rect"_S), make_tuple(right_rect, u"right_rect"_S), make_tuple(trapezium, u"trapezium"_S), make_tuple(simpson, u"simpson"_S)}))
                print(u"#. integrated using #.\n  from #. to #. (#. steps) = #."_S.format(func_name, rule_name, a, b, steps, integrate(func, a, b, steps, rule)));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/N-body_problem#Python
from typing import List
import math

class Vector:
    x : float
    y : float
    z : float

    def __init__(self, x, y, z):
        self.x = x
        self.y = y
        self.z = z

    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y, self.z + other.z)

    def __sub__(self, other):
        return Vector(self.x - other.x, self.y - other.y, self.z - other.z)

    def __mul__(self, other):
        return Vector(self.x * other, self.y * other, self.z * other)

    def __eq__(self, other):
        return self.x == other.x and self.y == other.y and self.z == other.z

    def __str__(self):
        return '({x}, {y}, {z})'.format(x=self.x, y=self.y, z=self.z)

    def abs(self):
        return math.sqrt(self.x*self.x + self.y*self.y + self.z*self.z)

origin = Vector(0, 0, 0)

class NBody:
    gc : float
    bodies : int
    timeSteps : int
    masses : List[float]
    positions : List[Vector]
    velocities : List[Vector]
    accelerations : List[Vector]

    def __init__(self, fileName):
        lines = open(fileName, "r").read().split("\n")
        gbt = lines[0].split(' ')
        self.gc = float(gbt[0])
        self.bodies = int(gbt[1])
        self.timeSteps = int(gbt[2])
        self.masses = [0.0 for i in range(self.bodies)]
        self.positions = [origin for i in range(self.bodies)]
        self.velocities = [origin for i in range(self.bodies)]
        self.accelerations = [origin for i in range(self.bodies)]
        for i in range(self.bodies):
            self.masses[i] = float(lines[i*3 + 1])
            self.positions[i] = self.__decompose(lines[i*3 + 2])
            self.velocities[i] = self.__decompose(lines[i*3 + 3])

        print("Contents of", fileName)
        for line in lines:
            print(line)
        print()
        print("Body   :      x          y          z    |", end=' ')
        print("     vx         vy         vz")

    def __decompose(self, line):
        xyz = line.split(' ')
        x = float(xyz[0])
        y = float(xyz[1])
        z = float(xyz[2])
        return Vector(x, y, z)

    def __computeAccelerations(self):
        for i in range(self.bodies):
            self.accelerations[i] = origin
            for j in range(self.bodies):
                if i != j:
                    temp = self.gc * self.masses[j] / math.pow((self.positions[i] - self.positions[j]).abs(), 3)
                    self.accelerations[i] += (self.positions[j] - self.positions[i]) * temp

    def __computePositions(self):
        for i in range(self.bodies):
            self.positions[i] += self.velocities[i] + self.accelerations[i] * 0.5

    def __computeVelocities(self):
        for i in range(self.bodies):
            self.velocities[i] += self.accelerations[i]

    def __resolveCollisions(self):
        for i in range(self.bodies):
            for j in range(self.bodies):
                if self.positions[i] == self.positions[j]:
                    (self.velocities[i], self.velocities[j]) = (self.velocities[j], self.velocities[i])

    def simulate(self):
        self.__computeAccelerations()
        self.__computePositions()
        self.__computeVelocities()
        self.__resolveCollisions()

    def printResults(self):
        for i in range(self.bodies):
            print("Body %d : %9.6f  %9.6f  %9.6f | %9.6f  %9.6f  %9.6f" % (i+1, self.positions[i].x, self.positions[i].y, self.positions[i].z, self.velocities[i].x, self.velocities[i].y, self.velocities[i].z))

nb = NBody("nbody.txt")
for i in range(nb.timeSteps):
    print("\nCycle %d" % (i + 1))
    nb.simulate()
    nb.printResults()
===
T Vector
   Float x
   Float y
   Float z

   F (x, y, z)
      .x = x
      .y = y
      .z = z

   F +(other)
      R Vector(.x + other.x, .y + other.y, .z + other.z)

   F -(other)
      R Vector(.x - other.x, .y - other.y, .z - other.z)

   F *(other)
      R Vector(.x * other, .y * other, .z * other)

   F ==(other)
      R .x == other.x & .y == other.y & .z == other.z

   F String()
      R ‘(#., #., #.)’.format(.x, .y, .z)

   F abs()
      R sqrt(.x * .x + .y * .y + .z * .z)

V origin = Vector(0, 0, 0)

T NBody
   Float gc
   Int bodies
   Int timeSteps
   [Float] masses
   [Vector] positions
   [Vector] velocities
   [Vector] accelerations

   F (fileName)
      V lines = File(fileName, ‘r’).read().split("\n")
      V gbt = lines[0].split(‘ ’)
      .gc = Float(gbt[0])
      .bodies = Int(gbt[1])
      .timeSteps = Int(gbt[2])
      .masses = (0 .< .bodies).map(i -> 0.0)
      .positions = (0 .< .bodies).map(i -> :origin)
      .velocities = (0 .< .bodies).map(i -> :origin)
      .accelerations = (0 .< .bodies).map(i -> :origin)
      L(i) 0 .< .bodies
         .masses[i] = Float(lines[i * 3 + 1])
         .positions[i] = .__decompose(lines[i * 3 + 2])
         .velocities[i] = .__decompose(lines[i * 3 + 3])

      print(‘Contents of ’fileName)
      L(line) lines
         print(line)
      print()
      print(‘Body   :      x          y          z    |’, end' ‘ ’)
      print(‘     vx         vy         vz’)

   F __decompose(line)
      V xyz = line.split(‘ ’)
      V x = Float(xyz[0])
      V y = Float(xyz[1])
      V z = Float(xyz[2])
      R Vector(x, y, z)

   F __computeAccelerations()
      L(i) 0 .< .bodies
         .accelerations[i] = :origin
         L(j) 0 .< .bodies
            I i != j
               V temp = .gc * .masses[j] / pow((.positions[i] - .positions[j]).abs(), 3)
               .accelerations[i] += (.positions[j] - .positions[i]) * temp

   F __computePositions()
      L(i) 0 .< .bodies
         .positions[i] += .velocities[i] + .accelerations[i] * 0.5

   F __computeVelocities()
      L(i) 0 .< .bodies
         .velocities[i] += .accelerations[i]

   F __resolveCollisions()
      L(i) 0 .< .bodies
         L(j) 0 .< .bodies
            I .positions[i] == .positions[j]
               swap(&.velocities[i], &.velocities[j])

   F simulate()
      .__computeAccelerations()
      .__computePositions()
      .__computeVelocities()
      .__resolveCollisions()

   F printResults()
      L(i) 0 .< .bodies
         print(‘Body #. : #2.6  #2.6  #2.6 | #2.6  #2.6  #2.6’.format(i + 1, .positions[i].x, .positions[i].y, .positions[i].z, .velocities[i].x, .velocities[i].y, .velocities[i].z))

V nb = NBody(‘nbody.txt’)
L(i) 0 .< nb.timeSteps
   print("\nCycle #.".format(i + 1))
   nb.simulate()
   nb.printResults()
===
class Vector
{
public:
    double x;
    double y;
    double z;

    template <typename T1, typename T2, typename T3> Vector(const T1 &x, const T2 &y, const T3 &z) :
        x(x),
        y(y),
        z(z)
    {
    }

    template <typename T1> auto operator+(const T1 &other) const
    {
        return Vector(x + other.x, y + other.y, z + other.z);
    }
    template <typename Ty> auto &operator+=(const Ty &t)
    {
        *this = *this + t;
        return *this;
    }

    template <typename T1> auto operator-(const T1 &other) const
    {
        return Vector(x - other.x, y - other.y, z - other.z);
    }
    template <typename Ty> auto &operator-=(const Ty &t)
    {
        *this = *this - t;
        return *this;
    }

    template <typename T1> auto operator*(const T1 &other) const
    {
        return Vector(x * other, y * other, z * other);
    }
    template <typename Ty> auto &operator*=(const Ty &t)
    {
        *this = *this * t;
        return *this;
    }

    template <typename T1> auto operator==(const T1 &other) const
    {
        return x == other.x && y == other.y && z == other.z;
    }

    operator String() const
    {
        return u"(#., #., #.)"_S.format(x, y, z);
    }

    auto abs()
    {
        return sqrt(x * x + y * y + z * z);
    }
};

auto origin = Vector(0, 0, 0);

class NBody
{
public:
    double gc;
    int bodies;
    int timeSteps;
    Array<double> masses;
    Array<Vector> positions;
    Array<Vector> velocities;
    Array<Vector> accelerations;

    template <typename T1> NBody(const T1 &fileName)
    {
        auto lines = File(fileName, u"r"_S).read().split(u"\n"_S);
        auto gbt = _get<0>(lines).split(u" "_S);
        gc = to_float(_get<0>(gbt));
        bodies = to_int(_get<1>(gbt));
        timeSteps = to_int(_get<2>(gbt));
        masses = range_el(0, bodies).map([](const auto &i){return 0.0;});
        positions = range_el(0, bodies).map([](const auto &i){return ::origin;});
        velocities = range_el(0, bodies).map([](const auto &i){return ::origin;});
        accelerations = range_el(0, bodies).map([](const auto &i){return ::origin;});
        for (auto i : range_el(0, bodies)) {
            masses.set(i, to_float(lines[i * 3 + 1]));
            positions.set(i, __decompose(lines[i * 3 + 2]));
            velocities.set(i, __decompose(lines[i * 3 + 3]));
        }

        print(u"Contents of "_S & fileName);
        for (auto &&line : lines)
            print(line);
        print();
        print(u"Body   :      x          y          z    |"_S, u" "_S);
        print(u"     vx         vy         vz"_S);
    }

    template <typename T1> auto __decompose(const T1 &line)
    {
        auto xyz = line.split(u" "_S);
        auto x = to_float(_get<0>(xyz));
        auto y = to_float(_get<1>(xyz));
        auto z = to_float(_get<2>(xyz));
        return Vector(x, y, z);
    }

    auto __computeAccelerations()
    {
        for (auto i : range_el(0, bodies)) {
            accelerations.set(i, ::origin);
            for (auto j : range_el(0, bodies))
                if (i != j) {
                    auto temp = gc * masses[j] / pow((positions[i] - positions[j]).abs(), 3);
                    accelerations[i] += (positions[j] - positions[i]) * temp;
                }
        }
    }

    auto __computePositions()
    {
        for (auto i : range_el(0, bodies))
            positions[i] += velocities[i] + accelerations[i] * 0.5;
    }

    auto __computeVelocities()
    {
        for (auto i : range_el(0, bodies))
            velocities[i] += accelerations[i];
    }

    auto __resolveCollisions()
    {
        for (auto i : range_el(0, bodies))
            for (auto j : range_el(0, bodies))
                if (positions[i] == positions[j])
                    swap(velocities[i], velocities[j]);
    }

    auto simulate()
    {
        __computeAccelerations();
        __computePositions();
        __computeVelocities();
        __resolveCollisions();
    }

    auto printResults()
    {
        for (auto i : range_el(0, bodies))
            print(u"Body #. : #2.6  #2.6  #2.6 | #2.6  #2.6  #2.6"_S.format(i + 1, positions[i].x, positions[i].y, positions[i].z, velocities[i].x, velocities[i].y, velocities[i].z));
    }
};

auto nb = NBody(u"nbody.txt"_S);

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto i : range_el(0, nb.timeSteps)) {
            print(u"\nCycle #."_S.format(i + 1));
            nb.simulate();
            nb.printResults();
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/N-queens_problem#Nim
BoardSize = 8

def underAttack(col, queens):
    if col in queens: return True
    for i, x in enumerate(queens):
        if abs(col - x) == len(queens) - i:
            return True
    return False

def solve(n):
    result = [[0] * 0]
    newSolutions : List[List[int]] = []
    for row in range(1, n + 1):
        for solution in result:
            for i in range(1, BoardSize + 1):
                if not underAttack(i, solution):
                    newSolutions.append(solution + [i])
        (result, newSolutions) = (newSolutions, result)
        newSolutions.clear()
    return result

print('Solutions for a chessboard of size ' + str(BoardSize) + 'x' + str(BoardSize))
print()

for i, answer in enumerate(solve(BoardSize)):
    for row, col in enumerate(answer):
        if row > 0:
            print(' ', end = '')
        print(chr(ord('a') + row) + str(col), end = '')
    print(end = "\n" if i % 4 == 3 else '      ')
===
V BoardSize = 8

F underAttack(col, queens)
   I col C queens
      R 1B
   L(x) queens
      V i = L.index
      I abs(col - x) == queens.len - i
         R 1B
   R 0B

F solve(n)
   V result = [[Int]()]
   [[Int]] newSolutions
   L(row) 1 .. n
      L(solution) result
         L(i) 1 .. BoardSize
            I !underAttack(i, solution)
               newSolutions.append(solution [+] [i])
      swap(&result, &newSolutions)
      newSolutions.clear()
   R result

print(‘Solutions for a chessboard of size ’String(BoardSize)‘x’String(BoardSize))
print()

L(answer) solve(BoardSize)
   V i = L.index
   L(col) answer
      V row = L.index
      I row > 0
         print(‘ ’, end' ‘’)
      print(Char(code' ‘a’.code + row)‘’String(col), end' ‘’)
   print(end' I i % 4 == 3 {"\n"} E ‘      ’)
===
auto BoardSize = 8;

template <typename T1, typename T2> auto underAttack(const T1 &col, const T2 &queens)
{
    if (in(col, queens))
        return true;
    {int Lindex = 0;
    for (auto &&x : queens) {
        auto i = Lindex;
        if (abs(col - x) == queens.len() - i)
            return true;
        Lindex++;
    }}
    return false;
}

template <typename T1> auto solve(const T1 &n)
{
    auto result = create_array({Array<int>()});
    Array<Array<int>> newSolutions;
    for (auto row : range_ee(1, n)) {
        for (auto &&solution : result)
            for (auto i : range_ee(1, BoardSize))
                if (!underAttack(i, solution))
                    newSolutions.append(solution + create_array({i}));
        swap(result, newSolutions);
        newSolutions.clear();
    }
    return result;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"Solutions for a chessboard of size "_S & String(BoardSize) & u"x"_S & String(BoardSize));
        print();
        {int Lindex = 0;

        for (auto &&answer : solve(BoardSize)) {
            auto i = Lindex;
            {int Lindex = 0;
            for (auto &&col : answer) {
                auto row = Lindex;
                if (row > 0)
                    print(u" "_S, u""_S);
                print(Char(u'a'_C.code + row) & String(col), u""_S);
                Lindex++;
            }}
            print(u""_S, mod(i, 4) == 3 ? u"\n"_S : u"      "_S);
            Lindex++;
        }}
    }
} code_block_1;


# https://www.rosettacode.org/wiki/N-smooth_numbers#Python
primes = [2, 3, 5, 7, 11, 13, 17, 19, 23]

def isPrime(n):
    if n < 2:
        return False

    for i in primes:
        if n == i:
            return True
        if n % i == 0:
            return False
        if i * i > n:
            return True
    print("Oops,", n, " is too large")
    return False

def init():
    s = 24
    while s < 600:
        if isPrime(s - 1) and s - 1 > primes[-1]:
            primes.append(s - 1)
        if isPrime(s + 1) and s + 1 > primes[-1]:
            primes.append(s + 1)
        s += 6

def nsmooth(n, size):
    assert(2 <= n <= 521)
    assert(size >= 1)

    bn = n
    ok = False
    for prime in primes:
        if bn == prime:
            ok = True
            break
    assert ok, "must be a prime number"

    ns = [BigInt(0)] * size
    ns[0] = 1

    next : List[BigInt] = []
    for prime in primes:
        if prime > bn:
            break
        next.append(prime)

    indicies = [0] * len(next)
    for m in range(1, size):
        ns[m] = min(next)
        for i in range(0, len(indicies)):
            if ns[m] == next[i]:
                indicies[i] += 1
                next[i] = primes[i] * ns[indicies[i]]

    return ns

init()

for p in primes:
    if p >= 30:
        break
    print("The first", p, "-smooth numbers are:")
    print(nsmooth(p, 25))
    print()

for p in primes[1:]:
    if p >= 30:
        break
    print("The 3000 to 3202", p, "-smooth numbers are:")
    print(nsmooth(p, 3002)[2999:])
    print()

for p in [503, 509, 521]:
    print("The 30000 to 3019", p, "-smooth numbers are:")
    print(nsmooth(p, 30019)[29999:])
    print()
===
V primes = [2, 3, 5, 7, 11, 13, 17, 19, 23]

F isPrime(n)
   I n < 2
      R 0B

   L(i) :primes
      I n == i
         R 1B
      I n % i == 0
         R 0B
      I i * i > n
         R 1B
   print(‘Oops, ’n‘  is too large’)
   R 0B

F init()
   V s = 24
   L s < 600
      I isPrime(s - 1) & s - 1 > :primes.last
         :primes.append(s - 1)
      I isPrime(s + 1) & s + 1 > :primes.last
         :primes.append(s + 1)
      s += 6

F nsmooth(n, size)
   assert(n C 2..521)
   assert(size >= 1)

   V bn = n
   V ok = 0B
   L(prime) :primes
      I bn == prime
         ok = 1B
         L.break
   assert(ok, ‘must be a prime number’)

   V ns = [BigInt(0)] * size
   ns[0] = 1

   [BigInt] next
   L(prime) :primes
      I prime > bn
         L.break
      next.append(prime)

   V indicies = [0] * next.len
   L(m) 1 .< size
      ns[m] = min(next)
      L(i) 0 .< indicies.len
         I ns[m] == next[i]
            indicies[i]++
            next[i] = :primes[i] * ns[indicies[i]]

   R ns

init()

L(p) primes
   I p >= 30
      L.break
   print(‘The first ’p‘ -smooth numbers are:’)
   print(nsmooth(p, 25))
   print()

L(p) primes[1..]
   I p >= 30
      L.break
   print(‘The 3000 to 3202 ’p‘ -smooth numbers are:’)
   print(nsmooth(p, 3002)[2999..])
   print()

L(p) [503, 509, 521]
   print(‘The 30000 to 3019 ’p‘ -smooth numbers are:’)
   print(nsmooth(p, 30019)[29999..])
   print()
===
auto primes = create_array({2, 3, 5, 7, 11, 13, 17, 19, 23});

template <typename T1> auto isPrime(const T1 &n)
{
    if (n < 2)
        return false;

    for (auto &&i : ::primes) {
        if (n == i)
            return true;
        if (mod(n, i) == 0)
            return false;
        if (i * i > n)
            return true;
    }
    print(u"Oops, "_S & n & u"  is too large"_S);
    return false;
}

auto init()
{
    auto s = 24;
    while (s < 600) {
        if (isPrime(s - 1) && s - 1 > ::primes.last())
            ::primes.append(s - 1);
        if (isPrime(s + 1) && s + 1 > ::primes.last())
            ::primes.append(s + 1);
        s += 6;
    }
}

template <typename T1, typename T2> auto nsmooth(const T1 &n, const T2 &size)
{
    assert(in(n, range_ee(2, 521)));
    assert(size >= 1);

    auto bn = n;
    auto ok = false;
    for (auto &&prime : ::primes)
        if (bn == prime) {
            ok = true;
            break;
        }
    assert(ok, u"must be a prime number"_S);

    auto ns = create_array({BigInt(0)}) * size;
    _set<0>(ns, 1);

    Array<BigInt> next;
    for (auto &&prime : ::primes) {
        if (prime > bn)
            break;
        next.append(prime);
    }

    auto indicies = create_array({0}) * next.len();
    for (auto m : range_el(1, size)) {
        ns.set(m, min(next));
        for (auto i : range_el(0, indicies.len()))
            if (ns[m] == next[i]) {
                indicies[i]++;
                next.set(i, ::primes[i] * ns[indicies[i]]);
            }
    }

    return ns;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        init();

        for (auto &&p : primes) {
            if (p >= 30)
                break;
            print(u"The first "_S & p & u" -smooth numbers are:"_S);
            print(nsmooth(p, 25));
            print();
        }

        for (auto &&p : primes[range_ei(1)]) {
            if (p >= 30)
                break;
            print(u"The 3000 to 3202 "_S & p & u" -smooth numbers are:"_S);
            print(nsmooth(p, 3002)[range_ei(2999)]);
            print();
        }

        for (auto &&p : create_array({503, 509, 521})) {
            print(u"The 30000 to 3019 "_S & p & u" -smooth numbers are:"_S);
            print(nsmooth(p, 30019)[range_ei(29999)]);
            print();
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Names_to_numbers#Nim
import re
Int64 = int

Names = {"one":   Int64(1),
         "two":         2,
         "three":       3,
         "four":        4,
         "five":        5,
         "six":         6,
         "seven":       7,
         "eight":       8,
         "nine":        9,
         "ten":         10,
         "eleven":      11,
         "twelve":      12,
         "thirteen":    13,
         "fourteen":    14,
         "fifteen":     15,
         "sixteen":     16,
         "seventeen":   17,
         "eighteen":    18,
         "nineteen":    19,
         "twenty":      20,
         "thirty":      30,
         "forty":       40,
         "fifty":       50,
         "sixty":       60,
         "seventy":     70,
         "eighty":      80,
         "ninety":      90,
         "hundred":     100,
         "thousand":    1000,
         "million":     1000000,
         "billion":     1000000000,
         "trillion":    1000000000000,
         "quadrillion": 1000000000000000,
         "quintillion": 1000000000000000000}

Zeros = ["zero", "nought", "nil", "none", "nothing"]

def nameToNum(name):
    text = name.lower()
    isNegative = text.startswith("minus ")
    if isNegative: text = text[6:]
    if text.startswith("a"):
        text = "one" + text[1:]
    words = [w for w in re.split(",|-| and | ", text) if len(w) != 0]
    if len(words) == 1 and words[0] in Zeros:
        return Int64(0)

    multiplier = Int64(1)
    sum = Int64(0)
    for i in range(len(words) - 1, -1, -1):
        num = Names.get(words[i], 0)
        if num >= 1000:
            multiplier = num
            if i == 0: sum += multiplier
        elif num >= 100:
            multiplier *= 100
            if i == 0: sum += multiplier
        else:
            sum += num * multiplier

    return -sum if isNegative else sum

names = [
    "none",
    "one",
    "twenty-five",
    "minus one hundred and seventeen",
    "hundred and fifty-six",
    "minus two thousand two",
    "nine thousand, seven hundred, one",
    "minus six hundred and twenty six thousand, eight hundred and fourteen",
    "four million, seven hundred thousand, three hundred and eighty-six",
    "fifty-one billion, two hundred and fifty-two million, seventeen thousand, one hundred eighty-four",
    "two hundred and one billion, twenty-one million, two thousand and one",
    "minus three hundred trillion, nine million, four hundred and one thousand and thirty-one",
    "seventeen quadrillion, one hundred thirty-seven",
    "a quintillion, eight trillion and five",
    "minus nine quintillion, two hundred and twenty-three quadrillion, three hundred and seventy-two trillion, thirty-six billion, eight hundred and fifty-four million, seven hundred and seventy-five thousand, eight hundred and eight"]

for name in names:
    print('%20d' % nameToNum(name), '=', name)
===
V Names = [‘one’ = Int64(1), ‘two’ = 2, ‘three’ = 3, ‘four’ = 4, ‘five’ = 5, ‘six’ = 6, ‘seven’ = 7, ‘eight’ = 8, ‘nine’ = 9, ‘ten’ = 10, ‘eleven’ = 11, ‘twelve’ = 12, ‘thirteen’ = 13, ‘fourteen’ = 14, ‘fifteen’ = 15, ‘sixteen’ = 16, ‘seventeen’ = 17, ‘eighteen’ = 18, ‘nineteen’ = 19, ‘twenty’ = 20, ‘thirty’ = 30, ‘forty’ = 40, ‘fifty’ = 50, ‘sixty’ = 60, ‘seventy’ = 70, ‘eighty’ = 80, ‘ninety’ = 90, ‘hundred’ = 100, ‘thousand’ = 1000, ‘million’ = 1000000, ‘billion’ = 1000000000, ‘trillion’ = 1000000000000, ‘quadrillion’ = 1000000000000000, ‘quintillion’ = 1000000000000000000]

V Zeros = [‘zero’, ‘nought’, ‘nil’, ‘none’, ‘nothing’]

F nameToNum(name)
   V text = name.lowercase()
   V isNegative = text.starts_with(‘minus ’)
   I isNegative
      text = text[6..]
   I text.starts_with(‘a’)
      text = ‘one’text[1..]
   V words = text.split(re:‘,|-| and | ’).filter(w -> !w.empty)
   I words.len == 1 & words[0] C Zeros
      R Int64(0)

   V multiplier = Int64(1)
   V sum = Int64(0)
   L(i) (words.len - 1 .< -1).step(-1)
      V num = Names.get(words[i], 0)
      I num >= 1000
         multiplier = num
         I i == 0
            sum += multiplier
      E I num >= 100
         multiplier *= 100
         I i == 0
            sum += multiplier
      E
         sum += num * multiplier

   R I isNegative {-sum} E sum

V names = [‘none’, ‘one’, ‘twenty-five’, ‘minus one hundred and seventeen’, ‘hundred and fifty-six’, ‘minus two thousand two’, ‘nine thousand, seven hundred, one’, ‘minus six hundred and twenty six thousand, eight hundred and fourteen’, ‘four million, seven hundred thousand, three hundred and eighty-six’, ‘fifty-one billion, two hundred and fifty-two million, seventeen thousand, one hundred eighty-four’, ‘two hundred and one billion, twenty-one million, two thousand and one’, ‘minus three hundred trillion, nine million, four hundred and one thousand and thirty-one’, ‘seventeen quadrillion, one hundred thirty-seven’, ‘a quintillion, eight trillion and five’, ‘minus nine quintillion, two hundred and twenty-three quadrillion, three hundred and seventy-two trillion, thirty-six billion, eight hundred and fifty-four million, seven hundred and seventy-five thousand, eight hundred and eight’]

L(name) names
   print((‘#20’.format(nameToNum(name)))‘ = ’name)
===
auto Names = create_dict(dict_of(u"one"_S, to_int64(1))(u"two"_S, 2)(u"three"_S, 3)(u"four"_S, 4)(u"five"_S, 5)(u"six"_S, 6)(u"seven"_S, 7)(u"eight"_S, 8)(u"nine"_S, 9)(u"ten"_S, 10)(u"eleven"_S, 11)(u"twelve"_S, 12)(u"thirteen"_S, 13)(u"fourteen"_S, 14)(u"fifteen"_S, 15)(u"sixteen"_S, 16)(u"seventeen"_S, 17)(u"eighteen"_S, 18)(u"nineteen"_S, 19)(u"twenty"_S, 20)(u"thirty"_S, 30)(u"forty"_S, 40)(u"fifty"_S, 50)(u"sixty"_S, 60)(u"seventy"_S, 70)(u"eighty"_S, 80)(u"ninety"_S, 90)(u"hundred"_S, 100)(u"thousand"_S, 1000)(u"million"_S, 1000000)(u"billion"_S, 1000000000)(u"trillion"_S, 1000000000000)(u"quadrillion"_S, 1000000000000000)(u"quintillion"_S, 1000000000000000000));

auto Zeros = create_array({u"zero"_S, u"nought"_S, u"nil"_S, u"none"_S, u"nothing"_S});

template <typename T1> auto nameToNum(const T1 &name)
{
    auto text = name.lowercase();
    auto isNegative = text.starts_with(u"minus "_S);
    if (isNegative)
        text = text[range_ei(6)];
    if (text.starts_with(u"a"_S))
        text = u"one"_S & text[range_ei(1)];
    auto words = text.split(re::_(u",|-| and | "_S)).filter([](const auto &w){return !w.empty();});
    if (words.len() == 1 && in(_get<0>(words), Zeros))
        return to_int64(0);

    auto multiplier = to_int64(1);
    auto sum = to_int64(0);
    for (auto i : range_el(words.len() - 1, -1).step(-1)) {
        auto num = Names.get(words[i], 0);
        if (num >= 1000) {
            multiplier = num;
            if (i == 0)
                sum += multiplier;
        }
        else if (num >= 100) {
            multiplier *= 100;
            if (i == 0)
                sum += multiplier;
        }
        else
            sum += num * multiplier;
    }

    return isNegative ? -sum : sum;
}

auto names = create_array({u"none"_S, u"one"_S, u"twenty-five"_S, u"minus one hundred and seventeen"_S, u"hundred and fifty-six"_S, u"minus two thousand two"_S, u"nine thousand, seven hundred, one"_S, u"minus six hundred and twenty six thousand, eight hundred and fourteen"_S, u"four million, seven hundred thousand, three hundred and eighty-six"_S, u"fifty-one billion, two hundred and fifty-two million, seventeen thousand, one hundred eighty-four"_S, u"two hundred and one billion, twenty-one million, two thousand and one"_S, u"minus three hundred trillion, nine million, four hundred and one thousand and thirty-one"_S, u"seventeen quadrillion, one hundred thirty-seven"_S, u"a quintillion, eight trillion and five"_S, u"minus nine quintillion, two hundred and twenty-three quadrillion, three hundred and seventy-two trillion, thirty-six billion, eight hundred and fifty-four million, seven hundred and seventy-five thousand, eight hundred and eight"_S});

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&name : names)
            print((u"#20"_S.format(nameToNum(name))) & u" = "_S & name);
    }
} code_block_1;