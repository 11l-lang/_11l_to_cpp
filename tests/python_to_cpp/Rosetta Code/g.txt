# https://www.rosettacode.org/wiki/Generate_Chess960_starting_position#Python
import random
Char = str

def random960():
    start = ['R', 'K', 'R']         # Subsequent order unchanged by insertions.
    #
    for piece in ['Q', 'N', 'N']:
        start.insert(random.randrange(len(start)+1), piece)
    #
    bishpos = random.randrange(len(start)+1)
    start.insert(bishpos, Char('B'))
    start.insert(random.randrange(bishpos + 1, len(start) + 1, 2), Char('B'))
    return start

print(random960())
===
F random960()
   V start = [‘R’, ‘K’, ‘R’]
   L(piece) [‘Q’, ‘N’, ‘N’]
      start.insert(random:(start.len + 1), piece)
   V bishpos = random:(start.len + 1)
   start.insert(bishpos, Char(‘B’))
   start.insert(random:(bishpos + 1), Char(‘B’))
   R start

print(random960())
===
auto random960()
{
    auto start = create_array({u'R'_C, u'K'_C, u'R'_C});
    for (auto &&piece : create_array({u'Q'_C, u'N'_C, u'N'_C}))
        start.insert(randomns::_(start.len() + 1), piece);
    auto bishpos = randomns::_(start.len() + 1);
    start.insert(bishpos, u'B'_C);
    start.insert(randomns::_(bishpos + 1), u'B'_C);
    return start;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(random960());
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Gapful_numbers#Python
import itertools

for start, n in [(100, 30), (1_000_000, 15), (1_000_000_000, 10)]:
    print("\nFirst", n, 'gapful numbers from', start)
    l = [0] * 0
    for x in itertools.count(start):
        if x % (int(str(x)[0]) * 10 + (x % 10)) == 0:
            l.append(x)
            if len(l) == n:
                break
    print(l)
===
L(start, n) [(100, 30), (1'000'000, 15), (1'000'000'000, 10)]
   print("\nFirst "n‘ gapful numbers from ’start)
   V l = [Int]()
   L(x) start..
      I x % (Int(String(x)[0]) * 10 + (x % 10)) == 0
         l.append(x)
         I l.len == n
            L.break
   print(l)
===
struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&[start, n] : create_array({make_tuple(100, 30), make_tuple(1'000'000, 15), make_tuple(1'000'000'000, 10)})) {
            print(u"\nFirst "_S & n & u" gapful numbers from "_S & start);
            auto l = Array<int>();
            for (auto x : range_ei(start))
                if (mod(x, (to_int(_get<0>(String(x))) * 10 + (mod(x, 10)))) == 0) {
                    l.append(x);
                    if (l.len() == n)
                        break;
                }
            print(l);
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Gauss-Jordan_matrix_inversion#Nim
Eps = 1e-10

def transformToRref(mat : list):
    lead = 0

    for r in range(len(mat)):
        if lead >= len(mat[0]): return

        i = r
        while mat[i][lead] == 0:
            i += 1
            if i == len(mat):
                i = r
                lead += 1
                if lead == len(mat[0]): return
        (mat[i], mat[r]) = (mat[r], mat[i])

        d = mat[r][lead]
        if abs(d) > Eps:    # Checking "d != 0" will give wrong results in some cases.
            for i in range(len(mat[r])):
                mat[r][i] /= d

        for i in range(len(mat)):
            if i != r:
                m = mat[i][lead]
                for c in range(len(mat[0])):
                    mat[i][c] -= mat[r][c] * m

        lead += 1

def inverse(mat):
    # Build augmented matrix.
    augmat = [[0.0] * (2 * len(mat)) for i in range(len(mat))]
    for i in range(len(mat)):
        for j in range(len(mat)):
            augmat[i][j] = mat[i][j]
        augmat[i][len(mat) + i] = 1

    # Transform it to reduced row echelon form.
    transformToRref(augmat)

    # Check if the first half is the identity matrix and extract second half.
    result = [[0.0] * len(mat) for i in range(len(mat))]
    for i in range(len(mat)):
        for j in range(len(mat)):
            if augmat[i][j] != float(i == j):
                raise ValueError('matrix is singular')
            result[i][j] = augmat[i][len(mat) + j]
    return result

def print_mat(mat):
    for row in mat:
        line = ''
        for val in row:
            if len(line) != 0:
                line += ' '
            line += '%9.5f' % val
        print(line)

def runTest(mat):
    print('Matrix:')
    print_mat(mat)
    print()
    print('Inverse:')
    print_mat(inverse(mat))
    print()
    print()

m1 = [[float(1), 2, 3],
      [float(4), 1, 6],
      [float(7), 8, 9]]

m2 = [[float( 2), -1,  0],
      [float(-1),  2, -1],
      [float( 0), -1,  2]]

m3 = [[float(-1), -2,  3,  2],
      [float(-4), -1,  6,  2],
      [float( 7), -8,  9,  1],
      [float( 1), -2,  1,  3]]

runTest(m1)
runTest(m2)
runTest(m3)
===
V Eps = 1e-10

F transformToRref(&mat)
   V lead = 0

   L(r) 0 .< mat.len
      I lead >= mat[0].len
         R

      V i = r
      L mat[i][lead] == 0
         i++
         I i == mat.len
            i = r
            lead++
            I lead == mat[0].len
               R
      swap(&mat[i], &mat[r])

      V d = mat[r][lead]
      I abs(d) > Eps
         L(i) 0 .< mat[r].len
            mat[r][i] /= d

      L(i) 0 .< mat.len
         I i != r
            V m = mat[i][lead]
            L(c) 0 .< mat[0].len
               mat[i][c] -= mat[r][c] * m

      lead++

F inverse(mat)
   V augmat = [[0.0] * (2 * mat.len)] * mat.len
   L(i) 0 .< mat.len
      L(j) 0 .< mat.len
         augmat[i][j] = mat[i][j]
      augmat[i][mat.len + i] = 1

   transformToRref(&augmat)

   V result = [[0.0] * mat.len] * mat.len
   L(i) 0 .< mat.len
      L(j) 0 .< mat.len
         I augmat[i][j] != Float(i == j)
            X ValueError(‘matrix is singular’)
         result[i][j] = augmat[i][mat.len + j]
   R result

F print_mat(mat)
   L(row) mat
      V line = ‘’
      L(val) row
         I !line.empty
            line ‘’= ‘ ’
         line ‘’= ‘#3.5’.format(val)
      print(line)

F runTest(mat)
   print(‘Matrix:’)
   print_mat(mat)
   print()
   print(‘Inverse:’)
   print_mat(inverse(mat))
   print()
   print()

V m1 = [[Float(1), 2, 3], [Float(4), 1, 6], [Float(7), 8, 9]]

V m2 = [[Float(2), -1, 0], [Float(-1), 2, -1], [Float(0), -1, 2]]

V m3 = [[Float(-1), -2, 3, 2], [Float(-4), -1, 6, 2], [Float(7), -8, 9, 1], [Float(1), -2, 1, 3]]

runTest(m1)
runTest(m2)
runTest(m3)
===
auto Eps = 1e-10;

template <typename T1> auto transformToRref(T1 &mat)
{
    auto lead = 0;

    for (auto r : range_el(0, mat.len())) {
        if (lead >= _get<0>(mat).len())
            return;

        auto i = r;
        while (mat[i][lead] == 0) {
            i++;
            if (i == mat.len()) {
                i = r;
                lead++;
                if (lead == _get<0>(mat).len())
                    return;
            }
        }
        swap(mat[i], mat[r]);

        auto d = mat[r][lead];
        if (abs(d) > Eps)
            for (auto i : range_el(0, mat[r].len()))
                mat[r][i] /= d;

        for (auto i : range_el(0, mat.len()))
            if (i != r) {
                auto m = mat[i][lead];
                for (auto c : range_el(0, _get<0>(mat).len()))
                    mat[i][c] -= mat[r][c] * m;
            }

        lead++;
    }
}

template <typename T1> auto inverse(const T1 &mat)
{
    auto augmat = create_array({create_array({0.0}) * (2 * mat.len())}) * mat.len();
    for (auto i : range_el(0, mat.len())) {
        for (auto j : range_el(0, mat.len()))
            augmat[i].set(j, mat[i][j]);
        augmat[i].set(mat.len() + i, 1);
    }

    transformToRref(augmat);

    auto result = create_array({create_array({0.0}) * mat.len()}) * mat.len();
    for (auto i : range_el(0, mat.len()))
        for (auto j : range_el(0, mat.len())) {
            if (augmat[i][j] != to_float(i == j))
                throw ValueError(u"matrix is singular"_S);
            result[i].set(j, augmat[i][mat.len() + j]);
        }
    return result;
}

template <typename T1> auto print_mat(const T1 &mat)
{
    for (auto &&row : mat) {
        auto line = u""_S;
        for (auto &&val : row) {
            if (!line.empty())
                line &= u" "_S;
            line &= u"#3.5"_S.format(val);
        }
        print(line);
    }
}

template <typename T1> auto runTest(const T1 &mat)
{
    print(u"Matrix:"_S);
    print_mat(mat);
    print();
    print(u"Inverse:"_S);
    print_mat(inverse(mat));
    print();
    print();
}

auto m1 = create_array({create_array<double>({to_float(1), 2, 3}), create_array<double>({to_float(4), 1, 6}), create_array<double>({to_float(7), 8, 9})});

auto m2 = create_array({create_array<double>({to_float(2), -1, 0}), create_array<double>({to_float(-1), 2, -1}), create_array<double>({to_float(0), -1, 2})});

auto m3 = create_array({create_array<double>({to_float(-1), -2, 3, 2}), create_array<double>({to_float(-4), -1, 6, 2}), create_array<double>({to_float(7), -8, 9, 1}), create_array<double>({to_float(1), -2, 1, 3})});

struct CodeBlock1
{
    CodeBlock1()
    {
        runTest(m1);
        runTest(m2);
        runTest(m3);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Generate_random_chess_position#Python
import random
Char = str

board = [[" "] * 8 for y in range(8)]
piece_list = ["R", "N", "B", "Q", "P"]

def place_kings(brd : list):
    while True:
        (rank_white, file_white, rank_black, file_black) = (random.randint(0,7), random.randint(0,7), random.randint(0,7), random.randint(0,7))
        diff_list = [abs(rank_white - rank_black),  abs(file_white - file_black)]
        if sum(diff_list) > 2 or set(diff_list) == set([0, 2]):
            (brd[rank_white][file_white], brd[rank_black][file_black]) = (Char("K"), Char("k"))
            break

def pawn_on_promotion_square(pc, pr):
    if pc == "P" and pr == 0:
        return True
    elif pc == "p" and pr == 7:
        return True
    return False

def populate_board(brd : list, wp, bp):
    for x in range(2):
        piece_amount : int
        pieces : List[Char]
        if x == 0:
            piece_amount = wp
            pieces = piece_list
        else:
            piece_amount = bp
            pieces = [s.lower() for s in piece_list]
        while piece_amount != 0:
            (piece_rank, piece_file) = (random.randint(0, 7), random.randint(0, 7))
            piece = random.choice(pieces)
            if brd[piece_rank][piece_file] == " " and pawn_on_promotion_square(piece, piece_rank) == False:
                brd[piece_rank][piece_file] = piece
                piece_amount -= 1

def fen_from_board(brd):
    fen = ""
    for x in brd:
        n = 0
        for y in x:
            if y == " ":
                n += 1
            else:
                if n != 0:
                    fen += str(n)
                fen += y
                n = 0
        if n != 0:
            fen += str(n)
        fen += "/" if fen.count("/") < 7 else ""
    fen += " w - - 0 1\n"
    return fen

(piece_amount_white, piece_amount_black) = (random.randint(0, 15), random.randint(0, 15))
place_kings(board)
populate_board(board, piece_amount_white, piece_amount_black)
print(fen_from_board(board))
for x in board:
    #print(x)
    print('[' + ', '.join("'" + c + "'" for c in x) + ']')
===
V board = [[‘ ’] * 8] * 8
V piece_list = [‘R’, ‘N’, ‘B’, ‘Q’, ‘P’]

F place_kings(&brd)
   L
      V (rank_white, file_white, rank_black, file_black) = (random:(0 .. 7), random:(0 .. 7), random:(0 .. 7), random:(0 .. 7))
      V diff_list = [abs(rank_white - rank_black), abs(file_white - file_black)]
      I sum(diff_list) > 2 | Set(diff_list) == Set([0, 2])
         (brd[rank_white][file_white], brd[rank_black][file_black]) = (Char(‘K’), Char(‘k’))
         L.break

F pawn_on_promotion_square(pc, pr)
   I pc == ‘P’ & pr == 0
      R 1B
   E I pc == ‘p’ & pr == 7
      R 1B
   R 0B

F populate_board(&brd, wp, bp)
   L(x) 2
      Int piece_amount
      [Char] pieces
      I x == 0
         piece_amount = wp
         pieces = :piece_list
      E
         piece_amount = bp
         pieces = :piece_list.map(s -> s.lowercase())
      L piece_amount != 0
         V (piece_rank, piece_file) = (random:(0 .. 7), random:(0 .. 7))
         V piece = random:choice(pieces)
         I brd[piece_rank][piece_file] == ‘ ’ & pawn_on_promotion_square(piece, piece_rank) == 0B
            brd[piece_rank][piece_file] = piece
            piece_amount--

F fen_from_board(brd)
   V fen = ‘’
   L(x) brd
      V n = 0
      L(y) x
         I y == ‘ ’
            n++
         E
            I n != 0
               fen ‘’= String(n)
            fen ‘’= y
            n = 0
      I n != 0
         fen ‘’= String(n)
      fen ‘’= I fen.count(‘/’) < 7 {‘/’} E ‘’
   fen ‘’= " w - - 0 1\n"
   R fen

V (piece_amount_white, piece_amount_black) = (random:(0 .. 15), random:(0 .. 15))
place_kings(&board)
populate_board(&board, piece_amount_white, piece_amount_black)
print(fen_from_board(board))
L(x) board
   print(‘[’x.map(c -> ‘'’c‘'’).join(‘, ’)‘]’)
===
auto board = create_array({create_array({u' '_C}) * 8}) * 8;
auto piece_list = create_array({u'R'_C, u'N'_C, u'B'_C, u'Q'_C, u'P'_C});

template <typename T1> auto place_kings(T1 &brd)
{
    while (true) {
        auto [rank_white, file_white, rank_black, file_black] = make_tuple(randomns::_(range_ee(0, 7)), randomns::_(range_ee(0, 7)), randomns::_(range_ee(0, 7)), randomns::_(range_ee(0, 7)));
        auto diff_list = create_array({abs(rank_white - rank_black), abs(file_white - file_black)});
        if (sum(diff_list) > 2 || create_set(diff_list) == create_set({0, 2})) {
            assign_from_tuple(brd[rank_white][file_white], brd[rank_black][file_black], make_tuple(u'K'_C, u'k'_C));
            break;
        }
    }
}

template <typename T1, typename T2> auto pawn_on_promotion_square(const T1 &pc, const T2 &pr)
{
    if (pc == u'P' && pr == 0)
        return true;
    else if (pc == u'p' && pr == 7)
        return true;
    return false;
}

template <typename T1, typename T2, typename T3> auto populate_board(T1 &brd, const T2 &wp, const T3 &bp)
{
    for (int x = 0; x < 2; x++) {
        int piece_amount;
        Array<Char> pieces;
        if (x == 0) {
            piece_amount = wp;
            pieces = ::piece_list;
        }
        else {
            piece_amount = bp;
            pieces = ::piece_list.map([](const auto &s){return s.lowercase();});
        }
        while (piece_amount != 0) {
            auto [piece_rank, piece_file] = make_tuple(randomns::_(range_ee(0, 7)), randomns::_(range_ee(0, 7)));
            auto piece = randomns::choice(pieces);
            if (brd[piece_rank][piece_file] == u' ' && pawn_on_promotion_square(piece, piece_rank) == false) {
                brd[piece_rank].set(piece_file, piece);
                piece_amount--;
            }
        }
    }
}

template <typename T1> auto fen_from_board(const T1 &brd)
{
    auto fen = u""_S;
    for (auto &&x : brd) {
        auto n = 0;
        for (auto &&y : x)
            if (y == u' ')
                n++;
            else {
                if (n != 0)
                    fen &= String(n);
                fen &= y;
                n = 0;
            }
        if (n != 0)
            fen &= String(n);
        fen &= fen.count(u"/"_S) < 7 ? u"/"_S : u""_S;
    }
    fen &= u" w - - 0 1\n"_S;
    return fen;
}

auto [piece_amount_white, piece_amount_black] = make_tuple(randomns::_(range_ee(0, 15)), randomns::_(range_ee(0, 15)));

struct CodeBlock1
{
    CodeBlock1()
    {
        place_kings(board);
        populate_board(board, piece_amount_white, piece_amount_black);
        print(fen_from_board(board));
        for (auto &&x : board)
            print(u"["_S & x.map([](const auto &c){return u"'"_S & c & u"'"_S;}).join(u", "_S) & u"]"_S);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Geohash#Python
ch32 = list("0123456789bcdefghjkmnpqrstuvwxyz")
bool2ch = {bin(i)[2:].zfill(5): ch for i, ch in enumerate(ch32)}
ch2bool = {v : k for k, v in bool2ch.items()}

def bisect(val, mn, mx, bits):
    mid = (mn + mx) / 2
    if val < mid:
        bits <<= 1                        # push 0
        mx = mid                          # range lower half
    else:
        bits = bits << 1 | 1              # push 1
        mn = mid                          # range upper half

    return (mn, mx, bits)

def encoder(lat, lng, pre):
    (latmin, latmax) = (-90.0, 90.0)
    (lngmin, lngmax) = (-180.0, 180.0)
    bits = Int64(0)
    for i in range(pre * 5):
        if i % 2 != 0:
            # odd bit: bisect latitude
            (latmin, latmax, bits) = bisect(lat, latmin, latmax, bits)
        else:
            # even bit: bisect longitude
            (lngmin, lngmax, bits) = bisect(lng, lngmin, lngmax, bits)
    # Bits to characters
    #b = f"{bits:0{pre * 5}b}"
    b = bin(bits)[2:].zfill(pre * 5)
    geo = (bool2ch[b[i*5: (i+1)*5]] for i in range(pre))

    return ''.join(geo)

def decoder(geo):
    (minmaxes, latlong) = ([[-90.0, 90.0], [-180.0, 180.0]], True)
    for c in geo:
        for bit in ch2bool[c]:
            minmaxes[latlong][bit != '1'] = sum(minmaxes[latlong]) / 2
            latlong = not latlong

    return minmaxes

for lat, lng, pre in [(51.433718, -0.214126,  2),
                      (51.433718, -0.214126,  9),
                      (57.64911,  10.40744 , 11)]:
    print("encoder(lat=%f, lng=%f, pre=%i) = '%s'"
          % (lat, lng, pre, encoder(lat, lng, pre)))
===
V ch32 = Array(‘0123456789bcdefghjkmnpqrstuvwxyz’)
V bool2ch = Dict(enumerate(ch32), (i, ch) -> (bin(i).zfill(5), ch))
V ch2bool = Dict(bool2ch.items(), (k, v) -> (v, k))

F bisect(val, =mn, =mx, =bits)
   V mid = (mn + mx) / 2
   I val < mid
      bits <<= 1
      mx = mid
   E
      bits = bits << 1 [|] 1
      mn = mid

   R (mn, mx, bits)

F encoder(lat, lng, pre)
   V (latmin, latmax) = (-90.0, 90.0)
   V (lngmin, lngmax) = (-180.0, 180.0)
   V bits = Int64(0)
   L(i) 0 .< pre * 5
      I i % 2 != 0
         (latmin, latmax, bits) = bisect(lat, latmin, latmax, bits)
      E
         (lngmin, lngmax, bits) = bisect(lng, lngmin, lngmax, bits)
   V b = bin(bits).zfill(pre * 5)
   V geo = ((0 .< pre).map(i -> :bool2ch[@b[i * 5 .< (i + 1) * 5]]))

   R geo.join(‘’)

F decoder(geo)
   V (minmaxes, latlong) = ([[-90.0, 90.0], [-180.0, 180.0]], 1B)
   L(c) geo
      L(bit) :ch2bool[c]
         minmaxes[latlong][bit != ‘1’] = sum(minmaxes[latlong]) / 2
         latlong = !latlong

   R minmaxes

L(lat, lng, pre) [(51.433718, -0.214126, 2), (51.433718, -0.214126, 9), (57.64911, 10.40744, 11)]
   print(‘encoder(lat=#.6, lng=#.6, pre=#.) = '#.'’.format(lat, lng, pre, encoder(lat, lng, pre)))
===
auto ch32 = create_array(u"0123456789bcdefghjkmnpqrstuvwxyz"_S);
auto bool2ch = create_dict(enumerate(ch32), [](const auto &i, const auto &ch){return make_tuple(bin(i).zfill(5), ch);});
auto ch2bool = create_dict(bool2ch.items(), [](const auto &k, const auto &v){return make_tuple(v, k);});

template <typename T1, typename T2, typename T3, typename T4> auto bisect(const T1 &val, T2 mn, T3 mx, T4 bits)
{
    auto mid = (mn + mx) / 2.0;
    if (val < mid) {
        bits <<= 1;
        mx = mid;
    }
    else {
        bits = bits << 1 | 1;
        mn = mid;
    }

    return make_tuple(mn, mx, bits);
}

template <typename T1, typename T2, typename T3> auto encoder(const T1 &lat, const T2 &lng, const T3 &pre)
{
    auto [latmin, latmax] = make_tuple(-90.0, 90.0);
    auto [lngmin, lngmax] = make_tuple(-180.0, 180.0);
    auto bits = to_int64(0);
    for (auto i : range_el(0, pre * 5))
        if (mod(i, 2) != 0)
            assign_from_tuple(latmin, latmax, bits, bisect(lat, latmin, latmax, bits));
        else
            assign_from_tuple(lngmin, lngmax, bits, bisect(lng, lngmin, lngmax, bits));
    auto b = bin(bits).zfill(pre * 5);
    auto geo = (range_el(0, pre).map([&b](const auto &i){return ::bool2ch[b[range_el(i * 5, (i + 1) * 5)]];}));

    return geo.join(u""_S);
}

template <typename T1> auto decoder(const T1 &geo)
{
    auto [minmaxes, latlong] = make_tuple(create_array({create_array({-90.0, 90.0}), create_array({-180.0, 180.0})}), true);
    for (auto &&c : geo)
        for (auto &&bit : ::ch2bool[c]) {
            minmaxes[latlong].set(bit != u'1', sum(minmaxes[latlong]) / 2.0);
            latlong = !latlong;
        }

    return minmaxes;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&[lat, lng, pre] : create_array({make_tuple(51.433718, -0.214126, 2), make_tuple(51.433718, -0.214126, 9), make_tuple(57.64911, 10.40744, 11)}))
            print(u"encoder(lat=#.6, lng=#.6, pre=#.) = '#.'"_S.format(lat, lng, pre, encoder(lat, lng, pre)));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Getting_the_number_of_decimals#Python
def dec(n):
    return len(n.split('.')[-1]) if '.' in n else 0

print(dec('12.345'))
print(dec('12.3450'))
===
F dec(n)
   R I ‘.’ C n {n.split(‘.’).last.len} E 0

print(dec(‘12.345’))
print(dec(‘12.3450’))
===
template <typename T1> auto dec(const T1 &n)
{
    return in(u'.'_C, n) ? n.split(u"."_S).last().len() : 0;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(dec(u"12.345"_S));
        print(dec(u"12.3450"_S));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Graph_colouring#Python
import collections, itertools

def first_avail_int(data):
    "return lowest int 0... not in data"
    d = set(data)
    for i in itertools.count(0):
        if i not in d:
            return i

def greedy_colour(name, connections):
    graph : DefaultDict[int, List[int]] = collections.defaultdict(list)  # maps vertex to direct connections

    for connection in connections.split(' '):
        if '-' in connection:
            (n1, n2) = map(int, connection.split('-'))
            graph[n1].append(n2)    # Each the neighbour of the other
            graph[n2].append(n1)
        else:
            graph[int(connection)] = [0] * 0

    "Greedy colourisation algo."
    order = sorted(graph.keys())      # Choose something
    colour : Dict[int, int] = {}
    neighbours = graph
    for node in order:
        used_neighbour_colours = (colour[nbr] for nbr in neighbours[node]
                                  if nbr in colour)
        colour[node] = first_avail_int(used_neighbour_colours)

    print("\n" + name)
    canonical_edges = set() # Tuple[int, int]
    for n1, neighbours in sorted(graph.items()):
        if len(neighbours):
            for n2 in neighbours:
                edge = tuple(sorted((n1, n2)))
                if edge not in canonical_edges:
                    print("       {}-{}: Colour: {}, {}".format(n1, n2, colour[n1], colour[n2]))
                    canonical_edges.add(edge)
        else:
            print("         {}: Colour: {}".format(n1, colour[n1]))
    lc = len(set(colour.values()))
    print("    #Nodes: {}\n    #Edges: {}\n  #Colours: {}".format(len(colour), len(canonical_edges), lc))

for name, connections in [
        ('Ex1', "0-1 1-2 2-0 3"),
        ('Ex2', "1-6 1-7 1-8 2-5 2-7 2-8 3-5 3-6 3-8 4-5 4-6 4-7"),
        ('Ex3', "1-4 1-6 1-8 3-2 3-6 3-8 5-2 5-4 5-8 7-2 7-4 7-6"),
        ('Ex4', "1-6 7-1 8-1 5-2 2-7 2-8 3-5 6-3 3-8 4-5 4-6 4-7"),
        ]:
    greedy_colour(name, connections)
===
F first_avail_int(data)
   ‘return lowest int 0... not in data’
   V d = Set(data)
   L(i) 0..
      I i !C d
         R i

F greedy_colour(name, connections)
   DefaultDict[Int, [Int]] graph

   L(connection) connections.split(‘ ’)
      I ‘-’ C connection
         V (n1, n2) = connection.split(‘-’).map(Int)
         graph[n1].append(n2)
         graph[n2].append(n1)
      E
         graph[Int(connection)] = [Int]()

   ‘Greedy colourisation algo.’
   V order = sorted(graph.keys())
   [Int = Int] colour
   V neighbours = graph
   L(node) order
      V used_neighbour_colours = (neighbours[node].filter(nbr -> nbr C @colour).map(nbr -> @colour[nbr]))
      colour[node] = first_avail_int(used_neighbour_colours)

   print("\n"name)
   V canonical_edges = Set[(Int, Int)]()
   L(n1, neighbours) sorted(graph.items())
      I !neighbours.empty
         L(n2) neighbours
            V edge = tuple_sorted((n1, n2))
            I edge !C canonical_edges
               print(‘       #.-#.: Colour: #., #.’.format(n1, n2, colour[n1], colour[n2]))
               canonical_edges.add(edge)
      E
         print(‘         #.: Colour: #.’.format(n1, colour[n1]))
   V lc = Set(colour.values()).len
   print("    #Nodes: #.\n    #Edges: #.\n  #Colours: #.".format(colour.len, canonical_edges.len, lc))

L(name, connections) [(‘Ex1’, ‘0-1 1-2 2-0 3’), (‘Ex2’, ‘1-6 1-7 1-8 2-5 2-7 2-8 3-5 3-6 3-8 4-5 4-6 4-7’), (‘Ex3’, ‘1-4 1-6 1-8 3-2 3-6 3-8 5-2 5-4 5-8 7-2 7-4 7-6’), (‘Ex4’, ‘1-6 7-1 8-1 5-2 2-7 2-8 3-5 6-3 3-8 4-5 4-6 4-7’)]
   greedy_colour(name, connections)
===
template <typename T1> auto first_avail_int(const T1 &data)
{
    u"return lowest int 0... not in data"_S;
    auto d = create_set(data);
    for (auto i : range_ei(0))
        if (!in(i, d))
            return i;
}

template <typename T1, typename T2> auto greedy_colour(const T1 &name, const T2 &connections)
{
    DefaultDict<int, Array<int>> graph;

    for (auto &&connection : connections.split(u" "_S))
        if (in(u'-'_C, connection)) {
            auto [n1, n2] = bind_array<2>(connection.split(u"-"_S).map([](const auto &x){return to_int(x);}));
            graph[n1].append(n2);
            graph[n2].append(n1);
        }
        else
            graph.set(to_int(connection), Array<int>());

    u"Greedy colourisation algo."_S;
    auto order = sorted(graph.keys());
    Dict<int, int> colour;
    auto neighbours = graph;
    for (auto &&node : order) {
        auto used_neighbour_colours = (neighbours[node].filter([&colour](const auto &nbr){return in(nbr, colour);}).map([&colour](const auto &nbr){return colour[nbr];}));
        colour.set(node, first_avail_int(used_neighbour_colours));
    }

    print(u"\n"_S & name);
    auto canonical_edges = Set<ivec2>();
    for (auto &&[n1, neighbours] : sorted(graph.items()))
        if (!neighbours.empty())
            for (auto &&n2 : neighbours) {
                auto edge = tuple_sorted(make_tuple(n1, n2));
                if (!in(edge, canonical_edges)) {
                    print(u"       #.-#.: Colour: #., #."_S.format(n1, n2, colour[n1], colour[n2]));
                    canonical_edges.add(edge);
                }
            }
        else
            print(u"         #.: Colour: #."_S.format(n1, colour[n1]));
    auto lc = create_set(colour.values()).len();
    print(u"    #Nodes: #.\n    #Edges: #.\n  #Colours: #."_S.format(colour.len(), canonical_edges.len(), lc));
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&[name, connections] : create_array({make_tuple(u"Ex1"_S, u"0-1 1-2 2-0 3"_S), make_tuple(u"Ex2"_S, u"1-6 1-7 1-8 2-5 2-7 2-8 3-5 3-6 3-8 4-5 4-6 4-7"_S), make_tuple(u"Ex3"_S, u"1-4 1-6 1-8 3-2 3-6 3-8 5-2 5-4 5-8 7-2 7-4 7-6"_S), make_tuple(u"Ex4"_S, u"1-6 7-1 8-1 5-2 2-7 2-8 3-5 6-3 3-8 4-5 4-6 4-7"_S)}))
            greedy_colour(name, connections);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Gray_code#Python
def gray_encode(n):
    return n ^ n >> 1

def gray_decode(n):
    m = n >> 1
    while m != 0:
        n ^= m
        m >>= 1
    return n

print("DEC,   BIN =>  GRAY => DEC")
for i in range(32):
    gray = gray_encode(i)
    dec = gray_decode(gray)
    #print(f" {i:>2d}, {i:>05b} => {gray:>05b} => {dec:>2d}")
    print(' %2d, %s => %s => %2d' % (i, bin(i)[2:].zfill(5), bin(gray)[2:].zfill(5), dec))
===
F gray_encode(n)
   R n (+) n >> 1

F gray_decode(=n)
   V m = n >> 1
   L m != 0
      n (+)= m
      m >>= 1
   R n

print(‘DEC,   BIN =>  GRAY => DEC’)
L(i) 32
   V gray = gray_encode(i)
   V dec = gray_decode(gray)
   print(‘ #2, #. => #. => #2’.format(i, bin(i).zfill(5), bin(gray).zfill(5), dec))
===
template <typename T1> auto gray_encode(const T1 &n)
{
    return n ^ n >> 1;
}

template <typename T1> auto gray_decode(T1 n)
{
    auto m = n >> 1;
    while (m != 0) {
        n ^= m;
        m >>= 1;
    }
    return n;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"DEC,   BIN =>  GRAY => DEC"_S);
        for (int i = 0; i < 32; i++) {
            auto gray = gray_encode(i);
            auto dec = gray_decode(gray);
            print(u" #2, #. => #. => #2"_S.format(i, bin(i).zfill(5), bin(gray).zfill(5), dec));
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Guess_the_number/With_feedback#Python
import random

(target_min, target_max) = (1, 100)

print("Guess my target number that is between %i and %i (inclusive).\n"
      % (target_min, target_max))
target = random.randint(target_min, target_max)
(answer, i) = (target_min - 1, 0)
while answer != target:
    i += 1
    txt = input("Your guess(%i): " % i)
    try:
        answer = int(txt)
    except ValueError:
        print("  I don't understand your input of '%s' ?" % txt)
        continue
    if answer < target_min or answer > target_max:
        print("  Out of range!")
        continue
    if answer == target:
        print("  Ye-Haw!!")
        break
    if answer < target: print("  Too low.")
    if answer > target: print("  Too high.")

print("\nThanks for playing.")
===
V (target_min, target_max) = (1, 100)

print("Guess my target number that is between #. and #. (inclusive).\n".format(target_min, target_max))
V target = random:(target_min .. target_max)
V (answer, i) = (target_min - 1, 0)
L answer != target
   i++
   V txt = input(‘Your guess(#.): ’.format(i))
   X.try
      answer = Int(txt)
   X.catch ValueError
      print(‘  I don't understand your input of '#.' ?’.format(txt))
      L.continue
   I answer < target_min | answer > target_max
      print(‘  Out of range!’)
      L.continue
   I answer == target
      print(‘  Ye-Haw!!’)
      L.break
   I answer < target
      print(‘  Too low.’)
   I answer > target
      print(‘  Too high.’)

print("\nThanks for playing.")
===
auto [target_min, target_max] = make_tuple(1, 100);

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"Guess my target number that is between #. and #. (inclusive).\n"_S.format(target_min, target_max));
    }
} code_block_1;

auto target = randomns::_(range_ee(target_min, target_max));
auto [answer, i] = make_tuple(target_min - 1, 0);

struct CodeBlock2
{
    CodeBlock2()
    {
        while (answer != target) {
            i++;
            auto txt = input(u"Your guess(#.): "_S.format(i));
            try
            {
                answer = to_int(txt);
            }
            catch (const ValueError&)
            {
                print(u"  I don't understand your input of '#.' ?"_S.format(txt));
                continue;
            }
            if (answer < target_min || answer > target_max) {
                print(u"  Out of range!"_S);
                continue;
            }
            if (answer == target) {
                print(u"  Ye-Haw!!"_S);
                break;
            }
            if (answer < target)
                print(u"  Too low."_S);
            if (answer > target)
                print(u"  Too high."_S);
        }

        print(u"\nThanks for playing."_S);
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Guess_the_number/With_feedback_(player)#Python
(target_min, target_max) = (1, 10)
(mn, mx) = (target_min, target_max)

print(
'''Think of a number between %i and %i and wait for me to guess it.
On every guess of mine you should state whether the guess was
too high, too low, or equal to your number by typing h, l, or =
''' % (target_min, target_max))

i = 0
while True:
    i += 1
    guess = (mn+mx)//2
    txt = input("Guess %2i is: %2i. The score for which is (h,l,=): "
                % (i, guess)).strip(' ').lower()[0]
    if txt not in 'hl=':
        print("  I don't understand your input of '%s' ?" % txt)
        continue
    if txt == 'h':
        mx = guess-1
    if txt == 'l':
        mn = guess+1
    if txt == '=':
        print("  Ye-Haw!!")
        break
    if (mn > mx) or (mn < target_min) or (mx > target_max):
        print("Please check your scoring as I cannot find the value")
        break

print("\nThanks for keeping score.")
===
V (target_min, target_max) = (1, 10)
V (mn, mx) = (target_min, target_max)

print(‘Think of a number between #. and #. and wait for me to guess it.
On every guess of mine you should state whether the guess was
too high, too low, or equal to your number by typing h, l, or =
’.format(target_min, target_max))

V i = 0
L
   i++
   V guess = (mn + mx) I/ 2
   V txt = input(‘Guess #2 is: #2. The score for which is (h,l,=): ’.format(i, guess)).trim(‘ ’).lowercase()[0]
   I txt !C ‘hl=’
      print(‘  I don't understand your input of '#.' ?’.format(txt))
      L.continue
   I txt == ‘h’
      mx = guess - 1
   I txt == ‘l’
      mn = guess + 1
   I txt == ‘=’
      print(‘  Ye-Haw!!’)
      L.break
   I (mn > mx) | (mn < target_min) | (mx > target_max)
      print(‘Please check your scoring as I cannot find the value’)
      L.break

print("\nThanks for keeping score.")
===
auto [target_min, target_max] = make_tuple(1, 10);
auto [mn, mx] = make_tuple(target_min, target_max);

struct CodeBlock1
{
    CodeBlock1()
    {
        print(uR"(Think of a number between #. and #. and wait for me to guess it.
On every guess of mine you should state whether the guess was
too high, too low, or equal to your number by typing h, l, or =
)"_S.format(target_min, target_max));
    }
} code_block_1;

auto i = 0;

struct CodeBlock2
{
    CodeBlock2()
    {
        while (true) {
            i++;
            auto guess = idiv((mn + mx), 2);
            auto txt = _get<0>(input(u"Guess #2 is: #2. The score for which is (h,l,=): "_S.format(i, guess)).trim(u" "_S).lowercase());
            if (!in(txt, u"hl="_S)) {
                print(u"  I don't understand your input of '#.' ?"_S.format(txt));
                continue;
            }
            if (txt == u'h')
                mx = guess - 1;
            if (txt == u'l')
                mn = guess + 1;
            if (txt == u'=') {
                print(u"  Ye-Haw!!"_S);
                break;
            }
            if ((mn > mx) || (mn < target_min) || (mx > target_max)) {
                print(u"Please check your scoring as I cannot find the value"_S);
                break;
            }
        }

        print(u"\nThanks for keeping score."_S);
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Generate_random_numbers_without_repeating_a_value#Nim
import random

def generate(a, b):
    result : List[int] = []
    count = b - a + 1
    generated = [False] * count
    while True:
        n = random.randint(a, b)
        if not generated[n - a]:
            generated[n - a] = True
            result.append(n)
            count -= 1
            if count == 0:
                break
    return result

for i in range(5):
    print(generate(1, 20))
===
F generate(a, b)
   [Int] result
   V count = b - a + 1
   V generated = [0B] * count
   L
      V n = random:(a .. b)
      I !generated[n - a]
         generated[n - a] = 1B
         result.append(n)
         I --count == 0
            L.break
   R result

L(i) 5
   print(generate(1, 20))
===
template <typename T1, typename T2> auto generate(const T1 &a, const T2 &b)
{
    Array<int> result;
    auto count = b - a + 1;
    auto generated = create_array({false}) * count;
    while (true) {
        auto n = randomns::_(range_ee(a, b));
        if (!generated[n - a]) {
            generated.set(n - a, true);
            result.append(n);
            if (--count == 0)
                break;
        }
    }
    return result;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (int i = 0; i < 5; i++)
            print(generate(1, 20));
    }
} code_block_1;