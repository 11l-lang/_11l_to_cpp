# https://www.rosettacode.org/wiki/Bacon_cipher#Nim
Char = str

codes = {'a': "AAAAA", 'b': "AAAAB", 'c': "AAABA", 'd': "AAABB", 'e': "AABAA",
         'f': "AABAB", 'g': "AABBA", 'h': "AABBB", 'i': "ABAAA", 'j': "ABAAB",
         'k': "ABABA", 'l': "ABABB", 'm': "ABBAA", 'n': "ABBAB", 'o': "ABBBA",
         'p': "ABBBB", 'q': "BAAAA", 'r': "BAAAB", 's': "BAABA", 't': "BAABB",
         'u': "BABAA", 'v': "BABAB", 'w': "BABBA", 'x': "BABBB", 'y': "BBAAA",
         'z': "BBAAB", ' ': "BBBAA"}

rev_codes = {v: k for k, v in codes.items()}

def encode(plaintext, message):
    et = ''
    for c in plaintext.lower():
        et += codes[c] if 'a' <= c <= 'z' else codes[Char(' ')]

    result = ''
    count = 0
    for c in message.lower():
        if 'a' <= c <= 'z':
            result += c if et[count] == 'A' else c.upper()
            count += 1
            if count == len(et): break
        else:
            result += c
    return result

def decode(message):
    result = ''
    et = ''
    for c in message:
        if 'A' <= c <= 'Z' or 'a' <= c <= 'z':
            et += 'A' if c.islower() else 'B'
    for i in range(0, len(et) - 4, 5):
        result += rev_codes[et[i:i+5]]
    return result

plaintext = "the quick brown fox jumps over the lazy dog"
message = "bacon's cipher is a method of steganography created by francis bacon." + \
          "this task is to implement a program for encryption and decryption of " + \
          "plaintext using the simple alphabet of the baconian cipher or some " + \
          "other kind of representation of this alphabet (make anything signify anything). " + \
          "the baconian alphabet may optionally be extended to encode all lower " + \
          "case characters individually and/or adding a few punctuation characters " + \
          "such as the space."

ciphertext = encode(plaintext, message)
print('Cipher text →')
print(ciphertext)
decodedtext = decode(ciphertext)
print("\nHidden text →")
print(decodedtext)
===
V codes = [‘a’ = ‘AAAAA’, ‘b’ = ‘AAAAB’, ‘c’ = ‘AAABA’, ‘d’ = ‘AAABB’, ‘e’ = ‘AABAA’, ‘f’ = ‘AABAB’, ‘g’ = ‘AABBA’, ‘h’ = ‘AABBB’, ‘i’ = ‘ABAAA’, ‘j’ = ‘ABAAB’, ‘k’ = ‘ABABA’, ‘l’ = ‘ABABB’, ‘m’ = ‘ABBAA’, ‘n’ = ‘ABBAB’, ‘o’ = ‘ABBBA’, ‘p’ = ‘ABBBB’, ‘q’ = ‘BAAAA’, ‘r’ = ‘BAAAB’, ‘s’ = ‘BAABA’, ‘t’ = ‘BAABB’, ‘u’ = ‘BABAA’, ‘v’ = ‘BABAB’, ‘w’ = ‘BABBA’, ‘x’ = ‘BABBB’, ‘y’ = ‘BBAAA’, ‘z’ = ‘BBAAB’, ‘ ’ = ‘BBBAA’]

V rev_codes = Dict(codes.items(), (k, v) -> (v, k))

F encode(plaintext, message)
   V et = ‘’
   L(c) plaintext.lowercase()
      et ‘’= I c C ‘a’..‘z’ {:codes[c]} E :codes[Char(‘ ’)]

   V result = ‘’
   V count = 0
   L(c) message.lowercase()
      I c C ‘a’..‘z’
         result ‘’= I et[count] == ‘A’ {c} E c.uppercase()
         count++
         I count == et.len
            L.break
      E
         result ‘’= c
   R result

F decode(message)
   V result = ‘’
   V et = ‘’
   L(c) message
      I c C ‘A’..‘Z’ | c C ‘a’..‘z’
         et ‘’= I c.is_lowercase() {‘A’} E ‘B’
   L(i) (0 .< et.len - 4).step(5)
      result ‘’= :rev_codes[et[i .< i + 5]]
   R result

V plaintext = ‘the quick brown fox jumps over the lazy dog’
V message = ‘bacon's cipher is a method of steganography created by francis bacon.’""‘this task is to implement a program for encryption and decryption of ’""‘plaintext using the simple alphabet of the baconian cipher or some ’""‘other kind of representation of this alphabet (make anything signify anything). ’""‘the baconian alphabet may optionally be extended to encode all lower ’""‘case characters individually and/or adding a few punctuation characters ’""‘such as the space.’

V ciphertext = encode(plaintext, message)
print(‘Cipher text →’)
print(ciphertext)
V decodedtext = decode(ciphertext)
print("\nHidden text →")
print(decodedtext)
===
auto codes = create_dict(dict_of(u'a'_C, u"AAAAA"_S)(u'b'_C, u"AAAAB"_S)(u'c'_C, u"AAABA"_S)(u'd'_C, u"AAABB"_S)(u'e'_C, u"AABAA"_S)(u'f'_C, u"AABAB"_S)(u'g'_C, u"AABBA"_S)(u'h'_C, u"AABBB"_S)(u'i'_C, u"ABAAA"_S)(u'j'_C, u"ABAAB"_S)(u'k'_C, u"ABABA"_S)(u'l'_C, u"ABABB"_S)(u'm'_C, u"ABBAA"_S)(u'n'_C, u"ABBAB"_S)(u'o'_C, u"ABBBA"_S)(u'p'_C, u"ABBBB"_S)(u'q'_C, u"BAAAA"_S)(u'r'_C, u"BAAAB"_S)(u's'_C, u"BAABA"_S)(u't'_C, u"BAABB"_S)(u'u'_C, u"BABAA"_S)(u'v'_C, u"BABAB"_S)(u'w'_C, u"BABBA"_S)(u'x'_C, u"BABBB"_S)(u'y'_C, u"BBAAA"_S)(u'z'_C, u"BBAAB"_S)(u' '_C, u"BBBAA"_S));

auto rev_codes = create_dict(codes.items(), [](const auto &k, const auto &v){return make_tuple(v, k);});

template <typename T1, typename T2> auto encode(const T1 &plaintext, const T2 &message)
{
    auto et = u""_S;
    for (auto &&c : plaintext.lowercase())
        et &= in(c, range_ee(u'a'_C, u'z'_C)) ? ::codes[c] : ::codes[u' '_C];

    auto result = u""_S;
    auto count = 0;
    for (auto &&c : message.lowercase())
        if (in(c, range_ee(u'a'_C, u'z'_C))) {
            result &= et[count] == u'A' ? c : c.uppercase();
            count++;
            if (count == et.len())
                break;
        }
        else
            result &= c;
    return result;
}

template <typename T1> auto decode(const T1 &message)
{
    auto result = u""_S;
    auto et = u""_S;
    for (auto &&c : message)
        if (in(c, range_ee(u'A'_C, u'Z'_C)) || in(c, range_ee(u'a'_C, u'z'_C)))
            et &= c.is_lowercase() ? u'A'_C : u'B'_C;
    for (auto i : range_el(0, et.len() - 4).step(5))
        result &= ::rev_codes[et[range_el(i, i + 5)]];
    return result;
}

auto plaintext = u"the quick brown fox jumps over the lazy dog"_S;
auto message = u"bacon's cipher is a method of steganography created by francis bacon."_S & u"this task is to implement a program for encryption and decryption of "_S & u"plaintext using the simple alphabet of the baconian cipher or some "_S & u"other kind of representation of this alphabet (make anything signify anything). "_S & u"the baconian alphabet may optionally be extended to encode all lower "_S & u"case characters individually and/or adding a few punctuation characters "_S & u"such as the space."_S;

auto ciphertext = encode(plaintext, message);

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"Cipher text →"_S);
        print(ciphertext);
    }
} code_block_1;

auto decodedtext = decode(ciphertext);

struct CodeBlock2
{
    CodeBlock2()
    {
        print(u"\nHidden text →"_S);
        print(decodedtext);
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Balanced_ternary#Python
from typing import ClassVar, List
from functools import reduce

def py_idiv(a, b): # ‘floored quotient of x and y’/‘python floor division implementation’
    if a >= 0:
        return a // b
    #return (a - b + 1) // b
    return -(-(a - b + 1) // b)

class BalancedTernary:
    str2dig : ClassVar = {'+': 1, '-': -1, '0': 0} # immutable
    dig2str : ClassVar = {1: '+', -1: '-', 0: '0'} # immutable
    table : ClassVar = [(0, -1), (1, -1), (-1, 0), (0, 0), (1, 0), (-1, 1), (0, 1)] # immutable

    # Represented as a list of 0, 1 or -1s, with least significant digit first.
    digits : List[int]

    def __init__(self, inp):
        if all(d in (0, 1, -1) for d in inp):
            self.digits = inp[:]
        else:
            raise ValueError("BalancedTernary: Wrong input digits.")

    @staticmethod
    def int2ternary(n):
        if n == 0: return [0]*0
        n3 = ((n % 3) + 3) % 3
        if n3 == 0: return [0] + BalancedTernary.int2ternary(py_idiv(n, 3))
        if n3 == 1: return [1] + BalancedTernary.int2ternary(py_idiv(n, 3))
        if n3 == 2: return [-1] + BalancedTernary.int2ternary(py_idiv((n + 1), 3))
        raise RuntimeError('')

    def to_int(self):
        return reduce(lambda y,x: x + 3 * y, reversed(self.digits), 0)

    def __str__(self):
        if len(self.digits) == 0: return "0"
        return "".join(BalancedTernary.dig2str[d] for d in reversed(self.digits))

    @staticmethod
    def neg(digs):
        return [-d for d in digs]

    def __neg__(self):
        return BalancedTernary(BalancedTernary.neg(self.digits))

    @staticmethod
    def add(a, b, c=0):
        if not (len(a) != 0 and len(b) != 0):
            if c == 0:
                return a if len(a) else b
            else:
                return BalancedTernary.add([c], a if len(a) else b)
        else:
            (d, c) = BalancedTernary.table[3 + (a[0] if len(a) else 0) + (b[0] if len(b) else 0) + c]
            res = BalancedTernary.add(a[1:], b[1:], c)
            # trim leading zeros
            if len(res) != 0 or d != 0:
                return [d] + res
            else:
                return res

    def __add__(self, b):
        return BalancedTernary(BalancedTernary.add(self.digits, b.digits))

    def __sub__(self, b):
        return self + (-b)
        #return self + BalancedTernary(BalancedTernary_neg(b.digits))

    def __mul__(self, b):
        def _mul(a : List[int], b : List[int]) -> List[int]:
            if not (len(a) != 0 and len(b) != 0):
                return [0]*0
            else:
                x : List[int] = []
                if   a[0] == -1: x = BalancedTernary.neg(b)
                elif a[0] ==  0: pass#x = []
                elif a[0] ==  1: x = b
                else: assert False
                y = [0] + _mul(list(a[1:]), b)
                return BalancedTernary.add(x, y)

        return BalancedTernary(_mul(list(self.digits), list(b.digits)))

def createBalancedTernaryFromStr(inp):
    return BalancedTernary([BalancedTernary.str2dig[c] for c in reversed(inp)])
def createBalancedTernaryFromInt(inp):
    return BalancedTernary(BalancedTernary.int2ternary(inp))

a = createBalancedTernaryFromStr("+-0++0+")
print("a:", a.to_int(), a)

b = createBalancedTernaryFromInt(-436)
print("b:", b.to_int(), b)

c = createBalancedTernaryFromStr("+-++-")
print("c:", c.to_int(), c)

r = a * (b - c)
print("a * (b - c):", r.to_int(), r)
===
F py_idiv(a, b)
   I a >= 0
      R a I/ b
   R -(-(a - b + 1) I/ b)

T BalancedTernary
   :str2dig = [‘+’ = 1, ‘-’ = -1, ‘0’ = 0]
   :dig2str = [1 = ‘+’, -1 = ‘-’, 0 = ‘0’]
   :table = [(0, -1), (1, -1), (-1, 0), (0, 0), (1, 0), (-1, 1), (0, 1)]

   [Int] digits

   F (inp)
      I all(inp.map(d -> d C (0, 1, -1)))
         .digits = copy(inp)
      E
         X ValueError(‘BalancedTernary: Wrong input digits.’)

   F :int2ternary(n)
      I n == 0
         R [Int]()
      V n3 = ((n % 3) + 3) % 3
      I n3 == 0
         R [0] [+] BalancedTernary.int2ternary(py_idiv(n, 3))
      I n3 == 1
         R [1] [+] BalancedTernary.int2ternary(py_idiv(n, 3))
      I n3 == 2
         R [-1] [+] BalancedTernary.int2ternary(py_idiv((n + 1), 3))
      X RuntimeError(‘’)

   F to_int()
      R reversed(.digits).reduce(0, (y, x) -> x + 3 * y)

   F String()
      I .digits.empty
         R ‘0’
      R reversed(.digits).map(d -> BalancedTernary.:dig2str[d]).join(‘’)

   F :neg(digs)
      R digs.map(d -> -d)

   F -()
      R BalancedTernary(BalancedTernary.neg(.digits))

   F :add(a, b, =c = 0)
      I !(!a.empty & !b.empty)
         I c == 0
            R I !a.empty {a} E b
         E
            R BalancedTernary.add([c], I !a.empty {a} E b)
      E
         (V d, c) = BalancedTernary.:table[3 + (I !a.empty {a[0]} E 0) + (I !b.empty {b[0]} E 0) + c]
         V res = BalancedTernary.add(a[1..], b[1..], c)
         I !res.empty | d != 0
            R [d] [+] res
         E
            R res

   F +(b)
      R BalancedTernary(BalancedTernary.add(.digits, b.digits))

   F -(b)
      R (.) + (-b)

   F *(b)
      F _mul([Int] &a, [Int] &b) -> [Int]
         I !(!a.empty & !b.empty)
            R [Int]()
         E
            [Int] x
            I a[0] == -1
               x = BalancedTernary.neg(b)
            E I a[0] == 0
            {
            }
            E I a[0] == 1
               x = b
            E
               assert(0B)
            V y = [0] [+] @_mul(&Array(a[1..]), &b)
            R BalancedTernary.add(x, y)

      R BalancedTernary(_mul(&Array(.digits), &Array(b.digits)))

F createBalancedTernaryFromStr(inp)
   R BalancedTernary(reversed(inp).map(c -> BalancedTernary.:str2dig[c]))
F createBalancedTernaryFromInt(inp)
   R BalancedTernary(BalancedTernary.int2ternary(inp))

V a = createBalancedTernaryFromStr(‘+-0++0+’)
print(‘a: ’a.to_int()‘ ’a)

V b = createBalancedTernaryFromInt(-436)
print(‘b: ’b.to_int()‘ ’b)

V c = createBalancedTernaryFromStr(‘+-++-’)
print(‘c: ’c.to_int()‘ ’c)

V r = a * (b - c)
print(‘a * (b - c): ’r.to_int()‘ ’r)
===
template <typename T1, typename T2> auto py_idiv(const T1 &a, const T2 &b)
{
    if (a >= 0)
        return idiv(a, b);
    return -(idiv(-(a - b + 1), b));
}

class BalancedTernary
{
public:
    static inline auto s_str2dig = create_dict(dict_of(u'+'_C, 1)(u'-'_C, -1)(u'0'_C, 0));
    static inline auto s_dig2str = create_dict(dict_of(1, u'+'_C)(-1, u'-'_C)(0, u'0'_C));
    static inline auto s_table = create_array({make_tuple(0, -1), make_tuple(1, -1), make_tuple(-1, 0), make_tuple(0, 0), make_tuple(1, 0), make_tuple(-1, 1), make_tuple(0, 1)});

    Array<int> digits;

    template <typename T1> BalancedTernary(const T1 &inp)
    {
        if (all_map(inp, [](const auto &d){return in(d, make_tuple(0, 1, -1));}))
            digits = copy(inp);
        else
            throw ValueError(u"BalancedTernary: Wrong input digits."_S);
    }

    template <typename T1> static auto s_int2ternary(const T1 &n)
    {
        if (n == 0)
            return Array<int>();
        auto n3 = mod(((mod(n, 3)) + 3), 3);
        if (n3 == 0)
            return create_array({0}) + BalancedTernary::s_int2ternary(py_idiv(n, 3));
        if (n3 == 1)
            return create_array({1}) + BalancedTernary::s_int2ternary(py_idiv(n, 3));
        if (n3 == 2)
            return create_array({-1}) + BalancedTernary::s_int2ternary(py_idiv((n + 1), 3));
        throw RuntimeError(u""_S);
    }

    auto to_int()
    {
        return reversed(digits).reduce(0, [](const auto &y, const auto &x){return x + 3 * y;});
    }

    operator String() const
    {
        if (digits.empty())
            return u"0"_S;
        return reversed(digits).map([](const auto &d){return BalancedTernary::s_dig2str[d];}).join(u""_S);
    }

    template <typename T1> static auto s_neg(const T1 &digs)
    {
        return digs.map([](const auto &d){return -d;});
    }

    auto operator-() const
    {
        return BalancedTernary(BalancedTernary::s_neg(digits));
    }

    template <typename T1, typename T2, typename T3 = decltype(0)> static auto s_add(const T1 &a, const T2 &b, T3 c = 0)
    {
        if (!(!a.empty() && !b.empty())) {
            if (c == 0)
                return !a.empty() ? a : b;
            else
                return BalancedTernary::s_add(create_array({c}), !a.empty() ? a : b);
        }
        else {
            TUPLE_ELEMENT_T(0, BalancedTernary::s_table[3 + (!a.empty() ? _get<0>(a) : 0) + (!b.empty() ? _get<0>(b) : 0) + c]) d;
            assign_from_tuple(d, c, BalancedTernary::s_table[3 + (!a.empty() ? _get<0>(a) : 0) + (!b.empty() ? _get<0>(b) : 0) + c]);
            auto res = BalancedTernary::s_add(a[range_ei(1)], b[range_ei(1)], c);
            if (!res.empty() || d != 0)
                return create_array({d}) + res;
            else
                return res;
        }
    }

    template <typename T1> auto operator+(const T1 &b) const
    {
        return BalancedTernary(BalancedTernary::s_add(digits, b.digits));
    }
    template <typename Ty> auto &operator+=(const Ty &t)
    {
        *this = *this + t;
        return *this;
    }

    template <typename T1> auto operator-(const T1 &b) const
    {
        return *this + (-b);
    }
    template <typename Ty> auto &operator-=(const Ty &t)
    {
        *this = *this - t;
        return *this;
    }

    template <typename T1> auto operator*(const T1 &b) const
    {
        std::function<Array<int>(Array<int>&, Array<int>&)> _mul = [&_mul](Array<int> &a, Array<int> &b) -> Array<int>
        {
            if (!(!a.empty() && !b.empty()))
                return Array<int>();
            else {
                Array<int> x;
                if (_get<0>(a) == -1)
                    x = BalancedTernary::s_neg(b);
                else if (_get<0>(a) == 0) {
                }

                else if (_get<0>(a) == 1)
                    x = b;
                else
                    assert(false);
                auto y = create_array({0}) + _mul(make_ref(create_array(a[range_ei(1)])), b);
                return BalancedTernary::s_add(x, y);
            }
        };

        return BalancedTernary(_mul(make_ref(create_array(digits)), make_ref(create_array(b.digits))));
    }
    template <typename Ty> auto &operator*=(const Ty &t)
    {
        *this = *this * t;
        return *this;
    }
};

template <typename T1> auto createBalancedTernaryFromStr(const T1 &inp)
{
    return BalancedTernary(reversed(inp).map([](const auto &c){return BalancedTernary::s_str2dig[c];}));
}
template <typename T1> auto createBalancedTernaryFromInt(const T1 &inp)
{
    return BalancedTernary(BalancedTernary::s_int2ternary(inp));
}

auto a = createBalancedTernaryFromStr(u"+-0++0+"_S);

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"a: "_S & a.to_int() & u" "_S & a);
    }
} code_block_1;

auto b = createBalancedTernaryFromInt(-436);

struct CodeBlock2
{
    CodeBlock2()
    {
        print(u"b: "_S & b.to_int() & u" "_S & b);
    }
} code_block_2;

auto c = createBalancedTernaryFromStr(u"+-++-"_S);

struct CodeBlock3
{
    CodeBlock3()
    {
        print(u"c: "_S & c.to_int() & u" "_S & c);
    }
} code_block_3;

auto r = a * (b - c);

struct CodeBlock4
{
    CodeBlock4()
    {
        print(u"a * (b - c): "_S & r.to_int() & u" "_S & r);
    }
} code_block_4;


# https://www.rosettacode.org/wiki/Banker%27s_algorithm#Python
resources = int(input("Cantidad de recursos: "))
processes = int(input("Cantidad de procesos: "))
max_resources = [int(i) for i in input("Recursos máximos: ").split()]

print("\n-- recursos asignados para cada proceso  --")
currently_allocated = [[int(i) for i in input("proceso {}: ".format(j + 1)).split()] for j in range(processes)]

print("\n--- recursos máximos para cada proceso  ---")
max_need = [[int(i) for i in input("proceso {}: ".format(j + 1)).split()] for j in range(processes)]

allocated = [0] * resources
for i in range(processes):
    for j in range(resources):
        allocated[j] += currently_allocated[i][j]
print("\nRecursos totales asignados  : {}".format(allocated))

available = [max_resources[i] - allocated[i] for i in range(resources)]
print("Recursos totales disponibles: {}\n".format(available))

running = [True] * processes
count = processes
while count != 0:
    safe = False
    for i in range(processes):
        if running[i]:
            executing = True
            for j in range(resources):
                if max_need[i][j] - currently_allocated[i][j] > available[j]:
                    executing = False
                    break
            if executing:
                print("proceso {} ejecutándose".format(i + 1))
                running[i] = False
                count -= 1
                safe = True
                for j in range(resources):
                    available[j] += currently_allocated[i][j]
                break
    if not safe:
        print("El proceso está en un estado inseguro.")
        break

    print("El proceso está en un estado seguro.\nRecursos disponibles: {}\n".format(available))
===
V resources = Int(input(‘Cantidad de recursos: ’))
V processes = Int(input(‘Cantidad de procesos: ’))
V max_resources = input(‘Recursos máximos: ’).split_py().map(i -> Int(i))

print("\n-- recursos asignados para cada proceso  --")
V currently_allocated = (0 .< processes).map(j -> input(‘proceso #.: ’.format(j + 1)).split_py().map(i -> Int(i)))

print("\n--- recursos máximos para cada proceso  ---")
V max_need = (0 .< processes).map(j -> input(‘proceso #.: ’.format(j + 1)).split_py().map(i -> Int(i)))

V allocated = [0] * resources
L(i) 0 .< processes
   L(j) 0 .< resources
      allocated[j] += currently_allocated[i][j]
print("\nRecursos totales asignados  : #.".format(allocated))

V available = (0 .< resources).map(i -> :max_resources[i] - :allocated[i])
print("Recursos totales disponibles: #.\n".format(available))

V running = [1B] * processes
V count = processes
L count != 0
   V safe = 0B
   L(i) 0 .< processes
      I running[i]
         V executing = 1B
         L(j) 0 .< resources
            I max_need[i][j] - currently_allocated[i][j] > available[j]
               executing = 0B
               L.break
         I executing
            print(‘proceso #. ejecutándose’.format(i + 1))
            running[i] = 0B
            count--
            safe = 1B
            L(j) 0 .< resources
               available[j] += currently_allocated[i][j]
            L.break
   I !safe
      print(‘El proceso está en un estado inseguro.’)
      L.break

   print("El proceso está en un estado seguro.\nRecursos disponibles: #.\n".format(available))
===
auto resources = to_int(input(u"Cantidad de recursos: "_S));
auto processes = to_int(input(u"Cantidad de procesos: "_S));
auto max_resources = input(u"Recursos máximos: "_S).split_py().map([](const auto &i){return to_int(i);});

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"\n-- recursos asignados para cada proceso  --"_S);
    }
} code_block_1;

auto currently_allocated = range_el(0, processes).map([](const auto &j){return input(u"proceso #.: "_S.format(j + 1)).split_py().map([](const auto &i){return to_int(i);});});

struct CodeBlock2
{
    CodeBlock2()
    {
        print(u"\n--- recursos máximos para cada proceso  ---"_S);
    }
} code_block_2;

auto max_need = range_el(0, processes).map([](const auto &j){return input(u"proceso #.: "_S.format(j + 1)).split_py().map([](const auto &i){return to_int(i);});});

auto allocated = create_array({0}) * resources;

struct CodeBlock3
{
    CodeBlock3()
    {
        for (auto i : range_el(0, processes))
            for (auto j : range_el(0, resources))
                allocated[j] += currently_allocated[i][j];
        print(u"\nRecursos totales asignados  : #."_S.format(allocated));
    }
} code_block_3;

auto available = range_el(0, resources).map([](const auto &i){return ::max_resources[i] - ::allocated[i];});

struct CodeBlock4
{
    CodeBlock4()
    {
        print(u"Recursos totales disponibles: #.\n"_S.format(available));
    }
} code_block_4;

auto running = create_array({true}) * processes;
auto count = processes;

struct CodeBlock5
{
    CodeBlock5()
    {
        while (count != 0) {
            auto safe = false;
            for (auto i : range_el(0, processes))
                if (running[i]) {
                    auto executing = true;
                    for (auto j : range_el(0, resources))
                        if (max_need[i][j] - currently_allocated[i][j] > available[j]) {
                            executing = false;
                            break;
                        }
                    if (executing) {
                        print(u"proceso #. ejecutándose"_S.format(i + 1));
                        running.set(i, false);
                        count--;
                        safe = true;
                        for (auto j : range_el(0, resources))
                            available[j] += currently_allocated[i][j];
                        break;
                    }
                }
            if (!safe) {
                print(u"El proceso está en un estado inseguro."_S);
                break;
            }

            print(u"El proceso está en un estado seguro.\nRecursos disponibles: #.\n"_S.format(available));
        }
    }
} code_block_5;


# https://www.rosettacode.org/wiki/Base-16_representation#Nim
from _11l import *

l = [n for n in range(500+1) if not hexu(n).isdigit()]

print('Found', len(l), "numbers between 0 and 500:\n")
for i, n in enumerate(l):
    print('%3d' % n, end = "\n" if (i + 1) % 19 == 0 else ' ')
print()
===
V l = (0 .. 500).filter(n -> !hex(n).is_digit())

print(‘Found ’l.len" numbers between 0 and 500:\n")
L(n) l
   V i = L.index
   print(‘#3’.format(n), end' I (i + 1) % 19 == 0 {"\n"} E ‘ ’)
print()
===
auto l = range_ee(0, 500).filter([](const auto &n){return !hex(n).is_digit();});

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"Found "_S & l.len() & u" numbers between 0 and 500:\n"_S);
        {int Lindex = 0;
        for (auto &&n : l) {
            auto i = Lindex;
            print(u"#3"_S.format(n), mod((i + 1), 19) == 0 ? u'\n'_C : u' '_C);
            Lindex++;
        }}
        print();
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Best_shuffle#Python
import random

def count(w1,wnew):
    return sum(int(c1==c2) for c1,c2 in zip(w1, wnew))

def best_shuffle(w):
    wnew = list(w)
    n = len(w)
    rangei = list(range(n))
    rangej = list(range(n))
    random.shuffle(rangei)
    random.shuffle(rangej)
    for i in rangei:
        for j in rangej:
            if i != j and wnew[j] != wnew[i] and w[i] != wnew[j] and w[j] != wnew[i]:
                (wnew[j], wnew[i]) = (wnew[i], wnew[j])
                break
    wnew_s = ''.join(wnew)
    return (wnew_s, count(w, wnew_s))

test_words = ['tree', 'abracadabra', 'seesaw', 'elk', 'grrrrrr', 'up', 'a',
              'antidisestablishmentarianism', 'hounddogs',
              'aardvarks are ant eaters', 'immediately', 'abba']
for w in test_words:
    (wnew, c) = best_shuffle(w)
    print("%29s, %-29s ,(%i)" % (w, wnew, c))
===
F count(w1, wnew)
   R sum(zip(w1, wnew).map((c1, c2) -> Int(c1 == c2)))

F best_shuffle(w)
   V wnew = Array(w)
   V n = w.len
   V rangei = Array(0 .< n)
   V rangej = Array(0 .< n)
   random:shuffle(&rangei)
   random:shuffle(&rangej)
   L(i) rangei
      L(j) rangej
         I i != j & wnew[j] != wnew[i] & w[i] != wnew[j] & w[j] != wnew[i]
            swap(&wnew[j], &wnew[i])
            L.break
   V wnew_s = wnew.join(‘’)
   R (wnew_s, count(w, wnew_s))

V test_words = [‘tree’, ‘abracadabra’, ‘seesaw’, ‘elk’, ‘grrrrrr’, ‘up’, ‘a’, ‘antidisestablishmentarianism’, ‘hounddogs’, ‘aardvarks are ant eaters’, ‘immediately’, ‘abba’]
L(w) test_words
   V (wnew, c) = best_shuffle(w)
   print(‘#29, #<29 ,(#.)’.format(w, wnew, c))
===
template <typename T1, typename T2> auto count(const T1 &w1, const T2 &wnew)
{
    return sum_map(zip(w1, wnew), [](const auto &c1, const auto &c2){return to_int(c1 == c2);});
}

template <typename T1> auto best_shuffle(const T1 &w)
{
    auto wnew = create_array(w);
    auto n = w.len();
    auto rangei = create_array(range_el(0, n));
    auto rangej = create_array(range_el(0, n));
    randomns::shuffle(rangei);
    randomns::shuffle(rangej);
    for (auto &&i : rangei)
        for (auto &&j : rangej)
            if (i != j && wnew[j] != wnew[i] && w[i] != wnew[j] && w[j] != wnew[i]) {
                swap(wnew[j], wnew[i]);
                break;
            }
    auto wnew_s = wnew.join(u""_S);
    return make_tuple(wnew_s, count(w, wnew_s));
}

auto test_words = create_array({u"tree"_S, u"abracadabra"_S, u"seesaw"_S, u"elk"_S, u"grrrrrr"_S, u"up"_S, u"a"_S, u"antidisestablishmentarianism"_S, u"hounddogs"_S, u"aardvarks are ant eaters"_S, u"immediately"_S, u"abba"_S});

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&w : test_words) {
            auto [wnew, c] = best_shuffle(w);
            print(u"#29, #<29 ,(#.)"_S.format(w, wnew, c));
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Bioinformatics/global_alignment#Nim
from _11l import *

ACGT = ['A', 'C', 'G', 'T']   # Four DNA bases.

def permutations(slist):
    l = sorted(slist)
    r = [l]
    while next_permutation(l):
        r += [l[:]]
    return r

def printCounts(dnaSeq):
    counts = collections.defaultdict(int) # Char
    for c in dnaSeq:
        counts[c] += 1
    print("\nNucleotide counts for {}:\n".format(dnaSeq))
    for base in ACGT:
        print("{:>10} {:11}".format(base, counts[base]))
    others = 0
    for base in counts.keys():
        if base not in ACGT:
            others += counts[base]
    print("     Other {:11}".format(others))
    print("  --------------------")
    print("  Total length {:7}".format(len(dnaSeq)))

def headTailOverlap(s1, s2):
    start = 0
    while True:
        start = s1.find(s2[0], start)
        if start < 0:
            return 0
        if s2.startswith(s1[start:]):
            return len(s1) - start
        start += 1

def deduplicate(slist):
    r : List[str] = []
    s = set(slist)
    for i, s1 in enumerate(s):
        for j, s2 in enumerate(s):
            if j != i and s1 in s2:
                break
        else:
            r.append(s1)
    return r

def shortestCommonSuperstring(sl):
    slist = deduplicate(sl)
    result = ''.join(slist)
    for perm in permutations(slist):
        sup : str = perm[0]
        for i in range(len(slist) - 1):
            overlapPos = headTailOverlap(perm[i], perm[i+1])
            sup += perm[i+1][overlapPos:]
        if len(sup) < len(result):
            result = sup
    return result

TestSequences = [
   ["TA", "AAG", "TA", "GAA", "TA"],
   ["CATTAGGG", "ATTAG", "GGG", "TA"],
   ["AAGAUGGA", "GGAGCGCAUC", "AUCGCAAUAAGGA"],
   ["ATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTAT",
    "GGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGT",
    "CTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA",
    "TGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC",
    "AACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT",
    "GCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTC",
    "CGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATTCTGCTTATAACACTATGTTCT",
    "TGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC",
    "CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATGCTCGTGC",
    "GATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATT",
    "TTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC",
    "CTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA",
    "TCTCTTAAACTCCTGCTAAATGCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGA"]]

for test in TestSequences:
    scs = shortestCommonSuperstring(test)
    printCounts(scs)
===
V ACGT = [‘A’, ‘C’, ‘G’, ‘T’]

F permutations(slist)
   V l = sorted(slist)
   V r = [l]
   L l.next_permutation()
      r [+]= copy(l)
   R r

F printCounts(dnaSeq)
   V counts = DefaultDict[Char, Int]()
   L(c) dnaSeq
      counts[c]++
   print("\nNucleotide counts for #.:\n".format(dnaSeq))
   L(base) :ACGT
      print(‘#10 #11’.format(base, counts[base]))
   V others = 0
   L(base) counts.keys()
      I base !C :ACGT
         others += counts[base]
   print(‘     Other #11’.format(others))
   print(‘  --------------------’)
   print(‘  Total length #7’.format(dnaSeq.len))

F headTailOverlap(s1, s2)
   V start = 0
   L
      start = s1.findi(s2[0], start)
      I start < 0
         R 0
      I s2.starts_with(s1[start ..])
         R s1.len - start
      start++

F deduplicate(slist)
   [String] r
   V s = Set(slist)
   L(s1) s
      V i = L.index
      L(s2) s
         V j = L.index
         I j != i & s1 C s2
            L.break
      L.was_no_break
         r.append(s1)
   R r

F shortestCommonSuperstring(sl)
   V slist = deduplicate(sl)
   V result = slist.join(‘’)
   L(perm) permutations(slist)
      String sup = perm[0]
      L(i) 0 .< slist.len - 1
         V overlapPos = headTailOverlap(perm[i], perm[i + 1])
         sup ‘’= perm[i + 1][overlapPos ..]
      I sup.len < result.len
         result = sup
   R result

V TestSequences = [[‘TA’, ‘AAG’, ‘TA’, ‘GAA’, ‘TA’], [‘CATTAGGG’, ‘ATTAG’, ‘GGG’, ‘TA’], [‘AAGAUGGA’, ‘GGAGCGCAUC’, ‘AUCGCAAUAAGGA’], [‘ATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTAT’, ‘GGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGT’, ‘CTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA’, ‘TGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC’, ‘AACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT’, ‘GCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTC’, ‘CGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATTCTGCTTATAACACTATGTTCT’, ‘TGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC’, ‘CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATGCTCGTGC’, ‘GATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATT’, ‘TTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC’, ‘CTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA’, ‘TCTCTTAAACTCCTGCTAAATGCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGA’]]

L(test) TestSequences
   V scs = shortestCommonSuperstring(test)
   printCounts(scs)
===
auto ACGT = create_array({u'A'_C, u'C'_C, u'G'_C, u'T'_C});

template <typename T1> auto permutations(const T1 &slist)
{
    auto l = sorted(slist);
    auto r = create_array({l});
    while (l.next_permutation())
        r.append(copy(l));
    return r;
}

template <typename T1> auto printCounts(const T1 &dnaSeq)
{
    auto counts = DefaultDict<Char, int>();
    for (auto &&c : dnaSeq)
        counts[c]++;
    print(u"\nNucleotide counts for #.:\n"_S.format(dnaSeq));
    for (auto &&base : ::ACGT)
        print(u"#10 #11"_S.format(base, counts[base]));
    auto others = 0;
    for (auto &&base : counts.keys())
        if (!in(base, ::ACGT))
            others += counts[base];
    print(u"     Other #11"_S.format(others));
    print(u"  --------------------"_S);
    print(u"  Total length #7"_S.format(dnaSeq.len()));
}

template <typename T1, typename T2> auto headTailOverlap(const T1 &s1, const T2 &s2)
{
    auto start = 0;
    while (true) {
        start = s1.findi(_get<0>(s2), start);
        if (start < 0)
            return 0;
        if (s2.starts_with(s1[range_ei(start)]))
            return s1.len() - start;
        start++;
    }
}

template <typename T1> auto deduplicate(const T1 &slist)
{
    Array<String> r;
    auto s = create_set(slist);
    {int Lindex = 0;
    for (auto &&s1 : s) {
        auto i = Lindex;
        {int Lindex = 0;
        for (auto &&s2 : s) {
            auto j = Lindex;
            if (j != i && in(s1, s2))
                goto break_;
            Lindex++;
        }}
        r.append(s1);
        break_:;
        Lindex++;
    }}
    return r;
}

template <typename T1> auto shortestCommonSuperstring(const T1 &sl)
{
    auto slist = deduplicate(sl);
    auto result = slist.join(u""_S);
    for (auto &&perm : permutations(slist)) {
        String sup = _get<0>(perm);
        for (auto i : range_el(0, slist.len() - 1)) {
            auto overlapPos = headTailOverlap(perm[i], perm[i + 1]);
            sup &= perm[i + 1][range_ei(overlapPos)];
        }
        if (sup.len() < result.len())
            result = sup;
    }
    return result;
}

auto TestSequences = create_array({create_array({u"TA"_S, u"AAG"_S, u"TA"_S, u"GAA"_S, u"TA"_S}), create_array({u"CATTAGGG"_S, u"ATTAG"_S, u"GGG"_S, u"TA"_S}), create_array({u"AAGAUGGA"_S, u"GGAGCGCAUC"_S, u"AUCGCAAUAAGGA"_S}), create_array({u"ATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTAT"_S, u"GGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGT"_S, u"CTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA"_S, u"TGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC"_S, u"AACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT"_S, u"GCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTC"_S, u"CGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATTCTGCTTATAACACTATGTTCT"_S, u"TGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC"_S, u"CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATGCTCGTGC"_S, u"GATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATT"_S, u"TTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC"_S, u"CTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA"_S, u"TCTCTTAAACTCCTGCTAAATGCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGA"_S})});

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&test : TestSequences) {
            auto scs = shortestCommonSuperstring(test);
            printCounts(scs);
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Bioinformatics/Sequence_mutation#Python
UInt32 = int

seed : UInt32 = 0
def nonrandom(n):
    global seed
    seed = (1664525 * seed + 1013904223) & 0xFFFF_FFFF
    return (seed >> 16) % n
def nonrandom_choice(lst):
    return lst[nonrandom(len(lst))]

#from collections import Counter
import collections

def basecount(dna):
    #return sorted(Counter(dna).items())
    d = collections.defaultdict(int) # Char
    for c in dna:
        d[c] += 1
    return sorted(d.items())

def seq_split(dna, n=50):
    return [dna[i: i+n] for i in range(0, len(dna), n)]

def seq_pp(dna, n=50):
    for i, part in enumerate(seq_split(dna, n)):
        print("{:>5}: {}".format(i*n, part))
    print("\n  BASECOUNT:")
    tot = 0
    for base, count in basecount(dna):
        print("    {:>3}: {}".format(base, count))
        tot += count
    (base, count) = ('TOT', tot)
    print("    {:>3}= {}".format(base, count))

def seq_mutate(dna : str, count=1, kinds="IDSSSS", choice="ATCG" ):
    mutation : List[Tuple[str, int]] = []
    k2txt = {'I': 'Insert', 'D': 'Delete', 'S': 'Substitute'}
    for _ in range(count):
        kind = nonrandom_choice(kinds)
        index = nonrandom(len(dna) + 1)
        if kind == 'I':    # Insert
            dna = dna[:index] + nonrandom_choice(choice) + dna[index:]
        elif kind == 'D' and len(dna) != 0:  # Delete
            dna = dna[:index] + dna[index+1:]
        elif kind == 'S' and len(dna) != 0:  # Substitute
            dna = dna[:index] + nonrandom_choice(choice) + dna[index+1:]
        mutation.append((k2txt[kind], index))
    return (dna, mutation)

#length = 250
print("SEQUENCE:")
#sequence = ''.join(nonrandom_choices('ACGT', weights=(1, 0.8, .9, 1.1), k=length))
sequence = 'TCAATCATTAATCGATTAATACATTCAATTTGAACATCTCCAGGAGAAGGCAGGGTAATCTCGTGTAGCCGTGCTTGGGGCCTCCGATATGGCCGGGGAATTTCAAAGTATAGTGTGCATCCCCTCATAATACATAGATCTATAGGTAAGTATATGGGTTGACGTTGTTAGATGCGATACACGTGCACACTTTATGAATTTTACGTTCCTCTGCCTAGAGTGCCAAGTTTCAATTTGCTACGGTTCCTCA'
seq_pp(sequence)
print("\n\nMUTATIONS:")
(mseq, m) = seq_mutate(sequence, 10)
for kind, index in m:
    print(" {:>10} @{}".format(kind, index))
print()
seq_pp(mseq)
===
UInt32 seed = 0
F nonrandom(n)
   :seed = (1664525 * :seed + 1013904223) [&] FFFF'FFFF
   R (:seed >> 16) % n
F nonrandom_choice(lst)
   R lst[nonrandom(lst.len)]

F basecount(dna)
   V d = DefaultDict[Char, Int]()
   L(c) dna
      d[c]++
   R sorted(d.items())

F seq_split(dna, n = 50)
   R (0 .< dna.len).step(n).map(i -> @dna[i .< i + @n])

F seq_pp(dna, n = 50)
   L(part) seq_split(dna, n)
      V i = L.index
      print(‘#5: #.’.format(i * n, part))
   print("\n  BASECOUNT:")
   V tot = 0
   L(base, count) basecount(dna)
      print(‘    #3: #.’.format(base, count))
      tot += count
   V (base, count) = (‘TOT’, tot)
   print(‘    #3= #.’.format(base, count))

F seq_mutate(String =dna; count = 1, kinds = ‘IDSSSS’, choice = ‘ATCG’)
   [(String, Int)] mutation
   V k2txt = [‘I’ = ‘Insert’, ‘D’ = ‘Delete’, ‘S’ = ‘Substitute’]
   L(_) 0 .< count
      V kind = nonrandom_choice(kinds)
      V index = nonrandom(dna.len + 1)
      I kind == ‘I’
         dna = dna[0 .< index]‘’nonrandom_choice(choice)‘’dna[index ..]
      E I kind == ‘D’ & !dna.empty
         dna = dna[0 .< index]‘’dna[index + 1 ..]
      E I kind == ‘S’ & !dna.empty
         dna = dna[0 .< index]‘’nonrandom_choice(choice)‘’dna[index + 1 ..]
      mutation.append((k2txt[kind], index))
   R (dna, mutation)

print(‘SEQUENCE:’)
V sequence = ‘TCAATCATTAATCGATTAATACATTCAATTTGAACATCTCCAGGAGAAGGCAGGGTAATCTCGTGTAGCCGTGCTTGGGGCCTCCGATATGGCCGGGGAATTTCAAAGTATAGTGTGCATCCCCTCATAATACATAGATCTATAGGTAAGTATATGGGTTGACGTTGTTAGATGCGATACACGTGCACACTTTATGAATTTTACGTTCCTCTGCCTAGAGTGCCAAGTTTCAATTTGCTACGGTTCCTCA’
seq_pp(sequence)
print("\n\nMUTATIONS:")
V (mseq, m) = seq_mutate(sequence, 10)
L(kind, index) m
   print(‘ #10 @#.’.format(kind, index))
print()
seq_pp(mseq)
===
uint32_t seed = 0;
template <typename T1> auto nonrandom(const T1 &n)
{
    ::seed = (1664525 * ::seed + 1013904223) & 0xFFFF'FFFF;
    return mod((::seed >> 16), n);
}
template <typename T1> auto nonrandom_choice(const T1 &lst)
{
    return lst[nonrandom(lst.len())];
}

template <typename T1> auto basecount(const T1 &dna)
{
    auto d = DefaultDict<Char, int>();
    for (auto &&c : dna)
        d[c]++;
    return sorted(d.items());
}

template <typename T1, typename T2 = decltype(50)> auto seq_split(const T1 &dna, const T2 &n = 50)
{
    return range_el(0, dna.len()).step(n).map([&dna, &n](const auto &i){return dna[range_el(i, i + n)];});
}

template <typename T1, typename T2 = decltype(50)> auto seq_pp(const T1 &dna, const T2 &n = 50)
{
    {int Lindex = 0;
    for (auto &&part : seq_split(dna, n)) {
        auto i = Lindex;
        print(u"#5: #."_S.format(i * n, part));
        Lindex++;
    }}
    print(u"\n  BASECOUNT:"_S);
    auto tot = 0;
    for (auto &&[base, count] : basecount(dna)) {
        print(u"    #3: #."_S.format(base, count));
        tot += count;
    }
    auto [base, count] = make_tuple(u"TOT"_S, tot);
    print(u"    #3= #."_S.format(base, count));
}

template <typename T2 = decltype(1), typename T3 = decltype(u"IDSSSS"_S), typename T4 = decltype(u"ATCG"_S)> auto seq_mutate(String dna, const T2 &count = 1, const T3 &kinds = u"IDSSSS"_S, const T4 &choice = u"ATCG"_S)
{
    Array<Tuple<String, int>> mutation;
    auto k2txt = create_dict(dict_of(u'I'_C, u"Insert"_S)(u'D'_C, u"Delete"_S)(u'S'_C, u"Substitute"_S));
    for (auto _ : range_el(0, count)) {
        auto kind = nonrandom_choice(kinds);
        auto index = nonrandom(dna.len() + 1);
        if (kind == u'I')
            dna = dna[range_el(0, index)] & nonrandom_choice(choice) & dna[range_ei(index)];
        else if (kind == u'D' && !dna.empty())
            dna = dna[range_el(0, index)] & dna[range_ei(index + 1)];
        else if (kind == u'S' && !dna.empty())
            dna = dna[range_el(0, index)] & nonrandom_choice(choice) & dna[range_ei(index + 1)];
        mutation.append(make_tuple(k2txt[kind], index));
    }
    return make_tuple(dna, mutation);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"SEQUENCE:"_S);
    }
} code_block_1;

auto sequence = u"TCAATCATTAATCGATTAATACATTCAATTTGAACATCTCCAGGAGAAGGCAGGGTAATCTCGTGTAGCCGTGCTTGGGGCCTCCGATATGGCCGGGGAATTTCAAAGTATAGTGTGCATCCCCTCATAATACATAGATCTATAGGTAAGTATATGGGTTGACGTTGTTAGATGCGATACACGTGCACACTTTATGAATTTTACGTTCCTCTGCCTAGAGTGCCAAGTTTCAATTTGCTACGGTTCCTCA"_S;

struct CodeBlock2
{
    CodeBlock2()
    {
        seq_pp(sequence);
        print(u"\n\nMUTATIONS:"_S);
    }
} code_block_2;

auto [mseq, m] = seq_mutate(sequence, 10);

struct CodeBlock3
{
    CodeBlock3()
    {
        for (auto &&[kind, index] : m)
            print(u" #10 @#."_S.format(kind, index));
        print();
        seq_pp(mseq);
    }
} code_block_3;


# https://www.rosettacode.org/wiki/Bioinformatics/Subsequence#Python
UInt32 = int

seed : UInt32 = 34
def nonrandom_choice(lst):
    global seed
    seed = (1664525 * seed + 1013904223) & 0xFFFF_FFFF
    return lst[(seed >> 16) % len(lst)]

def generate_sequence(n: int):
    return "".join([ nonrandom_choice(['A','C','G','T']) for _ in range(n) ])

def positions(dnaSeq, subSeq):
    r : List[int] = []
    start = 0
    while True:
        pos = dnaSeq.find(subSeq, start)
        if pos < 0: break
        r.append(pos)
        start = pos + 1
    return r

def dna_findall(needle: str, haystack: str) -> None:
    pp = positions(haystack, needle)
    if len(pp) == 0:
        print("No matches found")
    else:
        print("Found", needle, "at the following indices:")
        for p in pp:
            print(str(p) + ':' + str(p + len(needle)))

dna_seq = generate_sequence(200)
sample_seq = generate_sequence(4)

c = 1
for i in dna_seq:
    print(i, end="") if c % 20 != 0 else print(i)
    c += 1
print("\nSearch Sample:", sample_seq)

dna_findall(sample_seq, dna_seq)
===
UInt32 seed = 34
F nonrandom_choice(lst)
   :seed = (1664525 * :seed + 1013904223) [&] FFFF'FFFF
   R lst[(:seed >> 16) % lst.len]

F generate_sequence(Int n)
   R ((0 .< n).map(_ -> nonrandom_choice([‘A’, ‘C’, ‘G’, ‘T’]))).join(‘’)

F positions(dnaSeq, subSeq)
   [Int] r
   V start = 0
   L
      V pos = dnaSeq.findi(subSeq, start)
      I pos < 0
         L.break
      r.append(pos)
      start = pos + 1
   R r

F dna_findall(String needle, String haystack) -> N
   V pp = positions(haystack, needle)
   I pp.empty
      print(‘No matches found’)
   E
      print(‘Found ’needle‘ at the following indices:’)
      L(p) pp
         print(String(p)‘:’String(p + needle.len))

V dna_seq = generate_sequence(200)
V sample_seq = generate_sequence(4)

V c = 1
L(i) dna_seq
   I c % 20 != 0 {print(i, end' ‘’)} E print(i)
   c++
print("\nSearch Sample: "sample_seq)

dna_findall(sample_seq, dna_seq)
===
uint32_t seed = 34;
template <typename T1> auto nonrandom_choice(const T1 &lst)
{
    ::seed = (1664525 * ::seed + 1013904223) & 0xFFFF'FFFF;
    return lst[mod((::seed >> 16), lst.len())];
}

auto generate_sequence(const int n)
{
    return (range_el(0, n).map([](const auto &_){return nonrandom_choice(create_array({u'A'_C, u'C'_C, u'G'_C, u'T'_C}));})).join(u""_S);
}

template <typename T1, typename T2> auto positions(const T1 &dnaSeq, const T2 &subSeq)
{
    Array<int> r;
    auto start = 0;
    while (true) {
        auto pos = dnaSeq.findi(subSeq, start);
        if (pos < 0)
            break;
        r.append(pos);
        start = pos + 1;
    }
    return r;
}

void dna_findall(const String &needle, const String &haystack)
{
    auto pp = positions(haystack, needle);
    if (pp.empty())
        print(u"No matches found"_S);
    else {
        print(u"Found "_S & needle & u" at the following indices:"_S);
        for (auto &&p : pp)
            print(String(p) & u":"_S & String(p + needle.len()));
    }
}

auto dna_seq = generate_sequence(200);
auto sample_seq = generate_sequence(4);

auto c = 1;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&i : dna_seq) {
            if (mod(c, 20) != 0)
                print(i, u""_S);
            else
                print(i);
            c++;
        }
        print(u"\nSearch Sample: "_S & sample_seq);

        dna_findall(sample_seq, dna_seq);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Biorhythms#Python
import datetime, math

def biorhythms(birthdate_str, targetdate_str):
    """
    Print out biorhythm data for targetdate assuming you were
    born on birthdate.

    birthdate and targetdata are strings in this format:

    YYYY-MM-DD e.g. 1964-12-26
    """

    # print dates

    print("Born: "+birthdate_str+" Target: "+targetdate_str)

    # convert to date types - Python 3.7 or later

    birthdate = datetime.datetime.strptime(birthdate_str, '%Y-%m-%d')
    targetdate = datetime.datetime.strptime(targetdate_str, '%Y-%m-%d')

    # days between

    days = (targetdate - birthdate).days

    print("Day: "+str(days))

    # cycle logic - mostly from Julia example

    cycle_labels = ["Physical", "Emotional", "Mental"]
    cycle_lengths = [23, 28, 33]
    quadrants = [("up and rising", "peak"), ("up but falling", "transition"),
                   ("down and falling", "valley"), ("down but rising", "transition")]

    for i in range(3):
        label = cycle_labels[i]
        length = cycle_lengths[i]
        position = days % length
        quadrant = math.floor((4 * position) / length)
        percentage = int(round(100 * math.sin(2 * math.pi * position / length),0))
        transition_date = (targetdate + datetime.timedelta(days=math.floor((quadrant + 1)/4 * length) - position)).strftime('%Y-%m-%d')
        (trend, next) = quadrants[quadrant]

        description : str
        if percentage > 95:
            description = "peak"
        elif percentage < -95:
             description = "valley"
        elif abs(percentage) < 5:
             description = "critical transition"
        else:
             description = str(percentage)+"% ("+trend+", next "+next+" "+transition_date+")"
        print(label+" day "+str(position)+": "+description)

biorhythms("2043-03-09","2072-07-11")
===
F biorhythms(birthdate_str, targetdate_str)
   ‘
    Print out biorhythm data for targetdate assuming you were
    born on birthdate.

    birthdate and targetdata are strings in this format:

    YYYY-MM-DD e.g. 1964-12-26
    ’

   print(‘Born: ’birthdate_str‘ Target: ’targetdate_str)

   V birthdate = time:strptime(birthdate_str, ‘%Y-%m-%d’)
   V targetdate = time:strptime(targetdate_str, ‘%Y-%m-%d’)

   V days = (targetdate - birthdate).days()

   print(‘Day: ’String(days))

   V cycle_labels = [‘Physical’, ‘Emotional’, ‘Mental’]
   V cycle_lengths = [23, 28, 33]
   V quadrants = [(‘up and rising’, ‘peak’), (‘up but falling’, ‘transition’), (‘down and falling’, ‘valley’), (‘down but rising’, ‘transition’)]

   L(i) 3
      V label = cycle_labels[i]
      V length = cycle_lengths[i]
      V position = days % length
      V quadrant = floori((4 * position) / length)
      V percentage = Int(round(100 * sin(2 * math:pi * position / length), 0))
      V transition_date = (targetdate + TimeDelta(days' floori((quadrant + 1) / 4 * length) - position)).strftime(‘%Y-%m-%d’)
      V (trend, next) = quadrants[quadrant]

      String description
      I percentage > 95
         description = ‘peak’
      E I percentage < -95
         description = ‘valley’
      E I abs(percentage) < 5
         description = ‘critical transition’
      E
         description = String(percentage)‘% (’trend‘, next ’next‘ ’transition_date‘)’
      print(label‘ day ’String(position)‘: ’description)

biorhythms(‘2043-03-09’, ‘2072-07-11’)
===
template <typename T1, typename T2> auto biorhythms(const T1 &birthdate_str, const T2 &targetdate_str)
{
    uR"(
    Print out biorhythm data for targetdate assuming you were
    born on birthdate.

    birthdate and targetdata are strings in this format:

    YYYY-MM-DD e.g. 1964-12-26
    )"_S;

    print(u"Born: "_S & birthdate_str & u" Target: "_S & targetdate_str);

    auto birthdate = timens::strptime(birthdate_str, u"%Y-%m-%d"_S);
    auto targetdate = timens::strptime(targetdate_str, u"%Y-%m-%d"_S);

    auto days = (targetdate - birthdate).days();

    print(u"Day: "_S & String(days));

    auto cycle_labels = create_array({u"Physical"_S, u"Emotional"_S, u"Mental"_S});
    auto cycle_lengths = create_array({23, 28, 33});
    auto quadrants = create_array({make_tuple(u"up and rising"_S, u"peak"_S), make_tuple(u"up but falling"_S, u"transition"_S), make_tuple(u"down and falling"_S, u"valley"_S), make_tuple(u"down but rising"_S, u"transition"_S)});

    for (int i = 0; i < 3; i++) {
        auto label = cycle_labels[i];
        auto length = cycle_lengths[i];
        auto position = mod(days, length);
        auto quadrant = floori((4 * position) / length);
        auto percentage = to_int(round(100 * sin(2 * math::pi * position / length), 0));
        auto transition_date = (targetdate + TimeDelta(floori((quadrant + 1) / 4.0 * length) - position)).strftime(u"%Y-%m-%d"_S);
        auto [trend, next] = quadrants[quadrant];

        String description;
        if (percentage > 95)
            description = u"peak"_S;
        else if (percentage < -95)
            description = u"valley"_S;
        else if (abs(percentage) < 5)
            description = u"critical transition"_S;
        else
            description = String(percentage) & u"% ("_S & trend & u", next "_S & next & u" "_S & transition_date & u")"_S;
        print(label & u" day "_S & String(position) & u": "_S & description);
    }
}

struct CodeBlock1
{
    CodeBlock1()
    {
        biorhythms(u"2043-03-09"_S, u"2072-07-11"_S);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Birthday_problem#D
import random

def equal_birthdays(sharers, groupsize, rep):
    eq = 0
    for j in range(rep):
        group = [0] * 365
        for i in range(groupsize):
            group[random.randrange(len(group))] += 1
        if any(c >= sharers for c in group):
            eq += 1
    return (eq * 100.) / rep

group_est = 2
for sharers in range(2, 6):
    groupsize = group_est + 1
    # Coarse
    while equal_birthdays(sharers, groupsize, 100) < 50.:
        groupsize += 1

    # Finer
    for gs in range(int(groupsize - (groupsize - group_est)/4.), groupsize + 999):
        eq = equal_birthdays(sharers, gs, 250)
        if eq > 50.:
            groupsize = gs
            break

    # Finest
    for gs in range(groupsize - 1, groupsize + 999):
        eq = equal_birthdays(sharers, gs, 50_000)
        if eq > 50.:
            group_est = gs
            print("%i independent people in a group of %s share a common birthday. (%5.1f)" % (sharers, gs, eq))
            break
===
F equal_birthdays(sharers, groupsize, rep)
   V eq = 0
   L(j) 0 .< rep
      V group = [0] * 365
      L(i) 0 .< groupsize
         group[random:(group.len)]++
      I any(group.map(c -> c >= @sharers))
         eq++
   R (eq * 100.) / rep

V group_est = 2
L(sharers) 2..5
   V groupsize = group_est + 1
   L equal_birthdays(sharers, groupsize, 100) < 50.
      groupsize++

   L(gs) Int(groupsize - (groupsize - group_est) / 4.) .< groupsize + 999
      V eq = equal_birthdays(sharers, gs, 250)
      I eq > 50.
         groupsize = gs
         L.break

   L(gs) groupsize - 1 .< groupsize + 999
      V eq = equal_birthdays(sharers, gs, 50'000)
      I eq > 50.
         group_est = gs
         print(‘#. independent people in a group of #. share a common birthday. (#3.1)’.format(sharers, gs, eq))
         L.break
===
template <typename T1, typename T2, typename T3> auto equal_birthdays(const T1 &sharers, const T2 &groupsize, const T3 &rep)
{
    auto eq = 0;
    for (auto j : range_el(0, rep)) {
        auto group = create_array({0}) * 365;
        for (auto i : range_el(0, groupsize))
            group[randomns::_(group.len())]++;
        if (any_map(group, [&sharers](const auto &c){return c >= sharers;}))
            eq++;
    }
    return (eq * 100.) / rep;
}

auto group_est = 2;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto sharers : range_ee(2, 5)) {
            auto groupsize = group_est + 1;
            while (equal_birthdays(sharers, groupsize, 100) < 50.)
                groupsize++;

            for (auto gs : range_el(to_int(groupsize - (groupsize - group_est) / 4.), groupsize + 999)) {
                auto eq = equal_birthdays(sharers, gs, 250);
                if (eq > 50.) {
                    groupsize = gs;
                    break;
                }
            }

            for (auto gs : range_el(groupsize - 1, groupsize + 999)) {
                auto eq = equal_birthdays(sharers, gs, 50'000);
                if (eq > 50.) {
                    group_est = gs;
                    print(u"#. independent people in a group of #. share a common birthday. (#3.1)"_S.format(sharers, gs, eq));
                    break;
                }
            }
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Bitmap/Bresenham%27s_line_algorithm#Python
from copy import copy
from typing import NamedTuple, List

Byte = int
class Colour(NamedTuple):
    r : Byte
    g : Byte
    b : Byte

    def __eq__(self, other):
        return self.r == other.r and self.g == other.g and self.b == other.b

black = Colour(0,0,0)
white = Colour(255,255,255) # Colour ranges are not enforced.

class Bitmap:
    width : int
    height : int
    background : Colour
    map : List[List[Colour]]

    def __init__(self, width = 40, height = 40, background=white):
        assert width > 0 and height > 0# and type(background) == Colour
        self.width = width
        self.height = height
        self.background = background
        self.map = [[copy(background) for w in range(width)] for h in range(height)]

    def fillrect(self, x, y, width, height, colour=black):
        assert x >= 0 and y >= 0 and width > 0 and height > 0# and type(colour) == Colour
        for h in range(height):
            for w in range(width):
                self.map[y+h][x+w] = copy(colour)

    def chardisplay(self):
        txt = [''.join((' ' if bit==self.background else '@')
                       for bit in row)
               for row in self.map]
        # Boxing
        txt = ['|'+row+'|' for row in txt]
        txt.insert(0, '+' + '-' * self.width + '+')
        txt.append('+' + '-' * self.width + '+')
        print('\n'.join(reversed(txt)))

    def set(self, x, y, colour=black):
        #assert type(colour) == Colour
        self.map[y][x]=colour

    def get(self, x, y):
        return self.map[y][x]

    def line(self, x0, y0, x1, y1):
        "Bresenham's line algorithm"
        dx = abs(x1 - x0)
        dy = abs(y1 - y0)
        (x, y) = (x0, y0)
        sx = -1 if x0 > x1 else 1
        sy = -1 if y0 > y1 else 1
        if dx > dy:
            err = dx / 2.0
            while x != x1:
                self.set(x, y)
                err -= dy
                if err < 0:
                    y += sy
                    err += dx
                x += sx
        else:
            err = dy / 2.0
            while y != y1:
                self.set(x, y)
                err -= dx
                if err < 0:
                    x += sx
                    err += dy
                y += sy
        self.set(x, y)

bitmap = Bitmap(17,17)
for x0, y0, x1, y1 in ((1,8,8,16),(8,16,16,8),(16,8,8,1),(8,1,1,8)):
    bitmap.line(x0, y0, x1, y1)
bitmap.chardisplay()
===
T Colour
   Byte r
   Byte g
   Byte b

   F ==(other)
      R .r == other.r & .g == other.g & .b == other.b
   F (r, g, b)
      .r = r
      .g = g
      .b = b

V black = Colour(0, 0, 0)
V white = Colour(255, 255, 255)

T Bitmap
   Int width
   Int height
   Colour background
   [[Colour]] map

   F (width = 40, height = 40, background = white)
      assert(width > 0 & height > 0)
      .width = width
      .height = height
      .background = background
      .map = (0 .< height).map(h -> (0 .< @width).map(w -> copy(@@background)))

   F fillrect(x, y, width, height, colour = black)
      assert(x >= 0 & y >= 0 & width > 0 & height > 0)
      L(h) 0 .< height
         L(w) 0 .< width
            .map[y + h][x + w] = copy(colour)

   F chardisplay()
      V txt = .map.map(row -> row.map(bit -> (I bit == @@.background {‘ ’} E ‘@’)).join(‘’))
      txt = txt.map(row -> ‘|’row‘|’)
      txt.insert(0, ‘+’(‘-’ * .width)‘+’)
      txt.append(‘+’(‘-’ * .width)‘+’)
      print(reversed(txt).join("\n"))

   F set(x, y, colour = black)
      .map[y][x] = colour

   F get(x, y)
      R .map[y][x]

   F line(x0, y0, x1, y1)
      ‘Bresenham's line algorithm’
      V dx = abs(x1 - x0)
      V dy = abs(y1 - y0)
      V (x, y) = (x0, y0)
      V sx = I x0 > x1 {-1} E 1
      V sy = I y0 > y1 {-1} E 1
      I dx > dy
         V err = dx / 2.0
         L x != x1
            .set(x, y)
            err -= dy
            I err < 0
               y += sy
               err += dx
            x += sx
      E
         V err = dy / 2.0
         L y != y1
            .set(x, y)
            err -= dx
            I err < 0
               x += sx
               err += dy
            y += sy
      .set(x, y)

V bitmap = Bitmap(17, 17)
L(x0, y0, x1, y1) ((1, 8, 8, 16), (8, 16, 16, 8), (16, 8, 8, 1), (8, 1, 1, 8))
   bitmap.line(x0, y0, x1, y1)
bitmap.chardisplay()
===
class Colour
{
public:
    Byte r;
    Byte g;
    Byte b;

    template <typename T1> auto operator==(const T1 &other) const
    {
        return r == other.r && g == other.g && b == other.b;
    }
    template <typename T1, typename T2, typename T3> Colour(const T1 &r, const T2 &g, const T3 &b) :
        r(r),
        g(g),
        b(b)
    {
    }
};

auto black = Colour(0, 0, 0);
auto white = Colour(255, 255, 255);

class Bitmap
{
public:
    int width;
    int height;
    Colour background;
    Array<Array<Colour>> map;

    template <typename T1 = decltype(40), typename T2 = decltype(40), typename T3 = decltype(white)> Bitmap(const T1 &width = 40, const T2 &height = 40, const T3 &background = white) :
        width(width),
        height(height),
        background(background)
    {
        assert(width > 0 && height > 0);
        map = range_el(0, height).map([&background, &width](const auto &h){return range_el(0, width).map([&background](const auto &w){return copy(background);});});
    }

    template <typename T1, typename T2, typename T3, typename T4, typename T5 = decltype(black)> auto fillrect(const T1 &x, const T2 &y, const T3 &width, const T4 &height, const T5 &colour = black)
    {
        assert(x >= 0 && y >= 0 && width > 0 && height > 0);
        for (auto h : range_el(0, height))
            for (auto w : range_el(0, width))
                map[y + h].set(x + w, copy(colour));
    }

    auto chardisplay()
    {
        auto txt = map.map([this](const auto &row){return row.map([this](const auto &bit){return (bit == background ? u' '_C : u'@'_C);}).join(u""_S);});
        txt = txt.map([](const auto &row){return u"|"_S & row & u"|"_S;});
        txt.insert(0, u"+"_S & (u"-"_S * width) & u"+"_S);
        txt.append(u"+"_S & (u"-"_S * width) & u"+"_S);
        print(reversed(txt).join(u"\n"_S));
    }

    template <typename T1, typename T2, typename T3 = decltype(black)> auto set(const T1 &x, const T2 &y, const T3 &colour = black)
    {
        map[y].set(x, colour);
    }

    template <typename T1, typename T2> auto get(const T1 &x, const T2 &y)
    {
        return map[y][x];
    }

    template <typename T1, typename T2, typename T3, typename T4> auto line(const T1 &x0, const T2 &_y0_, const T3 &x1, const T4 &_y1_)
    {
        u"Bresenham's line algorithm"_S;
        auto dx = abs(x1 - x0);
        auto dy = abs(_y1_ - _y0_);
        auto [x, y] = make_tuple(x0, _y0_);
        auto sx = x0 > x1 ? -1 : 1;
        auto sy = _y0_ > _y1_ ? -1 : 1;
        if (dx > dy) {
            auto err = dx / 2.0;
            while (x != x1) {
                set(x, y);
                err -= dy;
                if (err < 0) {
                    y += sy;
                    err += dx;
                }
                x += sx;
            }
        }
        else {
            auto err = dy / 2.0;
            while (y != _y1_) {
                set(x, y);
                err -= dx;
                if (err < 0) {
                    x += sx;
                    err += dy;
                }
                y += sy;
            }
        }
        set(x, y);
    }
};

auto bitmap = Bitmap(17, 17);

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&[x0, _y0_, x1, _y1_] : make_tuple(make_tuple(1, 8, 8, 16), make_tuple(8, 16, 16, 8), make_tuple(16, 8, 8, 1), make_tuple(8, 1, 1, 8)))
            bitmap.line(x0, _y0_, x1, _y1_);
        bitmap.chardisplay();
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Bitmap/B%C3%A9zier_curves/Cubic#Python
from copy import copy
from typing import NamedTuple, List

Byte = int
class Colour(NamedTuple):
    r : Byte
    g : Byte
    b : Byte

    def __eq__(self, other):
        return self.r == other.r and self.g == other.g and self.b == other.b

black = Colour(0,0,0)
white = Colour(255,255,255) # Colour ranges are not enforced.

class Bitmap:
    width : int
    height : int
    background : Colour
    map : List[List[Colour]]

    def __init__(self, width = 40, height = 40, background=white):
        assert width > 0 and height > 0# and type(background) == Colour
        self.width = width
        self.height = height
        self.background = background
        self.map = [[copy(background) for w in range(width)] for h in range(height)]

    def fillrect(self, x, y, width, height, colour=black):
        assert x >= 0 and y >= 0 and width > 0 and height > 0# and type(colour) == Colour
        for h in range(height):
            for w in range(width):
                self.map[y+h][x+w] = copy(colour)

    def chardisplay(self):
        txt = [''.join((' ' if bit==self.background else '@')
                       for bit in row)
               for row in self.map]
        # Boxing
        txt = ['|'+row+'|' for row in txt]
        txt.insert(0, '+' + '-' * self.width + '+')
        txt.append('+' + '-' * self.width + '+')
        print('\n'.join(reversed(txt)))

    def set(self, x, y, colour=black):
        #assert type(colour) == Colour
        self.map[y][x]=colour

    def get(self, x, y):
        return self.map[y][x]

    def line(self, x0, y0, x1, y1):
        "Bresenham's line algorithm"
        dx = abs(x1 - x0)
        dy = abs(y1 - y0)
        (x, y) = (x0, y0)
        sx = -1 if x0 > x1 else 1
        sy = -1 if y0 > y1 else 1
        if dx > dy:
            err = dx / 2.0
            while x != x1:
                self.set(x, y)
                err -= dy
                if err < 0:
                    y += sy
                    err += dx
                x += sx
        else:
            err = dy / 2.0
            while y != y1:
                self.set(x, y)
                err -= dx
                if err < 0:
                    x += sx
                    err += dy
                y += sy
        self.set(x, y)

    def cubicbezier(self, x0, y0, x1, y1, x2, y2, x3, y3, n=20):
        pts : List[Tuple[int, int]] = []
        for i in range(n+1):
            t = float(i) / n
            a = (1. - t)**3
            b = 3. * t * (1. - t)**2
            c = 3.0 * t**2 * (1.0 - t)
            d = t**3

            x = int(a * x0 + b * x1 + c * x2 + d * x3)
            y = int(a * y0 + b * y1 + c * y2 + d * y3)
            pts.append( (x, y) )
        for i in range(n):
            self.line(pts[i][0], pts[i][1], pts[i+1][0], pts[i+1][1])

bitmap = Bitmap(17,17)
bitmap.cubicbezier(16,1, 1,4, 3,16, 15,11)
bitmap.chardisplay()
===
T Colour
   Byte r
   Byte g
   Byte b

   F ==(other)
      R .r == other.r & .g == other.g & .b == other.b
   F (r, g, b)
      .r = r
      .g = g
      .b = b

V black = Colour(0, 0, 0)
V white = Colour(255, 255, 255)

T Bitmap
   Int width
   Int height
   Colour background
   [[Colour]] map

   F (width = 40, height = 40, background = white)
      assert(width > 0 & height > 0)
      .width = width
      .height = height
      .background = background
      .map = (0 .< height).map(h -> (0 .< @width).map(w -> copy(@@background)))

   F fillrect(x, y, width, height, colour = black)
      assert(x >= 0 & y >= 0 & width > 0 & height > 0)
      L(h) 0 .< height
         L(w) 0 .< width
            .map[y + h][x + w] = copy(colour)

   F chardisplay()
      V txt = .map.map(row -> row.map(bit -> (I bit == @@.background {‘ ’} E ‘@’)).join(‘’))
      txt = txt.map(row -> ‘|’row‘|’)
      txt.insert(0, ‘+’(‘-’ * .width)‘+’)
      txt.append(‘+’(‘-’ * .width)‘+’)
      print(reversed(txt).join("\n"))

   F set(x, y, colour = black)
      .map[y][x] = colour

   F get(x, y)
      R .map[y][x]

   F line(x0, y0, x1, y1)
      ‘Bresenham's line algorithm’
      V dx = abs(x1 - x0)
      V dy = abs(y1 - y0)
      V (x, y) = (x0, y0)
      V sx = I x0 > x1 {-1} E 1
      V sy = I y0 > y1 {-1} E 1
      I dx > dy
         V err = dx / 2.0
         L x != x1
            .set(x, y)
            err -= dy
            I err < 0
               y += sy
               err += dx
            x += sx
      E
         V err = dy / 2.0
         L y != y1
            .set(x, y)
            err -= dx
            I err < 0
               x += sx
               err += dy
            y += sy
      .set(x, y)

   F cubicbezier(x0, y0, x1, y1, x2, y2, x3, y3, n = 20)
      [(Int, Int)] pts
      L(i) 0 .. n
         V t = Float(i) / n
         V a = (1. - t) ^ 3
         V b = 3. * t * (1. - t) ^ 2
         V c = 3.0 * t ^ 2 * (1.0 - t)
         V d = t ^ 3

         V x = Int(a * x0 + b * x1 + c * x2 + d * x3)
         V y = Int(a * y0 + b * y1 + c * y2 + d * y3)
         pts.append((x, y))
      L(i) 0 .< n
         .line(pts[i][0], pts[i][1], pts[i + 1][0], pts[i + 1][1])

V bitmap = Bitmap(17, 17)
bitmap.cubicbezier(16, 1, 1, 4, 3, 16, 15, 11)
bitmap.chardisplay()
===
class Colour
{
public:
    Byte r;
    Byte g;
    Byte b;

    template <typename T1> auto operator==(const T1 &other) const
    {
        return r == other.r && g == other.g && b == other.b;
    }
    template <typename T1, typename T2, typename T3> Colour(const T1 &r, const T2 &g, const T3 &b) :
        r(r),
        g(g),
        b(b)
    {
    }
};

auto black = Colour(0, 0, 0);
auto white = Colour(255, 255, 255);

class Bitmap
{
public:
    int width;
    int height;
    Colour background;
    Array<Array<Colour>> map;

    template <typename T1 = decltype(40), typename T2 = decltype(40), typename T3 = decltype(white)> Bitmap(const T1 &width = 40, const T2 &height = 40, const T3 &background = white) :
        width(width),
        height(height),
        background(background)
    {
        assert(width > 0 && height > 0);
        map = range_el(0, height).map([&background, &width](const auto &h){return range_el(0, width).map([&background](const auto &w){return copy(background);});});
    }

    template <typename T1, typename T2, typename T3, typename T4, typename T5 = decltype(black)> auto fillrect(const T1 &x, const T2 &y, const T3 &width, const T4 &height, const T5 &colour = black)
    {
        assert(x >= 0 && y >= 0 && width > 0 && height > 0);
        for (auto h : range_el(0, height))
            for (auto w : range_el(0, width))
                map[y + h].set(x + w, copy(colour));
    }

    auto chardisplay()
    {
        auto txt = map.map([this](const auto &row){return row.map([this](const auto &bit){return (bit == background ? u' '_C : u'@'_C);}).join(u""_S);});
        txt = txt.map([](const auto &row){return u"|"_S & row & u"|"_S;});
        txt.insert(0, u"+"_S & (u"-"_S * width) & u"+"_S);
        txt.append(u"+"_S & (u"-"_S * width) & u"+"_S);
        print(reversed(txt).join(u"\n"_S));
    }

    template <typename T1, typename T2, typename T3 = decltype(black)> auto set(const T1 &x, const T2 &y, const T3 &colour = black)
    {
        map[y].set(x, colour);
    }

    template <typename T1, typename T2> auto get(const T1 &x, const T2 &y)
    {
        return map[y][x];
    }

    template <typename T1, typename T2, typename T3, typename T4> auto line(const T1 &x0, const T2 &_y0_, const T3 &x1, const T4 &_y1_)
    {
        u"Bresenham's line algorithm"_S;
        auto dx = abs(x1 - x0);
        auto dy = abs(_y1_ - _y0_);
        auto [x, y] = make_tuple(x0, _y0_);
        auto sx = x0 > x1 ? -1 : 1;
        auto sy = _y0_ > _y1_ ? -1 : 1;
        if (dx > dy) {
            auto err = dx / 2.0;
            while (x != x1) {
                set(x, y);
                err -= dy;
                if (err < 0) {
                    y += sy;
                    err += dx;
                }
                x += sx;
            }
        }
        else {
            auto err = dy / 2.0;
            while (y != _y1_) {
                set(x, y);
                err -= dx;
                if (err < 0) {
                    x += sx;
                    err += dy;
                }
                y += sy;
            }
        }
        set(x, y);
    }

    template <typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9 = decltype(20)> auto cubicbezier(const T1 &x0, const T2 &_y0_, const T3 &x1, const T4 &_y1_, const T5 &x2, const T6 &y2, const T7 &x3, const T8 &y3, const T9 &n = 20)
    {
        Array<ivec2> pts;
        for (auto i : range_ee(0, n)) {
            auto t = to_float(i) / n;
            auto a = cube((1. - t));
            auto b = 3. * t * square((1. - t));
            auto c = 3.0 * square(t) * (1.0 - t);
            auto d = cube(t);

            auto x = to_int(a * x0 + b * x1 + c * x2 + d * x3);
            auto y = to_int(a * _y0_ + b * _y1_ + c * y2 + d * y3);
            pts.append(make_tuple(x, y));
        }
        for (auto i : range_el(0, n))
            line(_get<0>(pts[i]), _get<1>(pts[i]), _get<0>(pts[i + 1]), _get<1>(pts[i + 1]));
    }
};

auto bitmap = Bitmap(17, 17);

struct CodeBlock1
{
    CodeBlock1()
    {
        bitmap.cubicbezier(16, 1, 1, 4, 3, 16, 15, 11);
        bitmap.chardisplay();
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Bitmap/Midpoint_circle_algorithm#Python
from copy import copy
from typing import NamedTuple, List

Byte = int
class Colour(NamedTuple):
    r : Byte
    g : Byte
    b : Byte

    def __eq__(self, other):
        return self.r == other.r and self.g == other.g and self.b == other.b

black = Colour(0,0,0)
white = Colour(255,255,255) # Colour ranges are not enforced.

class Bitmap:
    width : int
    height : int
    background : Colour
    map : List[List[Colour]]

    def __init__(self, width = 40, height = 40, background=white):
        assert width > 0 and height > 0# and type(background) == Colour
        self.width = width
        self.height = height
        self.background = background
        self.map = [[copy(background) for w in range(width)] for h in range(height)]

    def fillrect(self, x, y, width, height, colour=black):
        assert x >= 0 and y >= 0 and width > 0 and height > 0# and type(colour) == Colour
        for h in range(height):
            for w in range(width):
                self.map[y+h][x+w] = copy(colour)

    def chardisplay(self):
        txt = [''.join((' ' if bit==self.background else '@')
                       for bit in row)
               for row in self.map]
        # Boxing
        txt = ['|'+row+'|' for row in txt]
        txt.insert(0, '+' + '-' * self.width + '+')
        txt.append('+' + '-' * self.width + '+')
        print('\n'.join(reversed(txt)))

    def set(self, x, y, colour=black):
        #assert type(colour) == Colour
        self.map[y][x]=colour

    def get(self, x, y):
        return self.map[y][x]

    def circle(self, x0, y0, radius, colour=black):
        f = 1 - radius
        ddf_x = 1
        ddf_y = -2 * radius
        x = 0
        y = radius
        self.set(x0, y0 + radius, colour)
        self.set(x0, y0 - radius, colour)
        self.set(x0 + radius, y0, colour)
        self.set(x0 - radius, y0, colour)

        while x < y:
            if f >= 0:
                y -= 1
                ddf_y += 2
                f += ddf_y
            x += 1
            ddf_x += 2
            f += ddf_x
            self.set(x0 + x, y0 + y, colour)
            self.set(x0 - x, y0 + y, colour)
            self.set(x0 + x, y0 - y, colour)
            self.set(x0 - x, y0 - y, colour)
            self.set(x0 + y, y0 + x, colour)
            self.set(x0 - y, y0 + x, colour)
            self.set(x0 + y, y0 - x, colour)
            self.set(x0 - y, y0 - x, colour)

bitmap = Bitmap(25,25)
bitmap.circle(x0=12, y0=12, radius=12)
bitmap.chardisplay()
===
T Colour
   Byte r
   Byte g
   Byte b

   F ==(other)
      R .r == other.r & .g == other.g & .b == other.b
   F (r, g, b)
      .r = r
      .g = g
      .b = b

V black = Colour(0, 0, 0)
V white = Colour(255, 255, 255)

T Bitmap
   Int width
   Int height
   Colour background
   [[Colour]] map

   F (width = 40, height = 40, background = white)
      assert(width > 0 & height > 0)
      .width = width
      .height = height
      .background = background
      .map = (0 .< height).map(h -> (0 .< @width).map(w -> copy(@@background)))

   F fillrect(x, y, width, height, colour = black)
      assert(x >= 0 & y >= 0 & width > 0 & height > 0)
      L(h) 0 .< height
         L(w) 0 .< width
            .map[y + h][x + w] = copy(colour)

   F chardisplay()
      V txt = .map.map(row -> row.map(bit -> (I bit == @@.background {‘ ’} E ‘@’)).join(‘’))
      txt = txt.map(row -> ‘|’row‘|’)
      txt.insert(0, ‘+’(‘-’ * .width)‘+’)
      txt.append(‘+’(‘-’ * .width)‘+’)
      print(reversed(txt).join("\n"))

   F set(x, y, colour = black)
      .map[y][x] = colour

   F get(x, y)
      R .map[y][x]

   F circle(x0, y0, radius, colour = black)
      V f = 1 - radius
      V ddf_x = 1
      V ddf_y = -2 * radius
      V x = 0
      V y = radius
      .set(x0, y0 + radius, colour)
      .set(x0, y0 - radius, colour)
      .set(x0 + radius, y0, colour)
      .set(x0 - radius, y0, colour)

      L x < y
         I f >= 0
            y--
            ddf_y += 2
            f += ddf_y
         x++
         ddf_x += 2
         f += ddf_x
         .set(x0 + x, y0 + y, colour)
         .set(x0 - x, y0 + y, colour)
         .set(x0 + x, y0 - y, colour)
         .set(x0 - x, y0 - y, colour)
         .set(x0 + y, y0 + x, colour)
         .set(x0 - y, y0 + x, colour)
         .set(x0 + y, y0 - x, colour)
         .set(x0 - y, y0 - x, colour)

V bitmap = Bitmap(25, 25)
bitmap.circle(x0' 12, y0' 12, radius' 12)
bitmap.chardisplay()
===
class Colour
{
public:
    Byte r;
    Byte g;
    Byte b;

    template <typename T1> auto operator==(const T1 &other) const
    {
        return r == other.r && g == other.g && b == other.b;
    }
    template <typename T1, typename T2, typename T3> Colour(const T1 &r, const T2 &g, const T3 &b) :
        r(r),
        g(g),
        b(b)
    {
    }
};

auto black = Colour(0, 0, 0);
auto white = Colour(255, 255, 255);

class Bitmap
{
public:
    int width;
    int height;
    Colour background;
    Array<Array<Colour>> map;

    template <typename T1 = decltype(40), typename T2 = decltype(40), typename T3 = decltype(white)> Bitmap(const T1 &width = 40, const T2 &height = 40, const T3 &background = white) :
        width(width),
        height(height),
        background(background)
    {
        assert(width > 0 && height > 0);
        map = range_el(0, height).map([&background, &width](const auto &h){return range_el(0, width).map([&background](const auto &w){return copy(background);});});
    }

    template <typename T1, typename T2, typename T3, typename T4, typename T5 = decltype(black)> auto fillrect(const T1 &x, const T2 &y, const T3 &width, const T4 &height, const T5 &colour = black)
    {
        assert(x >= 0 && y >= 0 && width > 0 && height > 0);
        for (auto h : range_el(0, height))
            for (auto w : range_el(0, width))
                map[y + h].set(x + w, copy(colour));
    }

    auto chardisplay()
    {
        auto txt = map.map([this](const auto &row){return row.map([this](const auto &bit){return (bit == background ? u' '_C : u'@'_C);}).join(u""_S);});
        txt = txt.map([](const auto &row){return u"|"_S & row & u"|"_S;});
        txt.insert(0, u"+"_S & (u"-"_S * width) & u"+"_S);
        txt.append(u"+"_S & (u"-"_S * width) & u"+"_S);
        print(reversed(txt).join(u"\n"_S));
    }

    template <typename T1, typename T2, typename T3 = decltype(black)> auto set(const T1 &x, const T2 &y, const T3 &colour = black)
    {
        map[y].set(x, colour);
    }

    template <typename T1, typename T2> auto get(const T1 &x, const T2 &y)
    {
        return map[y][x];
    }

    template <typename T1, typename T2, typename T3, typename T4 = decltype(black)> auto circle(const T1 &x0, const T2 &_y0_, const T3 &radius, const T4 &colour = black)
    {
        auto f = 1 - radius;
        auto ddf_x = 1;
        auto ddf_y = -2 * radius;
        auto x = 0;
        auto y = radius;
        set(x0, _y0_ + radius, colour);
        set(x0, _y0_ - radius, colour);
        set(x0 + radius, _y0_, colour);
        set(x0 - radius, _y0_, colour);

        while (x < y) {
            if (f >= 0) {
                y--;
                ddf_y += 2;
                f += ddf_y;
            }
            x++;
            ddf_x += 2;
            f += ddf_x;
            set(x0 + x, _y0_ + y, colour);
            set(x0 - x, _y0_ + y, colour);
            set(x0 + x, _y0_ - y, colour);
            set(x0 - x, _y0_ - y, colour);
            set(x0 + y, _y0_ + x, colour);
            set(x0 - y, _y0_ + x, colour);
            set(x0 + y, _y0_ - x, colour);
            set(x0 - y, _y0_ - x, colour);
        }
    }
};

auto bitmap = Bitmap(25, 25);

struct CodeBlock1
{
    CodeBlock1()
    {
        bitmap.circle(12, 12, 12);
        bitmap.chardisplay();
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Bitmap/Write_a_PPM_file#Python
from copy import copy
from typing import NamedTuple, List

Byte = int
class Colour(NamedTuple):
    r : Byte
    g : Byte
    b : Byte

    def __eq__(self, other):
        return self.r == other.r and self.g == other.g and self.b == other.b

black = Colour(0,0,0)
white = Colour(255,255,255) # Colour ranges are not enforced.

class Bitmap:
    width : int
    height : int
    background : Colour
    map : List[List[Colour]]

    def __init__(self, width = 40, height = 40, background=white):
        assert width > 0 and height > 0# and type(background) == Colour
        self.width = width
        self.height = height
        self.background = background
        self.map = [[copy(background) for w in range(width)] for h in range(height)]

    def fillrect(self, x, y, width, height, colour=black):
        assert x >= 0 and y >= 0 and width > 0 and height > 0# and type(colour) == Colour
        for h in range(height):
            for w in range(width):
                self.map[y+h][x+w] = copy(colour)

    def set(self, x, y, colour=black):
        #assert type(colour) == Colour
        self.map[y][x]=colour

    def get(self, x, y):
        return self.map[y][x]

    def writeppmp3(self):
        magic = "P3\n"
        comment = '# generated from Bitmap.writeppmp3\n'
        s = magic + comment + ('%i %i\n%i\n' % (self.width, self.height, 255))
        for h in range(self.height-1, -1, -1):
            for w in range(self.width):
                (r, g, b) = self.get(w, h)
                s += '   %3i %3i %3i' % (r, g, b)
            s += "\n"
        return s

    def writeppmp6(self):
        magic = "P6\n"
        comment = '# generated from Bitmap.writeppmp6\n'
        b : List[Byte] = []
        b += magic.encode()
        b += comment.encode()
        b += ('%i %i\n%i\n' % (self.width, self.height, 255)).encode()
        for h in range(self.height-1, -1, -1):
            for w in range(self.width):
                (r, g, bl) = self.get(w, h)
                b += [r, g, bl]
        return bytes(b)

# Draw something simple
bitmap = Bitmap(4, 4, black)
bitmap.fillrect(1, 0, 1, 2, white)
bitmap.set(3, 3, Colour(127, 0, 63))
# Whats in the generated PPM file
print(bitmap.writeppmp3())

# Write a P6 file
open('tmp.ppm', 'wb').write(bitmap.writeppmp6())
===
T Colour
   Byte r
   Byte g
   Byte b

   F ==(other)
      R .r == other.r & .g == other.g & .b == other.b
   F (r, g, b)
      .r = r
      .g = g
      .b = b

V black = Colour(0, 0, 0)
V white = Colour(255, 255, 255)

T Bitmap
   Int width
   Int height
   Colour background
   [[Colour]] map

   F (width = 40, height = 40, background = white)
      assert(width > 0 & height > 0)
      .width = width
      .height = height
      .background = background
      .map = (0 .< height).map(h -> (0 .< @width).map(w -> copy(@@background)))

   F fillrect(x, y, width, height, colour = black)
      assert(x >= 0 & y >= 0 & width > 0 & height > 0)
      L(h) 0 .< height
         L(w) 0 .< width
            .map[y + h][x + w] = copy(colour)

   F set(x, y, colour = black)
      .map[y][x] = colour

   F get(x, y)
      R .map[y][x]

   F writeppmp3()
      V magic = "P3\n"
      V comment = "# generated from Bitmap.writeppmp3\n"
      V s = magic‘’comment‘’("#. #.\n#.\n".format(.width, .height, 255))
      L(h) (.height - 1 .< -1).step(-1)
         L(w) 0 .< .width
            V (r, g, b) = .get(w, h)
            s ‘’= ‘   #3 #3 #3’.format(r, g, b)
         s ‘’= "\n"
      R s

   F writeppmp6()
      V magic = "P6\n"
      V comment = "# generated from Bitmap.writeppmp6\n"
      [Byte] b
      b [+]= magic.encode()
      b [+]= comment.encode()
      b [+]= ("#. #.\n#.\n".format(.width, .height, 255)).encode()
      L(h) (.height - 1 .< -1).step(-1)
         L(w) 0 .< .width
            V (r, g, bl) = .get(w, h)
            b [+]= [r, g, bl]
      R b

V bitmap = Bitmap(4, 4, black)
bitmap.fillrect(1, 0, 1, 2, white)
bitmap.set(3, 3, Colour(127, 0, 63))
print(bitmap.writeppmp3())

File(‘tmp.ppm’, ‘w’).write_bytes(bitmap.writeppmp6())
===
class Colour
{
public:
    Byte r;
    Byte g;
    Byte b;

    template <typename T1> auto operator==(const T1 &other) const
    {
        return r == other.r && g == other.g && b == other.b;
    }
    template <typename T1, typename T2, typename T3> Colour(const T1 &r, const T2 &g, const T3 &b) :
        r(r),
        g(g),
        b(b)
    {
    }
};

auto black = Colour(0, 0, 0);
auto white = Colour(255, 255, 255);

class Bitmap
{
public:
    int width;
    int height;
    Colour background;
    Array<Array<Colour>> map;

    template <typename T1 = decltype(40), typename T2 = decltype(40), typename T3 = decltype(white)> Bitmap(const T1 &width = 40, const T2 &height = 40, const T3 &background = white) :
        width(width),
        height(height),
        background(background)
    {
        assert(width > 0 && height > 0);
        map = range_el(0, height).map([&background, &width](const auto &h){return range_el(0, width).map([&background](const auto &w){return copy(background);});});
    }

    template <typename T1, typename T2, typename T3, typename T4, typename T5 = decltype(black)> auto fillrect(const T1 &x, const T2 &y, const T3 &width, const T4 &height, const T5 &colour = black)
    {
        assert(x >= 0 && y >= 0 && width > 0 && height > 0);
        for (auto h : range_el(0, height))
            for (auto w : range_el(0, width))
                map[y + h].set(x + w, copy(colour));
    }

    template <typename T1, typename T2, typename T3 = decltype(black)> auto set(const T1 &x, const T2 &y, const T3 &colour = black)
    {
        map[y].set(x, colour);
    }

    template <typename T1, typename T2> auto get(const T1 &x, const T2 &y)
    {
        return map[y][x];
    }

    auto writeppmp3()
    {
        auto magic = u"P3\n"_S;
        auto comment = u"# generated from Bitmap.writeppmp3\n"_S;
        auto s = magic & comment & (u"#. #.\n#.\n"_S.format(width, height, 255));
        for (auto h : range_el(height - 1, -1).step(-1)) {
            for (auto w : range_el(0, width)) {
                auto [r, g, b] = get(w, h);
                s &= u"   #3 #3 #3"_S.format(r, g, b);
            }
            s &= u"\n"_S;
        }
        return s;
    }

    auto writeppmp6()
    {
        auto magic = u"P6\n"_S;
        auto comment = u"# generated from Bitmap.writeppmp6\n"_S;
        Array<Byte> b;
        b.append(magic.encode());
        b.append(comment.encode());
        b.append((u"#. #.\n#.\n"_S.format(width, height, 255)).encode());
        for (auto h : range_el(height - 1, -1).step(-1))
            for (auto w : range_el(0, width)) {
                auto [r, g, bl] = get(w, h);
                b.append(create_array({r, g, bl}));
            }
        return b;
    }
};

auto bitmap = Bitmap(4, 4, black);

struct CodeBlock1
{
    CodeBlock1()
    {
        bitmap.fillrect(1, 0, 1, 2, white);
        bitmap.set(3, 3, Colour(127, 0, 63));
        print(bitmap.writeppmp3());

        File(u"tmp.ppm"_S, u"w"_S).write_bytes(bitmap.writeppmp6());
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Bitmap/Read_a_PPM_file#Python
from copy import copy
from typing import NamedTuple, List

Byte = int
class Colour(NamedTuple):
    r : Byte
    g : Byte
    b : Byte

    def __eq__(self, other):
        return self.r == other.r and self.g == other.g and self.b == other.b

black = Colour(0,0,0)
white = Colour(255,255,255) # Colour ranges are not enforced.

class Bitmap:
    width : int
    height : int
    background : Colour
    map : List[List[Colour]]

    def __init__(self, width = 40, height = 40, background=white):
        assert width > 0 and height > 0# and type(background) == Colour
        self.width = width
        self.height = height
        self.background = background
        self.map = [[copy(background) for w in range(width)] for h in range(height)]

    def fillrect(self, x, y, width, height, colour=black):
        assert x >= 0 and y >= 0 and width > 0 and height > 0# and type(colour) == Colour
        for h in range(height):
            for w in range(width):
                self.map[y+h][x+w] = copy(colour)

    def set(self, x, y, colour=black):
        #assert type(colour) == Colour
        self.map[y][x]=colour

    def get(self, x, y):
        return self.map[y][x]

    def togreyscale(self):
        for h in range(self.height):
            for w in range(self.width):
                (r, g, b) = self.get(w, h)
                l = int(0.2126 * r + 0.7152 * g + 0.0722 * b)
                self.set(w, h, Colour(l, l, l))

    def writeppmp3(self):
        magic = "P3\n"
        comment = '# generated from Bitmap.writeppmp3\n'
        s = magic + comment + ('%i %i\n%i\n' % (self.width, self.height, 255))
        for h in range(self.height-1, -1, -1):
            for w in range(self.width):
                (r, g, b) = self.get(w, h)
                s += '   %3i %3i %3i' % (r, g, b)
            s += "\n"
        return s

def tokenize(fstr):
    tokens : List[str] = []
    for line in fstr.split("\n"):
        if not line.startswith('#'):
            for t in line.split():
                tokens.append(t)
    return tokens

def ppmp3tobitmap(fstr):
    tokens = tokenize(fstr)
    tokeni = -1
    def nexttoken():
        nonlocal tokeni
        tokeni += 1
        return tokens[tokeni]
    assert 'P3' == nexttoken(), 'Wrong filetype'
    #(width, height, maxval) = (int(nexttoken()), int(nexttoken()), int(nexttoken()))
    width  = int(nexttoken())
    height = int(nexttoken())
    maxval = int(nexttoken())
    bitmap = Bitmap(width, height, Colour(0, 0, 0))
    for h in range(height-1, -1, -1):
        for w in range(0, width):
            #bitmap.set(w, h, Colour(int(nexttoken()), int(nexttoken()), int(nexttoken())))
            r = int(nexttoken())
            g = int(nexttoken())
            b = int(nexttoken())
            bitmap.set(w, h, Colour(r, g, b))

    return bitmap

ppmtxt = '''P3
# feep.ppm
4 4
15
 0  0  0    0  0  0    0  0  0   15  0 15
 0  0  0    0 15  7    0  0  0    0  0  0
 0  0  0    0  0  0    0 15  7    0  0  0
15  0 15    0  0  0    0  0  0    0  0  0
'''

bitmap = ppmp3tobitmap(ppmtxt)
print('Grey PPM:')
bitmap.togreyscale()
print(bitmap.writeppmp3())
===
T Colour
   Byte r
   Byte g
   Byte b

   F ==(other)
      R .r == other.r & .g == other.g & .b == other.b
   F (r, g, b)
      .r = r
      .g = g
      .b = b

V black = Colour(0, 0, 0)
V white = Colour(255, 255, 255)

T Bitmap
   Int width
   Int height
   Colour background
   [[Colour]] map

   F (width = 40, height = 40, background = white)
      assert(width > 0 & height > 0)
      .width = width
      .height = height
      .background = background
      .map = (0 .< height).map(h -> (0 .< @width).map(w -> copy(@@background)))

   F fillrect(x, y, width, height, colour = black)
      assert(x >= 0 & y >= 0 & width > 0 & height > 0)
      L(h) 0 .< height
         L(w) 0 .< width
            .map[y + h][x + w] = copy(colour)

   F set(x, y, colour = black)
      .map[y][x] = colour

   F get(x, y)
      R .map[y][x]

   F togreyscale()
      L(h) 0 .< .height
         L(w) 0 .< .width
            V (r, g, b) = .get(w, h)
            V l = Int(0.2126 * r + 0.7152 * g + 0.0722 * b)
            .set(w, h, Colour(l, l, l))

   F writeppmp3()
      V magic = "P3\n"
      V comment = "# generated from Bitmap.writeppmp3\n"
      V s = magic‘’comment‘’("#. #.\n#.\n".format(.width, .height, 255))
      L(h) (.height - 1 .< -1).step(-1)
         L(w) 0 .< .width
            V (r, g, b) = .get(w, h)
            s ‘’= ‘   #3 #3 #3’.format(r, g, b)
         s ‘’= "\n"
      R s

F tokenize(fstr)
   [String] tokens
   L(line) fstr.split("\n")
      I !line.starts_with(‘#’)
         L(t) line.split_py()
            tokens.append(t)
   R tokens

F ppmp3tobitmap(fstr)
   V tokens = tokenize(fstr)
   V tokeni = -1
   F nexttoken()
      @tokeni++
      R @tokens[@tokeni]
   assert(‘P3’ == nexttoken(), ‘Wrong filetype’)
   V width = Int(nexttoken())
   V height = Int(nexttoken())
   V maxval = Int(nexttoken())
   V bitmap = Bitmap(width, height, Colour(0, 0, 0))
   L(h) (height - 1 .< -1).step(-1)
      L(w) 0 .< width
         V r = Int(nexttoken())
         V g = Int(nexttoken())
         V b = Int(nexttoken())
         bitmap.set(w, h, Colour(r, g, b))

   R bitmap

V ppmtxt = ‘P3
# feep.ppm
4 4
15
 0  0  0    0  0  0    0  0  0   15  0 15
 0  0  0    0 15  7    0  0  0    0  0  0
 0  0  0    0  0  0    0 15  7    0  0  0
15  0 15    0  0  0    0  0  0    0  0  0
’

V bitmap = ppmp3tobitmap(ppmtxt)
print(‘Grey PPM:’)
bitmap.togreyscale()
print(bitmap.writeppmp3())
===
class Colour
{
public:
    Byte r;
    Byte g;
    Byte b;

    template <typename T1> auto operator==(const T1 &other) const
    {
        return r == other.r && g == other.g && b == other.b;
    }
    template <typename T1, typename T2, typename T3> Colour(const T1 &r, const T2 &g, const T3 &b) :
        r(r),
        g(g),
        b(b)
    {
    }
};

auto black = Colour(0, 0, 0);
auto white = Colour(255, 255, 255);

class Bitmap
{
public:
    int width;
    int height;
    Colour background;
    Array<Array<Colour>> map;

    template <typename T1 = decltype(40), typename T2 = decltype(40), typename T3 = decltype(white)> Bitmap(const T1 &width = 40, const T2 &height = 40, const T3 &background = white) :
        width(width),
        height(height),
        background(background)
    {
        assert(width > 0 && height > 0);
        map = range_el(0, height).map([&background, &width](const auto &h){return range_el(0, width).map([&background](const auto &w){return copy(background);});});
    }

    template <typename T1, typename T2, typename T3, typename T4, typename T5 = decltype(black)> auto fillrect(const T1 &x, const T2 &y, const T3 &width, const T4 &height, const T5 &colour = black)
    {
        assert(x >= 0 && y >= 0 && width > 0 && height > 0);
        for (auto h : range_el(0, height))
            for (auto w : range_el(0, width))
                map[y + h].set(x + w, copy(colour));
    }

    template <typename T1, typename T2, typename T3 = decltype(black)> auto set(const T1 &x, const T2 &y, const T3 &colour = black)
    {
        map[y].set(x, colour);
    }

    template <typename T1, typename T2> auto get(const T1 &x, const T2 &y)
    {
        return map[y][x];
    }

    auto togreyscale()
    {
        for (auto h : range_el(0, height))
            for (auto w : range_el(0, width)) {
                auto [r, g, b] = get(w, h);
                auto l = to_int(0.2126 * r + 0.7152 * g + 0.0722 * b);
                set(w, h, Colour(l, l, l));
            }
    }

    auto writeppmp3()
    {
        auto magic = u"P3\n"_S;
        auto comment = u"# generated from Bitmap.writeppmp3\n"_S;
        auto s = magic & comment & (u"#. #.\n#.\n"_S.format(width, height, 255));
        for (auto h : range_el(height - 1, -1).step(-1)) {
            for (auto w : range_el(0, width)) {
                auto [r, g, b] = get(w, h);
                s &= u"   #3 #3 #3"_S.format(r, g, b);
            }
            s &= u"\n"_S;
        }
        return s;
    }
};

template <typename T1> auto tokenize(const T1 &fstr)
{
    Array<String> tokens;
    for (auto &&line : fstr.split(u"\n"_S))
        if (!line.starts_with(u"#"_S))
            for (auto &&t : line.split_py())
                tokens.append(t);
    return tokens;
}

template <typename T1> auto ppmp3tobitmap(const T1 &fstr)
{
    auto tokens = tokenize(fstr);
    auto tokeni = -1;
    auto nexttoken = [&tokeni, &tokens]()
    {
        tokeni++;
        return tokens[tokeni];
    };
    assert(u"P3"_S == nexttoken(), u"Wrong filetype"_S);
    auto width = to_int(nexttoken());
    auto height = to_int(nexttoken());
    auto maxval = to_int(nexttoken());
    auto bitmap = Bitmap(width, height, Colour(0, 0, 0));
    for (auto h : range_el(height - 1, -1).step(-1))
        for (auto w : range_el(0, width)) {
            auto r = to_int(nexttoken());
            auto g = to_int(nexttoken());
            auto b = to_int(nexttoken());
            bitmap.set(w, h, Colour(r, g, b));
        }

    return bitmap;
}

auto ppmtxt = uR"(P3
# feep.ppm
4 4
15
 0  0  0    0  0  0    0  0  0   15  0 15
 0  0  0    0 15  7    0  0  0    0  0  0
 0  0  0    0  0  0    0 15  7    0  0  0
15  0 15    0  0  0    0  0  0    0  0  0
)"_S;

auto bitmap = ppmp3tobitmap(ppmtxt);

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"Grey PPM:"_S);
        bitmap.togreyscale();
        print(bitmap.writeppmp3());
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Grayscale_image#Python
from copy import copy
from typing import NamedTuple, List

Byte = int
class Colour(NamedTuple):
    r : Byte
    g : Byte
    b : Byte

    def __eq__(self, other):
        return self.r == other.r and self.g == other.g and self.b == other.b

black = Colour(0,0,0)
white = Colour(255,255,255) # Colour ranges are not enforced.

class Bitmap:
    width : int
    height : int
    background : Colour
    map : List[List[Colour]]

    def __init__(self, width = 40, height = 40, background=white):
        assert width > 0 and height > 0# and type(background) == Colour
        self.width = width
        self.height = height
        self.background = background
        self.map = [[copy(background) for w in range(width)] for h in range(height)]

    def fillrect(self, x, y, width, height, colour=black):
        assert x >= 0 and y >= 0 and width > 0 and height > 0# and type(colour) == Colour
        for h in range(height):
            for w in range(width):
                self.map[y+h][x+w] = copy(colour)

    def set(self, x, y, colour=black):
        #assert type(colour) == Colour
        self.map[y][x]=colour

    def get(self, x, y):
        return self.map[y][x]

    def togreyscale(self):
        for h in range(self.height):
            for w in range(self.width):
                (r, g, b) = self.get(w, h)
                l = int(0.2126 * r + 0.7152 * g + 0.0722 * b)
                self.set(w, h, Colour(l, l, l))

    def writeppmp3(self):
        magic = "P3\n"
        comment = '# generated from Bitmap.writeppmp3\n'
        s = magic + comment + ('%i %i\n%i\n' % (self.width, self.height, 255))
        for h in range(self.height-1, -1, -1):
            for w in range(self.width):
                (r, g, b) = self.get(w, h)
                s += '   %3i %3i %3i' % (r, g, b)
            s += "\n"
        return s

# Draw something simple
bitmap = Bitmap(4, 4, white)
bitmap.fillrect(1, 0, 1, 2, Colour(127, 0, 63))
bitmap.set(3, 3, Colour(0, 127, 31))
print('Colour:')
# Write to the open 'file' handle
print(bitmap.writeppmp3())
print('Grey:')
bitmap.togreyscale()
print(bitmap.writeppmp3())
===
T Colour
   Byte r
   Byte g
   Byte b

   F ==(other)
      R .r == other.r & .g == other.g & .b == other.b
   F (r, g, b)
      .r = r
      .g = g
      .b = b

V black = Colour(0, 0, 0)
V white = Colour(255, 255, 255)

T Bitmap
   Int width
   Int height
   Colour background
   [[Colour]] map

   F (width = 40, height = 40, background = white)
      assert(width > 0 & height > 0)
      .width = width
      .height = height
      .background = background
      .map = (0 .< height).map(h -> (0 .< @width).map(w -> copy(@@background)))

   F fillrect(x, y, width, height, colour = black)
      assert(x >= 0 & y >= 0 & width > 0 & height > 0)
      L(h) 0 .< height
         L(w) 0 .< width
            .map[y + h][x + w] = copy(colour)

   F set(x, y, colour = black)
      .map[y][x] = colour

   F get(x, y)
      R .map[y][x]

   F togreyscale()
      L(h) 0 .< .height
         L(w) 0 .< .width
            V (r, g, b) = .get(w, h)
            V l = Int(0.2126 * r + 0.7152 * g + 0.0722 * b)
            .set(w, h, Colour(l, l, l))

   F writeppmp3()
      V magic = "P3\n"
      V comment = "# generated from Bitmap.writeppmp3\n"
      V s = magic‘’comment‘’("#. #.\n#.\n".format(.width, .height, 255))
      L(h) (.height - 1 .< -1).step(-1)
         L(w) 0 .< .width
            V (r, g, b) = .get(w, h)
            s ‘’= ‘   #3 #3 #3’.format(r, g, b)
         s ‘’= "\n"
      R s

V bitmap = Bitmap(4, 4, white)
bitmap.fillrect(1, 0, 1, 2, Colour(127, 0, 63))
bitmap.set(3, 3, Colour(0, 127, 31))
print(‘Colour:’)
print(bitmap.writeppmp3())
print(‘Grey:’)
bitmap.togreyscale()
print(bitmap.writeppmp3())
===
class Colour
{
public:
    Byte r;
    Byte g;
    Byte b;

    template <typename T1> auto operator==(const T1 &other) const
    {
        return r == other.r && g == other.g && b == other.b;
    }
    template <typename T1, typename T2, typename T3> Colour(const T1 &r, const T2 &g, const T3 &b) :
        r(r),
        g(g),
        b(b)
    {
    }
};

auto black = Colour(0, 0, 0);
auto white = Colour(255, 255, 255);

class Bitmap
{
public:
    int width;
    int height;
    Colour background;
    Array<Array<Colour>> map;

    template <typename T1 = decltype(40), typename T2 = decltype(40), typename T3 = decltype(white)> Bitmap(const T1 &width = 40, const T2 &height = 40, const T3 &background = white) :
        width(width),
        height(height),
        background(background)
    {
        assert(width > 0 && height > 0);
        map = range_el(0, height).map([&background, &width](const auto &h){return range_el(0, width).map([&background](const auto &w){return copy(background);});});
    }

    template <typename T1, typename T2, typename T3, typename T4, typename T5 = decltype(black)> auto fillrect(const T1 &x, const T2 &y, const T3 &width, const T4 &height, const T5 &colour = black)
    {
        assert(x >= 0 && y >= 0 && width > 0 && height > 0);
        for (auto h : range_el(0, height))
            for (auto w : range_el(0, width))
                map[y + h].set(x + w, copy(colour));
    }

    template <typename T1, typename T2, typename T3 = decltype(black)> auto set(const T1 &x, const T2 &y, const T3 &colour = black)
    {
        map[y].set(x, colour);
    }

    template <typename T1, typename T2> auto get(const T1 &x, const T2 &y)
    {
        return map[y][x];
    }

    auto togreyscale()
    {
        for (auto h : range_el(0, height))
            for (auto w : range_el(0, width)) {
                auto [r, g, b] = get(w, h);
                auto l = to_int(0.2126 * r + 0.7152 * g + 0.0722 * b);
                set(w, h, Colour(l, l, l));
            }
    }

    auto writeppmp3()
    {
        auto magic = u"P3\n"_S;
        auto comment = u"# generated from Bitmap.writeppmp3\n"_S;
        auto s = magic & comment & (u"#. #.\n#.\n"_S.format(width, height, 255));
        for (auto h : range_el(height - 1, -1).step(-1)) {
            for (auto w : range_el(0, width)) {
                auto [r, g, b] = get(w, h);
                s &= u"   #3 #3 #3"_S.format(r, g, b);
            }
            s &= u"\n"_S;
        }
        return s;
    }
};

auto bitmap = Bitmap(4, 4, white);

struct CodeBlock1
{
    CodeBlock1()
    {
        bitmap.fillrect(1, 0, 1, 2, Colour(127, 0, 63));
        bitmap.set(3, 3, Colour(0, 127, 31));
        print(u"Colour:"_S);
        print(bitmap.writeppmp3());
        print(u"Grey:"_S);
        bitmap.togreyscale();
        print(bitmap.writeppmp3());
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Brace_expansion_using_ranges#Nim
from typing import Optional

def move(obj):
    return obj

def intFromString(s) -> Optional[int]:
    try:
        return int(s)
    except ValueError:
        return None

def parseRange(r):
    if len(r) == 0: return ['{}'] # rangeless, empty.
    sp = r.split('..')
    if len(sp) == 1: return ['{' + r + '}']
    first = sp[0]
    last = sp[1]
    incr = '1' if len(sp) == 2 else sp[2]

    val1 : Optional[int] = intFromString(first)
    val2 : Optional[int] = intFromString(last)
    val3 : Optional[int] = intFromString(incr)

    if val3 is None: return ['{' + r + '}']   # increment isn't a number.
    n3 = val3
    numeric = val1 is not None and val2 is not None

    n1 : int
    n2 : int
    if numeric:
        n1 = val1
        n2 = val2
    else:
        if (val1 is not None and val2 is None) or (val1 is None and val2 is not None):
            return ['{' + r + '}']   # mixed numeric/alpha not expanded.
        if len(first) != 1 or len(last) != 1:
            return ['{' + r + '}']   # start/end are not both single alpha.
        n1 = ord(first[0])
        n2 = ord(last[0])

    width = 1
    if numeric:
        width = max(len(first), len(last))

    if n3 == 0:
        # Zero increment.
        return [str(n1).zfill(width)] if numeric else [first]

    asc = n1 < n2
    if n3 < 0:
        asc = not asc
        (n1, n2) = (n2, n1)
        n3 = -n3

    result : List[str] = []
    i = n1
    if asc:
        while i <= n2:
            result.append(str(i).zfill(width) if numeric else chr(i))
            i += n3
    else:
        while i >= n2:
            result.append(str(i).zfill(width) if numeric else chr(i))
            i -= n3
    return result

def rangeExpand(s):
    result = ['']
    rng = ''
    inRng = False

    for c in s:
        if c == '{' and not inRng:
            inRng = True
            rng = ''
        elif c == '}' and inRng:
            rngRes = parseRange(rng)
            res : List[str] = []
            for r in result:
                for rr in rngRes:
                    res.append(r + '' + rr)
            result = move(res)
            inRng = False
        elif inRng:
            rng += c
        else:
            for i in range(len(result)):
                result[i] += '' + c

    if inRng:
        for i in range(len(result)):
            result[i] += '{' + rng   # unmatched braces.
    return result

examples = ["simpleNumberRising{1..3}.txt",
            "simpleAlphaDescending-{Z..X}.txt",
            "steppedDownAndPadded-{10..00..5}.txt",
            "minusSignFlipsSequence {030..20..-5}.txt",
            "combined-{Q..P}{2..1}.txt",
            "li{teral",
            "rangeless{}empty",
            "rangeless{random}string",
            "mixedNumberAlpha{5..k}",
            "steppedAlphaRising{P..Z..2}.txt",
            "stops after endpoint-{02..10..3}.txt"]

for s in examples:
    print(s + " ->\n    ", end = '')
    res = rangeExpand(s)
    print("\n    ".join(res))
    print()
===
F intFromString(s) -> Int?
   X.try
      R Int(s)
   X.catch ValueError
      R N

F parseRange(r)
   I r.empty
      R [‘{}’]
   V sp = r.split(‘..’)
   I sp.len == 1
      R [‘{’r‘}’]
   V first = sp[0]
   V last = sp[1]
   V incr = I sp.len == 2 {‘1’} E sp[2]

   Int? val1 = intFromString(first)
   Int? val2 = intFromString(last)
   Int? val3 = intFromString(incr)

   I val3 == N
      R [‘{’r‘}’]
   V n3 = val3
   V numeric = val1 != N & val2 != N

   Int n1
   Int n2
   I numeric
      n1 = val1
      n2 = val2
   E
      I (val1 != N & val2 == N) | (val1 == N & val2 != N)
         R [‘{’r‘}’]
      I first.len != 1 | last.len != 1
         R [‘{’r‘}’]
      n1 = first[0].code
      n2 = last[0].code

   V width = 1
   I numeric
      width = max(first.len, last.len)

   I n3 == 0
      R I numeric {[String(n1).zfill(width)]} E [first]

   V asc = n1 < n2
   I n3 < 0
      asc = !asc
      swap(&n1, &n2)
      n3 = -n3

   [String] result
   V i = n1
   I asc
      L i <= n2
         result.append(I numeric {String(i).zfill(width)} E Char(code' i))
         i += n3
   E
      L i >= n2
         result.append(I numeric {String(i).zfill(width)} E Char(code' i))
         i -= n3
   R result

F rangeExpand(s)
   V result = [‘’]
   V rng = ‘’
   V inRng = 0B

   L(c) s
      I c == ‘{’ & !inRng
         inRng = 1B
         rng = ‘’
      E I c == ‘}’ & inRng
         V rngRes = parseRange(rng)
         [String] res
         L(r) result
            L(rr) rngRes
               res.append(r‘’rr)
         result = move(res)
         inRng = 0B
      E I inRng
         rng ‘’= c
      E
         L(i) 0 .< result.len
            result[i] ‘’= ‘’c

   I inRng
      L(i) 0 .< result.len
         result[i] ‘’= ‘{’rng
   R result

V examples = [‘simpleNumberRising{1..3}.txt’, ‘simpleAlphaDescending-{Z..X}.txt’, ‘steppedDownAndPadded-{10..00..5}.txt’, ‘minusSignFlipsSequence {030..20..-5}.txt’, ‘combined-{Q..P}{2..1}.txt’, ‘li{teral’, ‘rangeless{}empty’, ‘rangeless{random}string’, ‘mixedNumberAlpha{5..k}’, ‘steppedAlphaRising{P..Z..2}.txt’, ‘stops after endpoint-{02..10..3}.txt’]

L(s) examples
   print(s" ->\n    ", end' ‘’)
   V res = rangeExpand(s)
   print(res.join("\n    "))
   print()
===
template <typename T1> Nullable<int> intFromString(const T1 &s)
{
    try
    {
        return to_int(s);
    }
    catch (const ValueError&)
    {
        return nullptr;
    }
}

template <typename T1> auto parseRange(const T1 &r)
{
    if (r.empty())
        return create_array({u"{}"_S});
    auto sp = r.split(u".."_S);
    if (sp.len() == 1)
        return create_array({u"{"_S & r & u"}"_S});
    auto first = _get<0>(sp);
    auto last = _get<1>(sp);
    auto incr = sp.len() == 2 ? u"1"_S : _get<2>(sp);

    Nullable<int> val1 = intFromString(first);
    Nullable<int> val2 = intFromString(last);
    Nullable<int> val3 = intFromString(incr);

    if (val3 == nullptr)
        return create_array({u"{"_S & r & u"}"_S});
    auto n3 = *val3;
    auto numeric = val1 != nullptr && val2 != nullptr;

    int n1;
    int n2;
    if (numeric) {
        n1 = *val1;
        n2 = *val2;
    }
    else {
        if ((val1 != nullptr && val2 == nullptr) || (val1 == nullptr && val2 != nullptr))
            return create_array({u"{"_S & r & u"}"_S});
        if (first.len() != 1 || last.len() != 1)
            return create_array({u"{"_S & r & u"}"_S});
        n1 = _get<0>(first).code;
        n2 = _get<0>(last).code;
    }

    auto width = 1;
    if (numeric)
        width = max(first.len(), last.len());

    if (n3 == 0)
        return numeric ? create_array({String(n1).zfill(width)}) : create_array({first});

    auto asc = n1 < n2;
    if (n3 < 0) {
        asc = !asc;
        swap(n1, n2);
        n3 = -n3;
    }

    Array<String> result;
    auto i = n1;
    if (asc)
        while (i <= n2) {
            result.append(numeric ? String(i).zfill(width) : Char(i));
            i += n3;
        }
    else
        while (i >= n2) {
            result.append(numeric ? String(i).zfill(width) : Char(i));
            i -= n3;
        }
    return result;
}

template <typename T1> auto rangeExpand(const T1 &s)
{
    auto result = create_array({u""_S});
    auto rng = u""_S;
    auto inRng = false;

    for (auto &&c : s)
        if (c == u'{' && !inRng) {
            inRng = true;
            rng = u""_S;
        }
        else if (c == u'}' && inRng) {
            auto rngRes = parseRange(rng);
            Array<String> res;
            for (auto &&r : result)
                for (auto &&rr : rngRes)
                    res.append(r & rr);
            result = std::move(res);
            inRng = false;
        }
        else if (inRng)
            rng &= c;
        else
            for (auto i : range_el(0, result.len()))
                result[i] &= u""_S & c;

    if (inRng)
        for (auto i : range_el(0, result.len()))
            result[i] &= u"{"_S & rng;
    return result;
}

auto examples = create_array({u"simpleNumberRising{1..3}.txt"_S, u"simpleAlphaDescending-{Z..X}.txt"_S, u"steppedDownAndPadded-{10..00..5}.txt"_S, u"minusSignFlipsSequence {030..20..-5}.txt"_S, u"combined-{Q..P}{2..1}.txt"_S, u"li{teral"_S, u"rangeless{}empty"_S, u"rangeless{random}string"_S, u"mixedNumberAlpha{5..k}"_S, u"steppedAlphaRising{P..Z..2}.txt"_S, u"stops after endpoint-{02..10..3}.txt"_S});

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&s : examples) {
            print(s & u" ->\n    "_S, u""_S);
            auto res = rangeExpand(s);
            print(res.join(u"\n    "_S));
            print();
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Brazilian_numbers#Nim
def isPrime(n):
    if n % 2 == 0:
        return n == 2
    if n % 3 == 0:
        return n == 3
    d = 5
    while d * d <= n:
        if n % d == 0:
            return False
        if n % (d + 2) == 0:
            return False
        d += 6
    return True

def sameDigits(n, b):
    d = n % b
    n //= b
    if d == 0:
        return False
    while n > 0:
        if n % b != d:
            return False
        n //= b
    return True

def isBrazilian(n):
    if n < 7:
        return False
    if (n & 1) == 0:
        return True
    for b in range(2, n - 1):
        if sameDigits(n, b):
            return True
    return False

def printList(title, check):
    print(title)
    n = 7
    l : List[int] = []
    while True:
        if check(n) and isBrazilian(n):
            l.append(n)
            if len(l) == 20: break
        n += 1
    print(', '.join(map(str, l)))
    print()

printList("First 20 Brazilian numbers:", lambda n: True)
printList("First 20 odd Brazilian numbers:", lambda n: (n & 1) != 0)
printList("First 20 prime Brazilian numbers:", lambda n: isPrime(n))
===
F isPrime(n)
   I n % 2 == 0
      R n == 2
   I n % 3 == 0
      R n == 3
   V d = 5
   L d * d <= n
      I n % d == 0
         R 0B
      I n % (d + 2) == 0
         R 0B
      d += 6
   R 1B

F sameDigits(=n, b)
   V d = n % b
   n I/= b
   I d == 0
      R 0B
   L n > 0
      I n % b != d
         R 0B
      n I/= b
   R 1B

F isBrazilian(n)
   I n < 7
      R 0B
   I (n [&] 1) == 0
      R 1B
   L(b) 2 .< n - 1
      I sameDigits(n, b)
         R 1B
   R 0B

F printList(title, check)
   print(title)
   V n = 7
   [Int] l
   L
      I check(n) & isBrazilian(n)
         l.append(n)
         I l.len == 20
            L.break
      n++
   print(l.map(String).join(‘, ’))
   print()

printList(‘First 20 Brazilian numbers:’, n -> 1B)
printList(‘First 20 odd Brazilian numbers:’, n -> (n [&] 1) != 0)
printList(‘First 20 prime Brazilian numbers:’, n -> isPrime(n))
===
template <typename T1> auto isPrime(const T1 &n)
{
    if (mod(n, 2) == 0)
        return n == 2;
    if (mod(n, 3) == 0)
        return n == 3;
    auto d = 5;
    while (d * d <= n) {
        if (mod(n, d) == 0)
            return false;
        if (mod(n, (d + 2)) == 0)
            return false;
        d += 6;
    }
    return true;
}

template <typename T1, typename T2> auto sameDigits(T1 n, const T2 &b)
{
    auto d = mod(n, b);
    n = idiv(n, b);
    if (d == 0)
        return false;
    while (n > 0) {
        if (mod(n, b) != d)
            return false;
        n = idiv(n, b);
    }
    return true;
}

template <typename T1> auto isBrazilian(const T1 &n)
{
    if (n < 7)
        return false;
    if ((n & 1) == 0)
        return true;
    for (auto b : range_el(2, n - 1))
        if (sameDigits(n, b))
            return true;
    return false;
}

template <typename T1, typename T2> auto printList(const T1 &title, const T2 &check)
{
    print(title);
    auto n = 7;
    Array<int> l;
    while (true) {
        if (check(n) && isBrazilian(n)) {
            l.append(n);
            if (l.len() == 20)
                break;
        }
        n++;
    }
    print(l.map([](const auto &x){return String(x);}).join(u", "_S));
    print();
}

struct CodeBlock1
{
    CodeBlock1()
    {
        printList(u"First 20 Brazilian numbers:"_S, [](const auto &n){return true;});
        printList(u"First 20 odd Brazilian numbers:"_S, [](const auto &n){return (n & 1) != 0;});
        printList(u"First 20 prime Brazilian numbers:"_S, [](const auto &n){return isPrime(n);});
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Burrows%E2%80%93Wheeler_transform#Python
def bwt(s : str):
    """Apply Burrows-Wheeler transform to input string."""
    assert "\002" not in s and "\003" not in s, "Input string cannot contain STX and ETX characters"
    s = "\002" + s + "\003"  # Add start and end of text marker
    table = sorted(s[i:] + s[:i] for i in range(len(s)))  # Table of rotations of string
    last_column = [row[-1:] for row in table]  # Last characters of each row
    return "".join(last_column)  # Convert list of characters into string

def ibwt(r : str):
    """Apply inverse Burrows-Wheeler transform."""
    table = [""] * len(r)  # Make empty table
    for i in range(len(r)):
        table = sorted(r[i] + table[i] for i in range(len(r)))  # Add a column of r
    s = [row for row in table if row.endswith("\003")][0]  # Find the correct row (ending in ETX)
    return s.rstrip("\003").strip("\002")  # Get rid of start and end markers

for text in ["banana",
             "appellee",
             "dogwood",
             "TO BE OR NOT TO BE OR WANT TO BE OR NOT?",
             "SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES"]:
    transformed = bwt(text)
    invTransformed = ibwt(transformed)

    print("Original text:                " + text)
    print("After transformation:         " + transformed.replace('\2', '^').replace('\3', '|'))
    print("After inverse transformation: " + invTransformed)
    print()
===
F bwt(String =s)
   ‘Apply Burrows-Wheeler transform to input string.’
   assert("\002" !C s & "\003" !C s, ‘Input string cannot contain STX and ETX characters’)
   s = "\002"s"\003"
   V table = sorted((0 .< s.len).map(i -> @s[i ..]‘’@s[0 .< i]))
   V last_column = table.map(row -> row[(len)-1 ..])
   R last_column.join(‘’)

F ibwt(String r)
   ‘Apply inverse Burrows-Wheeler transform.’
   V table = [‘’] * r.len
   L(i) 0 .< r.len
      table = sorted((0 .< r.len).map(i -> @r[i]‘’@table[i]))
   V s = table.filter(row -> row.ends_with("\003"))[0]
   R s.rtrim([Char]("\003")).trim([Char]("\002"))

L(text) [‘banana’, ‘appellee’, ‘dogwood’, ‘TO BE OR NOT TO BE OR WANT TO BE OR NOT?’, ‘SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES’]
   V transformed = bwt(text)
   V invTransformed = ibwt(transformed)

   print(‘Original text:                ’text)
   print(‘After transformation:         ’transformed.replace("\2", ‘^’).replace("\3", ‘|’))
   print(‘After inverse transformation: ’invTransformed)
   print()
===
auto bwt(String s)
{
    u"Apply Burrows-Wheeler transform to input string."_S;
    assert(!in(u"\002"_S, s) && !in(u"\003"_S, s), u"Input string cannot contain STX and ETX characters"_S);
    s = u"\002"_S & s & u"\003"_S;
    auto table = sorted(range_el(0, s.len()).map([&s](const auto &i){return s[range_ei(i)] & s[range_el(0, i)];}));
    auto last_column = table.map([](const auto &row){return row[range_elen_i( - 1)];});
    return last_column.join(u""_S);
}

auto ibwt(const String &r)
{
    u"Apply inverse Burrows-Wheeler transform."_S;
    auto table = create_array({u""_S}) * r.len();
    for (auto i : range_el(0, r.len()))
        table = sorted(range_el(0, r.len()).map([&r, &table](const auto &i){return r[i] & table[i];}));
    auto s = _get<0>(table.filter([](const auto &row){return row.ends_with(u"\003"_S);}));
    return s.rtrim(Array<Char>(u"\003"_S)).trim(Array<Char>(u"\002"_S));
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&text : create_array({u"banana"_S, u"appellee"_S, u"dogwood"_S, u"TO BE OR NOT TO BE OR WANT TO BE OR NOT?"_S, u"SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES"_S})) {
            auto transformed = bwt(text);
            auto invTransformed = ibwt(transformed);

            print(u"Original text:                "_S & text);
            print(u"After transformation:         "_S & transformed.replace(u"\2"_S, u"^"_S).replace(u"\3"_S, u"|"_S));
            print(u"After inverse transformation: "_S & invTransformed);
            print();
        }
    }
} code_block_1;