# https://www.rosettacode.org/wiki/Eertree#D
Char = str

class Node:
    length : int
    suffix : int

    def __init__(self, length, suffix = 0):
        self.length = length
        self.suffix = suffix
        self.edges : Dict[Char, int] = {}

oddRoot = 1

def eertree(s):
    tree = [Node(0, oddRoot), Node(-1, oddRoot)]
    suffix = oddRoot
    for i, c in enumerate(s):
        n = suffix
        k : int
        while True:
            k = tree[n].length
            b = i-k-1
            if b>=0 and s[b]==c:
                break
            n=tree[n].suffix

        if c in tree[n].edges:
            suffix = tree[n].edges[c]
            continue

        suffix = len(tree)
        tree += [Node(k+2)]
        tree[n].edges[c] = suffix
        if tree[suffix].length == 1:
            tree[suffix].suffix = 0
            continue

        while True:
            n = tree[n].suffix
            b = i-tree[n].length-1
            if b>=0 and s[b]==c:
                break

        tree[suffix].suffix = tree[n].edges[c]

    return tree

def subPalindromes(tree):
    s : List[str] = []

    def children(n : int, p : str) -> None:
        nonlocal s
        for c, n in tree[n].edges.items():
            p = c + p + c
            s += [p]
            children(n, p)

    children(0, '')
    for c, n in tree[1].edges.items():
        s += [c]
        children(n, c)

    return s

tree = eertree("eertree")
print(subPalindromes(tree))
===
T Node
   Int length
   Int suffix
   [Char = Int] edges

   F (length, suffix = 0)
      .length = length
      .suffix = suffix

V oddRoot = 1

F eertree(s)
   V tree = [Node(0, :oddRoot), Node(-1, :oddRoot)]
   V suffix = :oddRoot
   L(c) s
      V i = L.index
      V n = suffix
      Int k
      L
         k = tree[n].length
         V b = i - k - 1
         I b >= 0 & s[b] == c
            L.break
         n = tree[n].suffix

      I c C tree[n].edges
         suffix = tree[n].edges[c]
         L.continue

      suffix = tree.len
      tree [+]= Node(k + 2)
      tree[n].edges[c] = suffix
      I tree[suffix].length == 1
         tree[suffix].suffix = 0
         L.continue

      L
         n = tree[n].suffix
         V b = i - tree[n].length - 1
         I b >= 0 & s[b] == c
            L.break

      tree[suffix].suffix = tree[n].edges[c]

   R tree

F subPalindromes(tree)
   [String] s

   F children(Int n, String =p) -> N
      L(c, n) @tree[n].edges
         p = c‘’p‘’c
         @s [+]= p
         @children(n, p)

   children(0, ‘’)
   L(c, n) tree[1].edges
      s [+]= c
      children(n, c)

   R s

V tree = eertree(‘eertree’)
print(subPalindromes(tree))
===
class Node
{
public:
    int length;
    int suffix;
    Dict<Char, int> edges;

    template <typename T1, typename T2 = decltype(0)> Node(const T1 &length, const T2 &suffix = 0) :
        length(length),
        suffix(suffix)
    {
    }
};

auto oddRoot = 1;

template <typename T1> auto eertree(const T1 &s)
{
    auto tree = create_array<Node>({Node(0, ::oddRoot), Node(-1, ::oddRoot)});
    auto suffix = ::oddRoot;
    {int Lindex = 0;
    for (auto &&c : s) {{
        auto i = Lindex;
        auto n = suffix;
        int k;
        while (true) {
            k = tree[n].length;
            auto b = i - k - 1;
            if (b >= 0 && s[b] == c)
                break;
            n = tree[n].suffix;
        }

        if (in(c, tree[n].edges)) {
            suffix = tree[n].edges[c];
            goto on_continue;
        }

        suffix = tree.len();
        tree.append(Node(k + 2));
        tree[n].edges.set(c, suffix);
        if (tree[suffix].length == 1) {
            tree[suffix].suffix = 0;
            goto on_continue;
        }

        while (true) {
            n = tree[n].suffix;
            auto b = i - tree[n].length - 1;
            if (b >= 0 && s[b] == c)
                break;
        }

        tree[suffix].suffix = tree[n].edges[c];
} on_continue:
        Lindex++;
    }}

    return tree;
}

template <typename T1> auto subPalindromes(const T1 &tree)
{
    Array<String> s;

    std::function<void(int, String)> children = [&children, &s, &tree](const int n, String p) -> void
    {
        for (auto &&[c, n] : tree[n].edges) {
            p = c & p & c;
            s.append(p);
            children(n, p);
        }
    };

    children(0, u""_S);
    for (auto &&[c, n] : _get<1>(tree).edges) {
        s.append(c);
        children(n, c);
    }

    return s;
}

auto tree = eertree(u"eertree"_S);

struct CodeBlock1
{
    CodeBlock1()
    {
        print(subPalindromes(tree));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Eban_numbers#Nim
def iseban(n):
    if n == 0:
        return False
    (b, r) = divmod(n, 1_000_000_000)
    (m, r) = divmod(r, 1_000_000)
    (t, r) = divmod(r, 1_000)
    m = m % 10 if 30 <= m <= 66 else m
    t = t % 10 if 30 <= t <= 66 else t
    r = r % 10 if 30 <= r <= 66 else r
    return {b, m, t, r} <= {0, 2, 4, 6}

print('eban numbers up to and including 1000:')
for i in range(101):
    if iseban(i):
        print(i, end = ' ')

print("\n\neban numbers between 1000 and 4000 (inclusive):")
for i in range(1000, 4001):
    if iseban(i):
        print(i, end = ' ')

print()
for maxn in (10_000, 100_000, 1_000_000, 10_000_000):
    count = 0
    for i in range(maxn + 1):
        if iseban(i):
            count += 1
    print("\nNumber of eban numbers up to and including %8d: %4d" % (maxn, count))
===
F iseban(n)
   I n == 0
      R 0B
   V (b, r) = divmod(n, 1'000'000'000)
   (V m, r) = divmod(r, 1'000'000)
   (V t, r) = divmod(r, 1'000)
   m = I m C 30..66 {m % 10} E m
   t = I t C 30..66 {t % 10} E t
   r = I r C 30..66 {r % 10} E r
   R Set([b, m, t, r]) <= Set([0, 2, 4, 6])

print(‘eban numbers up to and including 1000:’)
L(i) 101
   I iseban(i)
      print(i, end' ‘ ’)

print("\n\neban numbers between 1000 and 4000 (inclusive):")
L(i) 1000..4000
   I iseban(i)
      print(i, end' ‘ ’)

print()
L(maxn) (10'000, 100'000, 1'000'000, 10'000'000)
   V count = 0
   L(i) 0 .. maxn
      I iseban(i)
         count++
   print("\nNumber of eban numbers up to and including #8: #4".format(maxn, count))
===
template <typename T1> auto iseban(const T1 &n)
{
    if (n == 0)
        return false;
    auto [b, r] = divmod(n, 1'000'000'000);
    TUPLE_ELEMENT_T(0, divmod(r, 1'000'000)) m;
    assign_from_tuple(m, r, divmod(r, 1'000'000));
    TUPLE_ELEMENT_T(0, divmod(r, 1'000)) t;
    assign_from_tuple(t, r, divmod(r, 1'000));
    m = in(m, range_ee(30, 66)) ? mod(m, 10) : m;
    t = in(t, range_ee(30, 66)) ? mod(t, 10) : t;
    r = in(r, range_ee(30, 66)) ? mod(r, 10) : r;
    return create_set({b, m, t, r}) <= create_set({0, 2, 4, 6});
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"eban numbers up to and including 1000:"_S);
        for (int i = 0; i < 101; i++)
            if (iseban(i))
                print(i, u" "_S);

        print(u"\n\neban numbers between 1000 and 4000 (inclusive):"_S);
        for (auto i : range_ee(1000, 4000))
            if (iseban(i))
                print(i, u" "_S);

        print();
        for (auto &&maxn : make_tuple(10'000, 100'000, 1'000'000, 10'000'000)) {
            auto count = 0;
            for (auto i : range_ee(0, maxn))
                if (iseban(i))
                    count++;
            print(u"\nNumber of eban numbers up to and including #8: #4"_S.format(maxn, count));
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Egyptian_division#Python
from itertools import product

def egyptian_divmod(dividend, divisor):
    assert divisor != 0
    (pwrs, dbls) = ([1], [divisor])
    while dbls[-1] <= dividend:
        pwrs.append(pwrs[-1] * 2)
        dbls.append(pwrs[-1] * divisor)
    (ans, accum) = (0, 0)
    for pwr, dbl in zip(pwrs[-2::-1], dbls[-2::-1]):
        if accum + dbl <= dividend:
            accum += dbl
            ans += pwr
    return (ans, abs(accum - dividend))

# Test it gives the same results as the divmod built-in
for i, j in product(range(13), range(1, 13)):
        assert egyptian_divmod(i, j) == divmod(i, j)
# Mandated result
(i, j) = (580, 34)
(d, m) = egyptian_divmod(i, j)
print('%i divided by %i using the Egyption method is %i remainder %i'
      % (i, j, d, m))
===
F egyptian_divmod(dividend, divisor)
   assert(divisor != 0)
   V (pwrs, dbls) = ([1], [divisor])
   L dbls.last <= dividend
      pwrs.append(pwrs.last * 2)
      dbls.append(pwrs.last * divisor)
   V (ans, accum) = (0, 0)
   L(pwr, dbl) zip(pwrs[((len)-2 ..).step(-1)], dbls[((len)-2 ..).step(-1)])
      I accum + dbl <= dividend
         accum += dbl
         ans += pwr
   R (ans, abs(accum - dividend))

L(i, j) cart_product(0.<13, 1..12)
   assert(egyptian_divmod(i, j) == divmod(i, j))
V (i, j) = (580, 34)
V (d, m) = egyptian_divmod(i, j)
print(‘#. divided by #. using the Egyption method is #. remainder #.’.format(i, j, d, m))
===
template <typename T1, typename T2> auto egyptian_divmod(const T1 &dividend, const T2 &divisor)
{
    assert(divisor != 0);
    auto [pwrs, dbls] = make_tuple(create_array({1}), create_array({divisor}));
    while (dbls.last() <= dividend) {
        pwrs.append(pwrs.last() * 2);
        dbls.append(pwrs.last() * divisor);
    }
    auto [ans, accum] = make_tuple(0, 0);
    for (auto &&[pwr, dbl] : zip(pwrs[range_elen_i( - 2).step(-1)], dbls[range_elen_i( - 2).step(-1)]))
        if (accum + dbl <= dividend) {
            accum += dbl;
            ans += pwr;
        }
    return make_tuple(ans, abs(accum - dividend));
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&[i, j] : cart_product(range_el(0, 13), range_ee(1, 12)))
            assert(egyptian_divmod(i, j) == divmod(i, j));
    }
} code_block_1;

auto [i, j] = make_tuple(580, 34);
auto [d, m] = egyptian_divmod(i, j);

struct CodeBlock2
{
    CodeBlock2()
    {
        print(u"#. divided by #. using the Egyption method is #. remainder #."_S.format(i, j, d, m));
    }
} code_block_2;


# https://www.rosettacode.org/wiki/EKG_sequence_convergence#Nim
from typing import List
import math

def ekg(n, limit):
    values = set() # int
    assert n >= 2
    r = [(1, 1), (2, n)]
    values.add(n)
    i = 3
    prev = n
    while i <= limit:
        val = 2
        while True:
            if val not in values and math.gcd(val, prev) != 1:
                values.add(val)
                r += [(i, val)]
                prev = val
                break
            val += 1
        i += 1
    return r

for n in [2, 5, 7, 9, 10]:
    result : List[int] = []
    for i, val in ekg(n, 10):
        result += [val]
    print(('EKG(' + str(n) + '):').ljust(8), ', '.join(map(str, result)))

ekg5 = [0] * 101
ekg7 = [0] * 101
for i, val in ekg(5, 100): ekg5[i] = val
for i, val in ekg(7, 100): ekg7[i] = val
convIndex = 0
for i in range(2, 101):
    if ekg5[i] == ekg7[i] and sorted(ekg5[1:i]) == sorted(ekg7[1:i]):
        convIndex = i
        break
print('EKG(5) and EKG(7) converge at index ' + str(convIndex) + '.')
===
F ekg(n, limit)
   V values = Set[Int]()
   assert(n >= 2)
   V r = [(1, 1), (2, n)]
   values.add(n)
   V i = 3
   V prev = n
   L i <= limit
      V val = 2
      L
         I val !C values & gcd(val, prev) != 1
            values.add(val)
            r [+]= (i, val)
            prev = val
            L.break
         val++
      i++
   R r

L(n) [2, 5, 7, 9, 10]
   [Int] result
   L(i, val) ekg(n, 10)
      result [+]= val
   print((‘EKG(’String(n)‘):’).ljust(8)‘ ’result.map(String).join(‘, ’))

V ekg5 = [0] * 101
V ekg7 = [0] * 101
L(i, val) ekg(5, 100)
   ekg5[i] = val
L(i, val) ekg(7, 100)
   ekg7[i] = val
V convIndex = 0
L(i) 2..100
   I ekg5[i] == ekg7[i] & sorted(ekg5[1 .< i]) == sorted(ekg7[1 .< i])
      convIndex = i
      L.break
print(‘EKG(5) and EKG(7) converge at index ’String(convIndex)‘.’)
===
template <typename T1, typename T2> auto ekg(const T1 &n, const T2 &limit)
{
    auto values = Set<int>();
    assert(n >= 2);
    auto r = create_array({make_tuple(1, 1), make_tuple(2, n)});
    values.add(n);
    auto i = 3;
    auto prev = n;
    while (i <= limit) {
        auto val = 2;
        while (true) {
            if (!in(val, values) && gcd(val, prev) != 1) {
                values.add(val);
                r.append(make_tuple(i, val));
                prev = val;
                break;
            }
            val++;
        }
        i++;
    }
    return r;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&n : create_array({2, 5, 7, 9, 10})) {
            Array<int> result;
            for (auto &&[i, val] : ekg(n, 10))
                result.append(val);
            print((u"EKG("_S & String(n) & u"):"_S).ljust(8) & u" "_S & result.map([](const auto &x){return String(x);}).join(u", "_S));
        }
    }
} code_block_1;

auto ekg5 = create_array({0}) * 101;
auto ekg7 = create_array({0}) * 101;

struct CodeBlock2
{
    CodeBlock2()
    {
        for (auto &&[i, val] : ekg(5, 100))
            ekg5.set(i, val);
        for (auto &&[i, val] : ekg(7, 100))
            ekg7.set(i, val);
    }
} code_block_2;

auto convIndex = 0;

struct CodeBlock3
{
    CodeBlock3()
    {
        for (auto i : range_ee(2, 100))
            if (ekg5[i] == ekg7[i] && sorted(ekg5[range_el(1, i)]) == sorted(ekg7[range_el(1, i)])) {
                convIndex = i;
                break;
            }
        print(u"EKG(5) and EKG(7) converge at index "_S & String(convIndex) & u"."_S);
    }
} code_block_3;


# https://www.rosettacode.org/wiki/Elementary_cellular_automaton#Nim
SIZE  = 32
LINES = SIZE // 2
RULE  = 90

def ruleTest(x):
    return 1 if RULE & (1 << (7 & x)) != 0 else 0

def bitVal(s, bit):
    return 1 if (s >> bit) & 1 != 0 else 0
   #return 1 if s & (1 << bit) != 0 else 0

def evolve(s):
    t = 0
    t |= ruleTest((bitVal(s, 0) << 2) | (bitVal(s, SIZE-1) << 1) | bitVal(s, SIZE-2)) << (SIZE-1)
    t |= ruleTest((bitVal(s, 1) << 2) | (bitVal(s, 0)      << 1) | bitVal(s, SIZE-1))
    for i in range(1, SIZE-1):
        t |= ruleTest((bitVal(s, i+1) << 2) | (bitVal(s, i) << 1) | bitVal(s, i-1)) << i
    return t

def show(state):
    for i in range(SIZE-1, -1, -1):
        print(' *'[bitVal(state, i)], end = '')
    print()

state = 1 << LINES
print('Rule', RULE)
for _ in range(LINES):
    show(state)
    state = evolve(state)
===
V SIZE = 32
V LINES = SIZE I/ 2
V RULE = 90

F ruleTest(x)
   R I :RULE [&] (1 << (7 [&] x)) != 0 {1} E 0

F bitVal(s, bit)
   R I (s >> bit) [&] 1 != 0 {1} E 0

F evolve(s)
   V t = 0
   t [|]= ruleTest((bitVal(s, 0) << 2) [|] (bitVal(s, :SIZE - 1) << 1) [|] bitVal(s, :SIZE - 2)) << (:SIZE - 1)
   t [|]= ruleTest((bitVal(s, 1) << 2) [|] (bitVal(s, 0) << 1) [|] bitVal(s, :SIZE - 1))
   L(i) 1 .< :SIZE - 1
      t [|]= ruleTest((bitVal(s, i + 1) << 2) [|] (bitVal(s, i) << 1) [|] bitVal(s, i - 1)) << i
   R t

F show(state)
   L(i) (:SIZE - 1 .< -1).step(-1)
      print(‘ *’[bitVal(state, i)], end' ‘’)
   print()

V state = 1 << LINES
print(‘Rule ’RULE)
L(_) 0 .< LINES
   show(state)
   state = evolve(state)
===
auto _SIZE_ = 32;
auto LINES = idiv(_SIZE_, 2);
auto RULE = 90;

template <typename T1> auto ruleTest(const T1 &x)
{
    return (::RULE & (1 << (7 & x))) != 0 ? 1 : 0;
}

template <typename T1, typename T2> auto bitVal(const T1 &s, const T2 &bit)
{
    return ((s >> bit) & 1) != 0 ? 1 : 0;
}

template <typename T1> auto evolve(const T1 &s)
{
    auto t = 0;
    t |= ruleTest((bitVal(s, 0) << 2) | (bitVal(s, ::_SIZE_ - 1) << 1) | bitVal(s, ::_SIZE_ - 2)) << (::_SIZE_ - 1);
    t |= ruleTest((bitVal(s, 1) << 2) | (bitVal(s, 0) << 1) | bitVal(s, ::_SIZE_ - 1));
    for (auto i : range_el(1, ::_SIZE_ - 1))
        t |= ruleTest((bitVal(s, i + 1) << 2) | (bitVal(s, i) << 1) | bitVal(s, i - 1)) << i;
    return t;
}

template <typename T1> auto show(const T1 &state)
{
    for (auto i : range_el(::_SIZE_ - 1, -1).step(-1))
        print(u" *"_S[bitVal(state, i)], u""_S);
    print();
}

auto state = 1 << LINES;

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"Rule "_S & RULE);
        for (auto _ : range_el(0, LINES)) {
            show(state);
            state = evolve(state);
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Elementary_cellular_automaton/Infinite_length#Nim
def step(cells, rule):
    result = ''
    for i in range(len(cells) - 2):
        bin = 0
        b = 2
        for n in range(i, i + 3):
            bin += int(cells[n] == '*') << b
            b >>= 1
        a = '*' if (rule & (1 << bin)) != 0 else '.'
        result += a
    return result

def addNoCells(cells : str):
    left  = '.' if cells[0]  == '*' else '*'
    right = '.' if cells[-1] == '*' else '*'
    cells = left + cells + right
    cells = left + cells + right
    return cells

def evolve(limit, rule):
    print('Rule #', rule, sep = '')
    cells = '*'
    for _ in range(limit):
        cells = addNoCells(cells)
        width = 40 + (len(cells) >> 1)
        print(cells.rjust(width))
        cells = step(cells, rule)

evolve(35, 90)
===
F step(cells, rule)
   V result = ‘’
   L(i) 0 .< cells.len - 2
      V bin = 0
      V b = 2
      L(n) i .< i + 3
         bin += Int(cells[n] == ‘*’) << b
         b >>= 1
      V a = I (rule [&] (1 << bin)) != 0 {‘*’} E ‘.’
      result ‘’= a
   R result

F addNoCells(String =cells)
   V left = I cells[0] == ‘*’ {‘.’} E ‘*’
   V right = I cells.last == ‘*’ {‘.’} E ‘*’
   cells = left‘’cells‘’right
   cells = left‘’cells‘’right
   R cells

F evolve(limit, rule)
   print(‘Rule #’rule)
   V cells = ‘*’
   L(_) 0 .< limit
      cells = addNoCells(cells)
      V width = 40 + (cells.len >> 1)
      print(cells.rjust(width))
      cells = step(cells, rule)

evolve(35, 90)
===
template <typename T1, typename T2> auto step(const T1 &cells, const T2 &rule)
{
    auto result = u""_S;
    for (auto i : range_el(0, cells.len() - 2)) {
        auto bin = 0;
        auto b = 2;
        for (auto n : range_el(i, i + 3)) {
            bin += to_int(cells[n] == u'*') << b;
            b >>= 1;
        }
        auto a = (rule & (1 << bin)) != 0 ? u'*'_C : u'.'_C;
        result &= a;
    }
    return result;
}

auto addNoCells(String cells)
{
    auto left = _get<0>(cells) == u'*' ? u'.'_C : u'*'_C;
    auto right = cells.last() == u'*' ? u'.'_C : u'*'_C;
    cells = left & cells & right;
    cells = left & cells & right;
    return cells;
}

template <typename T1, typename T2> auto evolve(const T1 &limit, const T2 &rule)
{
    print(u"Rule #"_S & rule);
    auto cells = u"*"_S;
    for (auto _ : range_el(0, limit)) {
        cells = addNoCells(cells);
        auto width = 40 + (cells.len() >> 1);
        print(cells.rjust(width));
        cells = step(cells, rule);
    }
}

struct CodeBlock1
{
    CodeBlock1()
    {
        evolve(35, 90);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Elementary_cellular_automaton/Random_Number_Generator#Nim
UInt64 = int

n = 64

def pow2(x):
    return UInt64(1) << x

def evolve(state : UInt64, rule):
    for _ in range(10):
        b = UInt64(0)
        for q in range(7, -1, -1):
            st = state
            b |= (st & 1) << q
            state = 0
            for i in range(n):
                t = ((st >> (i - 1) % 64) | (st << (n + 1 - i) % 64)) & 7
                if (rule & pow2(t)) != 0:
                    state |= pow2(i)
        print('', b, end = '')
    print()

evolve(1, 30)
===
V n = 64

F pow2(x)
   R UInt64(1) << x

F evolve(UInt64 =state; rule)
   L(_) 10
      V b = UInt64(0)
      L(q) (7 .< -1).step(-1)
         V st = state
         b [|]= (st [&] 1) << q
         state = 0
         L(i) 0 .< :n
            V t = ((st >> (i - 1) % 64) [|] (st << (:n + 1 - i) % 64)) [&] 7
            I (rule [&] pow2(t)) != 0
               state [|]= pow2(i)
      print(‘ ’b, end' ‘’)
   print()

evolve(1, 30)
===
auto n = 64;

template <typename T1> auto pow2(const T1 &x)
{
    return to_uint64(1) << x;
}

template <typename T2> auto evolve(UInt64 state, const T2 &rule)
{
    for (int _ = 0; _ < 10; _++) {
        auto b = to_uint64(0);
        for (auto q : range_el(7, -1).step(-1)) {
            auto st = state;
            b |= (st & 1) << q;
            state = 0;
            for (auto i : range_el(0, ::n)) {
                auto t = ((st >> mod((i - 1), 64)) | (st << mod((::n + 1 - i), 64))) & 7;
                if ((rule & pow2(t)) != 0)
                    state |= pow2(i);
            }
        }
        print(u" "_S & b, u""_S);
    }
    print();
}

struct CodeBlock1
{
    CodeBlock1()
    {
        evolve(1, 30);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Elliptic_curve_arithmetic#Python
class Point:
    x : float
    y : float
    def __init__(self, x=float('inf'), y=float('inf')):
        self.x = x
        self.y = y

    def copy(self): # const
        return Point(self.x, self.y)

    def is_zero(self): # const
        return self.x > 1e20 or self.x < -1e20

    def neg(self):
        return Point(self.x, -self.y)

    def dbl(self):
        if self.is_zero():
            return self.copy()
        if self.y == 0:
            return Point()
        l = (3 * self.x * self.x) / (2 * self.y)
        x = l * l - 2 * self.x
        return Point(x, l * (self.x - x) - self.y)

    def add(self, q):
        if self.x == q.x and self.y == q.y:
            return self.dbl()
        if self.is_zero():
            return q.copy()
        if q.is_zero():
            return self.copy()
        if q.x - self.x == 0:
            return Point()
        l = (q.y - self.y) / (q.x - self.x)
        x = l * l - self.x - q.x
        return Point(x, l * (self.x - x) - self.y)

    def mul(self, n):
        p = self.copy()
        r = Point()
        i = 1
        while i <= n:
            if i&n:
                r = r.add(p)
            p = p.dbl()
            i <<= 1
        return r

    def __str__(self):
        return "({:.3f}, {:.3f})".format(self.x, self.y)

Point_b = 7

def show(s, p):
    print(s, "Zero" if p.is_zero() else p)

def from_y(y):
    n = y * y - Point_b
    x = n**(1./3) if n>=0 else -((-n)**(1./3))
    return Point(x, y)

# demonstrate
a = from_y(1)
b = from_y(2)
show("a =", a)
show("b =", b)
c = a.add(b)
show("c = a + b =", c)
d = c.neg()
show("d = -c =", d)
show("c + d =", c.add(d))
show("a + b + d =", a.add(b.add(d)))
show("a * 12345 =", a.mul(12345))
===
T Point
   Float x
   Float y
   F (x = Float.infinity, y = Float.infinity)
      .x = x
      .y = y

   F.const copy()
      R Point(.x, .y)

   F.const is_zero()
      R .x > 1e20 | .x < -1e20

   F neg()
      R Point(.x, -.y)

   F dbl()
      I .is_zero()
         R .copy()
      I .y == 0
         R Point()
      V l = (3 * .x * .x) / (2 * .y)
      V x = l * l - 2 * .x
      R Point(x, l * (.x - x) - .y)

   F add(q)
      I .x == q.x & .y == q.y
         R .dbl()
      I .is_zero()
         R q.copy()
      I q.is_zero()
         R .copy()
      I q.x - .x == 0
         R Point()
      V l = (q.y - .y) / (q.x - .x)
      V x = l * l - .x - q.x
      R Point(x, l * (.x - x) - .y)

   F mul(n)
      V p = .copy()
      V r = Point()
      V i = 1
      L i <= n
         I i [&] n
            r = r.add(p)
         p = p.dbl()
         i <<= 1
      R r

   F String()
      R ‘(#.3, #.3)’.format(.x, .y)

V Point_b = 7

F show(s, p)
   print(s‘ ’(I p.is_zero() {‘Zero’} E p))

F from_y(y)
   V n = y * y - Point_b
   V x = I n >= 0 {n ^ (1. / 3)} E -((-n) ^ (1. / 3))
   R Point(x, y)

V a = from_y(1)
V b = from_y(2)
show(‘a =’, a)
show(‘b =’, b)
V c = a.add(b)
show(‘c = a + b =’, c)
V d = c.neg()
show(‘d = -c =’, d)
show(‘c + d =’, c.add(d))
show(‘a + b + d =’, a.add(b.add(d)))
show(‘a * 12345 =’, a.mul(12345))
===
class Point
{
public:
    double x;
    double y;
    template <typename T1 = decltype(std::numeric_limits<double>::infinity()), typename T2 = decltype(std::numeric_limits<double>::infinity())> Point(const T1 &x = std::numeric_limits<double>::infinity(), const T2 &y = std::numeric_limits<double>::infinity()) :
        x(x),
        y(y)
    {
    }

    auto copy() const
    {
        return Point(x, y);
    }

    auto is_zero() const
    {
        return x > 1e20 || x < -1e20;
    }

    auto neg()
    {
        return Point(x, -y);
    }

    auto dbl()
    {
        if (is_zero())
            return copy();
        if (y == 0)
            return Point();
        auto l = (3 * this->x * this->x) / (2 * y);
        auto x = l * l - 2 * this->x;
        return Point(x, l * (this->x - x) - y);
    }

    template <typename T1> auto add(const T1 &q)
    {
        if (this->x == q.x && y == q.y)
            return dbl();
        if (is_zero())
            return q.copy();
        if (q.is_zero())
            return copy();
        if (q.x - this->x == 0)
            return Point();
        auto l = (q.y - y) / (q.x - this->x);
        auto x = l * l - this->x - q.x;
        return Point(x, l * (this->x - x) - y);
    }

    template <typename T1> auto mul(const T1 &n)
    {
        auto p = copy();
        auto r = Point();
        auto i = 1;
        while (i <= n) {
            if (i & n)
                r = r.add(p);
            p = p.dbl();
            i <<= 1;
        }
        return r;
    }

    operator String() const
    {
        return u"(#.3, #.3)"_S.format(x, y);
    }
};

auto Point_b = 7;

template <typename T1, typename T2> auto show(const T1 &s, const T2 &p)
{
    print(s & u" "_S & (p.is_zero() ? u"Zero"_S : p));
}

template <typename T1> auto from_y(const T1 &y)
{
    auto n = y * y - Point_b;
    auto x = n >= 0 ? pow(n, (1. / 3.0)) : -(pow((-n), (1. / 3.0)));
    return Point(x, y);
}

auto a = from_y(1);
auto b = from_y(2);

struct CodeBlock1
{
    CodeBlock1()
    {
        show(u"a ="_S, a);
        show(u"b ="_S, b);
    }
} code_block_1;

auto c = a.add(b);

struct CodeBlock2
{
    CodeBlock2()
    {
        show(u"c = a + b ="_S, c);
    }
} code_block_2;

auto d = c.neg();

struct CodeBlock3
{
    CodeBlock3()
    {
        show(u"d = -c ="_S, d);
        show(u"c + d ="_S, c.add(d));
        show(u"a + b + d ="_S, a.add(b.add(d)));
        show(u"a * 12345 ="_S, a.mul(12345));
    }
} code_block_3;


# https://www.rosettacode.org/wiki/Emirp_primes#Nim
def reversed(n : int):
    result = 0
    while True:
        result = 10 * result + n % 10
        n //= 10
        if n == 0:
            return result

limit = 1_000_000
is_prime = [False] * 2 + [True] * (limit - 1)
for n in range(int(limit**0.5 + 1.5)): # stop at ``sqrt(limit)``
    if is_prime[n]:
        for i in range(n*n, limit+1, n):
            is_prime[i] = False

def is_emirp(n):
    if not is_prime[n]:
        return False
    r = reversed(n)
    return r != n and is_prime[r]

print('First 20 emirps:', end = '')
count = 0
for n in range(limit):
    if is_emirp(n):
        print('', n, end = '')
        count += 1
        if count == 20:
            break
print()

print('Emirps between 7700 and 8000:', end = '')
for n in range(7700, 8001):
    if is_emirp(n):
        print('', n, end = '')
print()

count = 0
for n in range(limit):
    if is_emirp(n):
        count += 1
        if count == 10000:
            print('The 10000th emirp:', n)
            break
===
F reversed(Int =n)
   V result = 0
   L
      result = 10 * result + n % 10
      n I/= 10
      I n == 0
         R result

V limit = 1'000'000
V is_prime = [0B] * 2 [+] [1B] * (limit - 1)
L(n) 0 .< Int(limit ^ 0.5 + 1.5)
   I is_prime[n]
      L(i) (n * n .. limit).step(n)
         is_prime[i] = 0B

F is_emirp(n)
   I !:is_prime[n]
      R 0B
   V r = reversed(n)
   R r != n & :is_prime[r]

print(‘First 20 emirps:’, end' ‘’)
V count = 0
L(n) 0 .< limit
   I is_emirp(n)
      print(‘ ’n, end' ‘’)
      count++
      I count == 20
         L.break
print()

print(‘Emirps between 7700 and 8000:’, end' ‘’)
L(n) 7700..8000
   I is_emirp(n)
      print(‘ ’n, end' ‘’)
print()

count = 0
L(n) 0 .< limit
   I is_emirp(n)
      count++
      I count == 10000
         print(‘The 10000th emirp: ’n)
         L.break
===
auto reversed(int n)
{
    auto result = 0;
    while (true) {
        result = 10 * result + mod(n, 10);
        n = idiv(n, 10);
        if (n == 0)
            return result;
    }
}

auto limit = 1'000'000;
auto is_prime = create_array({false}) * 2 + create_array({true}) * (limit - 1);

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto n : range_el(0, to_int(pow(limit, 0.5) + 1.5)))
            if (is_prime[n])
                for (auto i : range_ee(n * n, limit).step(n))
                    is_prime.set(i, false);
    }
} code_block_1;

template <typename T1> auto is_emirp(const T1 &n)
{
    if (!::is_prime[n])
        return false;
    auto r = reversed(n);
    return r != n && ::is_prime[r];
}

struct CodeBlock2
{
    CodeBlock2()
    {
        print(u"First 20 emirps:"_S, u""_S);
    }
} code_block_2;

auto count = 0;

struct CodeBlock3
{
    CodeBlock3()
    {
        for (auto n : range_el(0, limit))
            if (is_emirp(n)) {
                print(u" "_S & n, u""_S);
                count++;
                if (count == 20)
                    break;
            }
        print();

        print(u"Emirps between 7700 and 8000:"_S, u""_S);
        for (auto n : range_ee(7700, 8000))
            if (is_emirp(n))
                print(u" "_S & n, u""_S);
        print();

        count = 0;
        for (auto n : range_el(0, limit))
            if (is_emirp(n)) {
                count++;
                if (count == 10000) {
                    print(u"The 10000th emirp: "_S & n);
                    break;
                }
            }
    }
} code_block_3;


# https://www.rosettacode.org/wiki/Evolutionary_algorithm#Python
import random

target  = list("METHINKS IT IS LIKE A WEASEL")
alphabet = " ABCDEFGHIJLKLMNOPQRSTUVWXYZ"
p = 0.05 # mutation probability
c = 100  # number of children in each generation

def neg_fitness(trial):
    return sum(int(t != h) for t,h in list(zip(trial, target)))

def mutate(parent):
    return [(random.choice(alphabet) if random.random() < p else ch) for ch in parent]

parent = [random.choice(alphabet) for _ in range(len(target))]
i = 0
print("%3d" % i, "".join(parent))
while parent != target:
    copies = (mutate(parent) for _ in range(c))
    parent = min(copies, key=lambda x:neg_fitness(x))
    print("%3d" % i, "".join(parent))
    i += 1
===
V target = Array(‘METHINKS IT IS LIKE A WEASEL’)
V alphabet = ‘ ABCDEFGHIJLKLMNOPQRSTUVWXYZ’
V p = 0.05
V c = 100

F neg_fitness(trial)
   R sum(zip(trial, :target).map((t, h) -> Int(t != h)))

F mutate(parent)
   R parent.map(ch -> (I random:() < :p {random:choice(:alphabet)} E ch))

V parent = (0 .< target.len).map(_ -> random:choice(:alphabet))
V i = 0
print((‘#3’.format(i))‘ ’parent.join(‘’))
L parent != target
   V copies = ((0 .< c).map(_ -> mutate(:parent)))
   parent = min(copies, key' x -> neg_fitness(x))
   print((‘#3’.format(i))‘ ’parent.join(‘’))
   i++
===
auto target = create_array(u"METHINKS IT IS LIKE A WEASEL"_S);
auto alphabet = u" ABCDEFGHIJLKLMNOPQRSTUVWXYZ"_S;
auto p = 0.05;
auto c = 100;

template <typename T1> auto neg_fitness(const T1 &trial)
{
    return sum_map(zip(trial, ::target), [](const auto &t, const auto &h){return to_int(t != h);});
}

template <typename T1> auto mutate(const T1 &parent)
{
    return parent.map([](const auto &ch){return (randomns::_() < ::p ? randomns::choice(::alphabet) : ch);});
}

auto parent = range_el(0, target.len()).map([](const auto &_){return randomns::choice(::alphabet);});
auto i = 0;

struct CodeBlock1
{
    CodeBlock1()
    {
        print((u"#3"_S.format(i)) & u" "_S & parent.join(u""_S));
        while (parent != target) {
            auto copies = (range_el(0, c).map([](const auto &_){return mutate(::parent);}));
            parent = min_with_key(copies, [](const auto &x){return neg_fitness(x);});
            print((u"#3"_S.format(i)) & u" "_S & parent.join(u""_S));
            i++;
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Execute_a_Markov_algorithm#Nim
from typing import NamedTuple

class Rule(NamedTuple):
    pattern : str
    replacement : str
    terminating : bool

def parse(rules):
    result : List[Rule] = []
    for line in rules.split("\n"):
        if line.startswith('#'): continue
        if len(line.strip(' ')) == 0: continue

        (pat, rep) = line.split(' -> ')

        terminating = False
        if rep.startswith('.'):
            rep = rep[1:]
            terminating = True

        result.append(Rule(pat, rep, terminating))
    return result

def apply(text, rules):
    result = text
    changed = True

    while changed == True:
        changed = False
        for rule in rules:
            if rule.pattern in result:
                result = result.replace(rule.pattern, rule.replacement)
                if rule.terminating: return result
                changed = True
                break

    return result

SampleTexts = ["I bought a B of As from T S.",
               "I bought a B of As from T S.",
               "I bought a B of As W my Bgage from T S.",
               "_1111*11111_",
               "000000A000000"]

RuleSets = [

#................................................

"""# This rules file is extracted from Wikipedia:
# http://en.wikipedia.org/wiki/Markov_Algorithm
A -> apple
B -> bag
S -> shop
T -> the
the shop -> my brother
a never used -> .terminating rule""",

#................................................

"""# Slightly modified from the rules on Wikipedia
A -> apple
B -> bag
S -> .shop
T -> the
the shop -> my brother
a never used -> .terminating rule""",

#................................................

"""# BNF Syntax testing rules
A -> apple
WWWW -> with
Bgage -> ->.*
B -> bag
->.* -> money
W -> WW
S -> .shop
T -> the
the shop -> my brother
a never used -> .terminating rule""",

#................................................

"""### Unary Multiplication Engine, for testing Markov Algorithm implementations
### By Donal Fellows.
# Unary addition engine
_+1 -> _1+
1+1 -> 11+
# Pass for converting from the splitting of multiplication into ordinary
# addition
1! -> !1
,! -> !+
_! -> _
# Unary multiplication by duplicating left side, right side times
1*1 -> x,@y
1x -> xX
X, -> 1,1
X1 -> 1X
_x -> _X
,x -> ,X
y1 -> 1y
y_ -> _
# Next phase of applying
1@1 -> x,@y
1@_ -> @_
,@_ -> !_
++ -> +
# Termination cleanup for addition
_1 -> 1
1+_ -> 1
_+_ -> """,

#................................................

"""# Turing machine: three-state busy beaver
#
# state A, symbol 0 => write 1, move right, new state B
A0 -> 1B
# state A, symbol 1 => write 1, move left, new state C
0A1 -> C01
1A1 -> C11
# state B, symbol 0 => write 1, move left, new state A
0B0 -> A01
1B0 -> A11
# state B, symbol 1 => write 1, move right, new state B
B1 -> 1B
# state C, symbol 0 => write 1, move left, new state B
0C0 -> B01
1C0 -> B11
# state C, symbol 1 => write 1, move left, halt
0C1 -> H01
1C1 -> H11"""

]

for n, ruleset in enumerate(RuleSets):
    rules = parse(ruleset)
    print(apply(SampleTexts[n], rules))
===
T Rule
   String pattern
   String replacement
   Bool terminating
   F (pattern, replacement, terminating)
      .pattern = pattern
      .replacement = replacement
      .terminating = terminating

F parse(rules)
   [Rule] result
   L(line) rules.split("\n")
      I line.starts_with(‘#’)
         L.continue
      I line.trim(‘ ’).empty
         L.continue

      V (pat, rep) = line.split(‘ -> ’)

      V terminating = 0B
      I rep.starts_with(‘.’)
         rep = rep[1..]
         terminating = 1B

      result.append(Rule(pat, rep, terminating))
   R result

F apply(text, rules)
   V result = text
   V changed = 1B

   L changed == 1B
      changed = 0B
      L(rule) rules
         I rule.pattern C result
            result = result.replace(rule.pattern, rule.replacement)
            I rule.terminating
               R result
            changed = 1B
            L.break

   R result

V SampleTexts = [‘I bought a B of As from T S.’, ‘I bought a B of As from T S.’, ‘I bought a B of As W my Bgage from T S.’, ‘_1111*11111_’, ‘000000A000000’]

V RuleSets = [‘# This rules file is extracted from Wikipedia:
# http://en.wikipedia.org/wiki/Markov_Algorithm
A -> apple
B -> bag
S -> shop
T -> the
the shop -> my brother
a never used -> .terminating rule’, ‘# Slightly modified from the rules on Wikipedia
A -> apple
B -> bag
S -> .shop
T -> the
the shop -> my brother
a never used -> .terminating rule’, ‘# BNF Syntax testing rules
A -> apple
WWWW -> with
Bgage -> ->.*
B -> bag
->.* -> money
W -> WW
S -> .shop
T -> the
the shop -> my brother
a never used -> .terminating rule’, ‘### Unary Multiplication Engine, for testing Markov Algorithm implementations
### By Donal Fellows.
# Unary addition engine
_+1 -> _1+
1+1 -> 11+
# Pass for converting from the splitting of multiplication into ordinary
# addition
1! -> !1
,! -> !+
_! -> _
# Unary multiplication by duplicating left side, right side times
1*1 -> x,@y
1x -> xX
X, -> 1,1
X1 -> 1X
_x -> _X
,x -> ,X
y1 -> 1y
y_ -> _
# Next phase of applying
1@1 -> x,@y
1@_ -> @_
,@_ -> !_
++ -> +
# Termination cleanup for addition
_1 -> 1
1+_ -> 1
_+_ -> ’, ‘# Turing machine: three-state busy beaver
#
# state A, symbol 0 => write 1, move right, new state B
A0 -> 1B
# state A, symbol 1 => write 1, move left, new state C
0A1 -> C01
1A1 -> C11
# state B, symbol 0 => write 1, move left, new state A
0B0 -> A01
1B0 -> A11
# state B, symbol 1 => write 1, move right, new state B
B1 -> 1B
# state C, symbol 0 => write 1, move left, new state B
0C0 -> B01
1C0 -> B11
# state C, symbol 1 => write 1, move left, halt
0C1 -> H01
1C1 -> H11’]

L(ruleset) RuleSets
   V n = L.index
   V rules = parse(ruleset)
   print(apply(SampleTexts[n], rules))
===
class Rule
{
public:
    String pattern;
    String replacement;
    bool terminating;
    template <typename T1, typename T2, typename T3> Rule(const T1 &pattern, const T2 &replacement, const T3 &terminating) :
        pattern(pattern),
        replacement(replacement),
        terminating(terminating)
    {
    }
};

template <typename T1> auto parse(const T1 &rules)
{
    Array<Rule> result;
    for (auto &&line : rules.split(u"\n"_S)) {
        if (line.starts_with(u"#"_S))
            continue;
        if (line.trim(u" "_S).empty())
            continue;

        auto [pat, rep] = bind_array<2>(line.split(u" -> "_S));

        auto terminating = false;
        if (rep.starts_with(u"."_S)) {
            rep = rep[range_ei(1)];
            terminating = true;
        }

        result.append(Rule(pat, rep, terminating));
    }
    return result;
}

template <typename T1, typename T2> auto _apply_(const T1 &text, const T2 &rules)
{
    auto result = text;
    auto changed = true;

    while (changed == true) {
        changed = false;
        for (auto &&rule : rules)
            if (in(rule.pattern, result)) {
                result = result.replace(rule.pattern, rule.replacement);
                if (rule.terminating)
                    return result;
                changed = true;
                break;
            }
    }

    return result;
}

auto SampleTexts = create_array({u"I bought a B of As from T S."_S, u"I bought a B of As from T S."_S, u"I bought a B of As W my Bgage from T S."_S, u"_1111*11111_"_S, u"000000A000000"_S});

auto RuleSets = create_array({uR"(# This rules file is extracted from Wikipedia:
# http://en.wikipedia.org/wiki/Markov_Algorithm
A -> apple
B -> bag
S -> shop
T -> the
the shop -> my brother
a never used -> .terminating rule)"_S, uR"(# Slightly modified from the rules on Wikipedia
A -> apple
B -> bag
S -> .shop
T -> the
the shop -> my brother
a never used -> .terminating rule)"_S, uR"(# BNF Syntax testing rules
A -> apple
WWWW -> with
Bgage -> ->.*
B -> bag
->.* -> money
W -> WW
S -> .shop
T -> the
the shop -> my brother
a never used -> .terminating rule)"_S, uR"(### Unary Multiplication Engine, for testing Markov Algorithm implementations
### By Donal Fellows.
# Unary addition engine
_+1 -> _1+
1+1 -> 11+
# Pass for converting from the splitting of multiplication into ordinary
# addition
1! -> !1
,! -> !+
_! -> _
# Unary multiplication by duplicating left side, right side times
1*1 -> x,@y
1x -> xX
X, -> 1,1
X1 -> 1X
_x -> _X
,x -> ,X
y1 -> 1y
y_ -> _
# Next phase of applying
1@1 -> x,@y
1@_ -> @_
,@_ -> !_
++ -> +
# Termination cleanup for addition
_1 -> 1
1+_ -> 1
_+_ -> )"_S, uR"(# Turing machine: three-state busy beaver
#
# state A, symbol 0 => write 1, move right, new state B
A0 -> 1B
# state A, symbol 1 => write 1, move left, new state C
0A1 -> C01
1A1 -> C11
# state B, symbol 0 => write 1, move left, new state A
0B0 -> A01
1B0 -> A11
# state B, symbol 1 => write 1, move right, new state B
B1 -> 1B
# state C, symbol 0 => write 1, move left, new state B
0C0 -> B01
1C0 -> B11
# state C, symbol 1 => write 1, move left, halt
0C1 -> H01
1C1 -> H11)"_S});

struct CodeBlock1
{
    CodeBlock1()
    {
        {int Lindex = 0;

        for (auto &&ruleset : RuleSets) {
            auto n = Lindex;
            auto rules = parse(ruleset);
            print(_apply_(SampleTexts[n], rules));
            Lindex++;
        }}
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Execute_CopyPasta_Language#Python
import sys

if __name__ == '__main__':
    # get a filename from the command line and read the file in
    source = open(sys.argv[1]).read()

    # convert the source to lines of code
    lines = source.split("\n")

    # a variable to represent the 'clipboard'
    clipboard = ""

    # loop over the lines that were read
    loc = 0
    while loc < len(lines):
        # check which command is on this line
        command = lines[loc].strip(' ')

        try:
            if(command == "Copy"):
                clipboard += lines[loc + 1]
            elif(command == "CopyFile"):
                if(lines[loc + 1] == "TheF*ckingCode"):
                    clipboard += source
                else:
                    filetext = open(lines[loc+1]).read()
                    clipboard += filetext
            elif(command == "Duplicate"):
                clipboard += clipboard * ((int(lines[loc + 1])) - 1)
            elif(command == "Pasta!"):
                print(clipboard)
                break
            else:
                sys.exit("unknown command '" + command + "' encountered on line " + str(loc + 1))
        except:
            sys.exit("error while executing command '" + command + "' on line " + str(loc + 1))

        # increment past the command and the next line
        loc += 2
===
:start:
V source = File(:argv[1]).read()

V lines = source.split("\n")

V clipboard = ‘’

V loc = 0
L loc < lines.len
   V command = lines[loc].trim(‘ ’)

   X.try
      I (command == ‘Copy’)
         clipboard ‘’= lines[loc + 1]
      E I (command == ‘CopyFile’)
         I (lines[loc + 1] == ‘TheF*ckingCode’)
            clipboard ‘’= source
         E
            V filetext = File(lines[loc + 1]).read()
            clipboard ‘’= filetext
      E I (command == ‘Duplicate’)
         clipboard ‘’= clipboard * ((Int(lines[loc + 1])) - 1)
      E I (command == ‘Pasta!’)
         print(clipboard)
         L.break
      E
         exit(‘unknown command '’command‘' encountered on line ’String(loc + 1))
   X.catch
      exit(‘error while executing command '’command‘' on line ’String(loc + 1))

   loc += 2
===
Array<String> argv;

int MAIN_WITH_ARGV()
{
    INIT_ARGV();

    auto source = File(_get<1>(::argv)).read();

    auto lines = source.split(u"\n"_S);

    auto clipboard = u""_S;

    auto loc = 0;
    while (loc < lines.len()) {
        auto command = lines[loc].trim(u" "_S);

        try
        {
            if ((command == u"Copy"))
                clipboard &= lines[loc + 1];
            else if ((command == u"CopyFile")) {
                if ((lines[loc + 1] == u"TheF*ckingCode"))
                    clipboard &= source;
                else {
                    auto filetext = File(lines[loc + 1]).read();
                    clipboard &= filetext;
                }
            }
            else if ((command == u"Duplicate"))
                clipboard &= clipboard * ((to_int(lines[loc + 1])) - 1);
            else if ((command == u"Pasta!")) {
                print(clipboard);
                break;
            }
            else
                exit(u"unknown command '"_S & command & u"' encountered on line "_S & String(loc + 1));
        }
        catch (...)
        {
            exit(u"error while executing command '"_S & command & u"' on line "_S & String(loc + 1));
        }

        loc += 2;
    }
}


# https://www.rosettacode.org/wiki/Execute_HQ9%2B#Python
from typing import Dict, Callable
Char = str
import sys

def hello():
    print("Hello, world!")

src : str
def quine():
    print(src)

def bottles():
    for i in range(99,2,-1):
        print("%d bottles of beer on the wall" % i)
        print("%d bottles of beer" % i)
        print("Take one down, pass it around")
        print("%d bottles of beer on the wall" % (i-1))
        print()

    print("2 bottles of beer on the wall")
    print("2 bottles of beer")
    print("Take one down, pass it around")
    print("1 bottle of beer on the wall")
    print()

    print("1 bottle of beer on the wall")
    print("1 bottle of beer")
    print("Take one down, pass it around")
    print("No more bottles of beer on the wall")
    print()

    print("No more bottles of beer on the wall")
    print("No more bottles of beer on the wall")
    print("Go to the store and buy some more")
    print("99 bottles of beer on the wall.")
    print()

acc = 0
def incr():
    acc +=1

if __name__ == '__main__':
    src = open(sys.argv[1]).read()

    # Implement interpreter using a dispatch table
    dispatch : Dict[Char, Callable[[], None]] = {}
    dispatch[Char('h')] = hello
    dispatch[Char('q')] = quine
    dispatch[Char('9')] = bottles
    dispatch[Char('+')] = incr

    for i in src.lower():
        if i in dispatch:
            dispatch[i]()
===
F hello()
   print(‘Hello, world!’)

String src
F quine()
   print(:src)

F bottles()
   L(i) (99.<2).step(-1)
      print(‘#. bottles of beer on the wall’.format(i))
      print(‘#. bottles of beer’.format(i))
      print(‘Take one down, pass it around’)
      print(‘#. bottles of beer on the wall’.format(i - 1))
      print()

   print(‘2 bottles of beer on the wall’)
   print(‘2 bottles of beer’)
   print(‘Take one down, pass it around’)
   print(‘1 bottle of beer on the wall’)
   print()

   print(‘1 bottle of beer on the wall’)
   print(‘1 bottle of beer’)
   print(‘Take one down, pass it around’)
   print(‘No more bottles of beer on the wall’)
   print()

   print(‘No more bottles of beer on the wall’)
   print(‘No more bottles of beer on the wall’)
   print(‘Go to the store and buy some more’)
   print(‘99 bottles of beer on the wall.’)
   print()

V acc = 0
F incr()
   :acc++

:start:
src = File(:argv[1]).read()

[Char = (() -> N)] dispatch
dispatch[Char(‘h’)] = hello
dispatch[Char(‘q’)] = quine
dispatch[Char(‘9’)] = bottles
dispatch[Char(‘+’)] = incr

L(i) src.lowercase()
   I i C dispatch
      dispatch[i]()
===
Array<String> argv;

auto hello()
{
    print(u"Hello, world!"_S);
}

String src;
auto quine()
{
    print(::src);
}

auto bottles()
{
    for (auto i : range_el(99, 2).step(-1)) {
        print(u"#. bottles of beer on the wall"_S.format(i));
        print(u"#. bottles of beer"_S.format(i));
        print(u"Take one down, pass it around"_S);
        print(u"#. bottles of beer on the wall"_S.format(i - 1));
        print();
    }

    print(u"2 bottles of beer on the wall"_S);
    print(u"2 bottles of beer"_S);
    print(u"Take one down, pass it around"_S);
    print(u"1 bottle of beer on the wall"_S);
    print();

    print(u"1 bottle of beer on the wall"_S);
    print(u"1 bottle of beer"_S);
    print(u"Take one down, pass it around"_S);
    print(u"No more bottles of beer on the wall"_S);
    print();

    print(u"No more bottles of beer on the wall"_S);
    print(u"No more bottles of beer on the wall"_S);
    print(u"Go to the store and buy some more"_S);
    print(u"99 bottles of beer on the wall."_S);
    print();
}

auto acc = 0;
auto incr()
{
    ::acc++;
}

int MAIN_WITH_ARGV()
{
    INIT_ARGV();

    src = File(_get<1>(::argv)).read();

    Dict<Char, std::function<void()>> dispatch;
    dispatch.set(u'h'_C, hello);
    dispatch.set(u'q'_C, quine);
    dispatch.set(u'9'_C, bottles);
    dispatch.set(u'+'_C, incr);

    for (auto &&i : src.lowercase())
        if (in(i, dispatch))
            dispatch[i]();
}


# https://www.rosettacode.org/wiki/Exponentiation_operator#JavaScript
def my_pow(base, exp) -> float:
    if exp < 0:
        return 1 / my_pow(base, -exp)
    if exp == 0:
        return 1
    ans = base
    for i in range(exp - 1):
        ans *= base
    return ans

print("2  ^ 3   =", my_pow( 2,   3))
print("1  ^ -10 =", my_pow( 1, -10))
print("-1 ^ -3  =", my_pow(-1, -3))
print()
print("2.0 ^ -3 =", my_pow(2.0, -3))
print("1.5 ^ 0  =", my_pow(1.5,  0))
print("4.5 ^ 2  =", my_pow(4.5,  2))
===
F my_pow(base, exp) -> Float
   I exp < 0
      R 1 / my_pow(base, -exp)
   I exp == 0
      R 1
   V ans = base
   L(i) 0 .< exp - 1
      ans *= base
   R ans

print(‘2  ^ 3   = ’my_pow(2, 3))
print(‘1  ^ -10 = ’my_pow(1, -10))
print(‘-1 ^ -3  = ’my_pow(-1, -3))
print()
print(‘2.0 ^ -3 = ’my_pow(2.0, -3))
print(‘1.5 ^ 0  = ’my_pow(1.5, 0))
print(‘4.5 ^ 2  = ’my_pow(4.5, 2))
===
template <typename T1, typename T2> double my_pow(const T1 &base, const T2 &exp)
{
    if (exp < 0)
        return 1.0 / my_pow(base, -exp);
    if (exp == 0)
        return 1;
    auto ans = base;
    for (auto i : range_el(0, exp - 1))
        ans *= base;
    return ans;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"2  ^ 3   = "_S & my_pow(2, 3));
        print(u"1  ^ -10 = "_S & my_pow(1, -10));
        print(u"-1 ^ -3  = "_S & my_pow(-1, -3));
        print();
        print(u"2.0 ^ -3 = "_S & my_pow(2.0, -3));
        print(u"1.5 ^ 0  = "_S & my_pow(1.5, 0));
        print(u"4.5 ^ 2  = "_S & my_pow(4.5, 2));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Extra_primes
limit = 10_000

is_prime = [False] * 2 + [True] * (limit - 1)
for n in range(int(limit**0.5 + 1.5)): # stop at ``sqrt(limit)``
    if is_prime[n]:
        for i in range(n*n, limit+1, n):
            is_prime[i] = False

def is_extra_prime(n):
    if not is_prime[n]:
        return False
    s = 0
    for digit_char in str(n):
        digit = int(digit_char)
        if not is_prime[digit]:
            return False
        s += digit
    return bool(is_prime[s])

i = 0
for n in range(limit):
    if is_extra_prime(n):
        i += 1
        print('%4d' % n, end = "\n" if i % 9 == 0 else ' ')
===
V limit = 10'000

V is_prime = [0B] * 2 [+] [1B] * (limit - 1)
L(n) 0 .< Int(limit ^ 0.5 + 1.5)
   I is_prime[n]
      L(i) (n * n .. limit).step(n)
         is_prime[i] = 0B

F is_extra_prime(n)
   I !:is_prime[n]
      R 0B
   V s = 0
   L(digit_char) String(n)
      V digit = Int(digit_char)
      I !:is_prime[digit]
         R 0B
      s += digit
   R Bool(:is_prime[s])

V i = 0
L(n) 0 .< limit
   I is_extra_prime(n)
      i++
      print(‘#4’.format(n), end' I i % 9 == 0 {"\n"} E ‘ ’)
===
auto limit = 10'000;

auto is_prime = create_array({false}) * 2 + create_array({true}) * (limit - 1);

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto n : range_el(0, to_int(pow(limit, 0.5) + 1.5)))
            if (is_prime[n])
                for (auto i : range_ee(n * n, limit).step(n))
                    is_prime.set(i, false);
    }
} code_block_1;

template <typename T1> auto is_extra_prime(const T1 &n)
{
    if (!::is_prime[n])
        return false;
    auto s = 0;
    for (auto &&digit_char : String(n)) {
        auto digit = to_int(digit_char);
        if (!::is_prime[digit])
            return false;
        s += digit;
    }
    return bool(::is_prime[s]);
}

auto i = 0;

struct CodeBlock2
{
    CodeBlock2()
    {
        for (auto n : range_el(0, limit))
            if (is_extra_prime(n)) {
                i++;
                print(u"#4"_S.format(n), mod(i, 9) == 0 ? u'\n'_C : u' '_C);
            }
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Esthetic_numbers#Nim
from _11l import *

def isEsthetic(n, b):
    if n == 0: return False
    i = n % b
    n //= b
    while n > 0:
        j = n % b
        if abs(i - j) != 1:
            return False
        n //= b
        i = j
    return True

def listEsths(n1 : Int64, n2 : Int64, m1 : Int64, m2 : Int64, perLine, all):
    esths : List[Int64] = []

    def dfs(n : Int64, m : Int64, i : Int64) -> None:
        if i in range(n, m + 1):
            esths.append(i)
        if i == 0 or i > m: return
        d = i % 10
        i1 = i * 10 + d - 1
        i2 = i1 + 2
        if d == 0:
            dfs(n, m, i2)
        elif d == 9:
            dfs(n, m, i1)
        else:
            dfs(n, m, i1)
            dfs(n, m, i2)

    for i in range(10):
        dfs(n2, m2, i)

    print(f'Base 10: {len(esths)} esthetic numbers between {n1} and {m1}:')
    if all:
        for i, esth in enumerate(esths):
            print(esth, end = "\n" if (i + 1) % perLine == 0 else ' ')
        print()
    else:
        for i in range(perLine):
            print(esths[i], end = ' ')
        print("\n............")
        for i in range(len(esths) - perLine, len(esths)):
            print(esths[i], end = ' ')
        print()
    print()

for b in range(2, 17):
    print(f'Base {b}: {4 * b}th to {6 * b}th esthetic numbers:')
    n = Int64(1)
    c = Int64(0)
    while c < 6 * b:
        if isEsthetic(n, b):
            c += 1
            if c >= 4 * b: print(int_to_str_with_radix(n, b), end = ' ')
        n += 1
    print("\n")

# The following all use the obvious range limitations for the numbers in question.
listEsths(1000, 1010, 9999, 9898, 16, True)
listEsths(100_000_000, 101_010_101, 130_000_000, 123_456_789, 9, True)
listEsths(100_000_000_000, 101_010_101_010, 130_000_000_000, 123_456_789_898, 7, False)
listEsths(100_000_000_000_000, 101_010_101_010_101, 130_000_000_000, 123_456_789_898_989, 5, False)
listEsths(100_000_000_000_000_000, 101_010_101_010_101_010, 130_000_000_000_000_000, 123_456_789_898_989_898, 4, False)
===
F isEsthetic(=n, b)
   I n == 0
      R 0B
   V i = n % b
   n I/= b
   L n > 0
      V j = n % b
      I abs(i - j) != 1
         R 0B
      n I/= b
      i = j
   R 1B

F listEsths(Int64 n1, Int64 n2, Int64 m1, Int64 m2; perLine, all)
   [Int64] esths

   F dfs(Int64 n, Int64 m, Int64 i) -> N
      I i C n .. m
         @esths.append(i)
      I i == 0 | i > m
         R
      V d = i % 10
      V i1 = i * 10 + d - 1
      V i2 = i1 + 2
      I d == 0
         @dfs(n, m, i2)
      E I d == 9
         @dfs(n, m, i1)
      E
         @dfs(n, m, i1)
         @dfs(n, m, i2)

   L(i) 10
      dfs(n2, m2, i)

   print(‘Base 10: ’esths.len‘ esthetic numbers between ’n1‘ and ’m1‘:’)
   I all
      L(esth) esths
         V i = L.index
         print(esth, end' I (i + 1) % perLine == 0 {"\n"} E ‘ ’)
      print()
   E
      L(i) 0 .< perLine
         print(esths[i], end' ‘ ’)
      print("\n............")
      L(i) esths.len - perLine .< esths.len
         print(esths[i], end' ‘ ’)
      print()
   print()

L(b) 2..16
   print(‘Base ’b‘: ’(4 * b)‘th to ’(6 * b)‘th esthetic numbers:’)
   V n = Int64(1)
   V c = Int64(0)
   L c < 6 * b
      I isEsthetic(n, b)
         c++
         I c >= 4 * b
            print(String(n, radix' b), end' ‘ ’)
      n++
   print("\n")

listEsths(1000, 1010, 9999, 9898, 16, 1B)
listEsths(100'000'000, 101'010'101, 130'000'000, 123'456'789, 9, 1B)
listEsths(100'000'000'000, 101'010'101'010, 130'000'000'000, 123'456'789'898, 7, 0B)
listEsths(100'000'000'000'000, 101'010'101'010'101, 130'000'000'000, 123'456'789'898'989, 5, 0B)
listEsths(100'000'000'000'000'000, 101'010'101'010'101'010, 130'000'000'000'000'000, 123'456'789'898'989'898, 4, 0B)
===
template <typename T1, typename T2> auto isEsthetic(T1 n, const T2 &b)
{
    if (n == 0)
        return false;
    auto i = mod(n, b);
    n = idiv(n, b);
    while (n > 0) {
        auto j = mod(n, b);
        if (abs(i - j) != 1)
            return false;
        n = idiv(n, b);
        i = j;
    }
    return true;
}

template <typename T5, typename T6> auto listEsths(const Int64 &n1, const Int64 &n2, const Int64 &m1, const Int64 &m2, const T5 &perLine, const T6 &all)
{
    Array<Int64> esths;

    std::function<void(Int64, Int64, Int64)> dfs = [&dfs, &esths](const Int64 &n, const Int64 &m, const Int64 &i) -> void
    {
        if (in(i, range_ee(n, m)))
            esths.append(i);
        if (i == 0 || i > m)
            return;
        auto d = mod(i, 10);
        auto i1 = i * 10 + d - 1;
        auto i2 = i1 + 2;
        if (d == 0)
            dfs(n, m, i2);
        else if (d == 9)
            dfs(n, m, i1);
        else {
            dfs(n, m, i1);
            dfs(n, m, i2);
        }
    };

    for (int i = 0; i < 10; i++)
        dfs(n2, m2, i);

    print(u"Base 10: "_S & esths.len() & u" esthetic numbers between "_S & n1 & u" and "_S & m1 & u":"_S);
    if (all) {
        {int Lindex = 0;
        for (auto &&esth : esths) {
            auto i = Lindex;
            print(esth, mod((i + 1), perLine) == 0 ? u'\n'_C : u' '_C);
            Lindex++;
        }}
        print();
    }
    else {
        for (auto i : range_el(0, perLine))
            print(esths[i], u" "_S);
        print(u"\n............"_S);
        for (auto i : range_el(esths.len() - perLine, esths.len()))
            print(esths[i], u" "_S);
        print();
    }
    print();
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto b : range_ee(2, 16)) {
            print(u"Base "_S & b & u": "_S & (4 * b) & u"th to "_S & (6 * b) & u"th esthetic numbers:"_S);
            auto n = to_int64(1);
            auto c = to_int64(0);
            while (c < 6 * b) {
                if (isEsthetic(n, b)) {
                    c++;
                    if (c >= 4 * b)
                        print(int_to_str_with_radix(n, b), u" "_S);
                }
                n++;
            }
            print(u"\n"_S);
        }

        listEsths(1000, 1010, 9999, 9898, 16, true);
        listEsths(100'000'000, 101'010'101, 130'000'000, 123'456'789, 9, true);
        listEsths(100'000'000'000, 101'010'101'010, 130'000'000'000, 123'456'789'898, 7, false);
        listEsths(100'000'000'000'000, 101'010'101'010'101, 130'000'000'000, 123'456'789'898'989, 5, false);
        listEsths(100'000'000'000'000'000, 101'010'101'010'101'010, 130'000'000'000'000'000, 123'456'789'898'989'898, 4, false);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Exactly_three_adjacent_3_in_lists
lists = [[9,3,3,3,2,1,7,8,5],
         [5,2,9,3,3,7,8,4,1],
         [1,4,3,6,7,3,8,3,2],
         [1,2,3,4,5,6,7,8,9],
         [4,6,8,7,2,3,3,3,1]]

for l in lists:
    print(l, end = ' -> ')
    for i in range(len(l) - 2):
        if l[i] == l[i+1] == l[i+2] == 3:
            print('True')
            break
    else:
        print('False')
===
V lists = [[9, 3, 3, 3, 2, 1, 7, 8, 5], [5, 2, 9, 3, 3, 7, 8, 4, 1], [1, 4, 3, 6, 7, 3, 8, 3, 2], [1, 2, 3, 4, 5, 6, 7, 8, 9], [4, 6, 8, 7, 2, 3, 3, 3, 1]]

L(l) lists
   print(l, end' ‘ -> ’)
   L(i) 0 .< l.len - 2
      I l[i] == l[i + 1] == l[i + 2] == 3
         print(‘True’)
         L.break
   L.was_no_break
      print(‘False’)
===
auto lists = create_array({create_array({9, 3, 3, 3, 2, 1, 7, 8, 5}), create_array({5, 2, 9, 3, 3, 7, 8, 4, 1}), create_array({1, 4, 3, 6, 7, 3, 8, 3, 2}), create_array({1, 2, 3, 4, 5, 6, 7, 8, 9}), create_array({4, 6, 8, 7, 2, 3, 3, 3, 1})});

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&l : lists) {
            print(l, u" -> "_S);
            for (auto i : range_el(0, l.len() - 2))
                if (equal(l[i], l[i + 1], l[i + 2], 3)) {
                    print(u"True"_S);
                    goto break_;
                }
            print(u"False"_S);
            break_:;
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Erd%C5%91s-primes#Nim
import itertools, math
from typing import List

def primes_upto(limit):
    is_prime = [False] * 2 + [True] * (limit - 1)
    for n in range(int(limit**0.5 + 1.5)): # stop at ``sqrt(limit)``
        if is_prime[n]:
            for i in range(n*n, limit+1, n):
                is_prime[i] = False
    return is_prime

is_prime = primes_upto(1_000_000)
primeList = [i for i, prime in enumerate(is_prime) if prime]

factorials : List[int] = []
for n in itertools.count(1):
    if math.factorial(n) >= 1_000_000:
        break
    factorials.append(math.factorial(n))

def isErdosPrime(p):
    for f in factorials:
        if f >= p: break
        if is_prime[p - f]: return False
    return True

erdosList2500 : List[int] = []
for p in primeList:
    if p >= 2500: break
    if isErdosPrime(p):
        erdosList2500.append(p)

print('Found', len(erdosList2500), 'Erdos primes less than 2500:')
for i, prime in enumerate(erdosList2500):
    print('%5d' % prime, end = "\n" if (i+1) % 10 == 0 else ' ')
print()

count = 0
for p in primeList:
    if isErdosPrime(p):
        count += 1
        if count == 7875:
            print(f"\nThe 7875th Erdos prime is {p}.")
            break
===
F primes_upto(limit)
   V is_prime = [0B] * 2 [+] [1B] * (limit - 1)
   L(n) 0 .< Int(limit ^ 0.5 + 1.5)
      I is_prime[n]
         L(i) (n * n .. limit).step(n)
            is_prime[i] = 0B
   R is_prime

V is_prime = primes_upto(1'000'000)
V primeList = enumerate(is_prime).filter((i, prime) -> prime).map((i, prime) -> i)

[Int] factorials
L(n) 1..
   I factorial(n) >= 1'000'000
      L.break
   factorials.append(factorial(n))

F isErdosPrime(p)
   L(f) :factorials
      I f >= p
         L.break
      I :is_prime[p - f]
         R 0B
   R 1B

[Int] erdosList2500
L(p) primeList
   I p >= 2500
      L.break
   I isErdosPrime(p)
      erdosList2500.append(p)

print(‘Found ’erdosList2500.len‘ Erdos primes less than 2500:’)
L(prime) erdosList2500
   V i = L.index
   print(‘#5’.format(prime), end' I (i + 1) % 10 == 0 {"\n"} E ‘ ’)
print()

V count = 0
L(p) primeList
   I isErdosPrime(p)
      count++
      I count == 7875
         print("\nThe 7875th Erdos prime is "p‘.’)
         L.break
===
template <typename T1> auto primes_upto(const T1 &limit)
{
    auto is_prime = create_array({false}) * 2 + create_array({true}) * (limit - 1);
    for (auto n : range_el(0, to_int(pow(limit, 0.5) + 1.5)))
        if (is_prime[n])
            for (auto i : range_ee(n * n, limit).step(n))
                is_prime.set(i, false);
    return is_prime;
}

auto is_prime = primes_upto(1'000'000);
auto primeList = enumerate(is_prime).filter([](const auto &i, const auto &prime){return prime;}).map([](const auto &i, const auto &prime){return i;});

Array<int> factorials;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto n : range_ei(1)) {
            if (factorial(n) >= 1'000'000)
                break;
            factorials.append(factorial(n));
        }
    }
} code_block_1;

template <typename T1> auto isErdosPrime(const T1 &p)
{
    for (auto &&f : ::factorials) {
        if (f >= p)
            break;
        if (::is_prime[p - f])
            return false;
    }
    return true;
}

Array<int> erdosList2500;

struct CodeBlock2
{
    CodeBlock2()
    {
        for (auto &&p : primeList) {
            if (p >= 2500)
                break;
            if (isErdosPrime(p))
                erdosList2500.append(p);
        }

        print(u"Found "_S & erdosList2500.len() & u" Erdos primes less than 2500:"_S);
        {int Lindex = 0;
        for (auto &&prime : erdosList2500) {
            auto i = Lindex;
            print(u"#5"_S.format(prime), mod((i + 1), 10) == 0 ? u'\n'_C : u' '_C);
            Lindex++;
        }}
        print();
    }
} code_block_2;

auto count = 0;

struct CodeBlock3
{
    CodeBlock3()
    {
        for (auto &&p : primeList)
            if (isErdosPrime(p)) {
                count++;
                if (count == 7875) {
                    print(u"\nThe 7875th Erdos prime is "_S & p & u"."_S);
                    break;
                }
            }
    }
} code_block_3;