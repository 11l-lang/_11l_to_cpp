import sys
from typing import List

class Exception(Exception):
    message : str
    line : int
    column : int
    pos : int
    def __init__(self, message, line, column, pos):
        self.message = message
        self.line = line
        self.column = column
        self.pos = pos

class Converter:
    to_html_called_inside_to_html_outer_pos_list : List[int]
    habrahabr_html : bool
    ohd : bool
    instr : str

    def __init__(self, habrahabr_html, ohd):
        self.to_html_called_inside_to_html_outer_pos_list = []
        #self.newline_chars = []
        self.habrahabr_html = habrahabr_html
        self.ohd = ohd

    def instr_pos_to_line_column(self, pos):
        pos += sum(self.to_html_called_inside_to_html_outer_pos_list)
        line = 1
        line_start = -1
        t = 0
        while t < pos:
            if self.instr[t] == "\r":
                if t < pos-1 and self.instr[t+1] == "\n":
                    t += 1
                line += 1
                line_start = t
            elif self.instr[t] == "\n":
                line += 1
                line_start = t
            t += 1
        return (line, pos - line_start)

    def to_html(self, instr, outfilef : IO[str] = None, *, outer_pos = 0) -> str:
        self.to_html_called_inside_to_html_outer_pos_list.append(outer_pos)

        result : List[str] = [] # this should be faster than using regular string
        class Writer:
            write : Callable[[str], None]
        outfile = Writer()
        if outfilef == None:
            outfile.write = lambda s: result.append(s)
        else:
            outfile.write = lambda s: outfilef.write(s)

        if len(self.to_html_called_inside_to_html_outer_pos_list) == 1:
            self.instr = instr

        def exit_with_error(message, pos):
            p = self.instr_pos_to_line_column(pos)
            raise Exception(message, p[0], p[1], pos)

        i = 0
        def next_char(offset = 1):
            return instr[i + offset] if i + offset < len(instr) else "\0"[0]

        def i_next_str(str): # i_ — if_/is_
            #return i + len(str) <= len(instr) and instr[i:i+len(str)] == str
            return instr[i+1:i+1+len(str)] == str # first check is not necessarily in Python

        def prev_char(offset = 1):
            return instr[i - offset] if i - offset >= 0 else "\0"[0]

        def html_escape(str):
            str = str.replace('&', '&amp;').replace('<', '&lt;')
            if self.habrahabr_html:
                str = str.replace('"', '&quot;') # нужно для корректного отображения кавычек в <a href="http://address">, так как habrahabr автоматически конвертирует "" в «»
            return str
        def html_escapeq(str):
            return str.replace('&', '&amp;').replace('"', '&quot;')

        writepos = 0
        def write_to_pos(pos, npos):
            nonlocal writepos
            outfile.write(html_escape(instr[writepos:pos]))
            writepos = npos

        def write_to_i(add_str, skip_chars = 1):
            write_to_pos(i, i+skip_chars)
            outfile.write(add_str)

        def find_ending_pair_quote(i): # ищет окончание ‘строки’
            assert(instr[i] == "‘") # ’
            startqpos = i
            nesting_level = 0
            while True:
                if i == len(instr):
                    exit_with_error('Unpaired left single quotation mark', startqpos)
                ch = instr[i]
                if ch == "‘":
                    nesting_level += 1
                elif ch == "’":
                    nesting_level -= 1
                    if nesting_level == 0:
                        return i
                i += 1

        def find_ending_sq_bracket(str, i, start = 0):
            starti = i
            assert(str[i] == "[") # ]
            nesting_level = 0
            while True:
                ch = str[i]
                if ch == "[":
                    nesting_level += 1
                elif ch == "]":
                    nesting_level -= 1
                    if nesting_level == 0:
                        return i
                i += 1
                if i == len(str):
                    exit_with_error('Unended comment started', start + starti)

        def remove_comments(s, start, level = 3):
            while True:
                j = s.find("["*level) # ]
                if j == -1:
                    break
                k = find_ending_sq_bracket(s, j, start) + 1
                start += k - j
                s = s[0:j] + s[k:]
            return s

        nonunique_links : Dict[int, str] = {}
        link = ''

        def write_http_link(startpos, endpos, q_offset = 1, text = ''):
            nonlocal i, link
            # Ищем окончание ссылки
            nesting_level = 0
            i += 2
            while True:
                if i == len(instr):
                    exit_with_error('Unended link', endpos+q_offset)
                ch = instr[i]
                if ch == "[":
                    nesting_level += 1
                elif ch == "]":
                    if nesting_level == 0:
                        break
                    nesting_level -= 1
                elif ch == " ":
                    break
                i += 1

            link = html_escapeq(instr[endpos+1+q_offset:i])
            tag : str = '<a href="' + link + '"'
            if link.startswith('./'):
                tag += ' target="_self"'

            # Ищем альтернативный текст при такой записи: ссылка[http://... ‘альтернативный текст’]
            if instr[i] == " ":
                tag += ' title="'
                if next_char() == "‘": # ’[
                    endqpos2 = find_ending_pair_quote(i+1)
                    assert(instr[endqpos2+1] == ']')
                    tag += html_escapeq(remove_comments(instr[i+2:endqpos2], i+2))
                    i = endqpos2 + 1
                else:
                    endb = find_ending_sq_bracket(instr, endpos+q_offset)
                    tag += html_escapeq(remove_comments(instr[i+1:endb], i+1))
                    i = endb
                tag += '"'
            if next_char() == '[' and next_char(2) == '-':
                j = i + 3
                while j < len(instr):
                    if instr[j] == ']':
                        nonunique_links[int(instr[i+3:j])] = link
                        i = j
                        break
                    if not instr[j].isdigit():
                        break
                    j += 1
            if text == '':
                write_to_pos(startpos, i+1)
                text = html_escape(instr[startpos+q_offset:endpos])
            outfile.write(tag + '>' + (text if text != '' else link) + '</a>')

        def write_note(startpos, endpos, q_offset = 1):
            nonlocal i
            i += q_offset
            endqpos2 = find_ending_pair_quote(i+1) # [[‘
            if instr[endqpos2+1] != ']':
                exit_with_error("Bracket ] should follow after ’", endqpos2+1)
            write_to_pos(startpos, endqpos2+2)
            outfile.write('<abbr title="'
                + html_escapeq(remove_comments(instr[i+2:endqpos2], i+2)) + '">'
                + html_escape(remove_comments(instr[startpos+q_offset:endpos], startpos+q_offset)) + '</abbr>')
            i = endqpos2 + 1

        endi = 0
        def numbered_link(offset = 1):
            if next_char(offset) == '-' and next_char(offset+1).isdigit():
                j = i + offset + 1
                while j < len(instr): # [
                    if instr[j] == ']':
                        nonlocal link
                        try:
                            link = nonunique_links[int(instr[i+offset+1:j])]
                        except KeyError:
                            exit_with_error("Link with such index was not declared previously", i+offset+1)
                        nonlocal endi
                        endi = j
                        return True
                    if not instr[j].isdigit():
                        break
                    j += 1
            return False

        ordered_list_current_number = -1
        def close_ordered_list():
            nonlocal ordered_list_current_number
            if ordered_list_current_number != -1:
                write_to_i("</li>\n</ol>\n", 0)
                ordered_list_current_number = -1

        in_unordered_list = False
        def close_unordered_list():
            nonlocal in_unordered_list
            if in_unordered_list:
                write_to_i("</li>\n</ul>\n", 0)
                in_unordered_list = False

        ending_tags : List[str] = []
        new_line_tag = "\0"

        while i < len(instr):
            ch = instr[i]
            if i == 0 or prev_char() == "\n": # if beginning of line
                if ch == '.' and (next_char() in ' ‘'): # ’ this is unordered list
                    close_ordered_list()
                    s = ''
                    if not in_unordered_list:
                        s = "<ul>\n<li>"
                        in_unordered_list = True
                    else:
                        s = "</li>\n<li>"
                    write_to_i(s)
                    new_line_tag = '' # используем тот факт, что разрыва строк в списках вида `. элемент списка` быть не может, и следующий символ \n будет либо закрывать список, либо обозначать начало следующего элемента списка
                    if next_char() == ' ':
                        i += 1
                    else:
                        endqpos = find_ending_pair_quote(i + 1)
                        outfile.write(self.to_html(instr[i+2:endqpos], outer_pos = i+2))
                        i = endqpos
                    writepos = i + 1
                else:
                    close_unordered_list()
                    if ch.isdigit():
                        j = i + 1
                        while j < len(instr):
                            if not instr[j].isdigit():
                                break
                            j += 1
                        if instr[j:j+1] == '.' and instr[j+1:j+2] in (' ', '‘'): # ’ this is ordered list
                            value = int(instr[i:j])
                            s = ''
                            if ordered_list_current_number == -1:
                                s = ('<ol>' if value == 1 else '<ol start="' + str(value) + '">') + "\n<li>"
                                ordered_list_current_number = value
                            else:
                                s = "</li>\n" + ("<li>" if value == ordered_list_current_number + 1 else '<li value="' + str(value) + '">')
                                ordered_list_current_number = value
                            write_to_i(s)
                            new_line_tag = '' # используем тот факт, что разрыва строк в списках вида `1. элемент списка` быть не может
                            if instr[j+1] == ' ':
                                i = j + 1
                            else:
                                endqpos = find_ending_pair_quote(j + 1)
                                outfile.write(self.to_html(instr[j+2:endqpos], outer_pos = j+2))
                                i = endqpos
                            writepos = i + 1
                        else:
                            close_ordered_list()
                    else:
                        close_ordered_list()

                if ch == ' ':
                    write_to_i('&emsp;')
                elif ch == '-': # horizontal rule
                    if i_next_str('--'):
                        j = i + 3
                        while True:
                            if j == len(instr) or instr[j] == "\n":
                                write_to_i("<hr />\n")
                                i = j
                                writepos = j + 1
                                break
                            if instr[j] != '-':
                                break
                            j += 1
                elif ch in ('>', '<') and (next_char() in ' ‘['): # this is blockquote # ]’
                    write_to_pos(i, i + 2)
                    outfile.write('<blockquote'+(ch=='<')*' class="re"'+'>')
                    if next_char() == ' ': # > Quoted text.
                        new_line_tag = '</blockquote>'
                    else:
                        if next_char() == '[': # ]
                            if numbered_link(2): # >[-1]:‘Quoted text.’
                                linkstr = link
                                if len(linkstr) > 57:
                                    linkstr = linkstr[:linkstr.rfind('/', 0, 47)+1] + '...'
                                outfile.write('<a href="' + link + '">[' + instr[i+3:endi] + ']<i>' + linkstr + '</i></a>')
                                i = endi + 1
                            else: # >[http...]:‘Quoted text.’ or >[http...][-1]:‘Quoted text.’
                                i += 1
                                endb = find_ending_sq_bracket(instr, i)
                                linkn = ''
                                if instr[endb+1:endb+3] == '[-': # ]
                                    linkn = '['+instr[endb+3:find_ending_sq_bracket(instr, endb+1)]+']'
                                link = instr[i + 1:endb]
                                spacepos = link.find(' ')
                                if spacepos != -1:
                                    link = link[:spacepos]
                                if len(link) > 57:
                                    link = link[:link.rfind('/', 0, 47)+1] + '...'
                                write_http_link(i, i, 0, linkn+'<i>'+link+'</i>') # this function changes `link` :o, but I left[‘I mean didn't rename it to `link_`’] it as is [at least for a while] because it still works correctly
                                i += 1
                            if instr[i:i+2] != ':‘': # ’
                                exit_with_error("Quotation with url should always has :‘...’ after ["+link[:link.find(':')]+"://url]", i)
                            outfile.write(":<br />\n")
                            writepos = i + 2
                        else:
                            endqpos = find_ending_pair_quote(i + 1)
                            if instr[endqpos+1:endqpos+2] == "[": # >‘Author's name’[http...]:‘Quoted text.’ # ]
                                startqpos = i + 1
                                i = endqpos
                                outfile.write('<i>')
                                write_http_link(startqpos, endqpos)
                                outfile.write('</i>')
                                i += 1
                                if instr[i:i+2] != ':‘': # ’
                                    exit_with_error("Quotation with url should always has :‘...’ after ["+link[:link.find(':')]+"://url]", i)
                                outfile.write(":<br />\n")
                                writepos = i + 2
                            elif instr[endqpos+1:endqpos+2] == ":": # >‘Author's name’:‘Quoted text.’
                                outfile.write("<i>"+instr[i+2:endqpos]+"</i>:<br />\n")
                                i = endqpos + 2
                                if instr[i:i+1] != '‘': # ’
                                    exit_with_error("Quotation with author's name should be in the form >‘Author's name’:‘Quoted text.’ (opening quotation mark not found after colon)", i)
                                writepos = i + 1
                            # else this is just >‘Quoted text.’
                        ending_tags.append('</blockquote>')
                    i += 1

        if outfilef == None:
            r = "".join(result)
            if self.habrahabr_html:                               # // dirty hack
                r = r.replace("</blockquote>\n", '</blockquote>') # \\ (just left it as is)
            return r

        return ''

def to_html(instr, outfilef : IO[str] = None, ohd = False, *, habrahabr_html = False):
    return Converter(habrahabr_html, ohd).to_html(instr, outfilef)

if __name__ == '__main__':
    if '-h' in sys.argv or '--help' in sys.argv:
        print(R'''A Python implementation of pq markup to HTML converter.''')
        sys.exit(0)

    args_habrahabr_html       = '--habrahabr-html'       in sys.argv
    args_output_html_document = '--output-html-document' in sys.argv
    args_infile = sys.stdin
    i = 1
    while i < len(sys.argv):
        if sys.argv[i] in ('-f', '--file'):
            i += 2
            continue
        if not sys.argv[i].startswith('-'):
            args_infile = open(sys.argv[i], 'r', encoding = 'utf-8')
            break
        i += 1
    args_outfile = sys.stdout
    if '-f' in sys.argv:
        args_outfile = open(sys.argv[sys.argv.index('-f')     + 1], 'w', encoding = 'utf-8')
    elif '--file' in sys.argv:
        args_outfile = open(sys.argv[sys.argv.index('--file') + 1], 'w', encoding = 'utf-8')

    if args_output_html_document and args_habrahabr_html:
        sys.exit("Arguments --output-html-document and --habrahabr-html are mutually exclusive")

    try:
        to_html(args_infile.read(), args_outfile, args_output_html_document, habrahabr_html = args_habrahabr_html)
    except Exception as e:
        sys.stderr.write(e.message + " at line " + str(e.line) + ", column " + str(e.column) + "\n")
        sys.exit(-1)
===
//import sys

T Exception
   String message
   Int line
   Int column
   Int pos
   F (message, line, column, pos)
      .message = message
      .line = line
      .column = column
      .pos = pos

T Converter
   Array[Int] to_html_called_inside_to_html_outer_pos_list
   Bool habrahabr_html
   Bool ohd
   String instr

   F (habrahabr_html, ohd)
      .habrahabr_html = habrahabr_html
      .ohd = ohd

   F instr_pos_to_line_column(=pos)
      pos += sum(.to_html_called_inside_to_html_outer_pos_list)
      A line = 1
      A line_start = -1
      A t = 0
      L t < pos
         I .instr[t] == "\r"
            I t < pos - 1 & .instr[t + 1] == "\n"
               t++
            line++
            line_start = t
         E I .instr[t] == "\n"
            line++
            line_start = t
         t++
      R (line, pos - line_start)

   F to_html(instr, File? outfilef = N, ', outer_pos = 0) -> String
      .to_html_called_inside_to_html_outer_pos_list.append(outer_pos)
      Array[String] result
      T Writer
         (String -> N) write
      A outfile = Writer()
      I outfilef == N
         outfile.write = s -> @result.append(s)
      E
         outfile.write = s -> @outfilef.write(s)

      I .to_html_called_inside_to_html_outer_pos_list.len == 1
         .instr = instr

      F exit_with_error(message, pos)
         A p = @.instr_pos_to_line_column(pos)
         X Exception(message, p[0], p[1], pos)
      A i = 0
      F next_char(offset = 1)
         R I @i + offset < @instr.len {@instr[@i + offset]} E "\0"[0]

      F i_next_str(str)
         R @instr[@i + 1 .< @i + 1 + str.len] == str

      F prev_char(offset = 1)
         R I @i - offset >= 0 {@instr[@i - offset]} E "\0"[0]

      F html_escape(=str)
         str = str.replace(‘&’, ‘&amp;’).replace(‘<’, ‘&lt;’)
         I @.habrahabr_html
            str = str.replace(‘"’, ‘&quot;’)
         R str
      F html_escapeq(str)
         R str.replace(‘&’, ‘&amp;’).replace(‘"’, ‘&quot;’)
      A writepos = 0
      F write_to_pos(pos, npos)
         @outfile.write(@html_escape(@instr[@writepos .< pos]))
         @writepos = npos

      F write_to_i(add_str, skip_chars = 1)
         @write_to_pos(@i, @i + skip_chars)
         @outfile.write(add_str)

      F find_ending_pair_quote(=i)
         assert(@instr[i] == "‘")
         A startqpos = i
         A nesting_level = 0
         L
            I i == @instr.len
               @exit_with_error(‘Unpaired left single quotation mark’, startqpos)
            S @instr[i]
               "‘"
                  nesting_level++
               "’"
                  I --nesting_level == 0
                     R i
            i++

      F find_ending_sq_bracket(str, =i, start = 0)
         A starti = i
         assert(str[i] == ‘[’)
         A nesting_level = 0
         L
            S str[i]
               ‘[’
                  nesting_level++
               ‘]’
                  I --nesting_level == 0
                     R i
            i++
            I i == str.len
               @exit_with_error(‘Unended comment started’, start + starti)

      F remove_comments(=s, =start, level = 3)
         L
            A j = s.findi(‘[’ * level)
            I j == -1
               L.break
            A k = @find_ending_sq_bracket(s, j, start) + 1
            start += k - j
            s = s[0 .< j] + s[k ..]
         R s
      Dict[Int, String] nonunique_links
      A link = ‘’

      F write_http_link(startpos, endpos, q_offset = 1, =text = ‘’)
         A nesting_level = 0
         @i += 2
         L
            I @i == @instr.len
               @exit_with_error(‘Unended link’, endpos + q_offset)
            S @instr[@i]
               ‘[’
                  nesting_level++
               ‘]’
                  I nesting_level == 0
                     L.break
                  --nesting_level
               ‘ ’
                  L.break
            @i++
         @link = @html_escapeq(@instr[endpos + 1 + q_offset .< @i])
         String tag = ‘<a href="’@link‘"’
         I @link.starts_with(‘./’)
            tag ‘’= ‘ target="_self"’

         I @instr[@i] == ‘ ’
            tag ‘’= ‘ title="’
            I @next_char() == "‘"
               A endqpos2 = @find_ending_pair_quote(@i + 1)
               assert(@instr[endqpos2 + 1] == ‘]’)
               tag ‘’= @html_escapeq(@remove_comments(@instr[@i + 2 .< endqpos2], @i + 2))
               @i = endqpos2 + 1
            E
               A endb = @find_ending_sq_bracket(@instr, endpos + q_offset)
               tag ‘’= @html_escapeq(@remove_comments(@instr[@i + 1 .< endb], @i + 1))
               @i = endb
            tag ‘’= ‘"’
         I @next_char() == ‘[’ & @next_char(2) == ‘-’
            A j = @i + 3
            L j < @instr.len
               I @instr[j] == ‘]’
                  @nonunique_links[Int(@instr[@i + 3 .< j])] = @link
                  @i = j
                  L.break
               I !@instr[j].isdigit()
                  L.break
               j++
         I text == ‘’
            @write_to_pos(startpos, @i + 1)
            text = @html_escape(@instr[startpos + q_offset .< endpos])
         @outfile.write(tag‘>’(I text != ‘’ {text} E @link)‘</a>’)

      F write_note(startpos, endpos, q_offset = 1)
         @i += q_offset
         A endqpos2 = @find_ending_pair_quote(@i + 1)
         I @instr[endqpos2 + 1] != ‘]’
            @exit_with_error("Bracket ] should follow after ’", endqpos2 + 1)
         @write_to_pos(startpos, endqpos2 + 2)
         @outfile.write(‘<abbr title="’@html_escapeq(@remove_comments(@instr[@i + 2 .< endqpos2], @i + 2))‘">’@html_escape(@remove_comments(@instr[startpos + q_offset .< endpos], startpos + q_offset))‘</abbr>’)
         @i = endqpos2 + 1
      A endi = 0
      F numbered_link(offset = 1)
         I @next_char(offset) == ‘-’ & @next_char(offset + 1).isdigit()
            A j = @i + offset + 1
            L j < @instr.len
               I @instr[j] == ‘]’
                  X.try
                     @link = @nonunique_links[Int(@instr[@i + offset + 1 .< j])]
                  X.catch KeyError
                     @exit_with_error(‘Link with such index was not declared previously’, @i + offset + 1)
                  @endi = j
                  R 1B
               I !@instr[j].isdigit()
                  L.break
               j++
         R 0B
      A ordered_list_current_number = -1
      F close_ordered_list()
         I @ordered_list_current_number != -1
            @write_to_i("</li>\n</ol>\n", 0)
            @ordered_list_current_number = -1
      A in_unordered_list = 0B
      F close_unordered_list()
         I @in_unordered_list
            @write_to_i("</li>\n</ul>\n", 0)
            @in_unordered_list = 0B
      Array[String] ending_tags
      A new_line_tag = "\0"

      L i < instr.len
         A ch = instr[i]
         I i == 0 | prev_char() == "\n"
            I ch == ‘.’ & (next_char() C " ‘")
               close_ordered_list()
               A s = ‘’
               I !in_unordered_list
                  s = "<ul>\n<li>"
                  in_unordered_list = 1B
               E
                  s = "</li>\n<li>"
               write_to_i(s)
               new_line_tag = ‘’
               I next_char() == ‘ ’
                  i++
               E
                  A endqpos = find_ending_pair_quote(i + 1)
                  outfile.write(.to_html(instr[i + 2 .< endqpos], outer_pos' i + 2))
                  i = endqpos
               writepos = i + 1
            E
               close_unordered_list()
               I ch.isdigit()
                  A j = i + 1
                  L j < instr.len
                     I !instr[j].isdigit()
                        L.break
                     j++
                  I instr[j .< j + 1] == ‘.’ & instr[j + 1 .< j + 2] C (‘ ’, "‘")
                     A value = Int(instr[i .< j])
                     A s = ‘’
                     I ordered_list_current_number == -1
                        s = (I value == 1 {‘<ol>’} E ‘<ol start="’String(value)‘">’)"\n<li>"
                        ordered_list_current_number = value
                     E
                        s = "</li>\n"(I value == ordered_list_current_number + 1 {‘<li>’} E ‘<li value="’String(value)‘">’)
                        ordered_list_current_number = value
                     write_to_i(s)
                     new_line_tag = ‘’
                     I instr[j + 1] == ‘ ’
                        i = j + 1
                     E
                        A endqpos = find_ending_pair_quote(j + 1)
                        outfile.write(.to_html(instr[j + 2 .< endqpos], outer_pos' j + 2))
                        i = endqpos
                     writepos = i + 1
                  E
                     close_ordered_list()
               E
                  close_ordered_list()

            I ch == ‘ ’
               write_to_i(‘&emsp;’)
            E I ch == ‘-’
               I i_next_str(‘--’)
                  A j = i + 3
                  L
                     I j == instr.len | instr[j] == "\n"
                        write_to_i("<hr />\n")
                        i = j
                        writepos = j + 1
                        L.break
                     I instr[j] != ‘-’
                        L.break
                     j++
            E I ch C (‘>’, ‘<’) & (next_char() C " ‘[")
               write_to_pos(i, i + 2)
               outfile.write(‘<blockquote’((ch == ‘<’) * ‘ class="re"’)‘>’)
               I next_char() == ‘ ’
                  new_line_tag = ‘</blockquote>’
               E
                  I next_char() == ‘[’
                     I numbered_link(2)
                        A linkstr = link
                        I linkstr.len > 57
                           linkstr = linkstr[0 .< linkstr.rfindi(‘/’, 0, 47) + 1]‘...’
                        outfile.write(‘<a href="’link‘">[’instr[i + 3 .< endi]‘]<i>’linkstr‘</i></a>’)
                        i = endi + 1
                     E
                        i++
                        A endb = find_ending_sq_bracket(instr, i)
                        A linkn = ‘’
                        I instr[endb + 1 .< endb + 3] == ‘[-’
                           linkn = ‘[’instr[endb + 3 .< find_ending_sq_bracket(instr, endb + 1)]‘]’
                        link = instr[i + 1 .< endb]
                        A spacepos = link.findi(‘ ’)
                        I spacepos != -1
                           link = link[0 .< spacepos]
                        I link.len > 57
                           link = link[0 .< link.rfindi(‘/’, 0, 47) + 1]‘...’
                        write_http_link(i, i, 0, linkn‘<i>’link‘</i>’)
                        i++
                     I instr[i .< i + 2] != ":‘"
                        exit_with_error(‘Quotation with url should always has :‘...’ after [’link[0 .< link.findi(‘:’)]‘://url]’, i)
                     outfile.write(":<br />\n")
                     writepos = i + 2
                  E
                     A endqpos = find_ending_pair_quote(i + 1)
                     I instr[endqpos + 1 .< endqpos + 2] == ‘[’
                        A startqpos = i + 1
                        i = endqpos
                        outfile.write(‘<i>’)
                        write_http_link(startqpos, endqpos)
                        outfile.write(‘</i>’)
                        i++
                        I instr[i .< i + 2] != ":‘"
                           exit_with_error(‘Quotation with url should always has :‘...’ after [’link[0 .< link.findi(‘:’)]‘://url]’, i)
                        outfile.write(":<br />\n")
                        writepos = i + 2
                     E I instr[endqpos + 1 .< endqpos + 2] == ‘:’
                        outfile.write(‘<i>’instr[i + 2 .< endqpos]"</i>:<br />\n")
                        i = endqpos + 2
                        I instr[i .< i + 1] != "‘"
                           exit_with_error(‘Quotation with author's name should be in the form >‘Author's name’:‘Quoted text.’ (opening quotation mark not found after colon)’, i)
                        writepos = i + 1
                  ending_tags.append(‘</blockquote>’)
               i++

      I outfilef == N
         A r = result.join(‘’)
         I .habrahabr_html
            r = r.replace("</blockquote>\n", ‘</blockquote>’)
         R r
      R ‘’

F to_html(instr, File? outfilef = N, ohd = 0B, ', habrahabr_html = 0B)
   R Converter(habrahabr_html, ohd).to_html(instr, outfilef)

:start:
I ‘-h’ C :argv | ‘--help’ C :argv
   print(‘A Python implementation of pq markup to HTML converter.’)
   exit(0)
A args_habrahabr_html = ‘--habrahabr-html’ C :argv
A args_output_html_document = ‘--output-html-document’ C :argv
A args_infile = :stdin
A i = 1
L i < :argv.len
   I :argv[i] C (‘-f’, ‘--file’)
      i += 2
      L.continue
   I !:argv[i].starts_with(‘-’)
      args_infile = File(:argv[i], ‘r’, encoding' ‘utf-8’)
      L.break
   i++
A args_outfile = :stdout
I ‘-f’ C :argv
   args_outfile = File(:argv[:argv.index(‘-f’) + 1], ‘w’, encoding' ‘utf-8’)
E I ‘--file’ C :argv
   args_outfile = File(:argv[:argv.index(‘--file’) + 1], ‘w’, encoding' ‘utf-8’)

I args_output_html_document & args_habrahabr_html
   exit(‘Arguments --output-html-document and --habrahabr-html are mutually exclusive’)

X.try
   to_html(args_infile.read(), args_outfile, args_output_html_document, habrahabr_html' args_habrahabr_html)
X.catch Exception e
   :stderr.write(e.message‘ at line ’String(e.line)‘, column ’String(e.column)"\n")
   exit(-1)
===
Array<String> argv;

class Exception
{
public:
    String message;
    int line;
    int column;
    int pos;
    template <typename T1, typename T2, typename T3, typename T4> Exception(const T1 &message, const T2 &line, const T3 &column, const T4 &pos)
    {
        this->message = message;
        this->line = line;
        this->column = column;
        this->pos = pos;
    }
};

class Converter
{
public:
    Array<int> to_html_called_inside_to_html_outer_pos_list;
    bool habrahabr_html;
    bool ohd;
    String instr;

    template <typename T1, typename T2> Converter(const T1 &habrahabr_html, const T2 &ohd)
    {
        this->habrahabr_html = habrahabr_html;
        this->ohd = ohd;
    }

    template <typename T1> auto instr_pos_to_line_column(T1 pos)
    {
        pos += sum(to_html_called_inside_to_html_outer_pos_list);
        auto line = 1;
        auto line_start = -1;
        auto t = 0;
        while (t < pos) {
            if (instr[t] == u'\r') {
                if (t < pos - 1 && instr[t + 1] == u'\n')
                    t++;
                line++;
                line_start = t;
            }
            else if (instr[t] == u'\n') {
                line++;
                line_start = t;
            }
            t++;
        }
        return make_tuple(line, pos - line_start);
    }

    template <typename T1, typename T3 = decltype(0)> String to_html(const T1 &instr, File* const outfilef = nullptr, const T3 &outer_pos = 0)
    {
        to_html_called_inside_to_html_outer_pos_list.append(outer_pos);
        Array<String> result;
        class Writer
        {
        public:
            std::function<void(String)> write;
        };
        auto outfile = Writer();
        if (outfilef == nullptr)
            outfile.write = [&result](const auto &s){return result.append(s);};
        else
            outfile.write = [outfilef](const auto &s){return outfilef->write(s);};
        if (to_html_called_inside_to_html_outer_pos_list.len() == 1)
            this->instr = instr;

        auto exit_with_error = [this](const auto &message, const auto &pos)
        {
            auto p = instr_pos_to_line_column(pos);
            throw Exception(message, _get<0>(p), _get<1>(p), pos);
        };
        auto i = 0;
        auto next_char = [i, instr](const decltype(1) offset = 1)
        {
            return i + offset < instr.len() ? instr[i + offset] : _get<0>(u"\0"_S);
        };

        auto i_next_str = [i, instr](const auto &str)
        {
            return instr[range_el(i + 1, i + 1 + str.len())] == str;
        };

        auto prev_char = [i, instr](const decltype(1) offset = 1)
        {
            return i - offset >= 0 ? instr[i - offset] : _get<0>(u"\0"_S);
        };

        auto html_escape = [this](auto str)
        {
            str = str.replace(u"&"_S, u"&amp;"_S).replace(u"<"_S, u"&lt;"_S);
            if (habrahabr_html)
                str = str.replace(u"\""_S, u"&quot;"_S);
            return str;
        };
        auto html_escapeq = [](const auto &str)
        {
            return str.replace(u"&"_S, u"&amp;"_S).replace(u"\""_S, u"&quot;"_S);
        };
        auto writepos = 0;
        auto write_to_pos = [&writepos, html_escape, instr, outfile](const auto &pos, const auto &npos)
        {
            outfile.write(html_escape(instr[range_el(writepos, pos)]));
            writepos = npos;
        };

        auto write_to_i = [i, outfile, write_to_pos](const auto &add_str, const decltype(1) skip_chars = 1)
        {
            write_to_pos(i, i + skip_chars);
            outfile.write(add_str);
        };

        auto find_ending_pair_quote = [exit_with_error, instr](auto i)
        {
            assert(instr[i] == u'‘');
            auto startqpos = i;
            auto nesting_level = 0;
            while (true) {
                if (i == instr.len())
                    exit_with_error(u"Unpaired left single quotation mark"_S, startqpos);
                switch (instr[i])
                {
                case u'‘':
                    nesting_level++;
                    break;
                case u'’':
                    if (--nesting_level == 0)
                        return i;
                    break;
                }
                i++;
            }
        };

        auto find_ending_sq_bracket = [exit_with_error](const auto &str, auto i, const decltype(0) start = 0)
        {
            auto starti = i;
            assert(str[i] == u'[');
            auto nesting_level = 0;
            while (true) {
                switch (str[i])
                {
                case u'[':
                    nesting_level++;
                    break;
                case u']':
                    if (--nesting_level == 0)
                        return i;
                    break;
                }
                i++;
                if (i == str.len())
                    exit_with_error(u"Unended comment started"_S, start + starti);
            }
        };

        auto remove_comments = [find_ending_sq_bracket](auto s, auto start, const decltype(3) level = 3)
        {
            while (true) {
                auto j = s.findi(u"["_S * level);
                if (j == -1)
                    break;
                auto k = find_ending_sq_bracket(s, j, start) + 1;
                start += k - j;
                s = s[range_el(0, j)] + s[range_ei(k)];
            }
            return s;
        };
        Dict<int, String> nonunique_links;
        auto link = u""_S;

        auto write_http_link = [&i, &link, exit_with_error, find_ending_pair_quote, find_ending_sq_bracket, html_escape, html_escapeq, instr, next_char, nonunique_links, outfile, remove_comments, write_to_pos](const auto &startpos, const auto &endpos, const decltype(1) q_offset = 1, decltype(u""_S) text = u""_S)
        {
            auto nesting_level = 0;
            i += 2;
            while (true) {
                if (i == instr.len())
                    exit_with_error(u"Unended link"_S, endpos + q_offset);
                switch (instr[i])
                {
                case u'[':
                    nesting_level++;
                    break;
                case u']':
                    if (nesting_level == 0)
                        goto break_;
                    --nesting_level;
                    break;
                case u' ':
                    goto break_;
                    break;
                }
                i++;
            }
            break_:
            link = html_escapeq(instr[range_el(endpos + 1 + q_offset, i)]);
            String tag = u"<a href=\""_S + link + u"\""_S;
            if (link.starts_with(u"./"_S))
                tag += u" target=\"_self\""_S;

            if (instr[i] == u' ') {
                tag += u" title=\""_S;
                if (next_char() == u'‘') {
                    auto endqpos2 = find_ending_pair_quote(i + 1);
                    assert(instr[endqpos2 + 1] == u']');
                    tag += html_escapeq(remove_comments(instr[range_el(i + 2, endqpos2)], i + 2));
                    i = endqpos2 + 1;
                }
                else {
                    auto endb = find_ending_sq_bracket(instr, endpos + q_offset);
                    tag += html_escapeq(remove_comments(instr[range_el(i + 1, endb)], i + 1));
                    i = endb;
                }
                tag += u"\""_S;
            }
            if (next_char() == u'[' && next_char(2) == u'-') {
                auto j = i + 3;
                while (j < instr.len()) {
                    if (instr[j] == u']') {
                        nonunique_links.set(parse_int(instr[range_el(i + 3, j)]), link);
                        i = j;
                        break;
                    }
                    if (!instr[j].isdigit())
                        break;
                    j++;
                }
            }
            if (text == u"") {
                write_to_pos(startpos, i + 1);
                text = html_escape(instr[range_el(startpos + q_offset, endpos)]);
            }
            outfile.write(tag + u">"_S + (text != u"" ? text : link) + u"</a>"_S);
        };

        auto write_note = [&i, exit_with_error, find_ending_pair_quote, html_escape, html_escapeq, instr, outfile, remove_comments, write_to_pos](const auto &startpos, const auto &endpos, const decltype(1) q_offset = 1)
        {
            i += q_offset;
            auto endqpos2 = find_ending_pair_quote(i + 1);
            if (instr[endqpos2 + 1] != u']')
                exit_with_error(u"Bracket ] should follow after ’"_S, endqpos2 + 1);
            write_to_pos(startpos, endqpos2 + 2);
            outfile.write(u"<abbr title=\""_S + html_escapeq(remove_comments(instr[range_el(i + 2, endqpos2)], i + 2)) + u"\">"_S + html_escape(remove_comments(instr[range_el(startpos + q_offset, endpos)], startpos + q_offset)) + u"</abbr>"_S);
            i = endqpos2 + 1;
        };
        auto endi = 0;
        auto numbered_link = [&endi, &link, exit_with_error, i, instr, next_char, nonunique_links](const decltype(1) offset = 1)
        {
            if (next_char(offset) == u'-' && next_char(offset + 1).isdigit()) {
                auto j = i + offset + 1;
                while (j < instr.len()) {
                    if (instr[j] == u']') {
                        try
                        {
                            link = nonunique_links[parse_int(instr[range_el(i + offset + 1, j)])];
                        }
                        catch (const KeyError&)
                        {
                            exit_with_error(u"Link with such index was not declared previously"_S, i + offset + 1);
                        }
                        endi = j;
                        return true;
                    }
                    if (!instr[j].isdigit())
                        break;
                    j++;
                }
            }
            return false;
        };
        auto ordered_list_current_number = -1;
        auto close_ordered_list = [&ordered_list_current_number, write_to_i]()
        {
            if (ordered_list_current_number != -1) {
                write_to_i(u"</li>\n</ol>\n"_S, 0);
                ordered_list_current_number = -1;
            }
        };
        auto in_unordered_list = false;
        auto close_unordered_list = [&in_unordered_list, write_to_i]()
        {
            if (in_unordered_list) {
                write_to_i(u"</li>\n</ul>\n"_S, 0);
                in_unordered_list = false;
            }
        };
        Array<String> ending_tags;
        auto new_line_tag = u"\0"_S;

        while (i < instr.len()) {
            auto ch = instr[i];
            if (i == 0 || prev_char() == u'\n') {
                if (ch == u'.' && (in(next_char(), u" ‘"_S))) {
                    close_ordered_list();
                    auto s = u""_S;
                    if (!in_unordered_list) {
                        s = u"<ul>\n<li>"_S;
                        in_unordered_list = true;
                    }
                    else
                        s = u"</li>\n<li>"_S;
                    write_to_i(s);
                    new_line_tag = u""_S;
                    if (next_char() == u' ')
                        i++;
                    else {
                        auto endqpos = find_ending_pair_quote(i + 1);
                        outfile.write(to_html(instr[range_el(i + 2, endqpos)], nullptr, i + 2));
                        i = endqpos;
                    }
                    writepos = i + 1;
                }
                else {
                    close_unordered_list();
                    if (ch.isdigit()) {
                        auto j = i + 1;
                        while (j < instr.len()) {
                            if (!instr[j].isdigit())
                                break;
                            j++;
                        }
                        if (instr[range_el(j, j + 1)] == u'.' && in(instr[range_el(j + 1, j + 2)], make_tuple(u" "_S, u"‘"_S))) {
                            auto value = parse_int(instr[range_el(i, j)]);
                            auto s = u""_S;
                            if (ordered_list_current_number == -1) {
                                s = (value == 1 ? u"<ol>"_S : u"<ol start=\""_S + String(value) + u"\">"_S) + u"\n<li>"_S;
                                ordered_list_current_number = value;
                            }
                            else {
                                s = u"</li>\n"_S + (value == ordered_list_current_number + 1 ? u"<li>"_S : u"<li value=\""_S + String(value) + u"\">"_S);
                                ordered_list_current_number = value;
                            }
                            write_to_i(s);
                            new_line_tag = u""_S;
                            if (instr[j + 1] == u' ')
                                i = j + 1;
                            else {
                                auto endqpos = find_ending_pair_quote(j + 1);
                                outfile.write(to_html(instr[range_el(j + 2, endqpos)], nullptr, j + 2));
                                i = endqpos;
                            }
                            writepos = i + 1;
                        }
                        else
                            close_ordered_list();
                    }
                    else
                        close_ordered_list();
                }
                if (ch == u' ')
                    write_to_i(u"&emsp;"_S);
                else if (ch == u'-') {
                    if (i_next_str(u"--"_S)) {
                        auto j = i + 3;
                        while (true) {
                            if (j == instr.len() || instr[j] == u'\n') {
                                write_to_i(u"<hr />\n"_S);
                                i = j;
                                writepos = j + 1;
                                break;
                            }
                            if (instr[j] != u'-')
                                break;
                            j++;
                        }
                    }
                }
                else if (in(ch, make_tuple(u">"_S, u"<"_S)) && (in(next_char(), u" ‘["_S))) {
                    write_to_pos(i, i + 2);
                    outfile.write(u"<blockquote"_S + ((ch == u'<') * u" class=\"re\""_S) + u">"_S);
                    if (next_char() == u' ')
                        new_line_tag = u"</blockquote>"_S;
                    else {
                        if (next_char() == u'[') {
                            if (numbered_link(2)) {
                                auto linkstr = link;
                                if (linkstr.len() > 57)
                                    linkstr = linkstr[range_el(0, linkstr.rfindi(u"/"_S, 0, 47) + 1)] + u"..."_S;
                                outfile.write(u"<a href=\""_S + link + u"\">["_S + instr[range_el(i + 3, endi)] + u"]<i>"_S + linkstr + u"</i></a>"_S);
                                i = endi + 1;
                            }
                            else {
                                i++;
                                auto endb = find_ending_sq_bracket(instr, i);
                                auto linkn = u""_S;
                                if (instr[range_el(endb + 1, endb + 3)] == u"[-")
                                    linkn = u"["_S + instr[range_el(endb + 3, find_ending_sq_bracket(instr, endb + 1))] + u"]"_S;
                                link = instr[range_el(i + 1, endb)];
                                auto spacepos = link.findi(u" "_S);
                                if (spacepos != -1)
                                    link = link[range_el(0, spacepos)];
                                if (link.len() > 57)
                                    link = link[range_el(0, link.rfindi(u"/"_S, 0, 47) + 1)] + u"..."_S;
                                write_http_link(i, i, 0, linkn + u"<i>"_S + link + u"</i>"_S);
                                i++;
                            }
                            if (instr[range_el(i, i + 2)] != u":‘")
                                exit_with_error(u"Quotation with url should always has :‘...’ after ["_S + link[range_el(0, link.findi(u":"_S))] + u"://url]"_S, i);
                            outfile.write(u":<br />\n"_S);
                            writepos = i + 2;
                        }
                        else {
                            auto endqpos = find_ending_pair_quote(i + 1);
                            if (instr[range_el(endqpos + 1, endqpos + 2)] == u'[') {
                                auto startqpos = i + 1;
                                i = endqpos;
                                outfile.write(u"<i>"_S);
                                write_http_link(startqpos, endqpos);
                                outfile.write(u"</i>"_S);
                                i++;
                                if (instr[range_el(i, i + 2)] != u":‘")
                                    exit_with_error(u"Quotation with url should always has :‘...’ after ["_S + link[range_el(0, link.findi(u":"_S))] + u"://url]"_S, i);
                                outfile.write(u":<br />\n"_S);
                                writepos = i + 2;
                            }
                            else if (instr[range_el(endqpos + 1, endqpos + 2)] == u':') {
                                outfile.write(u"<i>"_S + instr[range_el(i + 2, endqpos)] + u"</i>:<br />\n"_S);
                                i = endqpos + 2;
                                if (instr[range_el(i, i + 1)] != u'‘')
                                    exit_with_error(u"Quotation with author's name should be in the form >‘Author's name’:‘Quoted text.’ (opening quotation mark not found after colon)"_S, i);
                                writepos = i + 1;
                            }
                        }
                        ending_tags.append(u"</blockquote>"_S);
                    }
                    i++;
                }
            }
        }

        if (outfilef == nullptr) {
            auto r = result.join(u""_S);
            if (habrahabr_html)
                r = r.replace(u"</blockquote>\n"_S, u"</blockquote>"_S);
            return r;
        }
        return u""_S;
    }
};

template <typename T1, typename T3 = decltype(false), typename T4 = decltype(false)> auto to_html(const T1 &instr, File* const outfilef = nullptr, const T3 &ohd = false, const T4 &habrahabr_html = false)
{
    return Converter(habrahabr_html, ohd).to_html(instr, outfilef);
}

int MAIN_WITH_ARGV()
{
    INIT_ARGV();

    if (in(u"-h"_S, ::argv) || in(u"--help"_S, ::argv)) {
        print(u"A Python implementation of pq markup to HTML converter."_S);
        exit(0);
    }
    auto args_habrahabr_html = in(u"--habrahabr-html"_S, ::argv);
    auto args_output_html_document = in(u"--output-html-document"_S, ::argv);
    auto args_infile = _stdin;
    auto i = 1;
    while (i < ::argv.len()) {
        if (in(::argv[i], make_tuple(u"-f"_S, u"--file"_S))) {
            i += 2;
            continue;
        }
        if (!::argv[i].starts_with(u"-"_S)) {
            args_infile = File(::argv[i], u"r"_S, u"utf-8"_S);
            break;
        }
        i++;
    }
    auto args_outfile = _stdout;
    if (in(u"-f"_S, ::argv))
        args_outfile = File(::argv[::argv.index(u"-f"_S) + 1], u"w"_S, u"utf-8"_S);
    else if (in(u"--file"_S, ::argv))
        args_outfile = File(::argv[::argv.index(u"--file"_S) + 1], u"w"_S, u"utf-8"_S);
    if (args_output_html_document && args_habrahabr_html)
        exit(u"Arguments --output-html-document and --habrahabr-html are mutually exclusive"_S);

    try
    {
        to_html(args_infile.read(), &args_outfile, args_output_html_document, args_habrahabr_html);
    }
    catch (const Exception& e)
    {
        _stderr.write(e.message + u" at line "_S + String(e.line) + u", column "_S + String(e.column) + u"\n"_S);
        exit(-1);
    }
}