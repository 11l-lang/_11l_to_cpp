import sys
from typing import List

class Exception(Exception):
    message : str
    line : int
    column : int
    pos : int
    def __init__(self, message, line, column, pos):
        self.message = message
        self.line = line
        self.column = column
        self.pos = pos

class Converter:
    to_html_called_inside_to_html_outer_pos_list : List[int]
    habrahabr_html : bool
    ohd : bool
    instr : str

    def __init__(self, habrahabr_html, ohd):
        self.to_html_called_inside_to_html_outer_pos_list = []
        #self.newline_chars = []
        self.habrahabr_html = habrahabr_html
        self.ohd = ohd

    def instr_pos_to_line_column(self, pos):
        pos += sum(self.to_html_called_inside_to_html_outer_pos_list)
        line = 1
        line_start = -1
        t = 0
        while t < pos:
            if self.instr[t] == "\r":
                if t < pos-1 and self.instr[t+1] == "\n":
                    t += 1
                line += 1
                line_start = t
            elif self.instr[t] == "\n":
                line += 1
                line_start = t
            t += 1
        return (line, pos - line_start)

    def to_html(self, instr, outfilef : IO[str] = None, *, outer_pos = 0):
        self.to_html_called_inside_to_html_outer_pos_list.append(outer_pos)

        result : List[str] = [] # this should be faster than using regular string
        class Writer:
            write : Callable[[str], None]
        outfile = Writer()
        if outfilef == None:
            outfile.write = lambda s: result.append(s)
        else:
            outfile.write = lambda s: outfilef.write(s)

        if len(self.to_html_called_inside_to_html_outer_pos_list) == 1:
            self.instr = instr

        def exit_with_error(message, pos):
            p = self.instr_pos_to_line_column(pos)
            raise Exception(message, p[0], p[1], pos)

        i = 0
        def next_char(offset = 1):
            return instr[i + offset] if i + offset < len(instr) else "\0"

        def i_next_str(str): # i_ — if_/is_
            #return i + len(str) <= len(instr) and instr[i:i+len(str)] == str
            return instr[i+1:i+1+len(str)] == str # first check is not necessarily in Python

        def prev_char(offset = 1):
            return instr[i - offset] if i - offset >= 0 else "\0"

        def html_escape(str):
            str = str.replace('&', '&amp;').replace('<', '&lt;')
            if self.habrahabr_html:
                str = str.replace('"', '&quot;') # нужно для корректного отображения кавычек в <a href="http://address">, так как habrahabr автоматически конвертирует "" в «»
            return str
        def html_escapeq(str):
            return str.replace('&', '&amp;').replace('"', '&quot;')

        writepos = 0
        def write_to_pos(pos, npos):
            nonlocal writepos
            outfile.write(html_escape(instr[writepos:pos]))
            writepos = npos

        def write_to_i(add_str, skip_chars = 1):
            write_to_pos(i, i+skip_chars)
            outfile.write(add_str)

        def find_ending_pair_quote(i): # ищет окончание ‘строки’
            assert(instr[i] == "‘") # ’
            startqpos = i
            nesting_level = 0
            while True:
                if i == len(instr):
                    exit_with_error('Unpaired left single quotation mark', startqpos)
                ch = instr[i]
                if ch == "‘":
                    nesting_level += 1
                elif ch == "’":
                    nesting_level -= 1
                    if nesting_level == 0:
                        return i
                i += 1

def to_html(instr, outfilef : IO[str] = None, ohd = False, *, habrahabr_html = False):
    return Converter(habrahabr_html, ohd).to_html(instr, outfilef)

if __name__ == '__main__':
    if '-h' in sys.argv or '--help' in sys.argv:
        print(R'''A Python implementation of pq markup to HTML converter.''')
        sys.exit(0)

    args_habrahabr_html       = '--habrahabr-html'       in sys.argv
    args_output_html_document = '--output-html-document' in sys.argv
    args_infile = sys.stdin
    i = 1
    while i < len(sys.argv):
        if sys.argv[i] in ('-f', '--file'):
            i += 2
            continue
        if not sys.argv[i].startswith('-'):
            args_infile = open(sys.argv[i], 'r', encoding = 'utf-8')
            break
        i += 1
    args_outfile = sys.stdout
    if '-f' in sys.argv:
        args_outfile = open(sys.argv[sys.argv.index('-f')     + 1], 'w', encoding = 'utf-8')
    elif '--file' in sys.argv:
        args_outfile = open(sys.argv[sys.argv.index('--file') + 1], 'w', encoding = 'utf-8')

    if args_output_html_document and args_habrahabr_html:
        sys.exit("Arguments --output-html-document and --habrahabr-html are mutually exclusive")

    try:
        to_html(args_infile.read(), args_outfile, args_output_html_document, habrahabr_html = args_habrahabr_html)
    except Exception as e:
        sys.stderr.write(e.message + " at line " + str(e.line) + ", column " + str(e.column) + "\n")
        sys.exit(-1)
===
//import sys

T Exception
   String message
   Int line
   Int column
   Int pos
   F (message, line, column, pos)
      .message = message
      .line = line
      .column = column
      .pos = pos

T Converter
   Array[Int] to_html_called_inside_to_html_outer_pos_list
   Bool habrahabr_html
   Bool ohd
   String instr

   F (habrahabr_html, ohd)
      .habrahabr_html = habrahabr_html
      .ohd = ohd

   F instr_pos_to_line_column(=pos)
      pos += sum(.to_html_called_inside_to_html_outer_pos_list)
      A line = 1
      A line_start = -1
      A t = 0
      L t < pos
         I .instr[t] == "\r"
            I t < pos - 1 & .instr[t + 1] == "\n"
               t++
            line++
            line_start = t
         E I .instr[t] == "\n"
            line++
            line_start = t
         t++
      R (line, pos - line_start)

   F to_html(instr, File? outfilef = N, ', outer_pos = 0)
      .to_html_called_inside_to_html_outer_pos_list.append(outer_pos)
      Array[String] result
      T Writer
         (String -> N) write
      A outfile = Writer()
      I outfilef == N
         outfile.write = s -> @result.append(s)
      E
         outfile.write = s -> @outfilef.write(s)

      I .to_html_called_inside_to_html_outer_pos_list.len == 1
         .instr = instr

      F exit_with_error(message, pos)
         A p = @.instr_pos_to_line_column(pos)
         X Exception(message, p[0], p[1], pos)
      A i = 0
      F next_char(offset = 1)
         R I @i + offset < @instr.len {@instr[@i + offset]} E "\0"

      F i_next_str(str)
         R @instr[@i + 1 .< @i + 1 + str.len] == str

      F prev_char(offset = 1)
         R I @i - offset >= 0 {@instr[@i - offset]} E "\0"

      F html_escape(=str)
         str = str.replace(‘&’, ‘&amp;’).replace(‘<’, ‘&lt;’)
         I @.habrahabr_html
            str = str.replace(‘"’, ‘&quot;’)
         R str
      F html_escapeq(str)
         R str.replace(‘&’, ‘&amp;’).replace(‘"’, ‘&quot;’)
      A writepos = 0
      F write_to_pos(pos, npos)
         @outfile.write(@html_escape(@instr[@writepos .< pos]))
         @writepos = npos

      F write_to_i(add_str, skip_chars = 1)
         @write_to_pos(@i, @i + skip_chars)
         @outfile.write(add_str)

      F find_ending_pair_quote(=i)
         assert(@instr[i] == "‘")
         A startqpos = i
         A nesting_level = 0
         L
            I i == @instr.len
               @exit_with_error(‘Unpaired left single quotation mark’, startqpos)
            S @instr[i]
               "‘"
                  nesting_level++
               "’"
                  I --nesting_level == 0
                     R i
            i++

F to_html(instr, File? outfilef = N, ohd = 0B, ', habrahabr_html = 0B)
   R Converter(habrahabr_html, ohd).to_html(instr, outfilef)

:start:
I ‘-h’ C :argv | ‘--help’ C :argv
   print(‘A Python implementation of pq markup to HTML converter.’)
   exit(0)
A args_habrahabr_html = ‘--habrahabr-html’ C :argv
A args_output_html_document = ‘--output-html-document’ C :argv
A args_infile = :stdin
A i = 1
L i < :argv.len
   I :argv[i] C (‘-f’, ‘--file’)
      i += 2
      L.continue
   I !:argv[i].starts_with(‘-’)
      args_infile = File(:argv[i], ‘r’, encoding' ‘utf-8’)
      L.break
   i++
A args_outfile = :stdout
I ‘-f’ C :argv
   args_outfile = File(:argv[:argv.index(‘-f’) + 1], ‘w’, encoding' ‘utf-8’)
E I ‘--file’ C :argv
   args_outfile = File(:argv[:argv.index(‘--file’) + 1], ‘w’, encoding' ‘utf-8’)

I args_output_html_document & args_habrahabr_html
   exit(‘Arguments --output-html-document and --habrahabr-html are mutually exclusive’)

X.try
   to_html(args_infile.read(), args_outfile, args_output_html_document, habrahabr_html' args_habrahabr_html)
X.catch Exception e
   :stderr.write(e.message‘ at line ’String(e.line)‘, column ’String(e.column)"\n")
   exit(-1)
===
Array<String> argv;

class Exception
{
public:
    String message;
    int line;
    int column;
    int pos;
    template <typename T1, typename T2, typename T3, typename T4> Exception(const T1 &message, const T2 &line, const T3 &column, const T4 &pos)
    {
        this->message = message;
        this->line = line;
        this->column = column;
        this->pos = pos;
    }
};

class Converter
{
public:
    Array<int> to_html_called_inside_to_html_outer_pos_list;
    bool habrahabr_html;
    bool ohd;
    String instr;

    template <typename T1, typename T2> Converter(const T1 &habrahabr_html, const T2 &ohd)
    {
        this->habrahabr_html = habrahabr_html;
        this->ohd = ohd;
    }

    template <typename T1> auto instr_pos_to_line_column(T1 pos)
    {
        pos += sum(to_html_called_inside_to_html_outer_pos_list);
        auto line = 1;
        auto line_start = -1;
        auto t = 0;
        while (t < pos) {
            if (instr[t] == u'\r') {
                if (t < pos - 1 && instr[t + 1] == u'\n')
                    t++;
                line++;
                line_start = t;
            }
            else if (instr[t] == u'\n') {
                line++;
                line_start = t;
            }
            t++;
        }
        return make_tuple(line, pos - line_start);
    }

    template <typename T1, typename T3 = decltype(0)> auto to_html(const T1 &instr, File* const outfilef = nullptr, const T3 &outer_pos = 0)
    {
        to_html_called_inside_to_html_outer_pos_list.append(outer_pos);
        Array<String> result;
        class Writer
        {
        public:
            std::function<void(String)> write;
        };
        auto outfile = Writer();
        if (outfilef == nullptr)
            outfile.write = [&result](const auto &s){return result.append(s);};
        else
            outfile.write = [outfilef](const auto &s){return outfilef->write(s);};
        if (to_html_called_inside_to_html_outer_pos_list.len() == 1)
            this->instr = instr;

        auto exit_with_error = [this](const auto &message, const auto &pos)
        {
            auto p = instr_pos_to_line_column(pos);
            throw Exception(message, _get<0>(p), _get<1>(p), pos);
        };
        auto i = 0;
        auto next_char = [i, instr](const auto &offset)
        {
            return i + offset < instr.len() ? instr[i + offset] : u"\0"_S;
        };

        auto i_next_str = [i, instr](const auto &str)
        {
            return instr[range_el(i + 1, i + 1 + str.len())] == str;
        };

        auto prev_char = [i, instr](const auto &offset)
        {
            return i - offset >= 0 ? instr[i - offset] : u"\0"_S;
        };

        auto html_escape = [this](auto str)
        {
            str = str.replace(u"&"_S, u"&amp;"_S).replace(u"<"_S, u"&lt;"_S);
            if (habrahabr_html)
                str = str.replace(u"\""_S, u"&quot;"_S);
            return str;
        };
        auto html_escapeq = [](const auto &str)
        {
            return str.replace(u"&"_S, u"&amp;"_S).replace(u"\""_S, u"&quot;"_S);
        };
        auto writepos = 0;
        auto write_to_pos = [&writepos, html_escape, instr, outfile](const auto &pos, const auto &npos)
        {
            outfile.write(html_escape(instr[range_el(writepos, pos)]));
            writepos = npos;
        };

        auto write_to_i = [i, outfile, write_to_pos](const auto &add_str, const auto &skip_chars)
        {
            write_to_pos(i, i + skip_chars);
            outfile.write(add_str);
        };

        auto find_ending_pair_quote = [exit_with_error, instr](auto i)
        {
            assert(instr[i] == u'‘');
            auto startqpos = i;
            auto nesting_level = 0;
            while (true) {
                if (i == instr.len())
                    exit_with_error(u"Unpaired left single quotation mark"_S, startqpos);
                switch (instr[i])
                {
                case u"‘"_S:
                    nesting_level++;
                    break;
                case u"’"_S:
                    if (--nesting_level == 0)
                        return i;
                    break;
                }
                i++;
            }
        };
    }
};

template <typename T1, typename T3 = decltype(false), typename T4 = decltype(false)> auto to_html(const T1 &instr, File* const outfilef = nullptr, const T3 &ohd = false, const T4 &habrahabr_html = false)
{
    return Converter(habrahabr_html, ohd).to_html(instr, outfilef);
}

int MAIN_WITH_ARGV()
{
    INIT_ARGV();

    if (in(u"-h"_S, ::argv) || in(u"--help"_S, ::argv)) {
        print(u"A Python implementation of pq markup to HTML converter."_S);
        exit(0);
    }
    auto args_habrahabr_html = in(u"--habrahabr-html"_S, ::argv);
    auto args_output_html_document = in(u"--output-html-document"_S, ::argv);
    auto args_infile = _stdin;
    auto i = 1;
    while (i < ::argv.len()) {
        if (in(::argv[i], make_tuple(u"-f"_S, u"--file"_S))) {
            i += 2;
            continue;
        }
        if (!::argv[i].starts_with(u"-"_S)) {
            args_infile = File(::argv[i], u"r"_S, u"utf-8"_S);
            break;
        }
        i++;
    }
    auto args_outfile = _stdout;
    if (in(u"-f"_S, ::argv))
        args_outfile = File(::argv[::argv.index(u"-f"_S) + 1], u"w"_S, u"utf-8"_S);
    else if (in(u"--file"_S, ::argv))
        args_outfile = File(::argv[::argv.index(u"--file"_S) + 1], u"w"_S, u"utf-8"_S);
    if (args_output_html_document && args_habrahabr_html)
        exit(u"Arguments --output-html-document and --habrahabr-html are mutually exclusive"_S);

    try
    {
        to_html(args_infile.read(), &args_outfile, args_output_html_document, args_habrahabr_html);
    }
    catch (const Exception& e)
    {
        _stderr.write(e.message + u" at line "_S + String(e.line) + u", column "_S + String(e.column) + u"\n"_S);
        exit(-1);
    }
}