import sys
from typing import List, IO, Callable, Dict
Char = str
import syntax_highlighter_for_pqmarkup

class Exception(Exception):
    message : str
    line : int
    column : int
    pos : int
    def __init__(self, message, line, column, pos):
        self.message = message
        self.line = line
        self.column = column
        self.pos = pos

class Converter:
    to_html_called_inside_to_html_outer_pos_list : List[int]
    habr_html : bool
    ohd : bool
    highlight_style_was_added = False
    instr : str

    def __init__(self, habr_html, ohd):
        self.to_html_called_inside_to_html_outer_pos_list = []
        #self.newline_chars = []
        self.habr_html = habr_html
        self.ohd = ohd

    def to_html(self, instr : str, outfilef : IO[str] = None, *, outer_pos = 0) -> str:
        self.to_html_called_inside_to_html_outer_pos_list.append(outer_pos)

        result : List[str] = [] # this should be faster than using regular string
        class Writer:
            write : Callable[[str], None]
        outfile = Writer()
        if outfilef is None:
            outfile.write = lambda s: result.append(s)
        else:
            outfile.write = lambda s: outfilef.write(s)

        # Сохраняем instr для определения номера строки по номеру символа
        if len(self.to_html_called_inside_to_html_outer_pos_list) == 1:
            self.instr = instr

        def exit_with_error(message, pos):
            pos += sum(self.to_html_called_inside_to_html_outer_pos_list)
            line = 1
            line_start = -1
            t = 0
            while t < pos:
                if self.instr[t] == "\n":
                    line += 1
                    line_start = t
                t += 1
            raise Exception(message, line, pos - line_start, pos)

        i = 0
        def next_char(offset = 1):
            return instr[i + offset] if i + offset < len(instr) else Char("\0")

        def i_next_str(str): # i_ — if_/is_
            #return i + len(str) <= len(instr) and instr[i:i+len(str)] == str
            return instr[i+1:i+1+len(str)] == str # first check is not necessarily in Python

        def prev_char(offset = 1):
            return instr[i - offset] if i - offset >= 0 else Char("\0")

        def html_escape(str):
            str = str.replace('&', '&amp;').replace('<', '&lt;')
            if self.habr_html:
                str = str.replace('"', '&quot;') # нужно для корректного отображения кавычек в <a href="http://address">, так как Habr автоматически конвертирует "" в «»
            return str
        def html_escapeq(str):
            return str.replace('&', '&amp;').replace('"', '&quot;')

        writepos = 0
        def write_to_pos(pos, npos):
            nonlocal writepos
            outfile.write(html_escape(instr[writepos:pos]))
            writepos = npos

        def write_to_i(add_str, skip_chars = 1):
            write_to_pos(i, i+skip_chars)
            outfile.write(add_str)

        def find_ending_pair_quote(i): # ищет окончание ‘строки’
            assert(instr[i] == "‘") # ’
            startqpos = i
            nesting_level = 0
            while True:
                if i == len(instr):
                    exit_with_error('Unpaired left single quotation mark', startqpos)
                ch = instr[i]
                if ch == "‘":
                    nesting_level += 1
                elif ch == "’":
                    nesting_level -= 1
                    if nesting_level == 0:
                        return i
                i += 1

        def find_ending_sq_bracket(str, i, start = 0):
            starti = i
            assert(str[i] == "[") # ]
            nesting_level = 0
            while True:
                ch = str[i]
                if ch == "[":
                    nesting_level += 1
                elif ch == "]":
                    nesting_level -= 1
                    if nesting_level == 0:
                        return i
                i += 1
                if i == len(str):
                    exit_with_error('Unended comment started', start + starti)

        def remove_comments(s : str, start, level = 3):
            while True:
                j = s.find("["*level) # ]
                if j == -1:
                    break
                k = find_ending_sq_bracket(s, j, start) + 1
                start += k - j
                s = s[0:j] + s[k:]
            return s

        nonunique_links : Dict[int, str] = {}
        link = ''

        def write_http_link(startpos, endpos : int, q_offset = 1, text = ''):
            nonlocal i, link
            # Ищем окончание ссылки
            nesting_level = 0
            i += 2
            while True:
                if i == len(instr):
                    exit_with_error('Unended link', endpos+q_offset)
                ch = instr[i]
                if ch == "[":
                    nesting_level += 1
                elif ch == "]":
                    if nesting_level == 0:
                        break
                    nesting_level -= 1
                elif ch == " ":
                    break
                i += 1

            link = html_escapeq(instr[endpos+1+q_offset:i])
            tag : str = '<a href="' + link + '"'
            if link.startswith('./'):
                tag += ' target="_self"'

            # Ищем альтернативный текст при такой записи: ссылка[http://... ‘альтернативный текст’]
            if instr[i] == " ":
                tag += ' title="'
                if next_char() == "‘": # [
                    endqpos2 = find_ending_pair_quote(i+1)
                    if instr[endqpos2+1] != ']': # [
                        exit_with_error('Expected `]` after `’`', endqpos2+1)
                    tag += html_escapeq(remove_comments(instr[i+2:endqpos2], i+2))
                    i = endqpos2 + 1
                else:
                    endb = find_ending_sq_bracket(instr, endpos+q_offset)
                    tag += html_escapeq(remove_comments(instr[i+1:endb], i+1))
                    i = endb
                tag += '"'
            if next_char() == '[' and next_char(2) == '-':
                j = i + 3
                while j < len(instr):
                    if instr[j] == ']':
                        nonunique_links[int(instr[i+3:j])] = link
                        i = j
                        break
                    if not instr[j].isdigit():
                        break
                    j += 1
            if text == '':
                write_to_pos(startpos, i+1)
                text = self.to_html(instr[startpos+q_offset:endpos], outer_pos = startpos+q_offset)
            outfile.write(tag + '>' + (text if text != '' else link) + '</a>')

        def write_note(startpos, endpos, q_offset = 1):
            nonlocal i
            i += q_offset
            endqpos2 = find_ending_pair_quote(i+1) # [[‘
            if instr[endqpos2+1] != ']':
                exit_with_error("Bracket ] should follow after ’", endqpos2+1)
            write_to_pos(startpos, endqpos2+2)
            outfile.write('<abbr title="'
                + html_escapeq(remove_comments(instr[i+2:endqpos2], i+2)) + '">'
                + html_escape(remove_comments(instr[startpos+q_offset:endpos], startpos+q_offset)) + '</abbr>')
            i = endqpos2 + 1

        endi = 0
        def numbered_link(offset = 1):
            if next_char(offset) == '-' and next_char(offset+1).isdigit():
                j = i + offset + 1
                while j < len(instr): # [
                    if instr[j] == ']':
                        nonlocal link
                        try:
                            link = nonunique_links[int(instr[i+offset+1:j])]
                        except KeyError:
                            exit_with_error("Link with such index was not declared previously", i+offset+1)
                        nonlocal endi
                        endi = j
                        return True
                    if not instr[j].isdigit():
                        break
                    j += 1
            return False

        ordered_list_current_number = -1
        def close_ordered_list():
            nonlocal ordered_list_current_number
            if ordered_list_current_number != -1:
                write_to_i("</li>\n</ol>\n", 0)
                ordered_list_current_number = -1

        in_unordered_list = False
        def close_unordered_list():
            nonlocal in_unordered_list
            if in_unordered_list:
                write_to_i("</li>\n</ul>\n", 0)
                in_unordered_list = False

        ending_tags : List[str] = []
        new_line_tag = "\0"

        while i < len(instr):
            ch = instr[i]
            if (i == 0 or prev_char() == "\n" # if beginning of line
                       or (i == writepos and len(ending_tags) != 0 and ending_tags[-1] in ('</blockquote>', '</div>') and instr[i-2:i] in ('>‘', '<‘', '!‘'))): # ’’’ # or beginning of blockquote or note
                if ch == '.' and (next_char() in ' ‘'): # ’ this is unordered list
                    close_ordered_list()
                    s = ''
                    if not in_unordered_list:
                        s = "<ul>\n<li>"
                        in_unordered_list = True
                    else:
                        s = "</li>\n<li>"
                    write_to_i(s)
                    new_line_tag = '' # используем тот факт, что разрыва строк в списках вида `. элемент списка` быть не может, и следующий символ \n будет либо закрывать список, либо обозначать начало следующего элемента списка
                    if next_char() == ' ':
                        i += 1
                    else:
                        endqpos = find_ending_pair_quote(i + 1)
                        outfile.write(self.to_html(instr[i+2:endqpos], outer_pos = i+2))
                        i = endqpos
                    writepos = i + 1
                else:
                    close_unordered_list()
                    if ch.isdigit():
                        j = i + 1
                        while j < len(instr):
                            if not instr[j].isdigit():
                                break
                            j += 1
                        if instr[j:j+1] == '.' and instr[j+1:j+2] in (' ', '‘'): # ’ this is ordered list
                            value = int(instr[i:j])
                            s = ''
                            if ordered_list_current_number == -1:
                                s = ('<ol>' if value == 1 else '<ol start="' + str(value) + '">') + "\n<li>"
                                ordered_list_current_number = value
                            else:
                                s = "</li>\n" + ("<li>" if value == ordered_list_current_number + 1 else '<li value="' + str(value) + '">')
                                ordered_list_current_number = value
                            write_to_i(s)
                            new_line_tag = '' # используем тот факт, что разрыва строк в списках вида `1. элемент списка` быть не может
                            if instr[j+1] == ' ':
                                i = j + 1
                            else:
                                endqpos = find_ending_pair_quote(j + 1)
                                outfile.write(self.to_html(instr[j+2:endqpos], outer_pos = j+2))
                                i = endqpos
                            writepos = i + 1
                        else:
                            close_ordered_list()
                    else:
                        close_ordered_list()

                if ch == ' ':
                    write_to_i('&emsp;')
                elif ch == '-': # horizontal rule
                    if i_next_str('--'):
                        j = i + 3
                        while True:
                            if j == len(instr) or instr[j] == "\n":
                                write_to_i("<hr />\n")
                                if j == len(instr):
                                    j -= 1
                                i = j
                                writepos = j + 1
                                break
                            if instr[j] != '-':
                                break
                            j += 1
                elif ch in ('>', '<') and (next_char() in ' ‘['): # this is blockquote # ]’
                    write_to_pos(i, i + 2)
                    outfile.write('<blockquote'+(ch=='<')*' class="re"'+'>')
                    if next_char() == ' ': # > Quoted text.
                        new_line_tag = '</blockquote>'
                    else:
                        if next_char() == '[': # ]
                            if numbered_link(2): # >[-1]:‘Quoted text.’
                                linkstr = link
                                if len(linkstr) > 57:
                                    linkstr = linkstr[:linkstr.rfind('/', 0, 47)+1] + '...'
                                outfile.write('<a href="' + link + '">[' + instr[i+3:endi] + ']<i>' + linkstr + '</i></a>')
                                i = endi + 1
                            else: # >[http...]:‘Quoted text.’ or >[http...][-1]:‘Quoted text.’
                                i += 1
                                endb = find_ending_sq_bracket(instr, i)
                                linkn = ''
                                if instr[endb+1:endb+3] == '[-': # ]
                                    linkn = '['+instr[endb+3:find_ending_sq_bracket(instr, endb+1)]+']'
                                link = instr[i + 1:endb]
                                spacepos = link.find(' ')
                                if spacepos != -1:
                                    link = link[:spacepos]
                                if len(link) > 57:
                                    link = link[:link.rfind('/', 0, 47)+1] + '...'
                                write_http_link(i, i, 0, linkn+'<i>'+link+'</i>') # this function changes `link` :o, but I left[‘I mean didn't rename it to `link_`’] it as is [at least for a while] because it still works correctly
                                i += 1
                            if instr[i:i+2] != ':‘': # ’
                                exit_with_error("Quotation with url should always has :‘...’ after ["+link[:link.find(':')]+"://url]", i)
                            outfile.write(":<br />\n")
                            writepos = i + 2
                        else:
                            endqpos = find_ending_pair_quote(i + 1)
                            if instr[endqpos+1:endqpos+2] == "[": # >‘Author's name’[http...]:‘Quoted text.’ # ]
                                startqpos = i + 1
                                i = endqpos
                                outfile.write('<i>')
                                assert(writepos == startqpos + 1)
                                writepos = startqpos
                                write_http_link(startqpos, endqpos)
                                outfile.write('</i>')
                                i += 1
                                if instr[i:i+2] != ':‘': # ’
                                    exit_with_error("Quotation with url should always has :‘...’ after ["+link[:link.find(':')]+"://url]", i)
                                outfile.write(":<br />\n")
                                writepos = i + 2
                            elif instr[endqpos+1:endqpos+2] == ":": # >‘Author's name’:‘Quoted text.’
                                outfile.write("<i>"+instr[i+2:endqpos]+"</i>:<br />\n")
                                i = endqpos + 1
                                if instr[i:i+2] != ':‘': # ’
                                    exit_with_error("Quotation with author's name should be in the form >‘Author's name’:‘Quoted text.’", i)
                                writepos = i + 2
                            # else this is just >‘Quoted text.’
                        ending_tags.append('</blockquote>')
                    i += 1

            if ch == "‘":
                prevci = i - 1
                prevc = instr[prevci] if prevci >= 0 else Char("\0")
                #assert(prevc == prev_char())
                startqpos = i
                i = find_ending_pair_quote(i)
                endqpos = i
                str_in_b = '' # (
                if prevc == ')':
                    openb = instr.rfind('(', 0, prevci - 1) # )
                    if openb != -1 and openb > 0:
                        str_in_b = instr[openb+1:startqpos-1]
                        prevci = openb - 1
                        prevc = instr[prevci]
                if prevc in 'PР': # Рисунок обрабатывается по-особенному
                    write_to_pos(prevci, endqpos + 1)
                    title = ''
                    endqpos2 : int
                    if i_next_str('[‘'): # альтернативный текст
                        endqpos2 = find_ending_pair_quote(i+2)
                        if instr[endqpos2+1] != ']': # [
                            exit_with_error('Expected `]` after `’`', endqpos2+1)
                        title = ' title="'+html_escapeq(remove_comments(instr[i+3:endqpos2], i+3))+'"'
                    imgtag = '<img'
                    if str_in_b != '':
                        wh = str_in_b.replace(',', ' ').split(' ')
                        assert(len(wh) in (1, 2))
                        imgtag += ' width="' + wh[0] + '" height="' + wh[-1] + '"'
                    imgtag += ' src="'+instr[startqpos+1:endqpos]+'"'+title+' />'
                    if i_next_str('[http') or i_next_str('[./'): # ]]
                        write_http_link(startqpos, endqpos, 1, imgtag)
                        writepos = i + 1
                    elif i_next_str('[‘'): # ’]
                        outfile.write(imgtag)
                        writepos = endqpos2 + 2
                        i = endqpos2 + 1
                    else:
                        outfile.write(imgtag)
                        i = endqpos
                elif i_next_str('[http') or i_next_str('[./'): # ]]
                    write_http_link(startqpos, endqpos)
                elif next_char() == '[' and numbered_link(2): # ]
                    i = endi
                    write_to_pos(startqpos, i+1)
                    outfile.write('<a href="' + link + '">' + html_escape(instr[startqpos+1:endqpos]) + '</a>')
                elif i_next_str('[‘'): # ’] сноска/альтернативный текст/текст всплывающей подсказки
                    write_note(startqpos, endqpos)
                elif next_char() == '{' and (self.habr_html or self.ohd):
                    # Ищем окончание спойлера }
                    nesting_level = 0
                    i += 2
                    while True:
                        if i == len(instr):
                            exit_with_error('Unended spoiler', endqpos+1)
                        ch = instr[i]
                        if ch == "{":
                            nesting_level += 1
                        elif ch == "}":
                            if nesting_level == 0:
                                break
                            nesting_level -= 1
                        i += 1
                    write_to_pos(prevci + 1, i + 1)
                    outer_p = endqpos+(3 if instr[endqpos+2] == "\n" else 2) # проверка на == "\n" нужна, чтобы переход на новую строку/перевод строки после `{` игнорировался
                    if self.habr_html:
                        outfile.write('<spoiler title="' + remove_comments(instr[startqpos+1:endqpos], startqpos+1).replace('"', "''") + '">\n' + self.to_html(instr[outer_p:i], outer_pos = outer_p) + "</spoiler>\n")
                    else:
                        outfile.write('<span class="spoiler_title" onclick="return spoiler2(this, event)">' + remove_comments(instr[startqpos+1:endqpos], startqpos+1) + '<br /></span>' # используется span, так как с div подчёркивание будет на весь экран
                            + '<div class="spoiler_text" style="display: none">\n' + self.to_html(instr[outer_p:i], outer_pos = outer_p) + "</div>\n")
                    if (next_char() == "\n" # чтобы переход на новую строку/перевод строки после `}` игнорировался
                            and not in_unordered_list and ordered_list_current_number == -1): # если находимся внутри списка, то пропуска новой строки делать не нужно
                        i += 1
                        writepos = i + 1
                elif prevc == "'": # raw [html] output
                    t = startqpos - 1
                    while t >= 0:
                        if instr[t] != "'":
                            break
                        t -= 1
                    eat_left = startqpos - 1 - t # количество кавычек, которые нужно съесть слева
                    t = endqpos + 1
                    while t < len(instr):
                        if instr[t] != "'":
                            break
                        t += 1
                    eat_right = t - (endqpos + 1) # количество кавычек, которые нужно съесть справа
                    write_to_pos(startqpos - eat_left, t)
                    outfile.write(instr[startqpos + eat_left:endqpos - eat_right + 1])
                elif prevc in '0OО':
                    write_to_pos(prevci, endqpos+1)
                    outfile.write(html_escape(instr[startqpos+1:endqpos]).replace("\n", "<br />\n"))
                elif prevc == "#":
                    ins = instr[startqpos+1:endqpos]
                    write_to_pos(prevci, endqpos+1)
                    if self.habr_html:
                        contains_new_line = "\n" in ins
                        outfile.write(('<source lang="' + str_in_b + '">' if str_in_b != '' else '<source>' if contains_new_line else '<code>') + ins + ("</source>" if str_in_b != '' or contains_new_line else "</code>")) # так как <source> в Habr — блочный элемент, а не встроенный\inline
                    else:
                        pre = '<pre ' + ('class="code_block"' if ins[0] == "\n" else 'style="display: inline"') + '>' # can not do `outfile.write('<pre ' + ...)` here because `outfile.write(syntax_highlighter_for_pqmarkup.css)` should be outside of <pre> block
                        if self.ohd and syntax_highlighter_for_pqmarkup.is_lang_supported(str_in_b):
                            if not self.highlight_style_was_added:
                                outfile.write(syntax_highlighter_for_pqmarkup.css)
                                self.highlight_style_was_added = True
                            try:
                                outfile.write(pre + syntax_highlighter_for_pqmarkup.highlight(str_in_b, ins) + '</pre>')
                            except syntax_highlighter_for_pqmarkup.Error as e:
                                exit_with_error('Syntax highlighter: ' + e.message, startqpos+1+e.pos)
                        else:
                            outfile.write(pre + html_escape(ins) + '</pre>') # в habr_html тег pre не стоит задействовать, так как в Habr для тега pre используется шрифт monospace, в котором символы ‘ и ’ выглядят непонятно (не так как в Courier New)
                    if ins[0] == "\n" and instr[i+1:i+2] == "\n":
                        outfile.write("\n")
                        new_line_tag = ''
                elif prevc in 'TТ':
                    write_to_pos(prevci, endqpos+1)
                    header_row = False
                    hor_row_align = ''
                    ver_row_align = ''

                    # Fill/prepare 2d-array `table`
                    class TableCell:
                        text  : str
                        attrs : str
                        def __init__(self, text : str, attrs : str): # type hints are needed to avoid this error in MSVC 2017: ‘error C2892: local class shall not have member templates’
                            self.text  = text
                            self.attrs = attrs
                    table : List[List[TableCell]] = []
                    j = startqpos + 1
                    while j < endqpos:
                        ch = instr[j]
                        if ch == "‘": # ’
                            empty_list : List[TableCell] = []
                            table.append(empty_list)
                            endrow = find_ending_pair_quote(j)
                            hor_col_align = ''
                            ver_col_align = ''

                            # Read table row
                            j += 1
                            while j < endrow:
                                ch = instr[j]
                                if ch == "‘": # ’
                                    end_of_column = find_ending_pair_quote(j)
                                    style = ""
                                    if hor_row_align != '' or hor_col_align != '':
                                        style += "text-align: " + (hor_col_align if hor_col_align != '' else hor_row_align)
                                    if ver_row_align != '' or ver_col_align != '':
                                        if style != "":
                                            style += "; "
                                        style += "vertical-align: " + (ver_col_align if ver_col_align != '' else ver_row_align)
                                    hor_col_align = ''
                                    ver_col_align = ''
                                    table[-1].append(TableCell(self.to_html(instr[j+1:end_of_column], outer_pos = j+1), ("th" if header_row else "td") + (' style="'+style+'"' if style != '' else '')))
                                    j = end_of_column
                                elif ch in '<>' and instr[j+1:j+2] in ('<', '>'):
                                    hor_col_align = {'<<':'left', '>>':'right', '><':'center', '<>':'justify'}[instr[j:j+2]]
                                    j += 1
                                elif instr[j:j+2] in ("/\\", "\\/"):
                                    ver_col_align = "top" if instr[j:j+2] == "/\\" else "bottom"
                                    j += 1
                                elif ch == "-":
                                    if len(table[-1]) == 0:
                                        exit_with_error('Wrong table column span marker "-"', j)
                                    table[-1].append(TableCell('', '-'))
                                elif ch == "|":
                                    if len(table) == 1:
                                        exit_with_error('Wrong table row span marker "|"', j)
                                    table[-1].append(TableCell('', '|'))
                                elif instr[j:j+3] == "[[[": # ]]]
                                    j = find_ending_sq_bracket(instr, j)
                                elif ch not in "  \t\n":
                                    exit_with_error('Unknown formatting character inside table row', j)
                                j += 1

                            header_row = False
                            hor_row_align = ''
                            ver_row_align = ''
                        elif ch in 'HН':
                            header_row = True
                        elif ch in '<>' and instr[j+1:j+2] in ('<', '>'):
                            hor_row_align = {'<<':'left', '>>':'right', '><':'center', '<>':'justify'}[instr[j:j+2]]
                            j += 1
                        elif instr[j:j+2] in ("/\\", "\\/"):
                            ver_row_align = "top" if instr[j:j+2] == "/\\" else "bottom"
                            j += 1
                        elif instr[j:j+3] == "[[[": # ]]]
                            j = find_ending_sq_bracket(instr, j)
                        elif ch not in "  \t\n":
                            exit_with_error('Unknown formatting character inside table', j)

                        j += 1

                    # Process column and row spans (walk in the reverse order — from bottom right corner of the table)
                    for y in range(len(table)-1, -1, -1):
                        for x in range(len(table[y])-1, -1, -1):
                            if table[y][x].attrs in ('-', '|'):
                                xx = x
                                yy = y
                                while True:
                                    if table[yy][xx].attrs == '-':
                                        xx -= 1
                                    elif table[yy][xx].attrs == '|':
                                        yy -= 1
                                    else:
                                        break
                                if xx < x:
                                    table[yy][xx].attrs += ' colspan="'+str(x-xx+1)+'"'
                                if yy < y:
                                    table[yy][xx].attrs += ' rowspan="'+str(y-yy+1)+'"'
                                for xxx in range(xx, x+1): # mark a whole rect of this merged cell as processed to avoid its further processing (in this loop) and to skip it at output table loop
                                    for yyy in range(yy, y+1):
                                        if (xxx, yyy) != (xx, yy):
                                            table[yyy][xxx].attrs = ''

                    # Output table
                    is_inline = True
                    if (prevci == 0 or
                        instr[prevci-1] == "\n" or # [[[
                       (prevci-3 >= 0 and instr[prevci-3:prevci] == ']]]' and instr[0:3] == '[[[' and find_ending_sq_bracket(instr, 0) == prevci-1)): # ]]]
                        is_inline = False
                    outfile.write("<table"+' style="display: inline"'*is_inline+">\n")
                    for row in table:
                        outfile.write("<tr>")
                        for cell in row:
                            if cell.attrs != '': # if this is a merged cell (cell.attrs == '') — skip it
                                outfile.write('<' + cell.attrs + '>' + cell.text + '</' + cell.attrs[:2] + '>')
                        outfile.write("</tr>\n")
                    outfile.write("</table>\n")
                    if not is_inline:
                        new_line_tag = ''
                elif prevc in '<>' and instr[prevci-1] in '<>': # выравнивание текста \ text alignment
                    write_to_pos(prevci-1, endqpos+1)
                    outfile.write('<div align="' + {'<<':'left', '>>':'right', '><':'center', '<>':'justify'}[instr[prevci-1]+prevc] + '">'
                                 + self.to_html(instr[startqpos+1:endqpos], outer_pos = startqpos+1) + "</div>\n")
                    new_line_tag = ''
                elif i_next_str(":‘") and instr[find_ending_pair_quote(i+2)+1:][:1] == '<': # this is reversed quote ‘Quoted text.’:‘Author's name’< # ’
                    endrq = find_ending_pair_quote(i+2)
                    i = endrq + 1
                    write_to_pos(prevci + 1, i + 1)
                    outfile.write('<blockquote>' + self.to_html(instr[startqpos+1:endqpos], outer_pos = startqpos+1) + "<br />\n<div align='right'><i>" + instr[endqpos+3:endrq] + "</i></div></blockquote>")
                    new_line_tag = ''
                else:
                    i = startqpos # откатываем позицию обратно
                    if prev_char() in '*_-~':
                        write_to_pos(i - 1, i + 1)
                        tag = {'*':'b', '_':'u', '-':'s', '~':'i'}[prev_char()]
                        outfile.write('<' + tag + '>')
                        ending_tags.append('</' + tag + '>')
                    elif prevc in 'HН':
                        write_to_pos(prevci, i + 1)
                        tag = 'h' + str(min(max(3 - (0 if str_in_b == '' else int(str_in_b)), 1), 6))
                        outfile.write('<' + tag + '>')
                        ending_tags.append('</' + tag + '>')
                    elif prevc in 'CС':
                        write_to_pos(prevci, i + 1)
                        which_color = 'color'
                        if str_in_b[0:1] == '-':
                            str_in_b = str_in_b[1:]
                            which_color = 'background-color'
                        if str_in_b[0:1] == '#':
                            new_str_in_b = ''
                            for c in str_in_b:
                                cc = {'а':'A','б':'B','с':'C','д':'D','е':'E','ф':'F'}.get(c.lower(), c)[0]
                                new_str_in_b += cc.lower() if c.islower() else cc
                            str_in_b = new_str_in_b
                        elif len(str_in_b) in (1, 3) and str_in_b.isdigit():
                            new_str = "#"
                            for ii in [0, 1, 2] if len(str_in_b) == 3 else [0, 0, 0]:
                                new_str += hex((int(str_in_b[ii]) * 0xFF + 4) // 8)[2:].upper().zfill(2) # 8 - FF, 0 - 00, 4 - 80 (почему не 7F[‘когда `+ 3` вместо `+ 4`’] — две субъективные причины: 1.‘больше нравится как выглядит’ и 2.‘количество пикселей в строке `80` при `"font_face": "Courier New", "font_size": 10`’)
                            str_in_b = new_str
                        if self.habr_html:
                            outfile.write('<font color="' + str_in_b + '">')
                            ending_tags.append('</font>')
                        else: # The <font> tag is not supported in HTML5.
                            outfile.write('<span style="'+which_color+': ' + str_in_b + '">')
                            ending_tags.append('</span>')
                    elif (instr[prevci-1:prevci], prevc) in (('/', "\\"), ("\\", '/')):
                        write_to_pos(prevci-1, i + 1)
                        tag = 'sup' if (instr[prevci-1], prevc) == ('/', "\\") else 'sub'
                        outfile.write('<' + tag + '>')
                        ending_tags.append('</' + tag + '>')
                    elif prevc == '!':
                        write_to_pos(prevci, i + 1)
                        outfile.write('<blockquote>' if self.habr_html else '<div class="note">')
                        ending_tags.append('</blockquote>' if self.habr_html else '</div>')
                    else: # ‘
                        ending_tags.append('’')
            elif ch == "’":
                write_to_pos(i, i + 1)
                if len(ending_tags) == 0:
                    exit_with_error('Unpaired right single quotation mark', i)
                last = ending_tags.pop()
                outfile.write(last)
                if next_char() == "\n" and (last.startswith('</h') or last in ('</blockquote>', '</div>')): # так как <h.> - блоковый элемент, то он автоматически завершает строку, поэтому лишний тег <br> в этом случае добавлять не нужно (иначе получится лишняя пустая строка после заголовка)
                    outfile.write("\n")
                    i += 1
                    writepos += 1
            elif ch == '`':
                # Сначала считаем количество символов ` — это определит границу, где находится окончание span of code
                start = i
                i += 1
                while i < len(instr):
                    if instr[i] != '`':
                        break
                    i += 1
                end = instr.find((i - start)*'`', i)
                if end == -1:
                    exit_with_error('Unended ` started', start)
                write_to_pos(start, end + i - start)
                ins = instr[i:end]
                delta = ins.count("‘") - ins.count("’") # в `backticks` могут быть ‘кавычки’ и в [[[комментариях]]] (выглядит это, например, так: [[[‘]]]`Don’t`), для этого и нужны
                if delta > 0: # эти строки кода[:backticks]
                    for ii in range(delta): # ‘‘
                        ending_tags.append('’')
                else:
                    for ii in range(-delta):
                        if ending_tags.pop() != '’':
                            exit_with_error('Unpaired single quotation mark found inside code block/span beginning', start)
                ins = html_escape(ins)
                if not "\n" in ins: # this is a single-line code -‘block’span
                    outfile.write('<code>' + ins + '</code>' if self.habr_html else '<pre class="inline_code">' + ins + '</pre>')
                else:
                    outfile.write('<pre>' + ins + '</pre>' + "\n"*(not self.habr_html))
                    new_line_tag = ''
                i = end + i - start - 1
            elif ch == '[': # ]
                if i_next_str('http') or i_next_str('./') or (i_next_str('‘') and prev_char() not in "\r\n\t \0") or numbered_link(): # ’
                    s = i - 1
                    while s >= writepos and instr[s] not in "\r\n\t [{(‘“": # ”’)}]
                        s -= 1
                    if i_next_str('‘'): # ’ сноска/альтернативный текст/текст всплывающей подсказки
                        write_note(s + 1, i, 0)
                    elif i_next_str('http') or i_next_str('./'):
                        write_http_link(s + 1, i, 0)
                    else:
                        write_to_pos(s + 1, endi+1)
                        outfile.write('<a href="' + link + '">' + html_escape(instr[s+1:i]) + '</a>')
                        i = endi
                elif i_next_str('[['): # ]] comment
                    comment_start = i
                    nesting_level = 0
                    while True:
                        ch = instr[i]
                        if ch == "[":
                            nesting_level += 1
                        elif ch == "]":
                            nesting_level -= 1
                            if nesting_level == 0:
                                break
                        elif ch == "‘": # [backticks:]а также эти строки кода
                            ending_tags.append('’') # ‘‘
                        elif ch == "’":
                            assert(ending_tags.pop() == '’')
                        i += 1
                        if i == len(instr):
                            exit_with_error('Unended comment started', comment_start)
                    write_to_pos(comment_start, i+1)
                    if instr[comment_start+3:comment_start+4] != '[': # это [[[такой]]] комментарий, а не [[[[такой]]]] или [[[[[такой и [[[[[[так далее]]]]]]]]]]], а [[[такие]]] комментарии следует транслировать в HTML: <!--[[[комментарий]...]...]-->
                        outfile.write('<!--')
                        outfile.write(remove_comments(instr[comment_start:i+1], comment_start, 4)) # берётся вся строка вместе со [[[скобочками]]] для [[[таких] ситуаций]]
                        outfile.write('-->')
                else:
                    write_to_i('<span class="sq"><span class="sq_brackets">'*self.ohd + '<font color="#BFBFBF">'*self.habr_html + '[' + '</font><font color="gray">'*self.habr_html + self.ohd*'</span>')
            elif ch == "]":
                write_to_i('<span class="sq_brackets">'*self.ohd + '</font><font color="#BFBFBF">'*self.habr_html + ']' + '</font>'*self.habr_html + self.ohd*'</span></span>')
            elif ch == "{":
                write_to_i('<span class="cu_brackets" onclick="return spoiler(this, event)"><span class="cu_brackets_b">'*self.ohd + '{' + self.ohd*'</span><span>…</span><span class="cu" style="display: none">')
            elif ch == "}":
                write_to_i('</span><span class="cu_brackets_b">'*self.ohd + '}' + self.ohd*'</span></span>')
            elif ch == "\n":
                write_to_i((new_line_tag if new_line_tag != "\0" else "<br />") + ("\n" if new_line_tag != '' else "")) # код `"\n" if new_line_tag != ''` нужен только для списков (unordered/ordered list)
                new_line_tag = "\0"

            i += 1

        close_ordered_list()
        close_unordered_list()

        write_to_pos(len(instr), 0)
        assert(len(ending_tags) == 0) # ‘слишком много открывающих одинарных кавычек’/‘где-то есть незакрытая открывающая кавычка’

        assert(self.to_html_called_inside_to_html_outer_pos_list.pop() == outer_pos)

        if outfilef is None:
            r = "".join(result)
            if self.habr_html:                                    # // dirty hack
                r = r.replace("</blockquote>\n", '</blockquote>') # \\ (just left it as is)
            return r

        return ''

def to_html(instr, outfilef : IO[str] = None, ohd = False, *, habr_html = False):
    return Converter(habr_html, ohd).to_html(instr, outfilef)

if __name__ == '__main__':
    # Support running module as a command line command.
    if '-h' in sys.argv or '--help' in sys.argv:
        print(R'''A Python implementation of pq markup to HTML converter.

Usage: pqmarkup [options] [INPUTFILE]

Positional arguments:
  INPUT_FILE            input file (STDIN is assumed if no INPUT_FILE is
                        given)

Options:
  -h, --help            show this help message and exit
  --habr-html           for publishing posts on habr.com
  --output-html-document
                        add some html header for rough testing preview of your
                        converted documents
  -f [OUTPUT_FILE], --file [OUTPUT_FILE]
                        write output to OUTPUT_FILE (defaults to STDOUT)''')
        sys.exit(0)

    args_habr_html            = '--habr-html'            in sys.argv
    args_output_html_document = '--output-html-document' in sys.argv
    args_infile = sys.stdin
    i = 1
    while i < len(sys.argv):
        if sys.argv[i] in ('-f', '--file'):
            i += 2
            continue
        if not sys.argv[i].startswith('-'):
            try:
                args_infile = open(sys.argv[i], 'r', encoding = 'utf-8-sig')
            except:
                sys.exit("Can't open file '" + sys.argv[i] + "'")
            break
        i += 1
    args_outfile = sys.stdout
    outfile_name : str
    try:
        if '-f' in sys.argv:
            outfile_name = sys.argv[sys.argv.index('-f')     + 1]
            args_outfile = open(outfile_name, 'w', encoding = 'utf-8', newline = "\n")
        elif '--file' in sys.argv:
            outfile_name = sys.argv[sys.argv.index('--file') + 1]
            args_outfile = open(outfile_name, 'w', encoding = 'utf-8', newline = "\n")
    except:
        sys.exit("Can't open file '" + outfile_name + "' for writing")

    if args_output_html_document and args_habr_html:
        sys.exit("Options --output-html-document and --habr-html are mutually exclusive")

    infile_str : str
    try:
        infile_str = args_infile.read()
    except UnicodeDecodeError:
        sys.exit('Input is not a valid UTF-8!')
    title = ''
    if infile_str.startswith('[[[H‘') or \
       infile_str.startswith('[[[Н‘'): # ’]]]’]]]
        i = 5
        nesting_level = 1
        while i < len(infile_str):
            ch = infile_str[i]
            if ch == "‘":
                nesting_level += 1
            elif ch == "’":
                nesting_level -= 1
                if nesting_level == 0:
                    break
            i += 1
        title = infile_str[5:i]

    if args_output_html_document:
        args_outfile.write(
R'''<html>
<head>
<meta charset="utf-8" />
''' + ('<title>' + title + "</title>\n" if title != '' else '') + R'''<base target="_blank">
<script type="text/javascript">
function spoiler(element, event)
{
    if (event.target.nodeName == 'A' || event.target.parentNode.nodeName == 'A' || event.target.onclick)//чтобы работали ссылки в спойлерах и спойлеры2 в спойлерах
        return;
    var e = element.firstChild.nextSibling.nextSibling;//element.getElementsByTagName('span')[0]
    e.previousSibling.style.display = e.style.display;//<span>…</span> must have inverted display style
    e.style.display = (e.style.display == "none" ? "" : "none");
    element.firstChild.style.fontWeight =
    element. lastChild.style.fontWeight = (e.style.display == "" ? "normal" : "bold");
    event.stopPropagation();
    //[-Чтобы была возможность выделять текст внутри раскрытого ‘скрытого текста’/спойлера, необходимо [скрытие/]закрытие спойлера делать не просто по нажатию левой кнопки мыши, а по отпусканию левой кнопки мыши при условии отсутствия движения курсора [мыши] после того, как была нажата левая кнопка мыши.-]
}
function spoiler2(element, event)
{
    element.nextSibling.style.display = (element.nextSibling.style.display == "none" ? "" : "none");
}
</script>
<style type="text/css">
div#main, td {
    font-size: 14px;
    font-family: Verdana, sans-serif;
    line-height: 160%;
    text-align: justify;
}
span.cu_brackets_b {
    font-size: initial;
    font-family: initial;
    font-weight: bold;
}
a {
    text-decoration: none;
    color: #6da3bd;
}
a:hover {
    text-decoration: underline;
    color: #4d7285;
}
h1, h2, h3, h4, h5, h6 {
    margin: 0;
    font-weight: 400;
}
h1 {font-size: 200%; line-height: 130%;}
h2 {font-size: 180%; line-height: 135%;}
h3 {font-size: 160%; line-height: 140%;}
h4 {font-size: 145%; line-height: 145%;}
h5 {font-size: 130%; line-height: 140%;}
h6 {font-size: 120%; line-height: 140%;}
span.sq {color: gray; font-size: 0.8rem; font-weight: normal; /*pointer-events: none;*/}
span.sq_brackets {color: #BFBFBF;}
span.cu_brackets {cursor: pointer;}
span.cu {background-color: #F7F7FF;}
abbr {text-decoration: none; border-bottom: 1px dotted;}
pre {margin: 0;}''' + # когда везде использовался <pre style="display: inline">, то margin в таких блоках не учитывался, поэтому и без этой строки с `pre {margin: 0}` код выглядел также как с этой строкой выглядят `<pre>` без `style="display: inline"`; но, вообще говоря, я добавил эту строку для соответствия форматированию Habr
'''
pre, code {font-family: 'Courier New'; line-height: normal}
ul, ol {margin: 11px 0 7px 0;}
ul li, ol li {padding: 7px 0;}
ul li:first-child, ol li:first-child {padding-top   : 0;}
ul  li:last-child, ol  li:last-child {padding-bottom: 0;}
table {margin: 9px 0; border-collapse: collapse;}
table th, table td {padding: 6px 13px; border: 1px solid #BFBFBF;}
span.spoiler_title {
    color: #548eaa;
    cursor: pointer;
    border-bottom: 1px dotted;
}
div.spoiler_text {
    /*border: 1px dotted;*/
    margin: 5px;
    padding: 3px;
}
blockquote {
    margin: 0 0 7px 0;
    padding: 7px 12px;
}
blockquote:not(.re) {border-left:  0.2em solid #90ddaa; background-color: #fbfffb;}
blockquote.re       {border-right: 0.2em solid #90ddaa; background-color: #f4fff8;}
div.note {
    padding: 18px 20px;
    background: #ffffd7;
}
pre.code_block {padding: 6px 0;}
pre.inline_code {
    display: inline;
    padding: 0px 3px;
    border: 1px solid #E5E5E5;
    background-color: #FAFAFA;
    border-radius: 3px;
}
img {vertical-align: middle;}

div#main {width: 100%;}
@media screen and (min-width: 1050px) {
    div#main {width: 1024px;}
}
</style>
</head>
<body>
<div id="main" style="margin: 0 auto">
''')
    try:
        to_html(infile_str, args_outfile, args_output_html_document, habr_html = args_habr_html)
    except Exception as e:
        sys.stderr.write(e.message + " at line " + str(e.line) + ", column " + str(e.column) + "\n")
        sys.exit(-1)
    if args_output_html_document:
        args_outfile.write(
'''</div>
</body>
</html>''')
===
T Exception
   String message
   Int line
   Int column
   Int pos
   F (message, line, column, pos)
      .message = message
      .line = line
      .column = column
      .pos = pos

T Converter
   [Int] to_html_called_inside_to_html_outer_pos_list
   Bool habr_html
   Bool ohd
   highlight_style_was_added = 0B
   String instr

   F (habr_html, ohd)

      .habr_html = habr_html
      .ohd = ohd

   F to_html(String instr, File? outfilef = N; ', outer_pos = 0) -> String
      .to_html_called_inside_to_html_outer_pos_list.append(outer_pos)

      [String] result
      T Writer
         (String -> N) write
      V outfile = Writer()
      I outfilef == N
         outfile.write = s -> @result.append(s)
      E
         outfile.write = s -> @outfilef.write(s)

      I .to_html_called_inside_to_html_outer_pos_list.len == 1
         .instr = instr

      F exit_with_error(message, =pos)
         pos += sum(@.to_html_called_inside_to_html_outer_pos_list)
         V line = 1
         V line_start = -1
         V t = 0
         L t < pos
            I @.instr[t] == "\n"
               line++
               line_start = t
            t++
         X Exception(message, line, pos - line_start, pos)

      V i = 0
      F next_char(offset = 1)
         R I @i + offset < @instr.len {@instr[@i + offset]} E Char("\0")

      F i_next_str(str)
         R @instr[@i + 1 .< @i + 1 + str.len] == str

      F prev_char(offset = 1)
         R I @i - offset >= 0 {@instr[@i - offset]} E Char("\0")

      F html_escape(=str)
         str = str.replace(‘&’, ‘&amp;’).replace(‘<’, ‘&lt;’)
         I @.habr_html
            str = str.replace(‘"’, ‘&quot;’)
         R str
      F html_escapeq(str)
         R str.replace(‘&’, ‘&amp;’).replace(‘"’, ‘&quot;’)

      V writepos = 0
      F write_to_pos(pos, npos)
         @outfile.write(@html_escape(@instr[@writepos .< pos]))
         @writepos = npos

      F write_to_i(add_str, skip_chars = 1)
         @write_to_pos(@i, @i + skip_chars)
         @outfile.write(add_str)

      F find_ending_pair_quote(=i)
         assert(@instr[i] == "‘")
         V startqpos = i
         V nesting_level = 0
         L
            I i == @instr.len
               @exit_with_error(‘Unpaired left single quotation mark’, startqpos)
            S @instr[i]
               "‘"
                  nesting_level++
               "’"
                  I --nesting_level == 0
                     R i
            i++

      F find_ending_sq_bracket(str, =i, start = 0)
         V starti = i
         assert(str[i] == ‘[’)
         V nesting_level = 0
         L
            S str[i]
               ‘[’
                  nesting_level++
               ‘]’
                  I --nesting_level == 0
                     R i
            i++
            I i == str.len
               @exit_with_error(‘Unended comment started’, start + starti)

      F remove_comments(String =s; =start, level = 3)
         L
            V j = s.findi(‘[’ * level)
            I j == -1
               L.break
            V k = @find_ending_sq_bracket(s, j, start) + 1
            start += k - j
            s = s[0 .< j]‘’s[k ..]
         R s

      [Int = String] nonunique_links
      V link = ‘’

      F write_http_link(startpos, Int endpos; q_offset = 1, =text = ‘’)

         V nesting_level = 0
         @i += 2
         L
            I @i == @instr.len
               @exit_with_error(‘Unended link’, endpos + q_offset)
            S @instr[@i]
               ‘[’
                  nesting_level++
               ‘]’
                  I nesting_level == 0
                     L.break
                  nesting_level--
               ‘ ’
                  L.break
            @i++

         @link = @html_escapeq(@instr[endpos + 1 + q_offset .< @i])
         String tag = ‘<a href="’@link‘"’
         I @link.starts_with(‘./’)
            tag ‘’= ‘ target="_self"’

         I @instr[@i] == ‘ ’
            tag ‘’= ‘ title="’
            I @next_char() == "‘"
               V endqpos2 = @find_ending_pair_quote(@i + 1)
               I @instr[endqpos2 + 1] != ‘]’
                  @exit_with_error("Expected `]` after `’`", endqpos2 + 1)
               tag ‘’= @html_escapeq(@remove_comments(@instr[@i + 2 .< endqpos2], @i + 2))
               @i = endqpos2 + 1
            E
               V endb = @find_ending_sq_bracket(@instr, endpos + q_offset)
               tag ‘’= @html_escapeq(@remove_comments(@instr[@i + 1 .< endb], @i + 1))
               @i = endb
            tag ‘’= ‘"’
         I @next_char() == ‘[’ & @next_char(2) == ‘-’
            V j = @i + 3
            L j < @instr.len
               I @instr[j] == ‘]’
                  @nonunique_links[Int(@instr[@i + 3 .< j])] = @link
                  @i = j
                  L.break
               I !@instr[j].is_digit()
                  L.break
               j++
         I text == ‘’
            @write_to_pos(startpos, @i + 1)
            text = @.to_html(@instr[startpos + q_offset .< endpos], outer_pos' startpos + q_offset)
         @outfile.write(tag‘>’(I text != ‘’ {text} E @link)‘</a>’)

      F write_note(startpos, endpos, q_offset = 1)
         @i += q_offset
         V endqpos2 = @find_ending_pair_quote(@i + 1)
         I @instr[endqpos2 + 1] != ‘]’
            @exit_with_error("Bracket ] should follow after ’", endqpos2 + 1)
         @write_to_pos(startpos, endqpos2 + 2)
         @outfile.write(‘<abbr title="’@html_escapeq(@remove_comments(@instr[@i + 2 .< endqpos2], @i + 2))‘">’@html_escape(@remove_comments(@instr[startpos + q_offset .< endpos], startpos + q_offset))‘</abbr>’)
         @i = endqpos2 + 1

      V endi = 0
      F numbered_link(offset = 1)
         I @next_char(offset) == ‘-’ & @next_char(offset + 1).is_digit()
            V j = @i + offset + 1
            L j < @instr.len
               I @instr[j] == ‘]’
                  X.try
                     @link = @nonunique_links[Int(@instr[@i + offset + 1 .< j])]
                  X.catch KeyError
                     @exit_with_error(‘Link with such index was not declared previously’, @i + offset + 1)
                  @endi = j
                  R 1B
               I !@instr[j].is_digit()
                  L.break
               j++
         R 0B

      V ordered_list_current_number = -1
      F close_ordered_list()
         I @ordered_list_current_number != -1
            @write_to_i("</li>\n</ol>\n", 0)
            @ordered_list_current_number = -1

      V in_unordered_list = 0B
      F close_unordered_list()
         I @in_unordered_list
            @write_to_i("</li>\n</ul>\n", 0)
            @in_unordered_list = 0B

      [String] ending_tags
      V new_line_tag = "\0"

      L i < instr.len
         V ch = instr[i]
         I (i == 0 | prev_char() == "\n" | (i == writepos & !ending_tags.empty & ending_tags.last C (‘</blockquote>’, ‘</div>’) & instr[i - 2 .< i] C (">‘", "<‘", "!‘")))
            I ch == ‘.’ & (next_char() C " ‘")
               close_ordered_list()
               V s = ‘’
               I !in_unordered_list
                  s = "<ul>\n<li>"
                  in_unordered_list = 1B
               E
                  s = "</li>\n<li>"
               write_to_i(s)
               new_line_tag = ‘’
               I next_char() == ‘ ’
                  i++
               E
                  V endqpos = find_ending_pair_quote(i + 1)
                  outfile.write(.to_html(instr[i + 2 .< endqpos], outer_pos' i + 2))
                  i = endqpos
               writepos = i + 1
            E
               close_unordered_list()
               I ch.is_digit()
                  V j = i + 1
                  L j < instr.len
                     I !instr[j].is_digit()
                        L.break
                     j++
                  I instr[j .< j + 1] == ‘.’ & instr[j + 1 .< j + 2] C (‘ ’, "‘")
                     V value = Int(instr[i .< j])
                     V s = ‘’
                     I ordered_list_current_number == -1
                        s = (I value == 1 {‘<ol>’} E ‘<ol start="’String(value)‘">’)"\n<li>"
                        ordered_list_current_number = value
                     E
                        s = "</li>\n"(I value == ordered_list_current_number + 1 {‘<li>’} E ‘<li value="’String(value)‘">’)
                        ordered_list_current_number = value
                     write_to_i(s)
                     new_line_tag = ‘’
                     I instr[j + 1] == ‘ ’
                        i = j + 1
                     E
                        V endqpos = find_ending_pair_quote(j + 1)
                        outfile.write(.to_html(instr[j + 2 .< endqpos], outer_pos' j + 2))
                        i = endqpos
                     writepos = i + 1
                  E
                     close_ordered_list()
               E
                  close_ordered_list()

            I ch == ‘ ’
               write_to_i(‘&emsp;’)
            E I ch == ‘-’
               I i_next_str(‘--’)
                  V j = i + 3
                  L
                     I j == instr.len | instr[j] == "\n"
                        write_to_i("<hr />\n")
                        I j == instr.len
                           j--
                        i = j
                        writepos = j + 1
                        L.break
                     I instr[j] != ‘-’
                        L.break
                     j++
            E I ch C (‘>’, ‘<’) & (next_char() C " ‘[")
               write_to_pos(i, i + 2)
               outfile.write(‘<blockquote’((ch == ‘<’) * ‘ class="re"’)‘>’)
               I next_char() == ‘ ’
                  new_line_tag = ‘</blockquote>’
               E
                  I next_char() == ‘[’
                     I numbered_link(2)
                        V linkstr = link
                        I linkstr.len > 57
                           linkstr = linkstr[0 .< linkstr.rfindi(‘/’, 0, 47) + 1]‘...’
                        outfile.write(‘<a href="’link‘">[’instr[i + 3 .< endi]‘]<i>’linkstr‘</i></a>’)
                        i = endi + 1
                     E
                        i++
                        V endb = find_ending_sq_bracket(instr, i)
                        V linkn = ‘’
                        I instr[endb + 1 .< endb + 3] == ‘[-’
                           linkn = ‘[’instr[endb + 3 .< find_ending_sq_bracket(instr, endb + 1)]‘]’
                        link = instr[i + 1 .< endb]
                        V spacepos = link.findi(‘ ’)
                        I spacepos != -1
                           link = link[0 .< spacepos]
                        I link.len > 57
                           link = link[0 .< link.rfindi(‘/’, 0, 47) + 1]‘...’
                        write_http_link(i, i, 0, linkn‘<i>’link‘</i>’)
                        i++
                     I instr[i .< i + 2] != ":‘"
                        exit_with_error(‘Quotation with url should always has :‘...’ after [’link[0 .< link.findi(‘:’)]‘://url]’, i)
                     outfile.write(":<br />\n")
                     writepos = i + 2
                  E
                     V endqpos = find_ending_pair_quote(i + 1)
                     I instr[endqpos + 1 .< endqpos + 2] == ‘[’
                        V startqpos = i + 1
                        i = endqpos
                        outfile.write(‘<i>’)
                        assert(writepos == startqpos + 1)
                        writepos = startqpos
                        write_http_link(startqpos, endqpos)
                        outfile.write(‘</i>’)
                        i++
                        I instr[i .< i + 2] != ":‘"
                           exit_with_error(‘Quotation with url should always has :‘...’ after [’link[0 .< link.findi(‘:’)]‘://url]’, i)
                        outfile.write(":<br />\n")
                        writepos = i + 2
                     E I instr[endqpos + 1 .< endqpos + 2] == ‘:’
                        outfile.write(‘<i>’instr[i + 2 .< endqpos]"</i>:<br />\n")
                        i = endqpos + 1
                        I instr[i .< i + 2] != ":‘"
                           exit_with_error(‘Quotation with author's name should be in the form >‘Author's name’:‘Quoted text.’’, i)
                        writepos = i + 2

                  ending_tags.append(‘</blockquote>’)
               i++

         I ch == "‘"
            V prevci = i - 1
            V prevc = I prevci >= 0 {instr[prevci]} E Char("\0")

            V startqpos = i
            i = find_ending_pair_quote(i)
            V endqpos = i
            V str_in_b = ‘’
            I prevc == ‘)’
               V openb = instr.rfindi(‘(’, 0, prevci - 1)
               I openb != -1 & openb > 0
                  str_in_b = instr[openb + 1 .< startqpos - 1]
                  prevci = openb - 1
                  prevc = instr[prevci]
            I prevc C ‘PР’
               write_to_pos(prevci, endqpos + 1)
               V title = ‘’
               Int endqpos2
               I i_next_str("[‘")
                  endqpos2 = find_ending_pair_quote(i + 2)
                  I instr[endqpos2 + 1] != ‘]’
                     exit_with_error("Expected `]` after `’`", endqpos2 + 1)
                  title = ‘ title="’html_escapeq(remove_comments(instr[i + 3 .< endqpos2], i + 3))‘"’
               V imgtag = ‘<img’
               I str_in_b != ‘’
                  V wh = str_in_b.replace(‘,’, ‘ ’).split(‘ ’)
                  assert(wh.len C (1, 2))
                  imgtag ‘’= ‘ width="’wh[0]‘" height="’wh.last‘"’
               imgtag ‘’= ‘ src="’instr[startqpos + 1 .< endqpos]‘"’title‘ />’
               I i_next_str(‘[http’) | i_next_str(‘[./’)
                  write_http_link(startqpos, endqpos, 1, imgtag)
                  writepos = i + 1
               E I i_next_str("[‘")
                  outfile.write(imgtag)
                  writepos = endqpos2 + 2
                  i = endqpos2 + 1
               E
                  outfile.write(imgtag)
                  i = endqpos
            E I i_next_str(‘[http’) | i_next_str(‘[./’)
               write_http_link(startqpos, endqpos)
            E I next_char() == ‘[’ & numbered_link(2)
               i = endi
               write_to_pos(startqpos, i + 1)
               outfile.write(‘<a href="’link‘">’html_escape(instr[startqpos + 1 .< endqpos])‘</a>’)
            E I i_next_str("[‘")
               write_note(startqpos, endqpos)
            E I next_char() == ‘{’ & (.habr_html | .ohd)
               V nesting_level = 0
               i += 2
               L
                  I i == instr.len
                     exit_with_error(‘Unended spoiler’, endqpos + 1)
                  S instr[i]
                     ‘{’
                        nesting_level++
                     ‘}’
                        I nesting_level == 0
                           L.break
                        nesting_level--
                  i++
               write_to_pos(prevci + 1, i + 1)
               V outer_p = endqpos + (I instr[endqpos + 2] == "\n" {3} E 2)
               I .habr_html
                  outfile.write(‘<spoiler title="’remove_comments(instr[startqpos + 1 .< endqpos], startqpos + 1).replace(‘"’, ‘''’)"\">\n"(.to_html(instr[outer_p .< i], outer_pos' outer_p))"</spoiler>\n")
               E
                  outfile.write(‘<span class="spoiler_title" onclick="return spoiler2(this, event)">’remove_comments(instr[startqpos + 1 .< endqpos], startqpos + 1)‘<br /></span>’"<div class=\"spoiler_text\" style=\"display: none\">\n"(.to_html(instr[outer_p .< i], outer_pos' outer_p))"</div>\n")
               I (next_char() == "\n" & !in_unordered_list & ordered_list_current_number == -1)
                  i++
                  writepos = i + 1
            E I prevc == ‘'’
               V t = startqpos - 1
               L t >= 0
                  I instr[t] != ‘'’
                     L.break
                  t--
               V eat_left = startqpos - 1 - t
               t = endqpos + 1
               L t < instr.len
                  I instr[t] != ‘'’
                     L.break
                  t++
               V eat_right = t - (endqpos + 1)
               write_to_pos(startqpos - eat_left, t)
               outfile.write(instr[startqpos + eat_left .< endqpos - eat_right + 1])
            E I prevc C ‘0OО’
               write_to_pos(prevci, endqpos + 1)
               outfile.write(html_escape(instr[startqpos + 1 .< endqpos]).replace("\n", "<br />\n"))
            E I prevc == ‘#’
               V ins = instr[startqpos + 1 .< endqpos]
               write_to_pos(prevci, endqpos + 1)
               I .habr_html
                  V contains_new_line = "\n" C ins
                  outfile.write((I str_in_b != ‘’ {‘<source lang="’str_in_b‘">’} E I contains_new_line {‘<source>’} E ‘<code>’)‘’ins‘’(I str_in_b != ‘’ | contains_new_line {‘</source>’} E ‘</code>’))
               E
                  V pre = ‘<pre ’(I ins[0] == "\n" {‘class="code_block"’} E ‘style="display: inline"’)‘>’
                  I .ohd & syntax_highlighter_for_pqmarkup:is_lang_supported(str_in_b)
                     I !(.highlight_style_was_added)
                        outfile.write(syntax_highlighter_for_pqmarkup:css)
                        .highlight_style_was_added = 1B
                     X.try
                        outfile.write(pre‘’syntax_highlighter_for_pqmarkup:highlight(str_in_b, ins)‘</pre>’)
                     X.catch syntax_highlighter_for_pqmarkup:Error e
                        exit_with_error(‘Syntax highlighter: ’e.message, startqpos + 1 + e.pos)
                  E
                     outfile.write(pre‘’html_escape(ins)‘</pre>’)
               I ins[0] == "\n" & instr[i + 1 .< i + 2] == "\n"
                  outfile.write("\n")
                  new_line_tag = ‘’
            E I prevc C ‘TТ’
               write_to_pos(prevci, endqpos + 1)
               V header_row = 0B
               V hor_row_align = ‘’
               V ver_row_align = ‘’

               T TableCell
                  String text
                  String attrs
                  F (String text, String attrs)
                     .text = text
                     .attrs = attrs
               [[TableCell]] table
               V j = startqpos + 1
               L j < endqpos
                  ch = instr[j]
                  I ch == "‘"
                     [TableCell] empty_list
                     table.append(empty_list)
                     V endrow = find_ending_pair_quote(j)
                     V hor_col_align = ‘’
                     V ver_col_align = ‘’

                     j++
                     L j < endrow
                        ch = instr[j]
                        I ch == "‘"
                           V end_of_column = find_ending_pair_quote(j)
                           V style = ‘’
                           I hor_row_align != ‘’ | hor_col_align != ‘’
                              style ‘’= ‘text-align: ’(I hor_col_align != ‘’ {hor_col_align} E hor_row_align)
                           I ver_row_align != ‘’ | ver_col_align != ‘’
                              I style != ‘’
                                 style ‘’= ‘; ’
                              style ‘’= ‘vertical-align: ’(I ver_col_align != ‘’ {ver_col_align} E ver_row_align)
                           hor_col_align = ‘’
                           ver_col_align = ‘’
                           table.last.append(TableCell(.to_html(instr[j + 1 .< end_of_column], outer_pos' j + 1), (I header_row {‘th’} E ‘td’)‘’(I style != ‘’ {‘ style="’style‘"’} E ‘’)))
                           j = end_of_column
                        E I ch C ‘<>’ & instr[j + 1 .< j + 2] C (‘<’, ‘>’)
                           hor_col_align = S instr[j .< j + 2] {‘<<’ {‘left’}; ‘>>’ {‘right’}; ‘><’ {‘center’}; ‘<>’ {‘justify’}}
                           j++
                        E I instr[j .< j + 2] C ("/\\", "\\/")
                           ver_col_align = I instr[j .< j + 2] == "/\\" {‘top’} E ‘bottom’
                           j++
                        E I ch == ‘-’
                           I table.last.empty
                              exit_with_error(‘Wrong table column span marker "-"’, j)
                           table.last.append(TableCell(‘’, ‘-’))
                        E I ch == ‘|’
                           I table.len == 1
                              exit_with_error(‘Wrong table row span marker "|"’, j)
                           table.last.append(TableCell(‘’, ‘|’))
                        E I instr[j .< j + 3] == ‘[[[’
                           j = find_ending_sq_bracket(instr, j)
                        E I ch !C "  \t\n"
                           exit_with_error(‘Unknown formatting character inside table row’, j)
                        j++

                     header_row = 0B
                     hor_row_align = ‘’
                     ver_row_align = ‘’
                  E I ch C ‘HН’
                     header_row = 1B
                  E I ch C ‘<>’ & instr[j + 1 .< j + 2] C (‘<’, ‘>’)
                     hor_row_align = S instr[j .< j + 2] {‘<<’ {‘left’}; ‘>>’ {‘right’}; ‘><’ {‘center’}; ‘<>’ {‘justify’}}
                     j++
                  E I instr[j .< j + 2] C ("/\\", "\\/")
                     ver_row_align = I instr[j .< j + 2] == "/\\" {‘top’} E ‘bottom’
                     j++
                  E I instr[j .< j + 3] == ‘[[[’
                     j = find_ending_sq_bracket(instr, j)
                  E I ch !C "  \t\n"
                     exit_with_error(‘Unknown formatting character inside table’, j)

                  j++

               L(y) (table.len - 1 .< -1).step(-1)
                  L(x) (table[y].len - 1 .< -1).step(-1)
                     I table[y][x].attrs C (‘-’, ‘|’)
                        V xx = x
                        V yy = y
                        L
                           I table[yy][xx].attrs == ‘-’
                              xx--
                           E I table[yy][xx].attrs == ‘|’
                              yy--
                           E
                              L.break
                        I xx < x
                           table[yy][xx].attrs ‘’= ‘ colspan="’String(x - xx + 1)‘"’
                        I yy < y
                           table[yy][xx].attrs ‘’= ‘ rowspan="’String(y - yy + 1)‘"’
                        L(xxx) xx .. x
                           L(yyy) yy .. y
                              I (xxx, yyy) != (xx, yy)
                                 table[yyy][xxx].attrs = ‘’

               V is_inline = 1B
               I (prevci == 0 | instr[prevci - 1] == "\n" | (prevci - 3 >= 0 & instr[prevci - 3 .< prevci] == ‘]]]’ & instr[0.<3] == ‘[[[’ & find_ending_sq_bracket(instr, 0) == prevci - 1))
                  is_inline = 0B
               outfile.write(‘<table’(‘ style="display: inline"’ * is_inline)">\n")
               L(row) table
                  outfile.write(‘<tr>’)
                  L(cell) row
                     I cell.attrs != ‘’
                        outfile.write(‘<’cell.attrs‘>’cell.text‘</’cell.attrs[0.<2]‘>’)
                  outfile.write("</tr>\n")
               outfile.write("</table>\n")
               I !is_inline
                  new_line_tag = ‘’
            E I prevc C ‘<>’ & instr[prevci - 1] C ‘<>’
               write_to_pos(prevci - 1, endqpos + 1)
               outfile.write(‘<div align="’(S instr[prevci - 1]‘’prevc {‘<<’ {‘left’}; ‘>>’ {‘right’}; ‘><’ {‘center’}; ‘<>’ {‘justify’}})‘">’(.to_html(instr[startqpos + 1 .< endqpos], outer_pos' startqpos + 1))"</div>\n")
               new_line_tag = ‘’
            E I i_next_str(":‘") & instr[find_ending_pair_quote(i + 2) + 1 ..][0.<1] == ‘<’
               V endrq = find_ending_pair_quote(i + 2)
               i = endrq + 1
               write_to_pos(prevci + 1, i + 1)
               outfile.write(‘<blockquote>’(.to_html(instr[startqpos + 1 .< endqpos], outer_pos' startqpos + 1))"<br />\n<div align='right'><i>"instr[endqpos + 3 .< endrq]‘</i></div></blockquote>’)
               new_line_tag = ‘’
            E
               i = startqpos
               I prev_char() C ‘*_-~’
                  write_to_pos(i - 1, i + 1)
                  V tag = S prev_char() {‘*’ {‘b’}; ‘_’ {‘u’}; ‘-’ {‘s’}; ‘~’ {‘i’}}
                  outfile.write(‘<’tag‘>’)
                  ending_tags.append(‘</’tag‘>’)
               E I prevc C ‘HН’
                  write_to_pos(prevci, i + 1)
                  V tag = ‘h’String(min(max(3 - (I str_in_b == ‘’ {0} E Int(str_in_b)), 1), 6))
                  outfile.write(‘<’tag‘>’)
                  ending_tags.append(‘</’tag‘>’)
               E I prevc C ‘CС’
                  write_to_pos(prevci, i + 1)
                  V which_color = ‘color’
                  I str_in_b[0.<1] == ‘-’
                     str_in_b = str_in_b[1..]
                     which_color = ‘background-color’
                  I str_in_b[0.<1] == ‘#’
                     V new_str_in_b = ‘’
                     L(c) str_in_b
                        V cc = (S c.lowercase() {‘а’ {‘A’}; ‘б’ {‘B’}; ‘с’ {‘C’}; ‘д’ {‘D’}; ‘е’ {‘E’}; ‘ф’ {‘F’} E c})[0]
                        new_str_in_b ‘’= I c.is_lowercase() {cc.lowercase()} E cc
                     str_in_b = new_str_in_b
                  E I str_in_b.len C (1, 3) & str_in_b.is_digit()
                     V new_str = ‘#’
                     L(ii) I str_in_b.len == 3 {[0, 1, 2]} E [0, 0, 0]
                        new_str ‘’= hex((Int(str_in_b[ii]) * F'F + 4) I/ 8).zfill(2)
                     str_in_b = new_str
                  I .habr_html
                     outfile.write(‘<font color="’str_in_b‘">’)
                     ending_tags.append(‘</font>’)
                  E
                     outfile.write(‘<span style="’which_color‘: ’str_in_b‘">’)
                     ending_tags.append(‘</span>’)
               E I (instr[prevci - 1 .< prevci], prevc) C ((‘/’, ‘\’), (‘\’, ‘/’))
                  write_to_pos(prevci - 1, i + 1)
                  V tag = I (instr[prevci - 1], prevc) == (‘/’, ‘\’) {‘sup’} E ‘sub’
                  outfile.write(‘<’tag‘>’)
                  ending_tags.append(‘</’tag‘>’)
               E I prevc == ‘!’
                  write_to_pos(prevci, i + 1)
                  outfile.write(I .habr_html {‘<blockquote>’} E ‘<div class="note">’)
                  ending_tags.append(I .habr_html {‘</blockquote>’} E ‘</div>’)
               E
                  ending_tags.append("’")
         E I ch == "’"
            write_to_pos(i, i + 1)
            I ending_tags.empty
               exit_with_error(‘Unpaired right single quotation mark’, i)
            V last = ending_tags.pop()
            outfile.write(last)
            I next_char() == "\n" & (last.starts_with(‘</h’) | last C (‘</blockquote>’, ‘</div>’))
               outfile.write("\n")
               i++
               writepos++
         E I ch == ‘`’
            V start = i
            i++
            L i < instr.len
               I instr[i] != ‘`’
                  L.break
               i++
            V end = instr.findi((i - start) * ‘`’, i)
            I end == -1
               exit_with_error(‘Unended ` started’, start)
            write_to_pos(start, end + i - start)
            V ins = instr[i .< end]
            V delta = ins.count("‘") - ins.count("’")
            I delta > 0
               L(ii) 0 .< delta
                  ending_tags.append("’")
            E
               L(ii) 0 .< -delta
                  I ending_tags.pop() != "’"
                     exit_with_error(‘Unpaired single quotation mark found inside code block/span beginning’, start)
            ins = html_escape(ins)
            I !("\n" C ins)
               outfile.write(I .habr_html {‘<code>’ins‘</code>’} E ‘<pre class="inline_code">’ins‘</pre>’)
            E
               outfile.write(‘<pre>’ins‘</pre>’("\n" * (!(.habr_html))))
               new_line_tag = ‘’
            i = end + i - start - 1
         E I ch == ‘[’
            I i_next_str(‘http’) | i_next_str(‘./’) | (i_next_str("‘") & prev_char() !C "\r\n\t \0") | numbered_link()
               V s = i - 1
               L s >= writepos & instr[s] !C "\r\n\t [{(‘“"
                  s--
               I i_next_str("‘")
                  write_note(s + 1, i, 0)
               E I i_next_str(‘http’) | i_next_str(‘./’)
                  write_http_link(s + 1, i, 0)
               E
                  write_to_pos(s + 1, endi + 1)
                  outfile.write(‘<a href="’link‘">’html_escape(instr[s + 1 .< i])‘</a>’)
                  i = endi
            E I i_next_str(‘[[’)
               V comment_start = i
               V nesting_level = 0
               L
                  S instr[i]
                     ‘[’
                        nesting_level++
                     ‘]’
                        I --nesting_level == 0
                           L.break
                     "‘"
                        ending_tags.append("’")
                     "’"
                        assert(ending_tags.pop() == "’")
                  i++
                  I i == instr.len
                     exit_with_error(‘Unended comment started’, comment_start)
               write_to_pos(comment_start, i + 1)
               I instr[comment_start + 3 .< comment_start + 4] != ‘[’
                  outfile.write(‘<!--’)
                  outfile.write(remove_comments(instr[comment_start .< i + 1], comment_start, 4))
                  outfile.write(‘-->’)
            E
               write_to_i((‘<span class="sq"><span class="sq_brackets">’ * .ohd)‘’(‘<font color="#BFBFBF">’ * .habr_html)‘[’(‘</font><font color="gray">’ * .habr_html)‘’(.ohd * ‘</span>’))
         E I ch == ‘]’
            write_to_i((‘<span class="sq_brackets">’ * .ohd)‘’(‘</font><font color="#BFBFBF">’ * .habr_html)‘]’(‘</font>’ * .habr_html)‘’(.ohd * ‘</span></span>’))
         E I ch == ‘{’
            write_to_i(‘<span class="cu_brackets" onclick="return spoiler(this, event)"><span class="cu_brackets_b">’ * .ohd‘{’(.ohd * ‘</span><span>…</span><span class="cu" style="display: none">’))
         E I ch == ‘}’
            write_to_i(‘</span><span class="cu_brackets_b">’ * .ohd‘}’(.ohd * ‘</span></span>’))
         E I ch == "\n"
            write_to_i((I new_line_tag != "\0" {new_line_tag} E ‘<br />’)‘’(I new_line_tag != ‘’ {"\n"} E ‘’))
            new_line_tag = "\0"

         i++

      close_ordered_list()
      close_unordered_list()

      write_to_pos(instr.len, 0)
      assert(ending_tags.empty)
      assert(.to_html_called_inside_to_html_outer_pos_list.pop() == outer_pos)

      I outfilef == N
         V r = result.join(‘’)
         I .habr_html
            r = r.replace("</blockquote>\n", ‘</blockquote>’)
         R r

      R ‘’

F to_html(instr, File? outfilef = N; ohd = 0B, ', habr_html = 0B)
   R Converter(habr_html, ohd).to_html(instr, outfilef)

:start:
I ‘-h’ C :argv | ‘--help’ C :argv
   print(‘A Python implementation of pq markup to HTML converter.

Usage: pqmarkup [options] [INPUTFILE]

Positional arguments:
  INPUT_FILE            input file (STDIN is assumed if no INPUT_FILE is
                        given)

Options:
  -h, --help            show this help message and exit
  --habr-html           for publishing posts on habr.com
  --output-html-document
                        add some html header for rough testing preview of your
                        converted documents
  -f [OUTPUT_FILE], --file [OUTPUT_FILE]
                        write output to OUTPUT_FILE (defaults to STDOUT)’)
   exit(0)

V args_habr_html = ‘--habr-html’ C :argv
V args_output_html_document = ‘--output-html-document’ C :argv
V args_infile = :stdin
V i = 1
L i < :argv.len
   I :argv[i] C (‘-f’, ‘--file’)
      i += 2
      L.continue
   I !:argv[i].starts_with(‘-’)
      X.try
         args_infile = File(:argv[i], ‘r’, encoding' ‘utf-8-sig’)
      X.catch
         exit(‘Can't open file '’:argv[i]‘'’)
      L.break
   i++
V args_outfile = :stdout
String outfile_name
X.try
   I ‘-f’ C :argv
      outfile_name = :argv[:argv.index(‘-f’) + 1]
      args_outfile = File(outfile_name, ‘w’, encoding' ‘utf-8’)
   E I ‘--file’ C :argv
      outfile_name = :argv[:argv.index(‘--file’) + 1]
      args_outfile = File(outfile_name, ‘w’, encoding' ‘utf-8’)
X.catch
   exit(‘Can't open file '’outfile_name‘' for writing’)

I args_output_html_document & args_habr_html
   exit(‘Options --output-html-document and --habr-html are mutually exclusive’)

String infile_str
X.try
   infile_str = args_infile.read()
X.catch UnicodeDecodeError
   exit(‘Input is not a valid UTF-8!’)
V title = ‘’
I infile_str.starts_with("[[[H‘") | infile_str.starts_with("[[[Н‘")
   i = 5
   V nesting_level = 1
   L i < infile_str.len
      S infile_str[i]
         "‘"
            nesting_level++
         "’"
            I --nesting_level == 0
               L.break
      i++
   title = infile_str[5 .< i]

I args_output_html_document
   args_outfile.write(‘<html>
<head>
<meta charset="utf-8" />
’(I title != ‘’ {‘<title>’title"</title>\n"} E ‘’)‘<base target="_blank">
<script type="text/javascript">
function spoiler(element, event)
{
    if (event.target.nodeName == 'A' || event.target.parentNode.nodeName == 'A' || event.target.onclick)//чтобы работали ссылки в спойлерах и спойлеры2 в спойлерах
        return;
    var e = element.firstChild.nextSibling.nextSibling;//element.getElementsByTagName('span')[0]
    e.previousSibling.style.display = e.style.display;//<span>…</span> must have inverted display style
    e.style.display = (e.style.display == "none" ? "" : "none");
    element.firstChild.style.fontWeight =
    element. lastChild.style.fontWeight = (e.style.display == "" ? "normal" : "bold");
    event.stopPropagation();
    //[-Чтобы была возможность выделять текст внутри раскрытого ‘скрытого текста’/спойлера, необходимо [скрытие/]закрытие спойлера делать не просто по нажатию левой кнопки мыши, а по отпусканию левой кнопки мыши при условии отсутствия движения курсора [мыши] после того, как была нажата левая кнопка мыши.-]
}
function spoiler2(element, event)
{
    element.nextSibling.style.display = (element.nextSibling.style.display == "none" ? "" : "none");
}
</script>
<style type="text/css">
div#main, td {
    font-size: 14px;
    font-family: Verdana, sans-serif;
    line-height: 160%;
    text-align: justify;
}
span.cu_brackets_b {
    font-size: initial;
    font-family: initial;
    font-weight: bold;
}
a {
    text-decoration: none;
    color: #6da3bd;
}
a:hover {
    text-decoration: underline;
    color: #4d7285;
}
h1, h2, h3, h4, h5, h6 {
    margin: 0;
    font-weight: 400;
}
h1 {font-size: 200%; line-height: 130%;}
h2 {font-size: 180%; line-height: 135%;}
h3 {font-size: 160%; line-height: 140%;}
h4 {font-size: 145%; line-height: 145%;}
h5 {font-size: 130%; line-height: 140%;}
h6 {font-size: 120%; line-height: 140%;}
span.sq {color: gray; font-size: 0.8rem; font-weight: normal; /*pointer-events: none;*/}
span.sq_brackets {color: #BFBFBF;}
span.cu_brackets {cursor: pointer;}
span.cu {background-color: #F7F7FF;}
abbr {text-decoration: none; border-bottom: 1px dotted;}
pre {margin: 0;}’""‘
pre, code {font-family: 'Courier New'; line-height: normal}
ul, ol {margin: 11px 0 7px 0;}
ul li, ol li {padding: 7px 0;}
ul li:first-child, ol li:first-child {padding-top   : 0;}
ul  li:last-child, ol  li:last-child {padding-bottom: 0;}
table {margin: 9px 0; border-collapse: collapse;}
table th, table td {padding: 6px 13px; border: 1px solid #BFBFBF;}
span.spoiler_title {
    color: #548eaa;
    cursor: pointer;
    border-bottom: 1px dotted;
}
div.spoiler_text {
    /*border: 1px dotted;*/
    margin: 5px;
    padding: 3px;
}
blockquote {
    margin: 0 0 7px 0;
    padding: 7px 12px;
}
blockquote:not(.re) {border-left:  0.2em solid #90ddaa; background-color: #fbfffb;}
blockquote.re       {border-right: 0.2em solid #90ddaa; background-color: #f4fff8;}
div.note {
    padding: 18px 20px;
    background: #ffffd7;
}
pre.code_block {padding: 6px 0;}
pre.inline_code {
    display: inline;
    padding: 0px 3px;
    border: 1px solid #E5E5E5;
    background-color: #FAFAFA;
    border-radius: 3px;
}
img {vertical-align: middle;}

div#main {width: 100%;}
@media screen and (min-width: 1050px) {
    div#main {width: 1024px;}
}
</style>
</head>
<body>
<div id="main" style="margin: 0 auto">
’)
X.try
   to_html(infile_str, args_outfile, args_output_html_document, habr_html' args_habr_html)
X.catch Exception e
   :stderr.write(e.message‘ at line ’String(e.line)‘, column ’String(e.column)"\n")
   exit(-1)
I args_output_html_document
   args_outfile.write(‘</div>
</body>
</html>’)
===
namespace syntax_highlighter_for_pqmarkup {
#include "syntax_highlighter_for_pqmarkup.hpp"
}

Array<String> argv;

class Exception
{
public:
    String message;
    int line;
    int column;
    int pos;
    template <typename T1, typename T2, typename T3, typename T4> Exception(const T1 &message, const T2 &line, const T3 &column, const T4 &pos) :
        message(message),
        line(line),
        column(column),
        pos(pos)
    {
    }
};

class Converter
{
public:
    Array<int> to_html_called_inside_to_html_outer_pos_list;
    bool habr_html;
    bool ohd;
    decltype(false) highlight_style_was_added = false;
    String instr;

    template <typename T1, typename T2> Converter(const T1 &habr_html, const T2 &ohd) :
        habr_html(habr_html),
        ohd(ohd)
    {
    }

    template <typename T3 = decltype(0)> String to_html(const String &instr, File* const outfilef = nullptr, const T3 &outer_pos = 0)
    {
        to_html_called_inside_to_html_outer_pos_list.append(outer_pos);

        Array<String> result;
        class Writer
        {
        public:
            std::function<void(const String&)> write;
        };
        auto outfile = Writer();
        if (outfilef == nullptr)
            outfile.write = [&result](const auto &s){return result.append(s);};
        else
            outfile.write = [&outfilef](const auto &s){return outfilef->write(s);};
        if (to_html_called_inside_to_html_outer_pos_list.len() == 1)
            this->instr = instr;

        auto exit_with_error = [this](const auto &message, auto pos)
        {
            pos += sum(to_html_called_inside_to_html_outer_pos_list);
            auto line = 1;
            auto line_start = -1;
            auto t = 0;
            while (t < pos) {
                if (this->instr[t] == u'\n') {
                    line++;
                    line_start = t;
                }
                t++;
            }
            throw Exception(message, line, pos - line_start, pos);
        };

        auto i = 0;
        auto next_char = [&i, &instr](const decltype(1) offset = 1)
        {
            return i + offset < instr.len() ? instr[i + offset] : u'\0'_C;
        };

        auto i_next_str = [&i, &instr](const auto &str)
        {
            return instr[range_el(i + 1, i + 1 + str.len())] == str;
        };

        auto prev_char = [&i, &instr](const decltype(1) offset = 1)
        {
            return i - offset >= 0 ? instr[i - offset] : u'\0'_C;
        };

        auto html_escape = [this](auto str)
        {
            str = str.replace(u"&"_S, u"&amp;"_S).replace(u"<"_S, u"&lt;"_S);
            if (habr_html)
                str = str.replace(u"\""_S, u"&quot;"_S);
            return str;
        };
        auto html_escapeq = [](const auto &str)
        {
            return str.replace(u"&"_S, u"&amp;"_S).replace(u"\""_S, u"&quot;"_S);
        };

        auto writepos = 0;
        auto write_to_pos = [&html_escape, &instr, &outfile, &writepos](const auto &pos, const auto &npos)
        {
            outfile.write(html_escape(instr[range_el(writepos, pos)]));
            writepos = npos;
        };

        auto write_to_i = [&i, &outfile, &write_to_pos](const auto &add_str, const decltype(1) skip_chars = 1)
        {
            write_to_pos(i, i + skip_chars);
            outfile.write(add_str);
        };

        auto find_ending_pair_quote = [&exit_with_error, &instr](auto i)
        {
            assert(instr[i] == u'‘');
            auto startqpos = i;
            auto nesting_level = 0;
            while (true) {
                if (i == instr.len())
                    exit_with_error(u"Unpaired left single quotation mark"_S, startqpos);
                switch (instr[i])
                {
                case u'‘':
                    nesting_level++;
                    break;
                case u'’':
                    if (--nesting_level == 0)
                        return i;
                    break;
                }
                i++;
            }
        };

        auto find_ending_sq_bracket = [&exit_with_error](const auto &str, auto i, const decltype(0) start = 0)
        {
            auto starti = i;
            assert(str[i] == u'[');
            auto nesting_level = 0;
            while (true) {
                switch (str[i])
                {
                case u'[':
                    nesting_level++;
                    break;
                case u']':
                    if (--nesting_level == 0)
                        return i;
                    break;
                }
                i++;
                if (i == str.len())
                    exit_with_error(u"Unended comment started"_S, start + starti);
            }
        };

        auto remove_comments = [&find_ending_sq_bracket](String s, auto start, const decltype(3) level = 3)
        {
            while (true) {
                auto j = s.findi(u"["_S * level);
                if (j == -1)
                    break;
                auto k = find_ending_sq_bracket(s, j, start) + 1;
                start += k - j;
                s = s[range_el(0, j)] & s[range_ei(k)];
            }
            return s;
        };

        Dict<int, String> nonunique_links;
        auto link = u""_S;

        auto write_http_link = [&exit_with_error, &find_ending_pair_quote, &find_ending_sq_bracket, &html_escapeq, &i, &instr, &link, &next_char, &nonunique_links, &outfile, &remove_comments, &write_to_pos, this](const auto &startpos, const int endpos, const decltype(1) q_offset = 1, decltype(u""_S) text = u""_S)
        {
            auto nesting_level = 0;
            i += 2;
            while (true) {
                if (i == instr.len())
                    exit_with_error(u"Unended link"_S, endpos + q_offset);
                switch (instr[i])
                {
                case u'[':
                    nesting_level++;
                    break;
                case u']':
                    if (nesting_level == 0)
                        goto break_;
                    nesting_level--;
                    break;
                case u' ':
                    goto break_;
                    break;
                }
                i++;
            }
            break_:;

            link = html_escapeq(instr[range_el(endpos + 1 + q_offset, i)]);
            String tag = u"<a href=\""_S & link & u"\""_S;
            if (link.starts_with(u"./"_S))
                tag &= u" target=\"_self\""_S;

            if (instr[i] == u' ') {
                tag &= u" title=\""_S;
                if (next_char() == u'‘') {
                    auto endqpos2 = find_ending_pair_quote(i + 1);
                    if (instr[endqpos2 + 1] != u']')
                        exit_with_error(u"Expected `]` after `’`"_S, endqpos2 + 1);
                    tag &= html_escapeq(remove_comments(instr[range_el(i + 2, endqpos2)], i + 2));
                    i = endqpos2 + 1;
                }
                else {
                    auto endb = find_ending_sq_bracket(instr, endpos + q_offset);
                    tag &= html_escapeq(remove_comments(instr[range_el(i + 1, endb)], i + 1));
                    i = endb;
                }
                tag &= u"\""_S;
            }
            if (next_char() == u'[' && next_char(2) == u'-') {
                auto j = i + 3;
                while (j < instr.len()) {
                    if (instr[j] == u']') {
                        nonunique_links.set(to_int(instr[range_el(i + 3, j)]), link);
                        i = j;
                        break;
                    }
                    if (!instr[j].is_digit())
                        break;
                    j++;
                }
            }
            if (text == u"") {
                write_to_pos(startpos, i + 1);
                text = to_html(instr[range_el(startpos + q_offset, endpos)], nullptr, startpos + q_offset);
            }
            outfile.write(tag & u">"_S & (text != u"" ? text : link) & u"</a>"_S);
        };

        auto write_note = [&exit_with_error, &find_ending_pair_quote, &html_escape, &html_escapeq, &i, &instr, &outfile, &remove_comments, &write_to_pos](const auto &startpos, const auto &endpos, const decltype(1) q_offset = 1)
        {
            i += q_offset;
            auto endqpos2 = find_ending_pair_quote(i + 1);
            if (instr[endqpos2 + 1] != u']')
                exit_with_error(u"Bracket ] should follow after ’"_S, endqpos2 + 1);
            write_to_pos(startpos, endqpos2 + 2);
            outfile.write(u"<abbr title=\""_S & html_escapeq(remove_comments(instr[range_el(i + 2, endqpos2)], i + 2)) & u"\">"_S & html_escape(remove_comments(instr[range_el(startpos + q_offset, endpos)], startpos + q_offset)) & u"</abbr>"_S);
            i = endqpos2 + 1;
        };

        auto endi = 0;
        auto numbered_link = [&endi, &exit_with_error, &i, &instr, &link, &next_char, &nonunique_links](const decltype(1) offset = 1)
        {
            if (next_char(offset) == u'-' && next_char(offset + 1).is_digit()) {
                auto j = i + offset + 1;
                while (j < instr.len()) {
                    if (instr[j] == u']') {
                        try
                        {
                            link = nonunique_links[to_int(instr[range_el(i + offset + 1, j)])];
                        }
                        catch (const KeyError&)
                        {
                            exit_with_error(u"Link with such index was not declared previously"_S, i + offset + 1);
                        }
                        endi = j;
                        return true;
                    }
                    if (!instr[j].is_digit())
                        break;
                    j++;
                }
            }
            return false;
        };

        auto ordered_list_current_number = -1;
        auto close_ordered_list = [&ordered_list_current_number, &write_to_i]()
        {
            if (ordered_list_current_number != -1) {
                write_to_i(u"</li>\n</ol>\n"_S, 0);
                ordered_list_current_number = -1;
            }
        };

        auto in_unordered_list = false;
        auto close_unordered_list = [&in_unordered_list, &write_to_i]()
        {
            if (in_unordered_list) {
                write_to_i(u"</li>\n</ul>\n"_S, 0);
                in_unordered_list = false;
            }
        };

        Array<String> ending_tags;
        auto new_line_tag = u"\0"_S;

        while (i < instr.len()) {
            auto ch = instr[i];
            if ((i == 0 || prev_char() == u'\n' || (i == writepos && !ending_tags.empty() && in(ending_tags.last(), make_tuple(u"</blockquote>"_S, u"</div>"_S)) && in(instr[range_el(i - 2, i)], make_tuple(u">‘"_S, u"<‘"_S, u"!‘"_S))))) {
                if (ch == u'.' && (in(next_char(), u" ‘"_S))) {
                    close_ordered_list();
                    auto s = u""_S;
                    if (!in_unordered_list) {
                        s = u"<ul>\n<li>"_S;
                        in_unordered_list = true;
                    }
                    else
                        s = u"</li>\n<li>"_S;
                    write_to_i(s);
                    new_line_tag = u""_S;
                    if (next_char() == u' ')
                        i++;
                    else {
                        auto endqpos = find_ending_pair_quote(i + 1);
                        outfile.write(to_html(instr[range_el(i + 2, endqpos)], nullptr, i + 2));
                        i = endqpos;
                    }
                    writepos = i + 1;
                }
                else {
                    close_unordered_list();
                    if (ch.is_digit()) {
                        auto j = i + 1;
                        while (j < instr.len()) {
                            if (!instr[j].is_digit())
                                break;
                            j++;
                        }
                        if (instr[range_el(j, j + 1)] == u'.' && in(instr[range_el(j + 1, j + 2)], make_tuple(u" "_S, u"‘"_S))) {
                            auto value = to_int(instr[range_el(i, j)]);
                            auto s = u""_S;
                            if (ordered_list_current_number == -1) {
                                s = (value == 1 ? u"<ol>"_S : u"<ol start=\""_S & String(value) & u"\">"_S) & u"\n<li>"_S;
                                ordered_list_current_number = value;
                            }
                            else {
                                s = u"</li>\n"_S & (value == ordered_list_current_number + 1 ? u"<li>"_S : u"<li value=\""_S & String(value) & u"\">"_S);
                                ordered_list_current_number = value;
                            }
                            write_to_i(s);
                            new_line_tag = u""_S;
                            if (instr[j + 1] == u' ')
                                i = j + 1;
                            else {
                                auto endqpos = find_ending_pair_quote(j + 1);
                                outfile.write(to_html(instr[range_el(j + 2, endqpos)], nullptr, j + 2));
                                i = endqpos;
                            }
                            writepos = i + 1;
                        }
                        else
                            close_ordered_list();
                    }
                    else
                        close_ordered_list();
                }
                if (ch == u' ')
                    write_to_i(u"&emsp;"_S);
                else if (ch == u'-') {
                    if (i_next_str(u"--"_S)) {
                        auto j = i + 3;
                        while (true) {
                            if (j == instr.len() || instr[j] == u'\n') {
                                write_to_i(u"<hr />\n"_S);
                                if (j == instr.len())
                                    j--;
                                i = j;
                                writepos = j + 1;
                                break;
                            }
                            if (instr[j] != u'-')
                                break;
                            j++;
                        }
                    }
                }
                else if (in(ch, make_tuple(u">"_S, u"<"_S)) && (in(next_char(), u" ‘["_S))) {
                    write_to_pos(i, i + 2);
                    outfile.write(u"<blockquote"_S & ((ch == u'<') * u" class=\"re\""_S) & u">"_S);
                    if (next_char() == u' ')
                        new_line_tag = u"</blockquote>"_S;
                    else {
                        if (next_char() == u'[') {
                            if (numbered_link(2)) {
                                auto linkstr = link;
                                if (linkstr.len() > 57)
                                    linkstr = linkstr[range_el(0, linkstr.rfindi(u"/"_S, 0, 47) + 1)] & u"..."_S;
                                outfile.write(u"<a href=\""_S & link & u"\">["_S & instr[range_el(i + 3, endi)] & u"]<i>"_S & linkstr & u"</i></a>"_S);
                                i = endi + 1;
                            }
                            else {
                                i++;
                                auto endb = find_ending_sq_bracket(instr, i);
                                auto linkn = u""_S;
                                if (instr[range_el(endb + 1, endb + 3)] == u"[-")
                                    linkn = u"["_S & instr[range_el(endb + 3, find_ending_sq_bracket(instr, endb + 1))] & u"]"_S;
                                link = instr[range_el(i + 1, endb)];
                                auto spacepos = link.findi(u" "_S);
                                if (spacepos != -1)
                                    link = link[range_el(0, spacepos)];
                                if (link.len() > 57)
                                    link = link[range_el(0, link.rfindi(u"/"_S, 0, 47) + 1)] & u"..."_S;
                                write_http_link(i, i, 0, linkn & u"<i>"_S & link & u"</i>"_S);
                                i++;
                            }
                            if (instr[range_el(i, i + 2)] != u":‘")
                                exit_with_error(u"Quotation with url should always has :‘...’ after ["_S & link[range_el(0, link.findi(u":"_S))] & u"://url]"_S, i);
                            outfile.write(u":<br />\n"_S);
                            writepos = i + 2;
                        }
                        else {
                            auto endqpos = find_ending_pair_quote(i + 1);
                            if (instr[range_el(endqpos + 1, endqpos + 2)] == u'[') {
                                auto startqpos = i + 1;
                                i = endqpos;
                                outfile.write(u"<i>"_S);
                                assert(writepos == startqpos + 1);
                                writepos = startqpos;
                                write_http_link(startqpos, endqpos);
                                outfile.write(u"</i>"_S);
                                i++;
                                if (instr[range_el(i, i + 2)] != u":‘")
                                    exit_with_error(u"Quotation with url should always has :‘...’ after ["_S & link[range_el(0, link.findi(u":"_S))] & u"://url]"_S, i);
                                outfile.write(u":<br />\n"_S);
                                writepos = i + 2;
                            }
                            else if (instr[range_el(endqpos + 1, endqpos + 2)] == u':') {
                                outfile.write(u"<i>"_S & instr[range_el(i + 2, endqpos)] & u"</i>:<br />\n"_S);
                                i = endqpos + 1;
                                if (instr[range_el(i, i + 2)] != u":‘")
                                    exit_with_error(u"Quotation with author's name should be in the form >‘Author's name’:‘Quoted text.’"_S, i);
                                writepos = i + 2;
                            }
                        }

                        ending_tags.append(u"</blockquote>"_S);
                    }
                    i++;
                }
            }

            if (ch == u'‘') {
                auto prevci = i - 1;
                auto prevc = prevci >= 0 ? instr[prevci] : u'\0'_C;

                auto startqpos = i;
                i = find_ending_pair_quote(i);
                auto endqpos = i;
                auto str_in_b = u""_S;
                if (prevc == u')') {
                    auto openb = instr.rfindi(u"("_S, 0, prevci - 1);
                    if (openb != -1 && openb > 0) {
                        str_in_b = instr[range_el(openb + 1, startqpos - 1)];
                        prevci = openb - 1;
                        prevc = instr[prevci];
                    }
                }
                if (in(prevc, u"PР"_S)) {
                    write_to_pos(prevci, endqpos + 1);
                    auto title = u""_S;
                    int endqpos2;
                    if (i_next_str(u"[‘"_S)) {
                        endqpos2 = find_ending_pair_quote(i + 2);
                        if (instr[endqpos2 + 1] != u']')
                            exit_with_error(u"Expected `]` after `’`"_S, endqpos2 + 1);
                        title = u" title=\""_S & html_escapeq(remove_comments(instr[range_el(i + 3, endqpos2)], i + 3)) & u"\""_S;
                    }
                    auto imgtag = u"<img"_S;
                    if (str_in_b != u"") {
                        auto wh = str_in_b.replace(u","_S, u" "_S).split(u" "_S);
                        assert(in(wh.len(), make_tuple(1, 2)));
                        imgtag &= u" width=\""_S & _get<0>(wh) & u"\" height=\""_S & wh.last() & u"\""_S;
                    }
                    imgtag &= u" src=\""_S & instr[range_el(startqpos + 1, endqpos)] & u"\""_S & title & u" />"_S;
                    if (i_next_str(u"[http"_S) || i_next_str(u"[./"_S)) {
                        write_http_link(startqpos, endqpos, 1, imgtag);
                        writepos = i + 1;
                    }
                    else if (i_next_str(u"[‘"_S)) {
                        outfile.write(imgtag);
                        writepos = endqpos2 + 2;
                        i = endqpos2 + 1;
                    }
                    else {
                        outfile.write(imgtag);
                        i = endqpos;
                    }
                }
                else if (i_next_str(u"[http"_S) || i_next_str(u"[./"_S))
                    write_http_link(startqpos, endqpos);
                else if (next_char() == u'[' && numbered_link(2)) {
                    i = endi;
                    write_to_pos(startqpos, i + 1);
                    outfile.write(u"<a href=\""_S & link & u"\">"_S & html_escape(instr[range_el(startqpos + 1, endqpos)]) & u"</a>"_S);
                }
                else if (i_next_str(u"[‘"_S))
                    write_note(startqpos, endqpos);
                else if (next_char() == u'{' && (habr_html || ohd)) {
                    auto nesting_level = 0;
                    i += 2;
                    while (true) {
                        if (i == instr.len())
                            exit_with_error(u"Unended spoiler"_S, endqpos + 1);
                        switch (instr[i])
                        {
                        case u'{':
                            nesting_level++;
                            break;
                        case u'}':
                            if (nesting_level == 0)
                                goto break_1;
                            nesting_level--;
                            break;
                        }
                        i++;
                    }
                    break_1:;
                    write_to_pos(prevci + 1, i + 1);
                    auto outer_p = endqpos + (instr[endqpos + 2] == u'\n' ? 3 : 2);
                    if (habr_html)
                        outfile.write(u"<spoiler title=\""_S & remove_comments(instr[range_el(startqpos + 1, endqpos)], startqpos + 1).replace(u"\""_S, u"''"_S) & u"\">\n"_S & (to_html(instr[range_el(outer_p, i)], nullptr, outer_p)) & u"</spoiler>\n"_S);
                    else
                        outfile.write(u"<span class=\"spoiler_title\" onclick=\"return spoiler2(this, event)\">"_S & remove_comments(instr[range_el(startqpos + 1, endqpos)], startqpos + 1) & u"<br /></span>"_S & u"<div class=\"spoiler_text\" style=\"display: none\">\n"_S & (to_html(instr[range_el(outer_p, i)], nullptr, outer_p)) & u"</div>\n"_S);
                    if ((next_char() == u'\n' && !in_unordered_list && ordered_list_current_number == -1)) {
                        i++;
                        writepos = i + 1;
                    }
                }
                else if (prevc == u'\'') {
                    auto t = startqpos - 1;
                    while (t >= 0) {
                        if (instr[t] != u'\'')
                            break;
                        t--;
                    }
                    auto eat_left = startqpos - 1 - t;
                    t = endqpos + 1;
                    while (t < instr.len()) {
                        if (instr[t] != u'\'')
                            break;
                        t++;
                    }
                    auto eat_right = t - (endqpos + 1);
                    write_to_pos(startqpos - eat_left, t);
                    outfile.write(instr[range_el(startqpos + eat_left, endqpos - eat_right + 1)]);
                }
                else if (in(prevc, u"0OО"_S)) {
                    write_to_pos(prevci, endqpos + 1);
                    outfile.write(html_escape(instr[range_el(startqpos + 1, endqpos)]).replace(u"\n"_S, u"<br />\n"_S));
                }
                else if (prevc == u'#') {
                    auto ins = instr[range_el(startqpos + 1, endqpos)];
                    write_to_pos(prevci, endqpos + 1);
                    if (habr_html) {
                        auto contains_new_line = in(u'\n'_C, ins);
                        outfile.write((str_in_b != u"" ? u"<source lang=\""_S & str_in_b & u"\">"_S : contains_new_line ? u"<source>"_S : u"<code>"_S) & ins & (str_in_b != u"" || contains_new_line ? u"</source>"_S : u"</code>"_S));
                    }
                    else {
                        auto pre = u"<pre "_S & (_get<0>(ins) == u'\n' ? u"class=\"code_block\""_S : u"style=\"display: inline\""_S) & u">"_S;
                        if (ohd && syntax_highlighter_for_pqmarkup::is_lang_supported(str_in_b)) {
                            if (!(highlight_style_was_added)) {
                                outfile.write(syntax_highlighter_for_pqmarkup::css);
                                highlight_style_was_added = true;
                            }
                            try
                            {
                                outfile.write(pre & syntax_highlighter_for_pqmarkup::highlight(str_in_b, ins) & u"</pre>"_S);
                            }
                            catch (const syntax_highlighter_for_pqmarkup::Error& e)
                            {
                                exit_with_error(u"Syntax highlighter: "_S & e.message, startqpos + 1 + e.pos);
                            }
                        }
                        else
                            outfile.write(pre & html_escape(ins) & u"</pre>"_S);
                    }
                    if (_get<0>(ins) == u'\n' && instr[range_el(i + 1, i + 2)] == u'\n') {
                        outfile.write(u"\n"_S);
                        new_line_tag = u""_S;
                    }
                }
                else if (in(prevc, u"TТ"_S)) {
                    write_to_pos(prevci, endqpos + 1);
                    auto header_row = false;
                    auto hor_row_align = u""_S;
                    auto ver_row_align = u""_S;

                    class TableCell
                    {
                    public:
                        String text;
                        String attrs;
                        TableCell(const String &text, const String &attrs) :
                            text(text),
                            attrs(attrs)
                        {
                        }
                    };
                    Array<Array<TableCell>> table;
                    auto j = startqpos + 1;
                    while (j < endqpos) {
                        ch = instr[j];
                        if (ch == u'‘') {
                            Array<TableCell> empty_list;
                            table.append(empty_list);
                            auto endrow = find_ending_pair_quote(j);
                            auto hor_col_align = u""_S;
                            auto ver_col_align = u""_S;

                            j++;
                            while (j < endrow) {
                                ch = instr[j];
                                if (ch == u'‘') {
                                    auto end_of_column = find_ending_pair_quote(j);
                                    auto style = u""_S;
                                    if (hor_row_align != u"" || hor_col_align != u"")
                                        style &= u"text-align: "_S & (hor_col_align != u"" ? hor_col_align : hor_row_align);
                                    if (ver_row_align != u"" || ver_col_align != u"") {
                                        if (style != u"")
                                            style &= u"; "_S;
                                        style &= u"vertical-align: "_S & (ver_col_align != u"" ? ver_col_align : ver_row_align);
                                    }
                                    hor_col_align = u""_S;
                                    ver_col_align = u""_S;
                                    table.last().append(TableCell(to_html(instr[range_el(j + 1, end_of_column)], nullptr, j + 1), (header_row ? u"th"_S : u"td"_S) & (style != u"" ? u" style=\""_S & style & u"\""_S : u""_S)));
                                    j = end_of_column;
                                }
                                else if (in(ch, u"<>"_S) && in(instr[range_el(j + 1, j + 2)], make_tuple(u"<"_S, u">"_S))) {
                                    hor_col_align = [&](const auto &a){return a == u"<<" ? u"left"_S : a == u">>" ? u"right"_S : a == u"><" ? u"center"_S : a == u"<>" ? u"justify"_S : throw KeyError(a);}(instr[range_el(j, j + 2)]);
                                    j++;
                                }
                                else if (in(instr[range_el(j, j + 2)], make_tuple(u"/\\"_S, u"\\/"_S))) {
                                    ver_col_align = instr[range_el(j, j + 2)] == u"/\\" ? u"top"_S : u"bottom"_S;
                                    j++;
                                }
                                else if (ch == u'-') {
                                    if (table.last().empty())
                                        exit_with_error(u"Wrong table column span marker \"-\""_S, j);
                                    table.last().append(TableCell(u""_S, u"-"_S));
                                }
                                else if (ch == u'|') {
                                    if (table.len() == 1)
                                        exit_with_error(u"Wrong table row span marker \"|\""_S, j);
                                    table.last().append(TableCell(u""_S, u"|"_S));
                                }
                                else if (instr[range_el(j, j + 3)] == u"[[[")
                                    j = find_ending_sq_bracket(instr, j);
                                else if (!in(ch, u"  \t\n"_S))
                                    exit_with_error(u"Unknown formatting character inside table row"_S, j);
                                j++;
                            }

                            header_row = false;
                            hor_row_align = u""_S;
                            ver_row_align = u""_S;
                        }
                        else if (in(ch, u"HН"_S))
                            header_row = true;
                        else if (in(ch, u"<>"_S) && in(instr[range_el(j + 1, j + 2)], make_tuple(u"<"_S, u">"_S))) {
                            hor_row_align = [&](const auto &a){return a == u"<<" ? u"left"_S : a == u">>" ? u"right"_S : a == u"><" ? u"center"_S : a == u"<>" ? u"justify"_S : throw KeyError(a);}(instr[range_el(j, j + 2)]);
                            j++;
                        }
                        else if (in(instr[range_el(j, j + 2)], make_tuple(u"/\\"_S, u"\\/"_S))) {
                            ver_row_align = instr[range_el(j, j + 2)] == u"/\\" ? u"top"_S : u"bottom"_S;
                            j++;
                        }
                        else if (instr[range_el(j, j + 3)] == u"[[[")
                            j = find_ending_sq_bracket(instr, j);
                        else if (!in(ch, u"  \t\n"_S))
                            exit_with_error(u"Unknown formatting character inside table"_S, j);

                        j++;
                    }
                    for (auto y : range_el(table.len() - 1, -1).step(-1))
                        for (auto x : range_el(table[y].len() - 1, -1).step(-1))
                            if (in(table[y][x].attrs, make_tuple(u"-"_S, u"|"_S))) {
                                auto xx = x;
                                auto yy = y;
                                while (true)
                                    if (table[yy][xx].attrs == u'-')
                                        xx--;
                                    else if (table[yy][xx].attrs == u'|')
                                        yy--;
                                    else
                                        break;
                                if (xx < x)
                                    table[yy][xx].attrs &= u" colspan=\""_S & String(x - xx + 1) & u"\""_S;
                                if (yy < y)
                                    table[yy][xx].attrs &= u" rowspan=\""_S & String(y - yy + 1) & u"\""_S;
                                for (auto xxx : range_ee(xx, x))
                                    for (auto yyy : range_ee(yy, y))
                                        if (make_tuple(xxx, yyy) != make_tuple(xx, yy))
                                            table[yyy][xxx].attrs = u""_S;
                            }

                    auto is_inline = true;
                    if ((prevci == 0 || instr[prevci - 1] == u'\n' || (prevci - 3 >= 0 && instr[range_el(prevci - 3, prevci)] == u"]]]" && instr[range_el(0, 3)] == u"[[[" && find_ending_sq_bracket(instr, 0) == prevci - 1)))
                        is_inline = false;
                    outfile.write(u"<table"_S & (u" style=\"display: inline\""_S * is_inline) & u">\n"_S);
                    for (auto &&row : table) {
                        outfile.write(u"<tr>"_S);
                        for (auto &&cell : row)
                            if (cell.attrs != u"")
                                outfile.write(u"<"_S & cell.attrs & u">"_S & cell.text & u"</"_S & cell.attrs[range_el(0, 2)] & u">"_S);
                        outfile.write(u"</tr>\n"_S);
                    }
                    outfile.write(u"</table>\n"_S);
                    if (!is_inline)
                        new_line_tag = u""_S;
                }
                else if (in(prevc, u"<>"_S) && in(instr[prevci - 1], u"<>"_S)) {
                    write_to_pos(prevci - 1, endqpos + 1);
                    outfile.write(u"<div align=\""_S & ([&](const auto &a){return a == u"<<" ? u"left"_S : a == u">>" ? u"right"_S : a == u"><" ? u"center"_S : a == u"<>" ? u"justify"_S : throw KeyError(a);}(instr[prevci - 1] & prevc)) & u"\">"_S & (to_html(instr[range_el(startqpos + 1, endqpos)], nullptr, startqpos + 1)) & u"</div>\n"_S);
                    new_line_tag = u""_S;
                }
                else if (i_next_str(u":‘"_S) && instr[range_ei(find_ending_pair_quote(i + 2) + 1)][range_el(0, 1)] == u'<') {
                    auto endrq = find_ending_pair_quote(i + 2);
                    i = endrq + 1;
                    write_to_pos(prevci + 1, i + 1);
                    outfile.write(u"<blockquote>"_S & (to_html(instr[range_el(startqpos + 1, endqpos)], nullptr, startqpos + 1)) & u"<br />\n<div align='right'><i>"_S & instr[range_el(endqpos + 3, endrq)] & u"</i></div></blockquote>"_S);
                    new_line_tag = u""_S;
                }
                else {
                    i = startqpos;
                    if (in(prev_char(), u"*_-~"_S)) {
                        write_to_pos(i - 1, i + 1);
                        auto tag = [&](const auto &a){return a == u'*' ? u'b'_C : a == u'_' ? u'u'_C : a == u'-' ? u's'_C : a == u'~' ? u'i'_C : throw KeyError(a);}(prev_char());
                        outfile.write(u"<"_S & tag & u">"_S);
                        ending_tags.append(u"</"_S & tag & u">"_S);
                    }
                    else if (in(prevc, u"HН"_S)) {
                        write_to_pos(prevci, i + 1);
                        auto tag = u"h"_S & String(min(max(3 - (str_in_b == u"" ? 0 : to_int(str_in_b)), 1), 6));
                        outfile.write(u"<"_S & tag & u">"_S);
                        ending_tags.append(u"</"_S & tag & u">"_S);
                    }
                    else if (in(prevc, u"CС"_S)) {
                        write_to_pos(prevci, i + 1);
                        auto which_color = u"color"_S;
                        if (str_in_b[range_el(0, 1)] == u'-') {
                            str_in_b = str_in_b[range_ei(1)];
                            which_color = u"background-color"_S;
                        }
                        if (str_in_b[range_el(0, 1)] == u'#') {
                            auto new_str_in_b = u""_S;
                            for (auto &&c : str_in_b) {
                                auto cc = _get<0>(([&](const auto &a){return a == u'а' ? u"A"_S : a == u'б' ? u"B"_S : a == u'с' ? u"C"_S : a == u'д' ? u"D"_S : a == u'е' ? u"E"_S : a == u'ф' ? u"F"_S : c;}(c.lowercase())));
                                new_str_in_b &= c.is_lowercase() ? cc.lowercase() : cc;
                            }
                            str_in_b = new_str_in_b;
                        }
                        else if (in(str_in_b.len(), make_tuple(1, 3)) && str_in_b.is_digit()) {
                            auto new_str = u"#"_S;
                            for (auto &&ii : str_in_b.len() == 3 ? create_array({0, 1, 2}) : create_array({0, 0, 0}))
                                new_str &= hex(idiv((to_int(str_in_b[ii]) * 0xFF + 4), 8)).zfill(2);
                            str_in_b = new_str;
                        }
                        if (habr_html) {
                            outfile.write(u"<font color=\""_S & str_in_b & u"\">"_S);
                            ending_tags.append(u"</font>"_S);
                        }
                        else {
                            outfile.write(u"<span style=\""_S & which_color & u": "_S & str_in_b & u"\">"_S);
                            ending_tags.append(u"</span>"_S);
                        }
                    }
                    else if (in(make_tuple(instr[range_el(prevci - 1, prevci)], prevc), make_tuple(make_tuple(u"/"_S, uR"(\)"_S), make_tuple(uR"(\)"_S, u"/"_S)))) {
                        write_to_pos(prevci - 1, i + 1);
                        auto tag = make_tuple(instr[prevci - 1], prevc) == make_tuple(u"/"_S, uR"(\)"_S) ? u"sup"_S : u"sub"_S;
                        outfile.write(u"<"_S & tag & u">"_S);
                        ending_tags.append(u"</"_S & tag & u">"_S);
                    }
                    else if (prevc == u'!') {
                        write_to_pos(prevci, i + 1);
                        outfile.write(habr_html ? u"<blockquote>"_S : u"<div class=\"note\">"_S);
                        ending_tags.append(habr_html ? u"</blockquote>"_S : u"</div>"_S);
                    }
                    else
                        ending_tags.append(u"’"_S);
                }
            }
            else if (ch == u'’') {
                write_to_pos(i, i + 1);
                if (ending_tags.empty())
                    exit_with_error(u"Unpaired right single quotation mark"_S, i);
                auto last = ending_tags.pop();
                outfile.write(last);
                if (next_char() == u'\n' && (last.starts_with(u"</h"_S) || in(last, make_tuple(u"</blockquote>"_S, u"</div>"_S)))) {
                    outfile.write(u"\n"_S);
                    i++;
                    writepos++;
                }
            }
            else if (ch == u'`') {
                auto start = i;
                i++;
                while (i < instr.len()) {
                    if (instr[i] != u'`')
                        break;
                    i++;
                }
                auto end = instr.findi((i - start) * u"`"_S, i);
                if (end == -1)
                    exit_with_error(u"Unended ` started"_S, start);
                write_to_pos(start, end + i - start);
                auto ins = instr[range_el(i, end)];
                auto delta = ins.count(u"‘"_S) - ins.count(u"’"_S);
                if (delta > 0)
                    for (auto ii : range_el(0, delta))
                        ending_tags.append(u"’"_S);
                else
                    for (auto ii : range_el(0, -delta))
                        if (ending_tags.pop() != u'’')
                            exit_with_error(u"Unpaired single quotation mark found inside code block/span beginning"_S, start);
                ins = html_escape(ins);
                if (!(in(u'\n'_C, ins)))
                    outfile.write(habr_html ? u"<code>"_S & ins & u"</code>"_S : u"<pre class=\"inline_code\">"_S & ins & u"</pre>"_S);
                else {
                    outfile.write(u"<pre>"_S & ins & u"</pre>"_S & (u"\n"_S * (!(habr_html))));
                    new_line_tag = u""_S;
                }
                i = end + i - start - 1;
            }
            else if (ch == u'[') {
                if (i_next_str(u"http"_S) || i_next_str(u"./"_S) || (i_next_str(u"‘"_S) && !in(prev_char(), u"\r\n\t \0"_S)) || numbered_link()) {
                    auto s = i - 1;
                    while (s >= writepos && !in(instr[s], u"\r\n\t [{(‘“"_S))
                        s--;
                    if (i_next_str(u"‘"_S))
                        write_note(s + 1, i, 0);
                    else if (i_next_str(u"http"_S) || i_next_str(u"./"_S))
                        write_http_link(s + 1, i, 0);
                    else {
                        write_to_pos(s + 1, endi + 1);
                        outfile.write(u"<a href=\""_S & link & u"\">"_S & html_escape(instr[range_el(s + 1, i)]) & u"</a>"_S);
                        i = endi;
                    }
                }
                else if (i_next_str(u"[["_S)) {
                    auto comment_start = i;
                    auto nesting_level = 0;
                    while (true) {
                        switch (instr[i])
                        {
                        case u'[':
                            nesting_level++;
                            break;
                        case u']':
                            if (--nesting_level == 0)
                                goto break_2;
                            break;
                        case u'‘':
                            ending_tags.append(u"’"_S);
                            break;
                        case u'’':
                            assert(ending_tags.pop() == u'’');
                            break;
                        }
                        i++;
                        if (i == instr.len())
                            exit_with_error(u"Unended comment started"_S, comment_start);
                    }
                    break_2:;
                    write_to_pos(comment_start, i + 1);
                    if (instr[range_el(comment_start + 3, comment_start + 4)] != u'[') {
                        outfile.write(u"<!--"_S);
                        outfile.write(remove_comments(instr[range_el(comment_start, i + 1)], comment_start, 4));
                        outfile.write(u"-->"_S);
                    }
                }
                else
                    write_to_i((u"<span class=\"sq\"><span class=\"sq_brackets\">"_S * ohd) & (u"<font color=\"#BFBFBF\">"_S * habr_html) & u"["_S & (u"</font><font color=\"gray\">"_S * habr_html) & (ohd * u"</span>"_S));
            }
            else if (ch == u']')
                write_to_i((u"<span class=\"sq_brackets\">"_S * ohd) & (u"</font><font color=\"#BFBFBF\">"_S * habr_html) & u"]"_S & (u"</font>"_S * habr_html) & (ohd * u"</span></span>"_S));
            else if (ch == u'{')
                write_to_i(u"<span class=\"cu_brackets\" onclick=\"return spoiler(this, event)\"><span class=\"cu_brackets_b\">"_S * ohd & u"{"_S & (ohd * u"</span><span>…</span><span class=\"cu\" style=\"display: none\">"_S));
            else if (ch == u'}')
                write_to_i(u"</span><span class=\"cu_brackets_b\">"_S * ohd & u"}"_S & (ohd * u"</span></span>"_S));
            else if (ch == u'\n') {
                write_to_i((new_line_tag != u'\0' ? new_line_tag : u"<br />"_S) & (new_line_tag != u"" ? u"\n"_S : u""_S));
                new_line_tag = u"\0"_S;
            }

            i++;
        }

        close_ordered_list();
        close_unordered_list();

        write_to_pos(instr.len(), 0);
        assert(ending_tags.empty());
        assert(to_html_called_inside_to_html_outer_pos_list.pop() == outer_pos);

        if (outfilef == nullptr) {
            auto r = result.join(u""_S);
            if (habr_html)
                r = r.replace(u"</blockquote>\n"_S, u"</blockquote>"_S);
            return r;
        }

        return u""_S;
    }
};

template <typename T1, typename T3 = decltype(false), typename T4 = decltype(false)> auto to_html(const T1 &instr, File* const outfilef = nullptr, const T3 &ohd = false, const T4 &habr_html = false)
{
    return Converter(habr_html, ohd).to_html(instr, outfilef);
}

int MAIN_WITH_ARGV()
{
    INIT_ARGV();

    if (in(u"-h"_S, ::argv) || in(u"--help"_S, ::argv)) {
        print(uR"(A Python implementation of pq markup to HTML converter.

Usage: pqmarkup [options] [INPUTFILE]

Positional arguments:
  INPUT_FILE            input file (STDIN is assumed if no INPUT_FILE is
                        given)

Options:
  -h, --help            show this help message and exit
  --habr-html           for publishing posts on habr.com
  --output-html-document
                        add some html header for rough testing preview of your
                        converted documents
  -f [OUTPUT_FILE], --file [OUTPUT_FILE]
                        write output to OUTPUT_FILE (defaults to STDOUT))"_S);
        exit(0);
    }

    auto args_habr_html = in(u"--habr-html"_S, ::argv);
    auto args_output_html_document = in(u"--output-html-document"_S, ::argv);
    auto args_infile = _stdin;
    auto i = 1;
    while (i < ::argv.len()) {
        if (in(::argv[i], make_tuple(u"-f"_S, u"--file"_S))) {
            i += 2;
            continue;
        }
        if (!::argv[i].starts_with(u"-"_S)) {
            try
            {
                args_infile = File(::argv[i], u"r"_S, u"utf-8-sig"_S);
            }
            catch (...)
            {
                exit(u"Can't open file '"_S & ::argv[i] & u"'"_S);
            }
            break;
        }
        i++;
    }
    auto args_outfile = _stdout;
    String outfile_name;
    try
    {
        if (in(u"-f"_S, ::argv)) {
            outfile_name = ::argv[::argv.index(u"-f"_S) + 1];
            args_outfile = File(outfile_name, u"w"_S, u"utf-8"_S);
        }
        else if (in(u"--file"_S, ::argv)) {
            outfile_name = ::argv[::argv.index(u"--file"_S) + 1];
            args_outfile = File(outfile_name, u"w"_S, u"utf-8"_S);
        }
    }
    catch (...)
    {
        exit(u"Can't open file '"_S & outfile_name & u"' for writing"_S);
    }
    if (args_output_html_document && args_habr_html)
        exit(u"Options --output-html-document and --habr-html are mutually exclusive"_S);

    String infile_str;
    try
    {
        infile_str = args_infile.read();
    }
    catch (const UnicodeDecodeError&)
    {
        exit(u"Input is not a valid UTF-8!"_S);
    }
    auto title = u""_S;
    if (infile_str.starts_with(u"[[[H‘"_S) || infile_str.starts_with(u"[[[Н‘"_S)) {
        i = 5;
        auto nesting_level = 1;
        while (i < infile_str.len()) {
            switch (infile_str[i])
            {
            case u'‘':
                nesting_level++;
                break;
            case u'’':
                if (--nesting_level == 0)
                    goto break_3;
                break;
            }
            i++;
        }
        break_3:;
        title = infile_str[range_el(5, i)];
    }
    if (args_output_html_document)
        args_outfile.write(uR"(<html>
<head>
<meta charset="utf-8" />
)"_S & (title != u"" ? u"<title>"_S & title & u"</title>\n"_S : u""_S) & uR"(<base target="_blank">
<script type="text/javascript">
function spoiler(element, event)
{
    if (event.target.nodeName == 'A' || event.target.parentNode.nodeName == 'A' || event.target.onclick)//чтобы работали ссылки в спойлерах и спойлеры2 в спойлерах
        return;
    var e = element.firstChild.nextSibling.nextSibling;//element.getElementsByTagName('span')[0]
    e.previousSibling.style.display = e.style.display;//<span>…</span> must have inverted display style
    e.style.display = (e.style.display == "none" ? "" : "none");
    element.firstChild.style.fontWeight =
    element. lastChild.style.fontWeight = (e.style.display == "" ? "normal" : "bold");
    event.stopPropagation();
    //[-Чтобы была возможность выделять текст внутри раскрытого ‘скрытого текста’/спойлера, необходимо [скрытие/]закрытие спойлера делать не просто по нажатию левой кнопки мыши, а по отпусканию левой кнопки мыши при условии отсутствия движения курсора [мыши] после того, как была нажата левая кнопка мыши.-]
}
function spoiler2(element, event)
{
    element.nextSibling.style.display = (element.nextSibling.style.display == "none" ? "" : "none");
}
</script>
<style type="text/css">
div#main, td {
    font-size: 14px;
    font-family: Verdana, sans-serif;
    line-height: 160%;
    text-align: justify;
}
span.cu_brackets_b {
    font-size: initial;
    font-family: initial;
    font-weight: bold;
}
a {
    text-decoration: none;
    color: #6da3bd;
}
a:hover {
    text-decoration: underline;
    color: #4d7285;
}
h1, h2, h3, h4, h5, h6 {
    margin: 0;
    font-weight: 400;
}
h1 {font-size: 200%; line-height: 130%;}
h2 {font-size: 180%; line-height: 135%;}
h3 {font-size: 160%; line-height: 140%;}
h4 {font-size: 145%; line-height: 145%;}
h5 {font-size: 130%; line-height: 140%;}
h6 {font-size: 120%; line-height: 140%;}
span.sq {color: gray; font-size: 0.8rem; font-weight: normal; /*pointer-events: none;*/}
span.sq_brackets {color: #BFBFBF;}
span.cu_brackets {cursor: pointer;}
span.cu {background-color: #F7F7FF;}
abbr {text-decoration: none; border-bottom: 1px dotted;}
pre {margin: 0;})"_S & uR"(
pre, code {font-family: 'Courier New'; line-height: normal}
ul, ol {margin: 11px 0 7px 0;}
ul li, ol li {padding: 7px 0;}
ul li:first-child, ol li:first-child {padding-top   : 0;}
ul  li:last-child, ol  li:last-child {padding-bottom: 0;}
table {margin: 9px 0; border-collapse: collapse;}
table th, table td {padding: 6px 13px; border: 1px solid #BFBFBF;}
span.spoiler_title {
    color: #548eaa;
    cursor: pointer;
    border-bottom: 1px dotted;
}
div.spoiler_text {
    /*border: 1px dotted;*/
    margin: 5px;
    padding: 3px;
}
blockquote {
    margin: 0 0 7px 0;
    padding: 7px 12px;
}
blockquote:not(.re) {border-left:  0.2em solid #90ddaa; background-color: #fbfffb;}
blockquote.re       {border-right: 0.2em solid #90ddaa; background-color: #f4fff8;}
div.note {
    padding: 18px 20px;
    background: #ffffd7;
}
pre.code_block {padding: 6px 0;}
pre.inline_code {
    display: inline;
    padding: 0px 3px;
    border: 1px solid #E5E5E5;
    background-color: #FAFAFA;
    border-radius: 3px;
}
img {vertical-align: middle;}

div#main {width: 100%;}
@media screen and (min-width: 1050px) {
    div#main {width: 1024px;}
}
</style>
</head>
<body>
<div id="main" style="margin: 0 auto">
)"_S);
    try
    {
        to_html(infile_str, &args_outfile, args_output_html_document, args_habr_html);
    }
    catch (const Exception& e)
    {
        _stderr.write(e.message & u" at line "_S & String(e.line) & u", column "_S & String(e.column) & u"\n"_S);
        exit(-1);
    }
    if (args_output_html_document)
        args_outfile.write(uR"(</div>
</body>
</html>)"_S);
}