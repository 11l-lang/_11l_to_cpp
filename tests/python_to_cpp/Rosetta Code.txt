# https://www.rosettacode.org/wiki/Visualize_a_tree#D
from typing import List

class Node:
    value : str
    left : 'Node' = None
    right : 'Node' = None

    def __init__(self, value, left : 'Node' = None, right : 'Node' = None):
        self.value = str(value)
        self.left = left
        self.right = right

    def tree_indent(self) -> List[str]:
        tr = self.right.tree_indent() if self.right != None else ['-- (null)']
        return ['--' + self.value] + list(map(lambda a: '  |' + a, self.left.tree_indent() if self.left != None else ['-- (null)'])) + ['  `' + tr[0]] + list(map(lambda a: "   " + a, tr[1:]))

tree = Node(1, Node(2, Node(4, Node(7)), Node(5)), Node(3, Node(6, Node(8), Node(9))))
print("\n".join(tree.tree_indent()))
===

T Node
   String value
   Node? left
   Node? right

   F (value, Node? left = N, Node? right = N)
      .value = String(value)
      .left = left
      .right = right

   F tree_indent() -> Array[String]
      A tr = I .right != N {.right.tree_indent()} E [‘-- (null)’]
      R [‘--’(.value)] [+] (I .left != N {.left.tree_indent()} E [‘-- (null)’]).map(a -> ‘  |’a) [+] [‘  `’tr[0]] + tr[1..].map(a -> ‘   ’a)
A tree = Node(1, Node(2, Node(4, Node(7)), Node(5)), Node(3, Node(6, Node(8), Node(9))))
print((tree.tree_indent()).join("\n"))
===
class Node : public SharedObject
{
public:
    String value;
    SharedPtr<Node> left;
    SharedPtr<Node> right;

    template <typename T1> Node(const T1 &value, SharedPtr<Node> left = nullptr, SharedPtr<Node> right = nullptr)
    {
        this->value = String(value);
        this->left = left;
        this->right = right;
    }

    Array<String> tree_indent()
    {
        auto tr = right != nullptr ? right->tree_indent() : create_array({u"-- (null)"_S});
        return create_array({u"--"_S + (value)}) + (left != nullptr ? left->tree_indent() : create_array({u"-- (null)"_S})).map([](const auto &a){return u"  |"_S + a;}) + create_array({u"  `"_S + _get<0>(tr)}) + tr[range_ei(1)].map([](const auto &a){return u"   "_S + a;});
    }
};
auto tree = make_SharedPtr<Node>(1, make_SharedPtr<Node>(2, make_SharedPtr<Node>(4, make_SharedPtr<Node>(7)), make_SharedPtr<Node>(5)), make_SharedPtr<Node>(3, make_SharedPtr<Node>(6, make_SharedPtr<Node>(8), make_SharedPtr<Node>(9))));

struct CodeBlock1
{
    CodeBlock1()
    {
        print((tree->tree_indent()).join(u"\n"_S));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Range_expansion#Python
def rangeexpand(txt):
    lst : List[int] = []
    for r in txt.split(','):
        if '-' in r[1:]:
            rr = r[1:].split('-', 1)
            lst += range(int(r[0] + '' + rr[0]), int(rr[1]) + 1)
        else:
            lst.append(int(r))
    return lst
 
print(rangeexpand('-6,-3--1,3-5,7-11,14,15,17-20'))
===
F rangeexpand(txt)
   Array[Int] lst
   L(r) txt.split(‘,’)
      I ‘-’ C r[1..]
         A rr = r[1..].split(‘-’, 1 + 1)
         lst [+]= (Int(r[0]‘’rr[0]) .< Int(rr[1]) + 1)
      E
         lst.append(Int(r))
   R lst
print(rangeexpand(‘-6,-3--1,3-5,7-11,14,15,17-20’))
===
template <typename T1> auto rangeexpand(const T1 &txt)
{
    Array<int> lst;
    for (auto r : txt.split(u","_S))
        if (in(u'-'_C, r[range_ei(1)])) {
            auto rr = r[range_ei(1)].split(u"-"_S, 1 + 1);
            lst.append(range_el(to_int(_get<0>(r) + _get<0>(rr)), to_int(_get<1>(rr)) + 1));
        }
        else
            lst.append(to_int(r));
    return lst;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(rangeexpand(u"-6,-3--1,3-5,7-11,14,15,17-20"_S));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Loops/Break#Python
import random
 
while True:
    a = random.randrange(20)
    print(a)
    if a == 10:
        break
    b = random.randrange(20)
    print(b)
===
//import random

L
   A a = random:(20)
   print(a)
   I a == 10
      L.break
   A b = random:(20)
   print(b)
===
struct CodeBlock1
{
    CodeBlock1()
    {
        while (true) {
            auto a = randomns::_(20);
            print(a);
            if (a == 10)
                break;
            auto b = randomns::_(20);
            print(b);
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Execute_Brain****/Python
import sys, collections

def bf(source):
    loop_ptrs : Dict[int, int] = {}
    loop_stack : List[int] = []
    for ptr, opcode in enumerate(source):
        if opcode == '[': loop_stack.append(ptr)
        if opcode == ']':
            sptr = loop_stack.pop()
            loop_ptrs[ptr] = sptr
            loop_ptrs[sptr] = ptr

    tape = collections.defaultdict(int) # int
    cell = 0
    ptr = 0
    while ptr < len(source):
        opcode = source[ptr]
        if   opcode == '>': cell += 1
        elif opcode == '<': cell -= 1
        elif opcode == '+': tape[cell] += 1
        elif opcode == '-': tape[cell] -= 1
        elif opcode == '.': sys.stdout.write(chr(tape[cell]))
        elif opcode == ',': tape[cell] = ord(sys.stdin.read(1))
        elif (opcode == '[' and not tape[cell]) or \
             (opcode == ']' and tape[cell]): ptr = loop_ptrs[ptr]
        ptr += 1

bf('++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.')
===
//import sys, collections

F bf(source)
   Dict[Int, Int] loop_ptrs
   Array[Int] loop_stack
   L(opcode) source
      A ptr = L.index
      I opcode == ‘[’
         loop_stack.append(ptr)
      I opcode == ‘]’
         A sptr = loop_stack.pop()
         loop_ptrs[ptr] = sptr
         loop_ptrs[sptr] = ptr
   A tape = DefaultDict[Int, Int]()
   A cell = 0
   A ptr = 0
   L ptr < source.len
      A opcode = source[ptr]
      I opcode == ‘>’
         cell++
      E I opcode == ‘<’
         cell--
      E I opcode == ‘+’
         tape[cell]++
      E I opcode == ‘-’
         tape[cell]--
      E I opcode == ‘.’
         :stdout.write(Char(code' tape[cell]))
      E I opcode == ‘,’
         tape[cell] = :stdin.read(1).code
      E I (opcode == ‘[’ & !(tape[cell])) | (opcode == ‘]’ & tape[cell])
         ptr = loop_ptrs[ptr]
      ptr++
bf(‘++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.’)
===
template <typename T1> auto bf(const T1 &source)
{
    Dict<int, int> loop_ptrs;
    Array<int> loop_stack;
    {int Lindex = 0;
    for (auto opcode : source) {
        auto ptr = Lindex;
        if (opcode == u'[')
            loop_stack.append(ptr);
        if (opcode == u']') {
            auto sptr = loop_stack.pop();
            loop_ptrs.set(ptr, sptr);
            loop_ptrs.set(sptr, ptr);
        }
        Lindex++;
    }}
    auto tape = DefaultDict<int, int>();
    auto cell = 0;
    auto ptr = 0;
    while (ptr < source.len()) {
        auto opcode = source[ptr];
        if (opcode == u'>')
            cell++;
        else if (opcode == u'<')
            cell--;
        else if (opcode == u'+')
            tape[cell]++;
        else if (opcode == u'-')
            tape[cell]--;
        else if (opcode == u'.')
            _stdout.write(Char(tape[cell]));
        else if (opcode == u',')
            tape.set(cell, _stdin.read(1).code);
        else if ((opcode == u'[' && !(tape[cell])) || (opcode == u']' && tape[cell]))
            ptr = loop_ptrs[ptr];
        ptr++;
    }
}

struct CodeBlock1
{
    CodeBlock1()
    {
        bf(u"++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++."_S);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Execute_Brain****
import sys, collections

def bf(source):
    tape = collections.defaultdict(int) # int
    cell = 0
    ptr = 0
    while ptr < len(source):
        opcode = source[ptr]
        if   opcode == '>': cell += 1
        elif opcode == '<': cell -= 1
        elif opcode == '+': tape[cell] += 1
        elif opcode == '-': tape[cell] -= 1
        elif opcode == '.': sys.stdout.write(chr(tape[cell]))
        elif opcode == ',': tape[cell] = ord(sys.stdin.read(1))
        elif opcode == '[':
            if tape[cell] == 0:
                nesting_level = 0
                while True:
                    ch = source[ptr]
                    if ch == '[':
                        nesting_level += 1
                    elif ch == ']':
                        nesting_level -= 1
                        if nesting_level == 0:
                            break
                    ptr += 1
        elif opcode == ']':
            if tape[cell] != 0:
                nesting_level = 0
                while True:
                    ch = source[ptr]
                    if ch == '[':
                        nesting_level -= 1
                        if nesting_level == 0:
                            break
                    elif ch == ']':
                        nesting_level += 1
                    ptr -= 1
        ptr += 1

bf('++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.')
===
//import sys, collections

F bf(source)
   A tape = DefaultDict[Int, Int]()
   A cell = 0
   A ptr = 0
   L ptr < source.len
      S source[ptr]
         ‘>’
            cell++
         ‘<’
            cell--
         ‘+’
            tape[cell]++
         ‘-’
            tape[cell]--
         ‘.’
            :stdout.write(Char(code' tape[cell]))
         ‘,’
            tape[cell] = :stdin.read(1).code
         ‘[’
            I tape[cell] == 0
               A nesting_level = 0
               L
                  S source[ptr]
                     ‘[’
                        nesting_level++
                     ‘]’
                        I --nesting_level == 0
                           L.break
                  ptr++
         ‘]’
            I tape[cell] != 0
               A nesting_level = 0
               L
                  S source[ptr]
                     ‘[’
                        I --nesting_level == 0
                           L.break
                     ‘]’
                        nesting_level++
                  ptr--
      ptr++
bf(‘++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.’)
===
template <typename T1> auto bf(const T1 &source)
{
    auto tape = DefaultDict<int, int>();
    auto cell = 0;
    auto ptr = 0;
    while (ptr < source.len()) {
        switch (source[ptr])
        {
        case u'>':
            cell++;
            break;
        case u'<':
            cell--;
            break;
        case u'+':
            tape[cell]++;
            break;
        case u'-':
            tape[cell]--;
            break;
        case u'.':
            _stdout.write(Char(tape[cell]));
            break;
        case u',':
            tape.set(cell, _stdin.read(1).code);
            break;
        case u'[':
            if (tape[cell] == 0) {
                auto nesting_level = 0;
                while (true) {
                    switch (source[ptr])
                    {
                    case u'[':
                        nesting_level++;
                        break;
                    case u']':
                        if (--nesting_level == 0)
                            goto break_;
                        break;
                    }
                    ptr++;
                }
                break_:;
            }
            break;
        case u']':
            if (tape[cell] != 0) {
                auto nesting_level = 0;
                while (true) {
                    switch (source[ptr])
                    {
                    case u'[':
                        if (--nesting_level == 0)
                            goto break_1;
                        break;
                    case u']':
                        nesting_level++;
                        break;
                    }
                    ptr--;
                }
                break_1:;
            }
            break;
        }
        ptr++;
    }
}

struct CodeBlock1
{
    CodeBlock1()
    {
        bf(u"++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++."_S);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/LZW_compression#Python
import sys
from typing import List

def compress(uncompressed):
    dict_size = 256
    dictionary = dict((str(chr(i)), i) for i in range(dict_size))
 
    w = ""
    result : List[int] = []
    for c in uncompressed:
        wc = w + c
        if wc in dictionary:
            w = wc
        else:
            result.append(dictionary[w])
            # Add wc to the dictionary.
            dictionary[wc] = dict_size
            dict_size += 1
            w = c
 
    # Output the code for w.
    if len(w):
        result.append(dictionary[w])
    return result

def decompress(compressed : List[int]):
    dict_size = 256
    dictionary = dict((i, str(chr(i))) for i in range(dict_size))
 
    result = ''
    w = str(chr(compressed.pop(0)))
    result += w
    for k in compressed:
        entry = ''
        if k in dictionary:
            entry = dictionary[k]
        elif k == dict_size:
            entry = w + w[0]
        else:
            sys.exit('Bad compressed k: '+str(k))
        result += entry
 
        dictionary[dict_size] = w + entry[0]
        dict_size += 1
 
        w = entry
    return result

compressed = compress('TOBEORNOTTOBEORTOBEORNOT')
print(compressed)
print(decompress(compressed))
===
//import sys

F compress(uncompressed)
   A dict_size = 256
   A dictionary = Dict((0 .< dict_size).map(i -> (String(Char(code' i)), i)))
   A w = ‘’
   Array[Int] result
   L(c) uncompressed
      A wc = w‘’c
      I wc C dictionary
         w = wc
      E
         result.append(dictionary[w])
         dictionary[wc] = dict_size
         dict_size++
         w = c

   I !w.empty
      result.append(dictionary[w])
   R result

F decompress(Array[Int] &compressed)
   A dict_size = 256
   A dictionary = Dict((0 .< dict_size).map(i -> (i, String(Char(code' i)))))
   A result = ‘’
   A w = String(Char(code' compressed.pop(0)))
   result ‘’= w
   L(k) compressed
      A entry = ‘’
      I k C dictionary
         entry = dictionary[k]
      E I k == dict_size
         entry = w‘’w[0]
      E
         exit(‘Bad compressed k: ’String(k))
      result ‘’= entry
      dictionary[dict_size] = w‘’entry[0]
      dict_size++
      w = entry
   R result
A compressed = compress(‘TOBEORNOTTOBEORTOBEORNOT’)
print(compressed)
print(decompress(compressed))
===
template <typename T1> auto compress(const T1 &uncompressed)
{
    auto dict_size = 256;
    auto dictionary = create_dict(range_el(0, dict_size).map([](const auto &i){return make_tuple(String(Char(i)), i);}));
    auto w = u""_S;
    Array<int> result;
    for (auto c : uncompressed) {
        auto wc = w + c;
        if (in(wc, dictionary))
            w = wc;
        else {
            result.append(dictionary[w]);
            dictionary.set(wc, dict_size);
            dict_size++;
            w = c;
        }
    }
    if (!w.empty())
        result.append(dictionary[w]);
    return result;
}

auto decompress(Array<int> &compressed)
{
    auto dict_size = 256;
    auto dictionary = create_dict(range_el(0, dict_size).map([](const auto &i){return make_tuple(i, String(Char(i)));}));
    auto result = u""_S;
    auto w = String(Char(compressed.pop(0)));
    result += w;
    for (auto k : compressed) {
        auto entry = u""_S;
        if (in(k, dictionary))
            entry = dictionary[k];
        else if (k == dict_size)
            entry = w + _get<0>(w);
        else
            exit(u"Bad compressed k: "_S + String(k));
        result += entry;
        dictionary.set(dict_size, w + _get<0>(entry));
        dict_size++;
        w = entry;
    }
    return result;
}
auto compressed = compress(u"TOBEORNOTTOBEORTOBEORNOT"_S);

struct CodeBlock1
{
    CodeBlock1()
    {
        print(compressed);
        print(decompress(compressed));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/100_doors#Python
# Please take solution from '../parser/Rosetta Code.txt'
doors = [False] * 100
for i in range(100):
   for j in range(i, 100, i+1):
       doors[j] = not doors[j]
   print('Door ' + str(i+1) + ': '+ ('open' if doors[i] else 'close'))
===
A doors = [0B] * 100
L(i) 0.<100
   L(j) (i .< 100).step(i + 1)
      doors[j] = !(doors[j])
   print(‘Door ’String(i + 1)‘: ’(I doors[i] {‘open’} E ‘close’))
===
auto doors = create_array({false}) * 100;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto i : range_el(0, 100)) {
            for (auto j : range_el(i, 100).step(i + 1))
                doors.set(j, !(doors[j]));
            print(u"Door "_S + String(i + 1) + u": "_S + (doors[i] ? u"open"_S : u"close"_S));
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/A%2BB#Python
print(sum(map(lambda i: int(i), input().split())))
===
print(sum(input().split((‘ ’, "\t", "\r", "\n"), group_delimiters' 1B).map(i -> Int(i))))
===
struct CodeBlock1
{
    CodeBlock1()
    {
        print(sum(input().split(make_tuple(u" "_S, u"\t"_S, u"\r"_S, u"\n"_S), nullptr, true).map([](const auto &i){return to_int(i);})));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/ABC_Problem#Python:_Iterative.2C_with_tests
def can_make_word(word):
    if word == '':
        return False
 
    blocks_remaining = 'BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM'.split(' ')

    for ch in word.upper():
        for block in blocks_remaining:
            if ch in block:
                blocks_remaining.remove(block)
                break
        else:
            return False
    return True
 
print(', '.join("'" + w + "': " + str(can_make_word(w)) for w in ['', 'a', 'baRk', 'booK', 'treat', 'COMMON', 'squad', 'Confused']))
===
F can_make_word(word)
   I word == ‘’
      R 0B
   A blocks_remaining = ‘BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM’.split(‘ ’)

   L(ch) word.uppercase()
      L(block) blocks_remaining
         I ch C block
            blocks_remaining.remove(block)
            L.break
         L.was_no_break
            R 0B
   R 1B
print([‘’, ‘a’, ‘baRk’, ‘booK’, ‘treat’, ‘COMMON’, ‘squad’, ‘Confused’].map(w -> ‘'’w‘': ’String(can_make_word(w))).join(‘, ’))
===
template <typename T1> auto can_make_word(const T1 &word)
{
    if (word == u"")
        return false;
    auto blocks_remaining = u"BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM"_S.split(u" "_S);
    for (auto ch : word.uppercase())
        {bool was_break = false;
        for (auto block : blocks_remaining) {
            if (in(ch, block)) {
                blocks_remaining.remove(block);
                was_break = true;
                break;
            }
        }
        if (!was_break)
            return false;
        }
    return true;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(create_array({u""_S, u"a"_S, u"baRk"_S, u"booK"_S, u"treat"_S, u"COMMON"_S, u"squad"_S, u"Confused"_S}).map([](const auto &w){return u"'"_S + w + u"': "_S + String(can_make_word(w));}).join(u", "_S));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Abundant,_deficient_and_perfect_number_classifications#Kotlin
# Please take solution from '../parser/Rosetta Code.txt'
def sum_proper_divisors(n):
    return 0 if n < 2 else sum(filter(lambda it: (n % it) == 0, range(1, n // 2 + 1)))
 
deficient = 0
perfect = 0
abundant = 0

for n in range(1, 20000+1):
    sp = sum_proper_divisors(n)
    if sp < n: deficient += 1
    elif sp == n: perfect += 1
    elif sp > n : abundant += 1

print("Deficient = " + str(deficient))
print("Perfect   = " + str(perfect))
print("Abundant  = " + str(abundant))
===
F sum_proper_divisors(n)
   R I n < 2 {0} E sum((1 .< n I/ 2 + 1).filter(it -> (@n % it) == 0))
A deficient = 0
A perfect = 0
A abundant = 0

L(n) 1 .< 20000 + 1
   A sp = sum_proper_divisors(n)
   I sp < n
      deficient++
   E I sp == n
      perfect++
   E I sp > n
      abundant++
print(‘Deficient = ’String(deficient))
print(‘Perfect   = ’String(perfect))
print(‘Abundant  = ’String(abundant))
===
template <typename T1> auto sum_proper_divisors(const T1 &n)
{
    return n < 2 ? 0 : sum(range_el(1, int(n)/int(2) + 1).filter([&n](const auto &it){return (mod(n, it)) == 0;}));
}
auto deficient = 0;
auto perfect = 0;
auto abundant = 0;

struct CodeBlock1
{
    CodeBlock1()
    {

        for (auto n : range_el(1, 20000 + 1)) {
            auto sp = sum_proper_divisors(n);
            if (sp < n)
                deficient++;
            else if (sp == n)
                perfect++;
            else if (sp > n)
                abundant++;
        }
        print(u"Deficient = "_S + String(deficient));
        print(u"Perfect   = "_S + String(perfect));
        print(u"Abundant  = "_S + String(abundant));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Align_columns#Python
from typing import Callable

txt = R"""Given$a$txt$file$of$many$lines,$where$fields$within$a$line$
are$delineated$by$a$single$'dollar'$character,$write$a$program
that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$
column$are$separated$by$at$least$one$space.
Further,$allow$for$each$word$in$a$column$to$be$either$left$
justified,$right$justified,$or$center$justified$within$its$column."""

parts = [line.rstrip("$").split("$") for line in txt.split("\n")]

max_widths = [0] * len(parts[0])
for line in parts:
    for i, word in enumerate(line):
        max_widths[i] = max(max_widths[i], len(word))

ljust : Callable[[str, int], str] = lambda s, w: s + ' '*(w-len(s))
centr : Callable[[str, int], str] = lambda s, w: ' '*(w-len(s) - (w//2 - len(s)//2)) + s + ' '*(w//2 - len(s)//2)
rjust : Callable[[str, int], str] = lambda s, w: ' '*(w-len(s)) + s
for i, justify in enumerate([ljust, centr, rjust]):
    print(["Left", "Center", "Right"][i] + " column-aligned output:")
    for line in parts:
        for j, word in enumerate(line):
            print(justify(word, max_widths[j]), end = ' ')
        print()
    print("- " * 52)
===
A txt = ‘Given$a$txt$file$of$many$lines,$where$fields$within$a$line$
are$delineated$by$a$single$'dollar'$character,$write$a$program
that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$
column$are$separated$by$at$least$one$space.
Further,$allow$for$each$word$in$a$column$to$be$either$left$
justified,$right$justified,$or$center$justified$within$its$column.’
A parts = txt.split("\n").map(line -> line.rtrim(‘$’).split(‘$’))
A max_widths = [0] * parts[0].len
L(line) parts
   L(word) line
      A i = L.index
      max_widths[i] = max(max_widths[i], word.len)
(String, Int -> String) ljust = (s, w) -> s‘’(‘ ’ * (w - s.len))
(String, Int -> String) centr = (s, w) -> (‘ ’ * (w - s.len - (w I/ 2 - s.len I/ 2)))‘’s‘’(‘ ’ * (w I/ 2 - s.len I/ 2))
(String, Int -> String) rjust = (s, w) -> (‘ ’ * (w - s.len))‘’s
L(justify) [ljust, centr, rjust]
   A i = L.index
   print([‘Left’, ‘Center’, ‘Right’][i]‘ column-aligned output:’)
   L(line) parts
      L(word) line
         A j = L.index
         print(justify(word, max_widths[j]), end' ‘ ’)
      print()
   print(‘- ’ * 52)
===
auto txt = uR"(Given$a$txt$file$of$many$lines,$where$fields$within$a$line$
are$delineated$by$a$single$'dollar'$character,$write$a$program
that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$
column$are$separated$by$at$least$one$space.
Further,$allow$for$each$word$in$a$column$to$be$either$left$
justified,$right$justified,$or$center$justified$within$its$column.)"_S;
auto parts = txt.split(u"\n"_S).map([](const auto &line){return line.rtrim(u"$"_S).split(u"$"_S);});
auto max_widths = create_array({0}) * _get<0>(parts).len();

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto line : parts)
            {int Lindex = 0;
            for (auto word : line) {
                auto i = Lindex;
                max_widths.set(i, max(max_widths[i], word.len()));
                Lindex++;
            }}
    }
} code_block_1;
std::function<String(const String&, const int)> ljust = [](const auto &s, const auto &w){return s + (u" "_S * (w - s.len()));};
std::function<String(const String&, const int)> centr = [](const auto &s, const auto &w){return (u" "_S * (w - s.len() - (int(w)/int(2) - int(s.len())/int(2)))) + s + (u" "_S * (int(w)/int(2) - int(s.len())/int(2)));};
std::function<String(const String&, const int)> rjust = [](const auto &s, const auto &w){return (u" "_S * (w - s.len())) + s;};

struct CodeBlock2
{
    CodeBlock2()
    {
        {int Lindex = 0;
        for (auto justify : create_array({ljust, centr, rjust})) {
            auto i = Lindex;
            print(create_array({u"Left"_S, u"Center"_S, u"Right"_S})[i] + u" column-aligned output:"_S);
            for (auto line : parts) {
                {int Lindex = 0;
                for (auto word : line) {
                    auto j = Lindex;
                    print(justify(word, max_widths[j]), u" "_S);
                    Lindex++;
                }}
                print();
            }
            print(u"- "_S * 52);
            Lindex++;
        }}
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Almost_prime#Kotlin
def k_prime(k, n):
    f = 0
    p = 2
    while f < k and p * p <= n:
        while n % p == 0:
            n /= p
            f += 1
        p += 1
    return f + (1 if n > 1 else 0) == k
 
def primes(k, n):
    i = 2
    list : List[int] = []
    while len(list) < n:
        if k_prime(k, i):
            list.append(i)
        i += 1
    return list
 
for k in range(1, 6):
    print('k = '+str(k)+': ', end = '')
    print(primes(k, 10))
===
F k_prime(k, =n)
   A f = 0
   A p = 2
   L f < k & p * p <= n
      L n % p == 0
         n /= p
         f++
      p++
   R f + (I n > 1 {1} E 0) == k

F primes(k, n)
   A i = 2
   Array[Int] list
   L list.len < n
      I k_prime(k, i)
         list.append(i)
      i++
   R list

L(k) 1.<6
   print(‘k = ’String(k)‘: ’, end' ‘’)
   print(primes(k, 10))
===
template <typename T1, typename T2> auto k_prime(const T1 &k, T2 n)
{
    auto f = 0;
    auto p = 2;
    while (f < k && p * p <= n) {
        while (mod(n, p) == 0) {
            n /= p;
            f++;
        }
        p++;
    }
    return f + (n > 1 ? 1 : 0) == k;
}

template <typename T1, typename T2> auto primes(const T1 &k, const T2 &n)
{
    auto i = 2;
    Array<int> list;
    while (list.len() < n) {
        if (k_prime(k, i))
            list.append(i);
        i++;
    }
    return list;
}

struct CodeBlock1
{
    CodeBlock1()
    {

        for (auto k : range_el(1, 6)) {
            print(u"k = "_S + String(k) + u": "_S, u""_S);
            print(primes(k, 10));
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Anagrams#Python
import collections
from typing import List, DefaultDict

anagram : DefaultDict[str, List[str]] = collections.defaultdict(list)
for word in open('unixdict.txt').read().split("\n"):
    anagram[''.join(sorted(word))].append(word)

count = max(len(ana) for ana in anagram.values())

for ana in anagram.values():
    if len(ana) == count:
        print(ana)
===
//import collections
DefaultDict[String, Array[String]] anagram
L(word) File(‘unixdict.txt’).read().split("\n")
   anagram[(sorted(word)).join(‘’)].append(word)
A count = max(anagram.values().map(ana -> ana.len))

L(ana) anagram.values()
   I ana.len == count
      print(ana)
===
DefaultDict<String, Array<String>> anagram;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto word : File(u"unixdict.txt"_S).read().split(u"\n"_S))
            anagram[(sorted(word)).join(u""_S)].append(word);
    }
} code_block_1;
auto count = max(anagram.values().map([](const auto &ana){return ana.len();}));

struct CodeBlock2
{
    CodeBlock2()
    {
        for (auto ana : anagram.values())
            if (ana.len() == count)
                print(ana);
    }
} code_block_2;