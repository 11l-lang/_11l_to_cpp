# https://www.rosettacode.org/wiki/Visualize_a_tree#D
from typing import List

class Node:
    value : str
    left : 'Node' = None
    right : 'Node' = None

    def __init__(self, value, left : 'Node' = None, right : 'Node' = None):
        self.value = str(value)
        self.left = left
        self.right = right

    def tree_indent(self) -> List[str]:
        tr = self.right.tree_indent() if self.right is not None else ['-- (null)']
        return ['--' + self.value] + list(map(lambda a: '  |' + a, self.left.tree_indent() if self.left is not None else ['-- (null)'])) + ['  `' + tr[0]] + list(map(lambda a: "   " + a, tr[1:]))

tree = Node(1, Node(2, Node(4, Node(7)), Node(5)), Node(3, Node(6, Node(8), Node(9))))
print("\n".join(tree.tree_indent()))
===

T Node
   String value
   Node? left
   Node? right

   F (value, Node? left = N, Node? right = N)
      .value = String(value)
      .left = left
      .right = right

   F tree_indent() -> [String]
      V tr = I .right != N {.right.tree_indent()} E [‘-- (null)’]
      R [‘--’(.value)] [+] (I .left != N {.left.tree_indent()} E [‘-- (null)’]).map(a -> ‘  |’a) [+] [‘  `’tr[0]] + tr[1..].map(a -> ‘   ’a)
V tree = Node(1, Node(2, Node(4, Node(7)), Node(5)), Node(3, Node(6, Node(8), Node(9))))
print(tree.tree_indent().join("\n"))
===
class Node : public SharedObject
{
public:
    String value;
    SharedPtr<Node> left;
    SharedPtr<Node> right;

    template <typename T1> Node(const T1 &value, SharedPtr<Node> left = nullptr, SharedPtr<Node> right = nullptr)
    {
        this->value = String(value);
        this->left = left;
        this->right = right;
    }

    Array<String> tree_indent()
    {
        auto tr = right != nullptr ? right->tree_indent() : create_array({u"-- (null)"_S});
        return create_array({u"--"_S + (value)}) + (left != nullptr ? left->tree_indent() : create_array({u"-- (null)"_S})).map([](const auto &a){return u"  |"_S + a;}) + create_array({u"  `"_S + _get<0>(tr)}) + tr[range_ei(1)].map([](const auto &a){return u"   "_S + a;});
    }
};
auto tree = make_SharedPtr<Node>(1, make_SharedPtr<Node>(2, make_SharedPtr<Node>(4, make_SharedPtr<Node>(7)), make_SharedPtr<Node>(5)), make_SharedPtr<Node>(3, make_SharedPtr<Node>(6, make_SharedPtr<Node>(8), make_SharedPtr<Node>(9))));

struct CodeBlock1
{
    CodeBlock1()
    {
        print(tree->tree_indent().join(u"\n"_S));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Range_expansion#Python
def rangeexpand(txt):
    lst : List[int] = []
    for r in txt.split(','):
        if '-' in r[1:]:
            rr = r[1:].split('-', 1)
            lst += range(int(r[0] + '' + rr[0]), int(rr[1]) + 1)
        else:
            lst.append(int(r))
    return lst
 
print(rangeexpand('-6,-3--1,3-5,7-11,14,15,17-20'))
===
F rangeexpand(txt)
   [Int] lst
   L(r) txt.split(‘,’)
      I ‘-’ C r[1..]
         V rr = r[1..].split(‘-’, 1 + 1)
         lst [+]= (Int(r[0]‘’rr[0]) .< Int(rr[1]) + 1)
      E
         lst.append(Int(r))
   R lst
print(rangeexpand(‘-6,-3--1,3-5,7-11,14,15,17-20’))
===
template <typename T1> auto rangeexpand(const T1 &txt)
{
    Array<int> lst;
    for (auto r : txt.split(u","_S))
        if (in(u'-'_C, r[range_ei(1)])) {
            auto rr = r[range_ei(1)].split(u"-"_S, 1 + 1);
            lst.append(range_el(to_int(_get<0>(r) + _get<0>(rr)), to_int(_get<1>(rr)) + 1));
        }
        else
            lst.append(to_int(r));
    return lst;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(rangeexpand(u"-6,-3--1,3-5,7-11,14,15,17-20"_S));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Loops/Break#Python
import random
 
while True:
    a = random.randrange(20)
    print(a)
    if a == 10:
        break
    b = random.randrange(20)
    print(b)
===
//import random

L
   V a = random:(20)
   print(a)
   I a == 10
      L.break
   V b = random:(20)
   print(b)
===
struct CodeBlock1
{
    CodeBlock1()
    {
        while (true) {
            auto a = randomns::_(20);
            print(a);
            if (a == 10)
                break;
            auto b = randomns::_(20);
            print(b);
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Execute_Brain****/Python
import sys, collections

def bf(source):
    loop_ptrs : Dict[int, int] = {}
    loop_stack : List[int] = []
    for ptr, opcode in enumerate(source):
        if opcode == '[': loop_stack.append(ptr)
        if opcode == ']':
            sptr = loop_stack.pop()
            loop_ptrs[ptr] = sptr
            loop_ptrs[sptr] = ptr

    tape = collections.defaultdict(int) # int
    cell = 0
    ptr = 0
    while ptr < len(source):
        opcode = source[ptr]
        if   opcode == '>': cell += 1
        elif opcode == '<': cell -= 1
        elif opcode == '+': tape[cell] += 1
        elif opcode == '-': tape[cell] -= 1
        elif opcode == '.': sys.stdout.write(chr(tape[cell]))
        elif opcode == ',': tape[cell] = ord(sys.stdin.read(1))
        elif (opcode == '[' and not tape[cell]) or \
             (opcode == ']' and tape[cell]): ptr = loop_ptrs[ptr]
        ptr += 1

bf('++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.')
===
//import sys, collections

F bf(source)
   Dict[Int, Int] loop_ptrs
   [Int] loop_stack
   L(opcode) source
      V ptr = L.index
      I opcode == ‘[’
         loop_stack.append(ptr)
      I opcode == ‘]’
         V sptr = loop_stack.pop()
         loop_ptrs[ptr] = sptr
         loop_ptrs[sptr] = ptr
   V tape = DefaultDict[Int, Int]()
   V cell = 0
   V ptr = 0
   L ptr < source.len
      V opcode = source[ptr]
      I opcode == ‘>’
         cell++
      E I opcode == ‘<’
         cell--
      E I opcode == ‘+’
         tape[cell]++
      E I opcode == ‘-’
         tape[cell]--
      E I opcode == ‘.’
         :stdout.write(Char(code' tape[cell]))
      E I opcode == ‘,’
         tape[cell] = :stdin.read(1).code
      E I (opcode == ‘[’ & !(tape[cell])) | (opcode == ‘]’ & tape[cell])
         ptr = loop_ptrs[ptr]
      ptr++
bf(‘++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.’)
===
template <typename T1> auto bf(const T1 &source)
{
    Dict<int, int> loop_ptrs;
    Array<int> loop_stack;
    {int Lindex = 0;
    for (auto opcode : source) {
        auto ptr = Lindex;
        if (opcode == u'[')
            loop_stack.append(ptr);
        if (opcode == u']') {
            auto sptr = loop_stack.pop();
            loop_ptrs.set(ptr, sptr);
            loop_ptrs.set(sptr, ptr);
        }
        Lindex++;
    }}
    auto tape = DefaultDict<int, int>();
    auto cell = 0;
    auto ptr = 0;
    while (ptr < source.len()) {
        auto opcode = source[ptr];
        if (opcode == u'>')
            cell++;
        else if (opcode == u'<')
            cell--;
        else if (opcode == u'+')
            tape[cell]++;
        else if (opcode == u'-')
            tape[cell]--;
        else if (opcode == u'.')
            _stdout.write(Char(tape[cell]));
        else if (opcode == u',')
            tape.set(cell, _stdin.read(1).code);
        else if ((opcode == u'[' && !(tape[cell])) || (opcode == u']' && tape[cell]))
            ptr = loop_ptrs[ptr];
        ptr++;
    }
}

struct CodeBlock1
{
    CodeBlock1()
    {
        bf(u"++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++."_S);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Execute_Brain****
import sys, collections

def bf(source):
    tape = collections.defaultdict(int) # int
    cell = 0
    ptr = 0
    while ptr < len(source):
        opcode = source[ptr]
        if   opcode == '>': cell += 1
        elif opcode == '<': cell -= 1
        elif opcode == '+': tape[cell] += 1
        elif opcode == '-': tape[cell] -= 1
        elif opcode == '.': sys.stdout.write(chr(tape[cell]))
        elif opcode == ',': tape[cell] = ord(sys.stdin.read(1))
        elif opcode == '[':
            if tape[cell] == 0:
                nesting_level = 0
                while True:
                    ch = source[ptr]
                    if ch == '[':
                        nesting_level += 1
                    elif ch == ']':
                        nesting_level -= 1
                        if nesting_level == 0:
                            break
                    ptr += 1
        elif opcode == ']':
            if tape[cell] != 0:
                nesting_level = 0
                while True:
                    ch = source[ptr]
                    if ch == '[':
                        nesting_level -= 1
                        if nesting_level == 0:
                            break
                    elif ch == ']':
                        nesting_level += 1
                    ptr -= 1
        ptr += 1

bf('++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.')
===
//import sys, collections

F bf(source)
   V tape = DefaultDict[Int, Int]()
   V cell = 0
   V ptr = 0
   L ptr < source.len
      S source[ptr]
         ‘>’
            cell++
         ‘<’
            cell--
         ‘+’
            tape[cell]++
         ‘-’
            tape[cell]--
         ‘.’
            :stdout.write(Char(code' tape[cell]))
         ‘,’
            tape[cell] = :stdin.read(1).code
         ‘[’
            I tape[cell] == 0
               V nesting_level = 0
               L
                  S source[ptr]
                     ‘[’
                        nesting_level++
                     ‘]’
                        I --nesting_level == 0
                           L.break
                  ptr++
         ‘]’
            I tape[cell] != 0
               V nesting_level = 0
               L
                  S source[ptr]
                     ‘[’
                        I --nesting_level == 0
                           L.break
                     ‘]’
                        nesting_level++
                  ptr--
      ptr++
bf(‘++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.’)
===
template <typename T1> auto bf(const T1 &source)
{
    auto tape = DefaultDict<int, int>();
    auto cell = 0;
    auto ptr = 0;
    while (ptr < source.len()) {
        switch (source[ptr])
        {
        case u'>':
            cell++;
            break;
        case u'<':
            cell--;
            break;
        case u'+':
            tape[cell]++;
            break;
        case u'-':
            tape[cell]--;
            break;
        case u'.':
            _stdout.write(Char(tape[cell]));
            break;
        case u',':
            tape.set(cell, _stdin.read(1).code);
            break;
        case u'[':
            if (tape[cell] == 0) {
                auto nesting_level = 0;
                while (true) {
                    switch (source[ptr])
                    {
                    case u'[':
                        nesting_level++;
                        break;
                    case u']':
                        if (--nesting_level == 0)
                            goto break_;
                        break;
                    }
                    ptr++;
                }
                break_:;
            }
            break;
        case u']':
            if (tape[cell] != 0) {
                auto nesting_level = 0;
                while (true) {
                    switch (source[ptr])
                    {
                    case u'[':
                        if (--nesting_level == 0)
                            goto break_1;
                        break;
                    case u']':
                        nesting_level++;
                        break;
                    }
                    ptr--;
                }
                break_1:;
            }
            break;
        }
        ptr++;
    }
}

struct CodeBlock1
{
    CodeBlock1()
    {
        bf(u"++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++."_S);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/LZW_compression#Python
import sys
from typing import List

def compress(uncompressed):
    dict_size = 256
    dictionary = dict((str(chr(i)), i) for i in range(dict_size))
 
    w = ""
    result : List[int] = []
    for c in uncompressed:
        wc = w + c
        if wc in dictionary:
            w = wc
        else:
            result.append(dictionary[w])
            # Add wc to the dictionary.
            dictionary[wc] = dict_size
            dict_size += 1
            w = c
 
    # Output the code for w.
    if len(w):
        result.append(dictionary[w])
    return result

def decompress(compressed : List[int]):
    dict_size = 256
    dictionary = dict((i, str(chr(i))) for i in range(dict_size))
 
    result = ''
    w = str(chr(compressed.pop(0)))
    result += w
    for k in compressed:
        entry = ''
        if k in dictionary:
            entry = dictionary[k]
        elif k == dict_size:
            entry = w + w[0]
        else:
            sys.exit('Bad compressed k: '+str(k))
        result += entry
 
        dictionary[dict_size] = w + entry[0]
        dict_size += 1
 
        w = entry
    return result

compressed = compress('TOBEORNOTTOBEORTOBEORNOT')
print(compressed)
print(decompress(compressed))
===
//import sys

F compress(uncompressed)
   V dict_size = 256
   V dictionary = Dict((0 .< dict_size).map(i -> (String(Char(code' i)), i)))
   V w = ‘’
   [Int] result
   L(c) uncompressed
      V wc = w‘’c
      I wc C dictionary
         w = wc
      E
         result.append(dictionary[w])
         dictionary[wc] = dict_size
         dict_size++
         w = c

   I !w.empty
      result.append(dictionary[w])
   R result

F decompress([Int] &compressed)
   V dict_size = 256
   V dictionary = Dict((0 .< dict_size).map(i -> (i, String(Char(code' i)))))
   V result = ‘’
   V w = String(Char(code' compressed.pop(0)))
   result ‘’= w
   L(k) compressed
      V entry = ‘’
      I k C dictionary
         entry = dictionary[k]
      E I k == dict_size
         entry = w‘’w[0]
      E
         exit(‘Bad compressed k: ’String(k))
      result ‘’= entry
      dictionary[dict_size] = w‘’entry[0]
      dict_size++
      w = entry
   R result
V compressed = compress(‘TOBEORNOTTOBEORTOBEORNOT’)
print(compressed)
print(decompress(&compressed))
===
template <typename T1> auto compress(const T1 &uncompressed)
{
    auto dict_size = 256;
    auto dictionary = create_dict(range_el(0, dict_size).map([](const auto &i){return make_tuple(String(Char(i)), i);}));
    auto w = u""_S;
    Array<int> result;
    for (auto c : uncompressed) {
        auto wc = w + c;
        if (in(wc, dictionary))
            w = wc;
        else {
            result.append(dictionary[w]);
            dictionary.set(wc, dict_size);
            dict_size++;
            w = c;
        }
    }
    if (!w.empty())
        result.append(dictionary[w]);
    return result;
}

auto decompress(Array<int> &compressed)
{
    auto dict_size = 256;
    auto dictionary = create_dict(range_el(0, dict_size).map([](const auto &i){return make_tuple(i, String(Char(i)));}));
    auto result = u""_S;
    auto w = String(Char(compressed.pop(0)));
    result += w;
    for (auto k : compressed) {
        auto entry = u""_S;
        if (in(k, dictionary))
            entry = dictionary[k];
        else if (k == dict_size)
            entry = w + _get<0>(w);
        else
            exit(u"Bad compressed k: "_S + String(k));
        result += entry;
        dictionary.set(dict_size, w + _get<0>(entry));
        dict_size++;
        w = entry;
    }
    return result;
}
auto compressed = compress(u"TOBEORNOTTOBEORTOBEORNOT"_S);

struct CodeBlock1
{
    CodeBlock1()
    {
        print(compressed);
        print(decompress(compressed));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/100_doors#Python
# Please take solution from '../parser/Rosetta Code.txt'
doors = [False] * 100
for i in range(100):
   for j in range(i, 100, i+1):
       doors[j] = not doors[j]
   print('Door ' + str(i+1) + ': '+ ('open' if doors[i] else 'close'))
===
V doors = [0B] * 100
L(i) 0.<100
   L(j) (i .< 100).step(i + 1)
      doors[j] = !(doors[j])
   print(‘Door ’String(i + 1)‘: ’(I doors[i] {‘open’} E ‘close’))
===
auto doors = create_array({false}) * 100;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto i : range_el(0, 100)) {
            for (auto j : range_el(i, 100).step(i + 1))
                doors.set(j, !(doors[j]));
            print(u"Door "_S + String(i + 1) + u": "_S + (doors[i] ? u"open"_S : u"close"_S));
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/A%2BB#Python
print(sum(map(lambda i: int(i), input().split())))
===
print(sum(input().split((‘ ’, "\t", "\r", "\n"), group_delimiters' 1B).map(i -> Int(i))))
===
struct CodeBlock1
{
    CodeBlock1()
    {
        print(sum(input().split(make_tuple(u" "_S, u"\t"_S, u"\r"_S, u"\n"_S), nullptr, true).map([](const auto &i){return to_int(i);})));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/ABC_Problem#Python:_Iterative.2C_with_tests
def can_make_word(word):
    if word == '':
        return False
 
    blocks_remaining = 'BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM'.split(' ')

    for ch in word.upper():
        for block in blocks_remaining:
            if ch in block:
                blocks_remaining.remove(block)
                break
        else:
            return False
    return True
 
print(', '.join("'" + w + "': " + str(can_make_word(w)) for w in ['', 'a', 'baRk', 'booK', 'treat', 'COMMON', 'squad', 'Confused']))
===
F can_make_word(word)
   I word == ‘’
      R 0B
   V blocks_remaining = ‘BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM’.split(‘ ’)

   L(ch) word.uppercase()
      L(block) blocks_remaining
         I ch C block
            blocks_remaining.remove(block)
            L.break
         L.was_no_break
            R 0B
   R 1B
print([‘’, ‘a’, ‘baRk’, ‘booK’, ‘treat’, ‘COMMON’, ‘squad’, ‘Confused’].map(w -> ‘'’w‘': ’String(can_make_word(w))).join(‘, ’))
===
template <typename T1> auto can_make_word(const T1 &word)
{
    if (word == u"")
        return false;
    auto blocks_remaining = u"BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM"_S.split(u" "_S);
    for (auto ch : word.uppercase())
        {bool was_break = false;
        for (auto block : blocks_remaining) {
            if (in(ch, block)) {
                blocks_remaining.remove(block);
                was_break = true;
                break;
            }
        }
        if (!was_break)
            return false;
        }
    return true;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(create_array({u""_S, u"a"_S, u"baRk"_S, u"booK"_S, u"treat"_S, u"COMMON"_S, u"squad"_S, u"Confused"_S}).map([](const auto &w){return u"'"_S + w + u"': "_S + String(can_make_word(w));}).join(u", "_S));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Abundant,_deficient_and_perfect_number_classifications#Kotlin
# Please take solution from '../parser/Rosetta Code.txt'
def sum_proper_divisors(n):
    return 0 if n < 2 else sum(filter(lambda it: (n % it) == 0, range(1, n // 2 + 1)))
 
deficient = 0
perfect = 0
abundant = 0

for n in range(1, 20000+1):
    sp = sum_proper_divisors(n)
    if sp < n: deficient += 1
    elif sp == n: perfect += 1
    elif sp > n : abundant += 1

print("Deficient = " + str(deficient))
print("Perfect   = " + str(perfect))
print("Abundant  = " + str(abundant))
===
F sum_proper_divisors(n)
   R I n < 2 {0} E sum((1 .< n I/ 2 + 1).filter(it -> (@n % it) == 0))
V deficient = 0
V perfect = 0
V abundant = 0

L(n) 1 .< 20000 + 1
   V sp = sum_proper_divisors(n)
   I sp < n
      deficient++
   E I sp == n
      perfect++
   E I sp > n
      abundant++
print(‘Deficient = ’String(deficient))
print(‘Perfect   = ’String(perfect))
print(‘Abundant  = ’String(abundant))
===
template <typename T1> auto sum_proper_divisors(const T1 &n)
{
    return n < 2 ? 0 : sum(range_el(1, int(n)/int(2) + 1).filter([&n](const auto &it){return (mod(n, it)) == 0;}));
}
auto deficient = 0;
auto perfect = 0;
auto abundant = 0;

struct CodeBlock1
{
    CodeBlock1()
    {

        for (auto n : range_el(1, 20000 + 1)) {
            auto sp = sum_proper_divisors(n);
            if (sp < n)
                deficient++;
            else if (sp == n)
                perfect++;
            else if (sp > n)
                abundant++;
        }
        print(u"Deficient = "_S + String(deficient));
        print(u"Perfect   = "_S + String(perfect));
        print(u"Abundant  = "_S + String(abundant));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Align_columns#Python
from typing import Callable

txt = R"""Given$a$txt$file$of$many$lines,$where$fields$within$a$line$
are$delineated$by$a$single$'dollar'$character,$write$a$program
that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$
column$are$separated$by$at$least$one$space.
Further,$allow$for$each$word$in$a$column$to$be$either$left$
justified,$right$justified,$or$center$justified$within$its$column."""

parts = [line.rstrip("$").split("$") for line in txt.split("\n")]

max_widths = [0] * len(parts[0])
for line in parts:
    for i, word in enumerate(line):
        max_widths[i] = max(max_widths[i], len(word))

ljust : Callable[[str, int], str] = lambda s, w: s + ' '*(w-len(s))
centr : Callable[[str, int], str] = lambda s, w: ' '*(w-len(s) - (w//2 - len(s)//2)) + s + ' '*(w//2 - len(s)//2)
rjust : Callable[[str, int], str] = lambda s, w: ' '*(w-len(s)) + s
for i, justify in enumerate([ljust, centr, rjust]):
    print(["Left", "Center", "Right"][i] + " column-aligned output:")
    for line in parts:
        for j, word in enumerate(line):
            print(justify(word, max_widths[j]), end = ' ')
        print()
    print("- " * 52)
===
V txt = ‘Given$a$txt$file$of$many$lines,$where$fields$within$a$line$
are$delineated$by$a$single$'dollar'$character,$write$a$program
that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$
column$are$separated$by$at$least$one$space.
Further,$allow$for$each$word$in$a$column$to$be$either$left$
justified,$right$justified,$or$center$justified$within$its$column.’
V parts = txt.split("\n").map(line -> line.rtrim(‘$’).split(‘$’))
V max_widths = [0] * parts[0].len
L(line) parts
   L(word) line
      V i = L.index
      max_widths[i] = max(max_widths[i], word.len)
(String, Int -> String) ljust = (s, w) -> s‘’(‘ ’ * (w - s.len))
(String, Int -> String) centr = (s, w) -> (‘ ’ * (w - s.len - (w I/ 2 - s.len I/ 2)))‘’s‘’(‘ ’ * (w I/ 2 - s.len I/ 2))
(String, Int -> String) rjust = (s, w) -> (‘ ’ * (w - s.len))‘’s
L(justify) [ljust, centr, rjust]
   V i = L.index
   print([‘Left’, ‘Center’, ‘Right’][i]‘ column-aligned output:’)
   L(line) parts
      L(word) line
         V j = L.index
         print(justify(word, max_widths[j]), end' ‘ ’)
      print()
   print(‘- ’ * 52)
===
auto txt = uR"(Given$a$txt$file$of$many$lines,$where$fields$within$a$line$
are$delineated$by$a$single$'dollar'$character,$write$a$program
that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$
column$are$separated$by$at$least$one$space.
Further,$allow$for$each$word$in$a$column$to$be$either$left$
justified,$right$justified,$or$center$justified$within$its$column.)"_S;
auto parts = txt.split(u"\n"_S).map([](const auto &line){return line.rtrim(u"$"_S).split(u"$"_S);});
auto max_widths = create_array({0}) * _get<0>(parts).len();

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto line : parts)
            {int Lindex = 0;
            for (auto word : line) {
                auto i = Lindex;
                max_widths.set(i, max(max_widths[i], word.len()));
                Lindex++;
            }}
    }
} code_block_1;
std::function<String(const String&, const int)> ljust = [](const auto &s, const auto &w){return s + (u" "_S * (w - s.len()));};
std::function<String(const String&, const int)> centr = [](const auto &s, const auto &w){return (u" "_S * (w - s.len() - (int(w)/int(2) - int(s.len())/int(2)))) + s + (u" "_S * (int(w)/int(2) - int(s.len())/int(2)));};
std::function<String(const String&, const int)> rjust = [](const auto &s, const auto &w){return (u" "_S * (w - s.len())) + s;};

struct CodeBlock2
{
    CodeBlock2()
    {
        {int Lindex = 0;
        for (auto justify : create_array({ljust, centr, rjust})) {
            auto i = Lindex;
            print(create_array({u"Left"_S, u"Center"_S, u"Right"_S})[i] + u" column-aligned output:"_S);
            for (auto line : parts) {
                {int Lindex = 0;
                for (auto word : line) {
                    auto j = Lindex;
                    print(justify(word, max_widths[j]), u" "_S);
                    Lindex++;
                }}
                print();
            }
            print(u"- "_S * 52);
            Lindex++;
        }}
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Almost_prime#Kotlin
def k_prime(k, n):
    f = 0
    p = 2
    while f < k and p * p <= n:
        while n % p == 0:
            n /= p
            f += 1
        p += 1
    return f + (1 if n > 1 else 0) == k
 
def primes(k, n):
    i = 2
    list : List[int] = []
    while len(list) < n:
        if k_prime(k, i):
            list.append(i)
        i += 1
    return list
 
for k in range(1, 6):
    print('k = '+str(k)+': ', end = '')
    print(primes(k, 10))
===
F k_prime(k, =n)
   V f = 0
   V p = 2
   L f < k & p * p <= n
      L n % p == 0
         n /= p
         f++
      p++
   R f + (I n > 1 {1} E 0) == k

F primes(k, n)
   V i = 2
   [Int] list
   L list.len < n
      I k_prime(k, i)
         list.append(i)
      i++
   R list

L(k) 1.<6
   print(‘k = ’String(k)‘: ’, end' ‘’)
   print(primes(k, 10))
===
template <typename T1, typename T2> auto k_prime(const T1 &k, T2 n)
{
    auto f = 0;
    auto p = 2;
    while (f < k && p * p <= n) {
        while (mod(n, p) == 0) {
            n /= p;
            f++;
        }
        p++;
    }
    return f + (n > 1 ? 1 : 0) == k;
}

template <typename T1, typename T2> auto primes(const T1 &k, const T2 &n)
{
    auto i = 2;
    Array<int> list;
    while (list.len() < n) {
        if (k_prime(k, i))
            list.append(i);
        i++;
    }
    return list;
}

struct CodeBlock1
{
    CodeBlock1()
    {

        for (auto k : range_el(1, 6)) {
            print(u"k = "_S + String(k) + u": "_S, u""_S);
            print(primes(k, 10));
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Anagrams#Python
import collections
from typing import List, DefaultDict

anagram : DefaultDict[str, List[str]] = collections.defaultdict(list)
for word in open('unixdict.txt').read().split("\n"):
    anagram[''.join(sorted(word))].append(word)

count = max(len(ana) for ana in anagram.values())

for ana in anagram.values():
    if len(ana) == count:
        print(ana)
===
//import collections
DefaultDict[String, [String]] anagram
L(word) File(‘unixdict.txt’).read().split("\n")
   anagram[sorted(word).join(‘’)].append(word)
V count = max(anagram.values().map(ana -> ana.len))

L(ana) anagram.values()
   I ana.len == count
      print(ana)
===
DefaultDict<String, Array<String>> anagram;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto word : File(u"unixdict.txt"_S).read().split(u"\n"_S))
            anagram[sorted(word).join(u""_S)].append(word);
    }
} code_block_1;
auto count = max(anagram.values().map([](const auto &ana){return ana.len();}));

struct CodeBlock2
{
    CodeBlock2()
    {
        for (auto ana : anagram.values())
            if (ana.len() == count)
                print(ana);
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Anagrams/Deranged_anagrams#Kotlin
from typing import Dict, List

def is_not_deranged(s1, s2):
    for i in range(len(s1)):
        if s1[i] == s2[i]:
            return True
    return False

anagram : Dict[str, List[str]] = {}
count = 0
for word in open('unixdict.txt').read().split("\n"):
    a = ''.join(sorted(word))
    if a not in anagram:
        anagram[a] = [word]
    else:
        for ana in anagram[a]:
            if is_not_deranged(ana, word):
                break
        else:
            anagram[a].append(word)
            count = max(count, len(word))

for ana in anagram.values():
    if len(ana) > 1 and len(ana[0]) == count:
        print(ana)
===

F is_not_deranged(s1, s2)
   L(i) 0 .< s1.len
      I s1[i] == s2[i]
         R 1B
   R 0B
Dict[String, [String]] anagram
V count = 0
L(word) File(‘unixdict.txt’).read().split("\n")
   V a = sorted(word).join(‘’)
   I a !C anagram
      anagram[a] = [word]
   E
      L(ana) anagram[a]
         I is_not_deranged(ana, word)
            L.break
         L.was_no_break
            anagram[a].append(word)
            count = max(count, word.len)

L(ana) anagram.values()
   I ana.len > 1 & ana[0].len == count
      print(ana)
===
template <typename T1, typename T2> auto is_not_deranged(const T1 &s1, const T2 &s2)
{
    for (auto i : range_el(0, s1.len()))
        if (s1[i] == s2[i])
            return true;
    return false;
}
Dict<String, Array<String>> anagram;
auto count = 0;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto word : File(u"unixdict.txt"_S).read().split(u"\n"_S)) {
            auto a = sorted(word).join(u""_S);
            if (!in(a, anagram))
                anagram.set(a, create_array({word}));
            else
                {bool was_break = false;
                for (auto ana : anagram[a]) {
                    if (is_not_deranged(ana, word)) {
                        was_break = true;
                        break;
                    }
                }
                if (!was_break) {
                    anagram[a].append(word);
                    count = max(count, word.len());
                }
                }
        }
        for (auto ana : anagram.values())
            if (ana.len() > 1 && _get<0>(ana).len() == count)
                print(ana);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Anonymous_recursion#C.2B.2B
def fib(n):
    def f(n : int) -> int:
        if n < 2:
            return n
        return f(n-1) + f(n-2)
    return f(n)

for i in range(21):
    print(fib(i), end = ' ')
===
F fib(n)
   F f(Int n) -> Int
      I n < 2
         R n
      R @f(n - 1) + @f(n - 2)
   R f(n)

L(i) 0.<21
   print(fib(i), end' ‘ ’)
===
template <typename T1> auto fib(const T1 &n)
{
    std::function<int(int)> f = [&f](const int n)
    {
        if (n < 2)
            return n;
        return f(n - 1) + f(n - 2);
    };
    return f(n);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto i : range_el(0, 21))
            print(fib(i), u" "_S);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Anti-primes
max_divisors = 0
c = 0
n = 1
while True:
    divisors = 1
    for i in range(1, n // 2 + 1):
        if n % i == 0:
            divisors += 1

    if divisors > max_divisors:
        max_divisors = divisors
        print(n, end = ' ')
        c += 1
        if c == 20:
            break

    n += 1
===
V max_divisors = 0
V c = 0
V n = 1
L
   V divisors = 1
   L(i) 1 .< n I/ 2 + 1
      I n % i == 0
         divisors++

   I divisors > max_divisors
      max_divisors = divisors
      print(n, end' ‘ ’)
      c++
      I c == 20
         L.break
   n++
===
auto max_divisors = 0;
auto c = 0;
auto n = 1;

struct CodeBlock1
{
    CodeBlock1()
    {
        while (true) {
            auto divisors = 1;
            for (auto i : range_el(1, int(n)/int(2) + 1))
                if (mod(n, i) == 0)
                    divisors++;

            if (divisors > max_divisors) {
                max_divisors = divisors;
                print(n, u" "_S);
                c++;
                if (c == 20)
                    break;
            }
            n++;
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Apply_a_callback_to_an_array#Kotlin
array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
arrsq = list(map(lambda i: i*i, array))
print(arrsq)
===
V array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
V arrsq = array.map(i -> i * i)
print(arrsq)
===
auto array = create_array({1, 2, 3, 4, 5, 6, 7, 8, 9, 10});
auto arrsq = array.map([](const auto &i){return i * i;});

struct CodeBlock1
{
    CodeBlock1()
    {
        print(arrsq);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Arithmetic-geometric_mean#Python
import math
 
def agm(a0, g0, tolerance = 1e-10):
    an = (a0 + g0) / 2.0
    gn = math.sqrt(a0 * g0)
    while abs(an - gn) > tolerance:
        (an, gn) = ((an + gn) / 2.0, math.sqrt(an * gn))
    return an
 
print(agm(1, 1 / math.sqrt(2)))
===
//import math

F agm(a0, g0, tolerance = 1e-10)
   V an = (a0 + g0) / 2.0
   V gn = sqrt(a0 * g0)
   L abs(an - gn) > tolerance
      (an, gn) = ((an + gn) / 2.0, sqrt(an * gn))
   R an
print(agm(1, 1 / sqrt(2)))
===
template <typename T1, typename T2, typename T3 = decltype(1e-10)> auto agm(const T1 &a0, const T2 &g0, const T3 &tolerance = 1e-10)
{
    auto an = (a0 + g0) / 2.0;
    auto gn = sqrt(a0 * g0);
    while (abs(an - gn) > tolerance)
        std::tie(an, gn) = make_tuple((an + gn) / 2.0, sqrt(an * gn));
    return an;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(agm(1, 1.0 / sqrt(2)));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Arithmetic_evaluation
import re
from typing import Callable, Dict, List, Optional

# class T_shared_ASTNode:
#     pass

class Symbol:
    id : str
    lbp : int
    nud_bp : int
    led_bp : int
    nud : Callable[['ASTNode'], 'ASTNode']
    led : Callable[['ASTNode', 'ASTNode'], 'ASTNode']

    def set_nud_bp(self, nud_bp, nud):
        self.nud_bp = nud_bp
        self.nud    = nud

    def set_led_bp(self, led_bp, led):
        self.led_bp = led_bp
        self.led    = led

class ASTNode:
    symbol : Symbol # &
    value : int
    first_child : Optional['ASTNode'] = None
    second_child : Optional['ASTNode'] = None

    def eval(self):
        sid = self.symbol.id
        if sid == '(number)':
            return self.value
        elif sid == '+':
            return self.first_child.eval() + self.second_child.eval()
        elif sid == '-':
            return -self.first_child.eval() if self.second_child is None else self.first_child.eval() - self.second_child.eval()
        elif sid == '*':
            return self.first_child.eval() * self.second_child.eval()
        elif sid == '/':
            return self.first_child.eval() / self.second_child.eval()
        elif sid == '(': # )
            return self.first_child.eval()
        else:
            assert(False)
            return 0

symbol_table : Dict[str, Symbol] = {}
tokens : List[str]
tokeni = -1
token_node : ASTNode

def advance(sid = ''):
    global token_node, tokeni
    if sid != '':
        assert(token_node.symbol.id == sid)
    tokeni += 1
    token_node = ASTNode()
    if tokeni == len(tokens):
        token_node.symbol = symbol_table['(end)']
        return
    token = tokens[tokeni]
    token_node.symbol = symbol_table['(number)' if token.isdigit() else token]
    if token.isdigit():
        token_node.value = int(token)

def expression(rbp = 0):
    t : ASTNode = token_node
    advance()
    left = t.symbol.nud(t)
    while rbp < token_node.symbol.lbp:
        t = token_node
        advance()
        left = t.symbol.led(t, left)
    return left

def parse(expr_str) -> ASTNode:
    global tokens, tokeni
    tokens = re.findall(R'\s*(\d+|.)', expr_str)
    tokeni = -1
    advance()
    return expression()

def symbol(id, bp = 0): # -> &
    if not id in symbol_table: # Bool was_added
        s = Symbol()           # V &s = :symbol_table.add(id, &was_added)
        s.id = id              # I was_added
        s.lbp = bp             #    s.id = id
        symbol_table[id] = s   #    s.lbp = bp
    return symbol_table[id]    # R s

def infix(id, bp):
    def led(self : ASTNode, left):
        self.first_child = left
        self.second_child = expression(self.symbol.led_bp)
        return self
    symbol(id, bp).set_led_bp(bp, led)

def prefix(id, bp):
    def nud(self : ASTNode):
        self.first_child = expression(self.symbol.nud_bp)
        return self
    symbol(id).set_nud_bp(bp, nud)

infix('+', 1)
infix('-', 1)
infix('*', 2)
infix('/', 2)
prefix('-', 3)

symbol('(number)').nud = lambda self: self
symbol('(end)')

def nud_parens(self : ASTNode):
    expr = expression() # (
    advance(')')
    return expr
symbol('(').nud = nud_parens
symbol(')')

for expr_str in ['-2 / 2 + 4 + 3 * 2',
                 '2 * (3 + (4 * 5 + (6 * 7) * 8) - 9) * 10']:
    print(expr_str + ' = ' + str(parse(expr_str).eval()))
===
//import re

T Symbol
   String id
   Int lbp
   Int nud_bp
   Int led_bp
   (ASTNode -> ASTNode) nud
   (ASTNode, ASTNode -> ASTNode) led

   F set_nud_bp(nud_bp, nud)
      .nud_bp = nud_bp
      .nud = nud

   F set_led_bp(led_bp, led)
      .led_bp = led_bp
      .led = led

T ASTNode
   Symbol& symbol
   Int value
   ASTNode? first_child
   ASTNode? second_child

   F eval()
      S .symbol.id
         ‘(number)’
            R .value
         ‘+’
            R .first_child.eval() + .second_child.eval()
         ‘-’
            R I .second_child == N {-.first_child.eval()} E .first_child.eval() - .second_child.eval()
         ‘*’
            R .first_child.eval() * .second_child.eval()
         ‘/’
            R .first_child.eval() / .second_child.eval()
         ‘(’
            R .first_child.eval()
         E
            assert(0B)
            R 0
Dict[String, Symbol] symbol_table
[String] tokens
V tokeni = -1
ASTNode token_node

F advance(sid = ‘’)
   I sid != ‘’
      assert(:token_node.symbol.id == sid)
   :tokeni++
   :token_node = ASTNode()
   I :tokeni == tokens.len
      :token_node.symbol = :symbol_table[‘(end)’]
      R
   V token = :tokens[:tokeni]
   :token_node.symbol = :symbol_table[I token.is_digit() {‘(number)’} E token]
   I token.is_digit()
      :token_node.value = Int(token)

F expression(rbp = 0)
   ASTNode t = :token_node
   advance()
   V left = t.symbol.nud(t)
   L rbp < :token_node.symbol.lbp
      t = :token_node
      advance()
      left = t.symbol.led(t, left)
   R left

F parse(expr_str) -> ASTNode
   :tokens = re:‘\s*(\d+|.)’.find_strings(expr_str)
   :tokeni = -1
   advance()
   R expression()

F symbol(id, bp = 0) -> &
   I !(id C :symbol_table)
      V s = Symbol()
      s.id = id
      s.lbp = bp
      :symbol_table[id] = s
   R :symbol_table[id]

F infix(id, bp)
   F led(ASTNode self, left)
      self.first_child = left
      self.second_child = expression(self.symbol.led_bp)
      R self
   symbol(id, bp).set_led_bp(bp, led)

F prefix(id, bp)
   F nud(ASTNode self)
      self.first_child = expression(self.symbol.nud_bp)
      R self
   symbol(id).set_nud_bp(bp, nud)
infix(‘+’, 1)
infix(‘-’, 1)
infix(‘*’, 2)
infix(‘/’, 2)
prefix(‘-’, 3)
symbol(‘(number)’).nud = self -> self
symbol(‘(end)’)

F nud_parens(ASTNode self)
   V expr = expression()
   advance(‘)’)
   R expr
symbol(‘(’).nud = nud_parens
symbol(‘)’)

L(expr_str) [‘-2 / 2 + 4 + 3 * 2’, ‘2 * (3 + (4 * 5 + (6 * 7) * 8) - 9) * 10’]
   print(expr_str‘ = ’String(parse(expr_str).eval()))
===
class ASTNode;

class Symbol
{
public:
    String id;
    int lbp;
    int nud_bp;
    int led_bp;
    std::function<SharedPtr<ASTNode>(const SharedPtr<ASTNode>&)> nud;
    std::function<SharedPtr<ASTNode>(const SharedPtr<ASTNode>&, const SharedPtr<ASTNode>&)> led;

    template <typename T1, typename T2> auto set_nud_bp(const T1 &nud_bp, const T2 &nud)
    {
        this->nud_bp = nud_bp;
        this->nud = nud;
    }

    template <typename T1, typename T2> auto set_led_bp(const T1 &led_bp, const T2 &led)
    {
        this->led_bp = led_bp;
        this->led = led;
    }
};

class ASTNode : public SharedObject
{
public:
    Symbol *symbol;
    int value;
    SharedPtr<ASTNode> first_child;
    SharedPtr<ASTNode> second_child;

    auto eval()
    {
        if (symbol->id == u"(number)"_S)
            return value;
        else if (symbol->id == u'+')
            return first_child->eval() + second_child->eval();
        else if (symbol->id == u'-')
            return second_child == nullptr ? -first_child->eval() : first_child->eval() - second_child->eval();
        else if (symbol->id == u'*')
            return first_child->eval() * second_child->eval();
        else if (symbol->id == u'/')
            return first_child->eval() / second_child->eval();
        else if (symbol->id == u'(')
            return first_child->eval();
        else {
            assert(false);
            return 0;
        }
    }
};
Dict<String, Symbol> symbol_table;
Array<String> tokens;
auto tokeni = -1;
SharedPtr<ASTNode> token_node;

template <typename T1 = decltype(u""_S)> auto advance(const T1 &sid = u""_S)
{
    if (sid != u"")
        assert(::token_node->symbol->id == sid);
    ::tokeni++;
    ::token_node = make_SharedPtr<ASTNode>();
    if (::tokeni == tokens.len()) {
        ::token_node->symbol = &::symbol_table[u"(end)"_S];
        return;
    }
    auto token = ::tokens[::tokeni];
    ::token_node->symbol = &::symbol_table[token.is_digit() ? u"(number)"_S : token];
    if (token.is_digit())
        ::token_node->value = to_int(token);
}

template <typename T1 = decltype(0)> auto expression(const T1 &rbp = 0)
{
    SharedPtr<ASTNode> t = ::token_node;
    advance();
    auto left = t->symbol->nud(t);
    while (rbp < ::token_node->symbol->lbp) {
        t = ::token_node;
        advance();
        left = t->symbol->led(t, left);
    }
    return left;
}

template <typename T1> SharedPtr<ASTNode> parse(const T1 &expr_str)
{
    ::tokens = re::_(uR"(\s*(\d+|.))"_S).find_strings(expr_str);
    ::tokeni = -1;
    advance();
    return expression();
}

template <typename T1, typename T2 = decltype(0)> auto& symbol(const T1 &id, const T2 &bp = 0)
{
    if (!(in(id, ::symbol_table))) {
        auto s = Symbol();
        s.id = id;
        s.lbp = bp;
        ::symbol_table.set(id, s);
    }
    return ::symbol_table[id];
}

template <typename T1, typename T2> auto infix(const T1 &id, const T2 &bp)
{
    auto led = [](const SharedPtr<ASTNode> &self, const auto &left)
    {
        self->first_child = left;
        self->second_child = expression(self->symbol->led_bp);
        return self;
    };
    symbol(id, bp).set_led_bp(bp, led);
}

template <typename T1, typename T2> auto prefix(const T1 &id, const T2 &bp)
{
    auto nud = [](const SharedPtr<ASTNode> &self)
    {
        self->first_child = expression(self->symbol->nud_bp);
        return self;
    };
    symbol(id).set_nud_bp(bp, nud);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        infix(u"+"_S, 1);
        infix(u"-"_S, 1);
        infix(u"*"_S, 2);
        infix(u"/"_S, 2);
        prefix(u"-"_S, 3);
        symbol(u"(number)"_S).nud = [](const auto &self){return self;};
        symbol(u"(end)"_S);
    }
} code_block_1;

auto nud_parens(SharedPtr<ASTNode> self)
{
    auto expr = expression();
    advance(u")"_S);
    return expr;
}

struct CodeBlock2
{
    CodeBlock2()
    {
        symbol(u"("_S).nud = nud_parens;
        symbol(u")"_S);
        for (auto expr_str : create_array({u"-2 / 2 + 4 + 3 * 2"_S, u"2 * (3 + (4 * 5 + (6 * 7) * 8) - 9) * 10"_S}))
            print(expr_str + u" = "_S + String(parse(expr_str)->eval()));
    }
} code_block_2;


---
class ASTNode;

class Symbol
{
public:
    String id;
    int lbp;
    int nud_bp;
    int led_bp;
    std::function<std::unique_ptr<ASTNode>(std::unique_ptr<ASTNode>)> nud;
    std::function<std::unique_ptr<ASTNode>(std::unique_ptr<ASTNode>, std::unique_ptr<ASTNode>)> led;

    template <typename T1, typename T2> auto set_nud_bp(const T1 &nud_bp, const T2 &nud)
    {
        this->nud_bp = nud_bp;
        this->nud = nud;
    }

    template <typename T1, typename T2> auto set_led_bp(const T1 &led_bp, const T2 &led)
    {
        this->led_bp = led_bp;
        this->led = led;
    }
};

class ASTNode
{
public:
    Symbol *symbol;
    int value;
    std::unique_ptr<ASTNode> first_child;
    std::unique_ptr<ASTNode> second_child;

    auto eval()
    {
        if (symbol->id == u"(number)"_S)
            return value;
        else if (symbol->id == u'+')
            return first_child->eval() + second_child->eval();
        else if (symbol->id == u'-')
            return second_child == nullptr ? -first_child->eval() : first_child->eval() - second_child->eval();
        else if (symbol->id == u'*')
            return first_child->eval() * second_child->eval();
        else if (symbol->id == u'/')
            return first_child->eval() / second_child->eval();
        else if (symbol->id == u'(')
            return first_child->eval();
        else {
            assert(false);
            return 0;
        }
    }
};
Dict<String, Symbol> symbol_table;
Array<String> tokens;
auto tokeni = -1;
std::unique_ptr<ASTNode> token_node;

template <typename T1 = decltype(u""_S)> auto advance(const T1 &sid = u""_S)
{
    if (sid != u"")
        assert(::token_node->symbol->id == sid);
    ::tokeni++;
    ::token_node = std::make_unique<ASTNode>();
    if (::tokeni == tokens.len()) {
        ::token_node->symbol = &::symbol_table[u"(end)"_S];
        return;
    }
    auto token = ::tokens[::tokeni];
    ::token_node->symbol = &::symbol_table[token.is_digit() ? u"(number)"_S : token];
    if (token.is_digit())
        ::token_node->value = to_int(token);
}

template <typename T1 = decltype(0)> auto expression(const T1 &rbp = 0)
{
    std::unique_ptr<ASTNode> t = std::move(::token_node);
    advance();
    auto left = t->symbol->nud(std::move(t));
    while (rbp < ::token_node->symbol->lbp) {
        t = std::move(::token_node);
        advance();
        left = t->symbol->led(std::move(t), std::move(left));
    }
    return left;
}

template <typename T1> std::unique_ptr<ASTNode> parse(const T1 &expr_str)
{
    ::tokens = re::_(uR"(\s*(\d+|.))"_S).find_strings(expr_str);
    ::tokeni = -1;
    advance();
    return expression();
}

template <typename T1, typename T2 = decltype(0)> auto& symbol(const T1 &id, const T2 &bp = 0)
{
    if (!(in(id, ::symbol_table))) {
        auto s = Symbol();
        s.id = id;
        s.lbp = bp;
        ::symbol_table.set(id, s);
    }
    return ::symbol_table[id];
}

template <typename T1, typename T2> auto infix(const T1 &id, const T2 &bp)
{
    auto led = [](std::unique_ptr<ASTNode> self, std::unique_ptr<ASTNode> left)
    {
        self->first_child = std::move(left);
        self->second_child = expression(self->symbol->led_bp);
        return self;
    };
    symbol(id, bp).set_led_bp(bp, led);
}

template <typename T1, typename T2> auto prefix(const T1 &id, const T2 &bp)
{
    auto nud = [](std::unique_ptr<ASTNode> self)
    {
        self->first_child = expression(self->symbol->nud_bp);
        return self;
    };
    symbol(id).set_nud_bp(bp, nud);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        infix(u"+"_S, 1);
        infix(u"-"_S, 1);
        infix(u"*"_S, 2);
        infix(u"/"_S, 2);
        prefix(u"-"_S, 3);
        symbol(u"(number)"_S).nud = [](std::unique_ptr<ASTNode>self){return self;};
        symbol(u"(end)"_S);
    }
} code_block_1;

auto nud_parens(std::unique_ptr<ASTNode> self)
{
    auto expr = expression();
    advance(u")"_S);
    return expr;
}

struct CodeBlock2
{
    CodeBlock2()
    {
        symbol(u"("_S).nud = nud_parens;
        symbol(u")"_S);
        for (auto expr_str : create_array({u"-2 / 2 + 4 + 3 * 2"_S, u"2 * (3 + (4 * 5 + (6 * 7) * 8) - 9) * 10"_S}))
            print(expr_str + u" = "_S + String(parse(expr_str)->eval()));
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Associative_array/Iteration#Python
d = {'key1': 'value1', 'key2': 'value2'}

for key, value in d.items():
    print(key + ' = ' + value)

for key in d.keys():
    print(key)

for value in d.values():
    print(value)
===
V d = [‘key1’ = ‘value1’, ‘key2’ = ‘value2’]

L(key, value) d
   print(key‘ = ’value)

L(key) d.keys()
   print(key)

L(value) d.values()
   print(value)
===
auto d = create_dict(dict_of(u"key1"_S, u"value1"_S)(u"key2"_S, u"value2"_S));

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&[key, value] : d)
            print(key + u" = "_S + value);
        for (auto key : d.keys())
            print(key);
        for (auto value : d.values())
            print(value);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Averages/Arithmetic_mean#Python
def average(x):
    return sum(x)/float(len(x))# if x else 0
print (average([0,0,3,1,4,1,5,9,0,0]))
===
F average(x)
   R sum(x) / Float(x.len)
print(average([0, 0, 3, 1, 4, 1, 5, 9, 0, 0]))
===
template <typename T1> auto average(const T1 &x)
{
    return sum(x) / to_float(x.len());
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(average(create_array({0, 0, 3, 1, 4, 1, 5, 9, 0, 0})));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Averages/Mean_angle#C.23
import math

def mean_angle(angles):
    x = sum(math.cos(math.radians(a)) for a in angles) / len(angles)
    y = sum(math.sin(math.radians(a)) for a in angles) / len(angles)
    return math.degrees(math.atan2(y, x))

print(mean_angle([350, 10]))
print(mean_angle([90, 180, 270, 360]))
print(mean_angle([10, 20, 30]))
===
//import math

F mean_angle(angles)
   V x = sum(angles.map(a -> cos(radians(a)))) / angles.len
   V y = sum(angles.map(a -> sin(radians(a)))) / angles.len
   R degrees(atan2(y, x))
print(mean_angle([350, 10]))
print(mean_angle([90, 180, 270, 360]))
print(mean_angle([10, 20, 30]))
===
template <typename T1> auto mean_angle(const T1 &angles)
{
    auto x = sum(angles.map([](const auto &a){return cos(radians(a));})) / angles.len();
    auto y = sum(angles.map([](const auto &a){return sin(radians(a));})) / angles.len();
    return degrees(atan2(y, x));
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(mean_angle(create_array({350, 10})));
        print(mean_angle(create_array({90, 180, 270, 360})));
        print(mean_angle(create_array({10, 20, 30})));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Averages/Mean_time_of_day#Python
import math

def mean_angle(angles):
    x = sum(math.cos(math.radians(a)) for a in angles) / len(angles)
    y = sum(math.sin(math.radians(a)) for a in angles) / len(angles)
    return math.degrees(math.atan2(y, x))

def mean_time(times):
    t = (time.split(':') for time in times)
    seconds = ((float(hms[2]) + int(hms[1]) * 60 + int(hms[0]) * 3600) 
               for hms in t)
    day = 24 * 60 * 60
    to_angles = [s * 360.0 / day for s in seconds]
    mean_as_angle = mean_angle(to_angles)
    mean_seconds = round(mean_as_angle * day / 360.0)
    if mean_seconds < 0:
        mean_seconds += day
    h = mean_seconds // 3600
    m = mean_seconds % 3600
    s = m % 60
    m = m // 60
    return str(h).zfill(2)+':'+str(m).zfill(2)+':'+str(s).zfill(2)
 
print(mean_time(['23:00:17', '23:40:20', '00:12:45', '00:17:19']))
===
//import math

F mean_angle(angles)
   V x = sum(angles.map(a -> cos(radians(a)))) / angles.len
   V y = sum(angles.map(a -> sin(radians(a)))) / angles.len
   R degrees(atan2(y, x))

F mean_time(times)
   V t = (times.map(time -> time.split(‘:’)))
   V seconds = (t.map(hms -> (Float(hms[2]) + Int(hms[1]) * 60 + Int(hms[0]) * 3600)))
   V day = 24 * 60 * 60
   V to_angles = seconds.map(s -> s * 360.0 / @day)
   V mean_as_angle = mean_angle(to_angles)
   V mean_seconds = round(mean_as_angle * day / 360.0)
   I mean_seconds < 0
      mean_seconds += day
   V h = mean_seconds I/ 3600
   V m = mean_seconds % 3600
   V s = m % 60
   m = m I/ 60
   R String(h).zfill(2)‘:’String(m).zfill(2)‘:’String(s).zfill(2)
print(mean_time([‘23:00:17’, ‘23:40:20’, ‘00:12:45’, ‘00:17:19’]))
===
template <typename T1> auto mean_angle(const T1 &angles)
{
    auto x = sum(angles.map([](const auto &a){return cos(radians(a));})) / angles.len();
    auto y = sum(angles.map([](const auto &a){return sin(radians(a));})) / angles.len();
    return degrees(atan2(y, x));
}

template <typename T1> auto mean_time(const T1 &times)
{
    auto t = (times.map([](const auto &time){return time.split(u":"_S);}));
    auto seconds = (t.map([](const auto &hms){return (to_float(_get<2>(hms)) + to_int(_get<1>(hms)) * 60 + to_int(_get<0>(hms)) * 3600);}));
    auto day = 24 * 60 * 60;
    auto to_angles = seconds.map([&day](const auto &s){return s * 360.0 / day;});
    auto mean_as_angle = mean_angle(to_angles);
    auto mean_seconds = round(mean_as_angle * day / 360.0);
    if (mean_seconds < 0)
        mean_seconds += day;
    auto h = int(mean_seconds)/int(3600);
    auto m = mod(mean_seconds, 3600);
    auto s = mod(m, 60);
    m = int(m)/int(60);
    return String(h).zfill(2) + u":"_S + String(m).zfill(2) + u":"_S + String(s).zfill(2);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(mean_time(create_array({u"23:00:17"_S, u"23:40:20"_S, u"00:12:45"_S, u"00:17:19"_S})));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Averages/Median#Python
def median(aray):
    srtd = sorted(aray)
    alen = len(srtd)
    return 0.5*(srtd[(alen-1)//2] + srtd[alen//2])

print(median([4.1, 5.6, 7.2, 1.7, 9.3, 4.4, 3.2]))
print(median([4.1, 7.2, 1.7, 9.3, 4.4, 3.2]))
===
F median(aray)
   V srtd = sorted(aray)
   V alen = srtd.len
   R 0.5 * (srtd[(alen - 1) I/ 2] + srtd[alen I/ 2])
print(median([4.1, 5.6, 7.2, 1.7, 9.3, 4.4, 3.2]))
print(median([4.1, 7.2, 1.7, 9.3, 4.4, 3.2]))
===
template <typename T1> auto median(const T1 &aray)
{
    auto srtd = sorted(aray);
    auto alen = srtd.len();
    return 0.5 * (srtd[int((alen - 1))/int(2)] + srtd[int(alen)/int(2)]);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(median(create_array({4.1, 5.6, 7.2, 1.7, 9.3, 4.4, 3.2})));
        print(median(create_array({4.1, 7.2, 1.7, 9.3, 4.4, 3.2})));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Averages/Mode#Python
import collections

def modes(values):
    count = collections.defaultdict(int) # int
    for v in values:
        count[v] += 1
    best = max(count.values())
    return [kv[0] for kv in count.items() if kv[1] == best]
 
print(modes([1,3,6,6,6,6,7,7,12,12,17]))
print(modes([1,1,2,4,4]))
===
//import collections

F modes(values)
   V count = DefaultDict[Int, Int]()
   L(v) values
      count[v]++
   V best = max(count.values())
   R count.filter(kv -> kv[1] == @best).map(kv -> kv[0])
print(modes([1, 3, 6, 6, 6, 6, 7, 7, 12, 12, 17]))
print(modes([1, 1, 2, 4, 4]))
===
template <typename T1> auto modes(const T1 &values)
{
    auto count = DefaultDict<int, int>();
    for (auto v : values)
        count[v]++;
    auto best = max(count.values());
    return count.filter([&best](const auto &kv){return _get<1>(kv) == best;}).map([](const auto &kv){return _get<0>(kv);});
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(modes(create_array({1, 3, 6, 6, 6, 6, 7, 7, 12, 12, 17})));
        print(modes(create_array({1, 1, 2, 4, 4})));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Averages/Root_mean_square#Python
import math

def qmean(num):
    return math.sqrt(sum(n*n for n in num)/float(len(num)))
 
print(qmean(range(1,11)))
===
//import math

F qmean(num)
   R sqrt(sum(num.map(n -> n * n)) / Float(num.len))
print(qmean((1.<11)))
===
template <typename T1> auto qmean(const T1 &num)
{
    return sqrt(sum(num.map([](const auto &n){return n * n;})) / to_float(num.len()));
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(qmean(range_el(1, 11)));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Averages/Simple_moving_average#D
from typing import List

class SMA:
    data : List[float]
    sum = 0.0
    index = 0
    n_filled = 0
    period : int # Why not `period = 0`? Because `Int period` means that `period` must be initialized in constructor.

    def __init__(self, period):
        self.period = period
        self.data = [0.0] * period

    def add(self, v):
        self.sum += v - self.data[self.index]
        self.data[self.index] = v
        self.index = (self.index + 1) % self.period
        self.n_filled = min(self.period, self.n_filled + 1)
        return self.sum / self.n_filled

sma3 = SMA(3)
sma5 = SMA(5)

for e in [1, 2, 3, 4, 5, 5, 4, 3, 2, 1]:
    print('Added %d, sma(3) = %f, sma(5) = %f' % (e, sma3.add(e), sma5.add(e)))
===

T SMA
   [Float] data
   sum = 0.0
   index = 0
   n_filled = 0
   Int period

   F (period)
      .period = period
      .data = [0.0] * period

   F add(v)
      .sum += v - .data[.index]
      .data[.index] = v
      .index = (.index + 1) % .period
      .n_filled = min(.period, .n_filled + 1)
      R .sum / .n_filled
V sma3 = SMA(3)
V sma5 = SMA(5)

L(e) [1, 2, 3, 4, 5, 5, 4, 3, 2, 1]
   print(‘Added #.0, sma(3) = #.6, sma(5) = #.6’.format(e, sma3.add(e), sma5.add(e)))
===
class SMA
{
public:
    Array<double> data;
    decltype(0.0) sum = 0.0;
    decltype(0) index = 0;
    decltype(0) n_filled = 0;
    int period;

    template <typename T1> SMA(const T1 &period)
    {
        this->period = period;
        data = create_array({0.0}) * period;
    }

    template <typename T1> auto add(const T1 &v)
    {
        sum += v - data[index];
        data.set(index, v);
        index = mod((index + 1), period);
        n_filled = min(period, n_filled + 1);
        return sum / n_filled;
    }
};
auto sma3 = SMA(3);
auto sma5 = SMA(5);

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto e : create_array({1, 2, 3, 4, 5, 5, 4, 3, 2, 1}))
            print(u"Added #.0, sma(3) = #.6, sma(5) = #.6"_S.format(e, sma3.add(e), sma5.add(e)));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Balanced_brackets#Python
import random

def gen(n):
    txt = ['[', ']'] * n
    random.shuffle(txt)
    return ''.join(txt)

def is_balanced(s):
    nesting_level = 0
    for c in s:
        c = c
        if c == '[':
            nesting_level += 1
        elif c == ']':
            nesting_level -= 1
            if nesting_level < 0:
                return False
    return True

for n in range(10):
    s = gen(n)
    print(s + ' '*(20-len(s)) + 'is ' + ('balanced' if is_balanced(s) else 'not balanced'))
===
//import random

F gen(n)
   V txt = [‘[’, ‘]’] * n
   random:shuffle(&txt)
   R txt.join(‘’)

F is_balanced(s)
   V nesting_level = 0
   L(c) s
      S c
         ‘[’
            nesting_level++
         ‘]’
            I --nesting_level < 0
               R 0B
   R 1B

L(n) 0.<10
   V s = gen(n)
   print(s‘’(‘ ’ * (20 - s.len))‘is ’(I is_balanced(s) {‘balanced’} E ‘not balanced’))
===
template <typename T1> auto gen(const T1 &n)
{
    auto txt = create_array({u'['_C, u']'_C}) * n;
    randomns::shuffle(txt);
    return txt.join(u""_S);
}

template <typename T1> auto is_balanced(const T1 &s)
{
    auto nesting_level = 0;
    for (auto c : s)
        switch (c)
        {
        case u'[':
            nesting_level++;
            break;
        case u']':
            if (--nesting_level < 0)
                return false;
            break;
        }
    return true;
}

struct CodeBlock1
{
    CodeBlock1()
    {

        for (auto n : range_el(0, 10)) {
            auto s = gen(n);
            print(s + (u" "_S * (20 - s.len())) + u"is "_S + (is_balanced(s) ? u"balanced"_S : u"not balanced"_S));
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Benford%27s_law#D
import math

def get_fibs():
    a = 1.0
    b = 1.0
    r : List[float] = []
    for i in range(1000):
        r.append(a)
        (a, b) = (b, a + b)
    return r

def benford(seq):
    freqs = [(0.0, 0.0)] * 9
    seq_len = 0
    for d in seq:
        if d != 0:
            i = ord(str(d)[0]) - ord('1')
            freqs[i] = (freqs[i][0], freqs[i][1] + 1)
            seq_len += 1

    for i in range(len(freqs)):
        freqs[i] = (math.log10(1.0 + 1.0 / (i + 1)), freqs[i][1] / seq_len)

    return freqs

print('%9s %9s %9s' % ('Actual', 'Expected', 'Deviation'))
for i, p in enumerate(benford(get_fibs())):
    print('%d: %5.2f%% | %5.2f%% | %5.4f%%' % (i+1, p[1] * 100, p[0] * 100, abs(p[1] - p[0]) * 100))
===
//import math

F get_fibs()
   V a = 1.0
   V b = 1.0
   [Float] r
   L(i) 0.<1000
      r.append(a)
      (a, b) = (b, a + b)
   R r

F benford(seq)
   V freqs = [(0.0, 0.0)] * 9
   V seq_len = 0
   L(d) seq
      I d != 0
         V i = String(d)[0].code - ‘1’.code
         freqs[i] = (freqs[i][0], freqs[i][1] + 1)
         seq_len++

   L(i) 0 .< freqs.len
      freqs[i] = (log10(1.0 + 1.0 / (i + 1)), freqs[i][1] / seq_len)
   R freqs
print(‘#9 #9 #9’.format(‘Actual’, ‘Expected’, ‘Deviation’))
L(p) benford(get_fibs())
   V i = L.index
   print(‘#.0: #2.2% | #2.2% | #0.4%’.format(i + 1, p[1] * 100, p[0] * 100, abs(p[1] - p[0]) * 100))
===
auto get_fibs()
{
    auto a = 1.0;
    auto b = 1.0;
    Array<double> r;
    for (auto i : range_el(0, 1000)) {
        r.append(a);
        std::tie(a, b) = make_tuple(b, a + b);
    }
    return r;
}

template <typename T1> auto benford(const T1 &seq)
{
    auto freqs = create_array({make_tuple(0.0, 0.0)}) * 9;
    auto seq_len = 0;
    for (auto d : seq)
        if (d != 0) {
            auto i = _get<0>(String(d)).code - u'1'_C.code;
            freqs.set(i, make_tuple(_get<0>(freqs[i]), _get<1>(freqs[i]) + 1));
            seq_len++;
        }
    for (auto i : range_el(0, freqs.len()))
        freqs.set(i, make_tuple(log10(1.0 + 1.0 / (i + 1)), _get<1>(freqs[i]) / seq_len));
    return freqs;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"#9 #9 #9"_S.format(u"Actual"_S, u"Expected"_S, u"Deviation"_S));
        {int Lindex = 0;
        for (auto p : benford(get_fibs())) {
            auto i = Lindex;
            print(u"#.0: #2.2% | #2.2% | #0.4%"_S.format(i + 1, _get<1>(p) * 100, _get<0>(p) * 100, abs(_get<1>(p) - _get<0>(p)) * 100));
            Lindex++;
        }}
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Box_the_compass#Python
majors   = 'north east south west'.split()
majors   *= 2 # no need for modulo later
quarter1 = 'N,N by E,N-NE,NE by N,NE,NE by E,E-NE,E by N'.split(',')
quarter2 = [p.replace('NE','EN') for p in quarter1]
 
def degrees2compasspoint(d):
    d = (d % 360) + 360/64
    majorindex = int(d / 90)
    minorindex  = int( (d % 90 *4) // 45 )
    p1 = majors[majorindex]
    p2 = majors[majorindex+1]
    q : List[str]
    if p1 in ('north', 'south'):
        q = quarter1
    else:
        q = quarter2
    return q[minorindex].replace('N', p1).replace('E', p2).capitalize()
 
if __name__ == '__main__':
    for i in range(33):
        d = i * 11.25
        m = i % 3
        if   m == 1: d += 5.62
        elif m == 2: d -= 5.62
        n = i % 32 + 1
        print( '%2i %-18s %7.2f°' % (n, degrees2compasspoint(d), d) )
===
V majors = ‘north east south west’.split((‘ ’, "\t", "\r", "\n"), group_delimiters' 1B)
majors *= 2
V quarter1 = ‘N,N by E,N-NE,NE by N,NE,NE by E,E-NE,E by N’.split(‘,’)
V quarter2 = quarter1.map(p -> p.replace(‘NE’, ‘EN’))

F degrees2compasspoint(=d)
   d = (d % 360) + 360 / 64
   V majorindex = Int(d / 90)
   V minorindex = Int((d % 90 * 4) I/ 45)
   V p1 = :majors[majorindex]
   V p2 = :majors[majorindex + 1]
   [String] q
   I p1 C (‘north’, ‘south’)
      q = :quarter1
   E
      q = :quarter2
   R q[minorindex].replace(‘N’, p1).replace(‘E’, p2).capitalize()

:start:
L(i) 0.<33
   V d = i * 11.25
   S i % 3
      1
         d += 5.62
      2
         d -= 5.62
   V n = i % 32 + 1
   print(‘#2.0 #<18 #4.2°’.format(n, degrees2compasspoint(d), d))
===
auto majors = u"north east south west"_S.split(make_tuple(u" "_S, u"\t"_S, u"\r"_S, u"\n"_S), nullptr, true);

struct CodeBlock1
{
    CodeBlock1()
    {
        majors *= 2;
    }
} code_block_1;
auto quarter1 = u"N,N by E,N-NE,NE by N,NE,NE by E,E-NE,E by N"_S.split(u","_S);
auto quarter2 = quarter1.map([](const auto &p){return p.replace(u"NE"_S, u"EN"_S);});

template <typename T1> auto degrees2compasspoint(T1 d)
{
    d = (mod(d, 360)) + 360.0 / 64;
    auto majorindex = to_int(d / 90.0);
    auto minorindex = to_int(int((mod(d, 90) * 4))/int(45));
    auto p1 = ::majors[majorindex];
    auto p2 = ::majors[majorindex + 1];
    Array<String> q;
    if (in(p1, make_tuple(u"north"_S, u"south"_S)))
        q = ::quarter1;
    else
        q = ::quarter2;
    return q[minorindex].replace(u"N"_S, p1).replace(u"E"_S, p2).capitalize();
}

int main()
{
    for (auto i : range_el(0, 33)) {
        auto d = i * 11.25;
        switch (mod(i, 3))
        {
        case 1:
            d += 5.62;
            break;
        case 2:
            d -= 5.62;
            break;
        }
        auto n = mod(i, 32) + 1;
        print(u"#2.0 #<18 #4.2°"_S.format(n, degrees2compasspoint(d), d));
    }
}


# https://www.rosettacode.org/wiki/Brace_expansion#Python
def getitem(s, depth = 0):
    out = ['']
    while s != '':
        c = str(s[0])
        if depth and (c == ',' or c == '}'):
            return (out, s)
        if c == '{':
            global getgroup # to suppress error 'undefined identifier' in `x = getgroup(s[1:], depth+1)`
            x = getgroup(s[1:], depth+1) #                                     ^^^^^^^^
            if len(x[0]):
                #nout : List[str] = []
                #for a in out:
                #    for b in x[0]:
                #        nout.append(a + '' + b)
                #out = nout
                out = [a + '' + b for a in out for b in x[0]]
                s = x[1]
                continue
        if c == '\\' and len(s) > 1:
            (s, c) = (s[1:], c + s[1])
 
        out = [a+c for a in out]
        s = s[1:]
 
    return (out, s)
 
def getgroup(s, depth):
    out : List[str] = []
    comma = False
    while s != '':
        gs = getitem(s, depth)
        s = gs[1]
        if s == '': break
        out += gs[0]
 
        if s[0] == '}':
            if comma: return (out, s[1:])
            return (['{' + a + '}' for a in out], s[1:])
 
        if s[0] == ',':
            (comma, s) = (True, s[1:])
 
    return (['']*0, '')

# stolen cowbells from perl6 example
for s in R'''~/{Downloads,Pictures}/*.{jpg,gif,png}
It{{em,alic}iz,erat}e{d,}, please.
{,{,gotta have{ ,\, again\, }}more }cowbell!
{}} some }{,{\\{ edge, edge} \,}{ cases, {here} \\\\\}'''.split('\n'):
    print("\n\t".join([s] + getitem(s)[0]) + "\n")
===
F getitem(=s, depth = 0)
   V out = [‘’]
   L s != ‘’
      V c = String(s[0])
      I depth & (c == ‘,’ | c == ‘}’)
         R (out, s)
      I c == ‘{’
         V x = getgroup(s[1..], depth + 1)
         I !x[0].empty
            out = multiloop(out, x[0], (a, b) -> a‘’b)
            s = x[1]
            L.continue
      I c == "\\" & s.len > 1
         (s, c) = (s[1..], c‘’s[1])
      out = out.map(a -> a‘’@c)
      s = s[1..]
   R (out, s)

F getgroup(=s, depth)
   [String] out
   V comma = 0B
   L s != ‘’
      V gs = getitem(s, depth)
      s = gs[1]
      I s == ‘’
         L.break
      out [+]= gs[0]

      I s[0] == ‘}’
         I comma
            R (out, s[1..])
         R (out.map(a -> ‘{’a‘}’), s[1..])

      I s[0] == ‘,’
         (comma, s) = (1B, s[1..])
   R ([‘’] * 0, ‘’)

L(s) ‘~/{Downloads,Pictures}/*.{jpg,gif,png}
It{{em,alic}iz,erat}e{d,}, please.
{,{,gotta have{ ,\, again\, }}more }cowbell!
{}} some }{,{\\{ edge, edge} \,}{ cases, {here} \\\\\}’.split("\n")
   print(([s] [+] getitem(s)[0]).join("\n\t")"\n")
===
template <typename T1, typename T2 = decltype(0)> auto getitem(T1 s, const T2 &depth = 0)
{
    auto out = create_array({u""_S});
    while (s != u"") {
        auto c = String(_get<0>(s));
        if (depth && (c == u',' || c == u'}'))
            return make_tuple(out, s);
        if (c == u'{') {
            auto x = getgroup(s[range_ei(1)], depth + 1);
            if (!_get<0>(x).empty()) {
                out = multiloop(out, _get<0>(x), [](const auto &a, const auto &b){return a + b;});
                s = _get<1>(x);
                continue;
            }
        }
        if (c == u'\\' && s.len() > 1)
            std::tie(s, c) = make_tuple(s[range_ei(1)], c + _get<1>(s));
        out = out.map([&c](const auto &a){return a + c;});
        s = s[range_ei(1)];
    }
    return make_tuple(out, s);
}

template <typename T1, typename T2> auto getgroup(T1 s, const T2 &depth)
{
    Array<String> out;
    auto comma = false;
    while (s != u"") {
        auto gs = getitem(s, depth);
        s = _get<1>(gs);
        if (s == u"")
            break;
        out.append(_get<0>(gs));

        if (_get<0>(s) == u'}') {
            if (comma)
                return make_tuple(out, s[range_ei(1)]);
            return make_tuple(out.map([](const auto &a){return u"{"_S + a + u"}"_S;}), s[range_ei(1)]);
        }
        if (_get<0>(s) == u',')
            std::tie(comma, s) = make_tuple(true, s[range_ei(1)]);
    }
    return make_tuple(create_array({u""_S}) * 0, u""_S);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto s : uR"(~/{Downloads,Pictures}/*.{jpg,gif,png}
It{{em,alic}iz,erat}e{d,}, please.
{,{,gotta have{ ,\, again\, }}more }cowbell!
{}} some }{,{\\{ edge, edge} \,}{ cases, {here} \\\\\})"_S.split(u"\n"_S))
            print((create_array({s}) + _get<0>(getitem(s))).join(u"\n\t"_S) + u"\n"_S);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Calculating_the_value_of_e#Python
import math
#Implementation of Brother's formula
e0 = 0.0
e = 2.0
n = 0
fact = 1
while(e-e0 > 1e-15):
    e0 = e
    n += 1
    fact *= 2*n*(2*n+1)
    e += (2.0*n+2)/fact
 
print("Computed e = "+str(e))
print("Real e = "+str(math.e))
print("Error = "+str(math.e-e))
print("Number of iterations = "+str(n))
===
//import math
V e0 = 0.0
V e = 2.0
V n = 0
V fact = 1
L (e - e0 > 1e-15)
   e0 = e
   n++
   fact *= 2 * n * (2 * n + 1)
   e += (2.0 * n + 2) / fact
print(‘Computed e = ’String(e))
print(‘Real e = ’String(math:e))
print(‘Error = ’String(math:e - e))
print(‘Number of iterations = ’String(n))
===
auto e0 = 0.0;
auto e = 2.0;
auto n = 0;
auto fact = 1;

struct CodeBlock1
{
    CodeBlock1()
    {
        while ((e - e0 > 1e-15)) {
            e0 = e;
            n++;
            fact *= 2 * n * (2 * n + 1);
            e += (2.0 * n + 2) / fact;
        }
        print(u"Computed e = "_S + String(e));
        print(u"Real e = "_S + String(math::e));
        print(u"Error = "_S + String(math::e - e));
        print(u"Number of iterations = "_S + String(n));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Cantor_set#Python
WIDTH = 81
HEIGHT = 5

def cantor(start, len, index):
    global lines
    seg = len // 3
    if seg == 0:
        return
    for it in range(HEIGHT-index):
        i = index + it
        for jt in range(seg):
            j = start + seg + jt
            pos = i * WIDTH + j
            lines[pos] = ' '
    cantor(start,           seg, index + 1)
    cantor(start + seg * 2, seg, index + 1)

lines = ['*'] * (WIDTH*HEIGHT)
cantor(0, WIDTH, 1)

for i in range(HEIGHT):
    beg = WIDTH * i
    print(''.join(lines[beg : beg+WIDTH]))
===
V WIDTH = 81
V HEIGHT = 5

F cantor(start, len, index)
   V seg = len I/ 3
   I seg == 0
      R
   L(it) 0 .< :HEIGHT - index
      V i = index + it
      L(jt) 0 .< seg
         V j = start + seg + jt
         V pos = i * :WIDTH + j
         :lines[pos] = ‘ ’
   cantor(start, seg, index + 1)
   cantor(start + seg * 2, seg, index + 1)
V lines = [‘*’] * (WIDTH * HEIGHT)
cantor(0, WIDTH, 1)

L(i) 0 .< HEIGHT
   V beg = WIDTH * i
   print((lines[beg .< beg + WIDTH]).join(‘’))
===
auto WIDTH = 81;
auto HEIGHT = 5;

template <typename T1, typename T2, typename T3> auto cantor(const T1 &start, const T2 &len, const T3 &index)
{
    auto seg = int(len)/int(3);
    if (seg == 0)
        return;
    for (auto it : range_el(0, ::HEIGHT - index)) {
        auto i = index + it;
        for (auto jt : range_el(0, seg)) {
            auto j = start + seg + jt;
            auto pos = i * ::WIDTH + j;
            ::lines.set(pos, u' '_C);
        }
    }
    cantor(start, seg, index + 1);
    cantor(start + seg * 2, seg, index + 1);
}
auto lines = create_array({u'*'_C}) * (WIDTH * HEIGHT);

struct CodeBlock1
{
    CodeBlock1()
    {
        cantor(0, WIDTH, 1);

        for (auto i : range_el(0, HEIGHT)) {
            auto beg = WIDTH * i;
            print((lines[range_el(beg, beg + WIDTH)]).join(u""_S));
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Cartesian_product_of_two_or_more_lists#Go
def cart_prod(a, b):
    p = [(0, 0)] * (len(a) * len(b))
    i = 0
    for aa in a:
        for bb in b:
            p[i] = (aa, bb)
            i += 1
    return p

print(cart_prod([1, 2], [3, 4]))
print(cart_prod([3, 4], [1, 2]))
print(cart_prod([1, 2], []))
print(cart_prod([], [1, 2]))
===
F cart_prod(a, b)
   V p = [(0, 0)] * (a.len * b.len)
   V i = 0
   L(aa) a
      L(bb) b
         p[i] = (aa, bb)
         i++
   R p
print(cart_prod([1, 2], [3, 4]))
print(cart_prod([3, 4], [1, 2]))
print(cart_prod([1, 2], []))
print(cart_prod([], [1, 2]))
===
template <typename T1, typename T2> auto cart_prod(const T1 &a, const T2 &b)
{
    auto p = create_array({make_tuple(0, 0)}) * (a.len() * b.len());
    auto i = 0;
    for (auto aa : a)
        for (auto bb : b) {
            p.set(i, make_tuple(aa, bb));
            i++;
        }
    return p;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(cart_prod(create_array({1, 2}), create_array({3, 4})));
        print(cart_prod(create_array({3, 4}), create_array({1, 2})));
        print(cart_prod(create_array({1, 2}), create_array({})));
        print(cart_prod(create_array({}), create_array({1, 2})));
    }
} code_block_1;


def cart_prod(a, b):
    p : List[Tuple[int, int]] = []
    for i in a:
        for j in b:
            p += [(i, j)]
    return p
===
F cart_prod(a, b)
   [(Int, Int)] p
   L(i) a
      L(j) b
         p [+]= (i, j)
   R p
===
template <typename T1, typename T2> auto cart_prod(const T1 &a, const T2 &b)
{
    Array<Tuple<int, int>> p;
    for (auto i : a)
        for (auto j : b)
            p.append(make_tuple(i, j));
    return p;
}


def cart_prod(a, b):
    return [(aa, bb) for aa in a for bb in b]
===
F cart_prod(a, b)
   R multiloop(a, b, (aa, bb) -> (aa, bb))
===
template <typename T1, typename T2> auto cart_prod(const T1 &a, const T2 &b)
{
    return multiloop(a, b, [](const auto &aa, const auto &bb){return make_tuple(aa, bb);});
}


# https://www.rosettacode.org/wiki/Catalan_numbers
c = 1
for n in range(1, 16):
    print(c)
    c = 2*(2*n - 1) * c // (n + 1)
===
V c = 1
L(n) 1.<16
   print(c)
   c = 2 * (2 * n - 1) * c I/ (n + 1)
===
auto c = 1;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto n : range_el(1, 16)) {
            print(c);
            c = int(2 * (2 * n - 1) * c)/int((n + 1));
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Catalan_numbers/Pascal%27s_triangle#Python
n = 15
t = [0] * (n + 2)
t[1] = 1
for i in range(1, n + 1):
    for j in range(i, 1, -1): t[j] += t[j - 1]
    t[i + 1] = t[i]
    for j in range(i + 1, 1, -1): t[j] += t[j - 1]
    print(t[i+1] - t[i], end=' ')
===
V n = 15
V t = [0] * (n + 2)
t[1] = 1
L(i) 1 .< n + 1
   L(j) (i .< 1).step(-1)
      t[j] += t[j - 1]
   t[i + 1] = t[i]
   L(j) (i + 1 .< 1).step(-1)
      t[j] += t[j - 1]
   print(t[i + 1] - t[i], end' ‘ ’)
===
auto n = 15;
auto t = create_array({0}) * (n + 2);

struct CodeBlock1
{
    CodeBlock1()
    {
        _set<1>(t, 1);
        for (auto i : range_el(1, n + 1)) {
            for (auto j : range_el(i, 1).step(-1))
                t[j] += t[j - 1];
            t.set(i + 1, t[i]);
            for (auto j : range_el(i + 1, 1).step(-1))
                t[j] += t[j - 1];
            print(t[i + 1] - t[i], u" "_S);
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Catamorphism
from functools import reduce

print(reduce(lambda x, y: x + y, range(1, 4)))
print(reduce(lambda x, y: x + y, range(1, 4), 3))
print(reduce(lambda x, y: x + y, [1, 1, 3]))
print(reduce(lambda x, y: x + y, [1, 1, 3], 2))
===
print((1.<4).reduce((x, y) -> x + y))
print((1.<4).reduce(3, (x, y) -> x + y))
print([1, 1, 3].reduce((x, y) -> x + y))
print([1, 1, 3].reduce(2, (x, y) -> x + y))
===
struct CodeBlock1
{
    CodeBlock1()
    {
        print(range_el(1, 4).reduce([](const auto &x, const auto &y){return x + y;}));
        print(range_el(1, 4).reduce(3, [](const auto &x, const auto &y){return x + y;}));
        print(create_array({1, 1, 3}).reduce([](const auto &x, const auto &y){return x + y;}));
        print(create_array({1, 1, 3}).reduce(2, [](const auto &x, const auto &y){return x + y;}));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Character_codes#Python
print(ord('a')) # prints "97"
print(chr(97))  # prints "a"
===
print(‘a’.code)
print(Char(code' 97))
===
struct CodeBlock1
{
    CodeBlock1()
    {
        print(u'a'_C.code);
        print(Char(97));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Check_that_file_exists#Python
import os
 
os.path.isfile("input.txt")
os.path.isfile("/input.txt")
os.path.isdir("docs")
os.path.isdir("/docs")
===
//import os
fs:is_file(‘input.txt’)
fs:is_file(‘/input.txt’)
fs:is_directory(‘docs’)
fs:is_directory(‘/docs’)
===
struct CodeBlock1
{
    CodeBlock1()
    {
        fs::is_file(u"input.txt"_S);
        fs::is_file(u"/input.txt"_S);
        fs::is_directory(u"docs"_S);
        fs::is_directory(u"/docs"_S);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Chinese_remainder_theorem#Python
from functools import reduce

def mul_inv(a, b):
    b0 = b
    x0 = 0
    x1 = 1
    if b == 1: return 1
    while a > 1:
        q = a // b
        (a, b) = (b, a%b)
        (x0, x1) = (x1 - q * x0, x0)
    if x1 < 0: x1 += b0
    return x1

def chinese_remainder(n, a):
    sum = 0
    prod = reduce(lambda a, b: a*b, n)
    for n_i, a_i in zip(n, a):
        p = prod // n_i
        sum += a_i * mul_inv(p, n_i) * p
    return sum % prod

n = [3, 5, 7]
a = [2, 3, 2]
print(chinese_remainder(n, a))
===

F mul_inv(=a, =b)
   V b0 = b
   V x0 = 0
   V x1 = 1
   I b == 1
      R 1
   L a > 1
      V q = a I/ b
      (a, b) = (b, a % b)
      (x0, x1) = (x1 - q * x0, x0)
   I x1 < 0
      x1 += b0
   R x1

F chinese_remainder(n, a)
   V sum = 0
   V prod = n.reduce((a, b) -> a * b)
   L(n_i, a_i) zip(n, a)
      V p = prod I/ n_i
      sum += a_i * mul_inv(p, n_i) * p
   R sum % prod
V n = [3, 5, 7]
V a = [2, 3, 2]
print(chinese_remainder(n, a))
===
template <typename T1, typename T2> auto mul_inv(T1 a, T2 b)
{
    auto b0 = b;
    auto x0 = 0;
    auto x1 = 1;
    if (b == 1)
        return 1;
    while (a > 1) {
        auto q = int(a)/int(b);
        std::tie(a, b) = make_tuple(b, mod(a, b));
        std::tie(x0, x1) = make_tuple(x1 - q * x0, x0);
    }
    if (x1 < 0)
        x1 += b0;
    return x1;
}

template <typename T1, typename T2> auto chinese_remainder(const T1 &n, const T2 &a)
{
    auto sum = 0;
    auto prod = n.reduce([](const auto &a, const auto &b){return a * b;});
    for (auto &&[n_i, a_i] : zip(n, a)) {
        auto p = int(prod)/int(n_i);
        sum += a_i * mul_inv(p, n_i) * p;
    }
    return mod(sum, prod);
}
auto n = create_array({3, 5, 7});
auto a = create_array({2, 3, 2});

struct CodeBlock1
{
    CodeBlock1()
    {
        print(chinese_remainder(n, a));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Compare_a_list_of_strings#D
for strings_s in ['AA AA AA AA', 'AA ACB BB CC']:
    strings = strings_s.split(' ')
    print(strings)
    print(all(a[0] == a[1] for a in zip(strings, strings[1:]))) # All equal
    print(all(a[0]  < a[1] for a in zip(strings, strings[1:]))) # Strictly ascending
    print()
===
L(strings_s) [‘AA AA AA AA’, ‘AA ACB BB CC’]
   V strings = strings_s.split(‘ ’)
   print(strings)
   print(all(zip(strings, strings[1..]).map(a -> a[0] == a[1])))
   print(all(zip(strings, strings[1..]).map(a -> a[0] < a[1])))
   print()
===
struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto strings_s : create_array({u"AA AA AA AA"_S, u"AA ACB BB CC"_S})) {
            auto strings = strings_s.split(u" "_S);
            print(strings);
            print(all(zip(strings, strings[range_ei(1)]).map([](const auto &a){return _get<0>(a) == _get<1>(a);})));
            print(all(zip(strings, strings[range_ei(1)]).map([](const auto &a){return _get<0>(a) < _get<1>(a);})));
            print();
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Continued_fraction#C
def calc(f_a, f_b, n = 1000):
    r = 0.0
    while n > 0:
        r = f_b(n) / (f_a(n) + r)
        n -= 1
    return f_a(0) + r

print(calc(lambda n: 2 if n > 0 else 1, lambda n: 1))
print(calc(lambda n: n if n > 0 else 2, lambda n: n - 1 if n > 1 else 1))
print(calc(lambda n: 6 if n > 0 else 3, lambda n: (2 * n - 1) ** 2))
===
F calc(f_a, f_b, =n = 1000)
   V r = 0.0
   L n > 0
      r = f_b(n) / (f_a(n) + r)
      n--
   R f_a(0) + r
print(calc(n -> I n > 0 {2} E 1, n -> 1))
print(calc(n -> I n > 0 {n} E 2, n -> I n > 1 {n - 1} E 1))
print(calc(n -> I n > 0 {6} E 3, n -> (2 * n - 1) ^ 2))
===
template <typename T1, typename T2, typename T3 = decltype(1000)> auto calc(const T1 &f_a, const T2 &f_b, T3 n = 1000)
{
    auto r = 0.0;
    while (n > 0) {
        r = f_b(n) / (f_a(n) + r);
        n--;
    }
    return f_a(0) + r;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(calc([](const auto &n){return n > 0 ? 2 : 1;}, [](const auto &n){return 1;}));
        print(calc([](const auto &n){return n > 0 ? n : 2;}, [](const auto &n){return n > 1 ? n - 1 : 1;}));
        print(calc([](const auto &n){return n > 0 ? 6 : 3;}, [](const auto &n){return pow((2 * n - 1), 2);}));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Convert_seconds_to_compound_duration#Julia
def duration(sec):
    t : List[int] = []
    for dm in [60, 60, 24, 7]:
        m : int
        (sec, m) = (sec // dm, sec % dm)
        t.insert(0, m)
    t.insert(0, sec)
    return ', '.join(str(num_unit[0]) + ' ' + str(num_unit[1]) for num_unit in zip(t, ['wk', 'd', 'hr', 'min', 'sec']) if num_unit[0] > 0)
 
print(duration(7259))
print(duration(86400))
print(duration(6000000))
===
F duration(=sec)
   [Int] t
   L(dm) [60, 60, 24, 7]
      Int m
      (sec, m) = (sec I/ dm, sec % dm)
      t.insert(0, m)
   t.insert(0, sec)
   R zip(t, [‘wk’, ‘d’, ‘hr’, ‘min’, ‘sec’]).filter(num_unit -> num_unit[0] > 0).map(num_unit -> String(num_unit[0])‘ ’String(num_unit[1])).join(‘, ’)
print(duration(7259))
print(duration(86400))
print(duration(6000000))
===
template <typename T1> auto duration(T1 sec)
{
    Array<int> t;
    for (auto dm : create_array({60, 60, 24, 7})) {
        int m;
        std::tie(sec, m) = make_tuple(int(sec)/int(dm), mod(sec, dm));
        t.insert(0, m);
    }
    t.insert(0, sec);
    return zip(t, create_array({u"wk"_S, u"d"_S, u"hr"_S, u"min"_S, u"sec"_S})).filter([](const auto &num_unit){return _get<0>(num_unit) > 0;}).map([](const auto &num_unit){return String(_get<0>(num_unit)) + u" "_S + String(_get<1>(num_unit));}).join(u", "_S);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(duration(7259));
        print(duration(86400));
        print(duration(6000000));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Conway%27s_Game_of_Life#Python
import collections
 
cellcountx = 6
cellcounty = 5
celltable = {
 (1, 2): 1,
 (1, 3): 1,
 (0, 3): 1,
}
 
universe = collections.defaultdict(int) # Tuple[int, int]
universe[(1, 1)] = 1
universe[(2, 1)] = 1
universe[(3, 1)] = 1
universe[(1, 4)] = 1
universe[(2, 4)] = 1
universe[(3, 4)] = 1
 
for i in range(4):
    print("\nGeneration " + str(i) + ':')
    for row in range(cellcounty):
        print('  ' + ''.join(['. ', 'O '][universe[(row, col)]] for col in range(cellcountx)))
    nextgeneration = collections.defaultdict(int) # Tuple[int, int]
    for row in range(cellcounty):
        for col in range(cellcountx):
            nextgeneration[(row, col)] = celltable.get(
                ( universe[(row, col)],
                 -universe[(row, col)] + sum(universe[(r, c)]
                                             for r in range(row-1, row+2)
                                             for c in range(col-1, col+2))
                ), 0)
    universe = nextgeneration
===
//import collections
V cellcountx = 6
V cellcounty = 5
V celltable = [(1, 2) = 1, (1, 3) = 1, (0, 3) = 1]
V universe = DefaultDict[(Int, Int), Int]()
universe[(1, 1)] = 1
universe[(2, 1)] = 1
universe[(3, 1)] = 1
universe[(1, 4)] = 1
universe[(2, 4)] = 1
universe[(3, 4)] = 1

L(i) 0.<4
   print("\nGeneration "String(i)‘:’)
   L(row) 0 .< cellcounty
      print(‘  ’(0 .< cellcountx).map(col -> [‘. ’, ‘O ’][:universe[(@row, col)]]).join(‘’))
   V nextgeneration = DefaultDict[(Int, Int), Int]()
   L(row) 0 .< cellcounty
      L(col) 0 .< cellcountx
         nextgeneration[(row, col)] = celltable.get((universe[(row, col)], -universe[(row, col)] + sum(multiloop((row - 1 .< row + 2), (col - 1 .< col + 2), (r, c) -> :universe[(r, c)]))), 0)
   universe = nextgeneration
===
auto cellcountx = 6;
auto cellcounty = 5;
auto celltable = create_dict(dict_of(make_tuple(1, 2), 1)(make_tuple(1, 3), 1)(make_tuple(0, 3), 1));
auto universe = DefaultDict<Tuple<int, int>, int>();

struct CodeBlock1
{
    CodeBlock1()
    {
        universe.set(make_tuple(1, 1), 1);
        universe.set(make_tuple(2, 1), 1);
        universe.set(make_tuple(3, 1), 1);
        universe.set(make_tuple(1, 4), 1);
        universe.set(make_tuple(2, 4), 1);
        universe.set(make_tuple(3, 4), 1);

        for (auto i : range_el(0, 4)) {
            print(u"\nGeneration "_S + String(i) + u":"_S);
            for (auto row : range_el(0, cellcounty))
                print(u"  "_S + range_el(0, cellcountx).map([&row](const auto &col){return create_array({u". "_S, u"O "_S})[::universe[make_tuple(row, col)]];}).join(u""_S));
            auto nextgeneration = DefaultDict<Tuple<int, int>, int>();
            for (auto row : range_el(0, cellcounty))
                for (auto col : range_el(0, cellcountx))
                    nextgeneration.set(make_tuple(row, col), celltable.get(make_tuple(universe[make_tuple(row, col)], -universe[make_tuple(row, col)] + sum(multiloop(range_el(row - 1, row + 2), range_el(col - 1, col + 2), [](const auto &r, const auto &c){return ::universe[make_tuple(r, c)];}))), 0));
            universe = nextgeneration;
        }
    }
} code_block_1;