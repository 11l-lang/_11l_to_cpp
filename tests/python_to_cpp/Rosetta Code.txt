# https://www.rosettacode.org/wiki/Visualize_a_tree#D
from typing import List

class Node:
    value : str
    left : 'Node' = None
    right : 'Node' = None

    def __init__(self, value, left : 'Node' = None, right : 'Node' = None):
        self.value = str(value)
        self.left = left
        self.right = right

    def tree_indent(self) -> List[str]:
        tr = self.right.tree_indent() if self.right is not None else ['-- (null)']
        return ['--' + self.value] + list(map(lambda a: '  |' + a, self.left.tree_indent() if self.left is not None else ['-- (null)'])) + ['  `' + tr[0]] + list(map(lambda a: "   " + a, tr[1:]))

tree = Node(1, Node(2, Node(4, Node(7)), Node(5)), Node(3, Node(6, Node(8), Node(9))))
print("\n".join(tree.tree_indent()))
===
T Node
   String value
   Node? left
   Node? right

   F (value, Node? left = N, Node? right = N)
      .value = String(value)
      .left = left
      .right = right

   F tree_indent() -> [String]
      V tr = I .right != N {.right.tree_indent()} E [‘-- (null)’]
      R [‘--’(.value)] [+] (I .left != N {.left.tree_indent()} E [‘-- (null)’]).map(a -> ‘  |’a) [+] [‘  `’tr[0]] [+] tr[1..].map(a -> ‘   ’a)

V tree = Node(1, Node(2, Node(4, Node(7)), Node(5)), Node(3, Node(6, Node(8), Node(9))))
print(tree.tree_indent().join("\n"))
===
class Node
{
public:
    String value;
    std::unique_ptr<Node> left;
    std::unique_ptr<Node> right;

    template <typename T1> Node(const T1 &value, std::unique_ptr<Node> left = nullptr, std::unique_ptr<Node> right = nullptr) :
        left(std::move(left)),
        right(std::move(right))
    {
        this->value = String(value);
    }

    Array<String> tree_indent()
    {
        auto tr = right != nullptr ? right->tree_indent() : create_array({u"-- (null)"_S});
        return create_array({u"--"_S & (value)}) + (left != nullptr ? left->tree_indent() : create_array({u"-- (null)"_S})).map([](const auto &a){return u"  |"_S & a;}) + create_array({u"  `"_S & _get<0>(tr)}) + tr[range_ei(1)].map([](const auto &a){return u"   "_S & a;});
    }
};

auto tree = std::make_unique<Node>(1, std::make_unique<Node>(2, std::make_unique<Node>(4, std::make_unique<Node>(7)), std::make_unique<Node>(5)), std::make_unique<Node>(3, std::make_unique<Node>(6, std::make_unique<Node>(8), std::make_unique<Node>(9))));

struct CodeBlock1
{
    CodeBlock1()
    {
        print(tree->tree_indent().join(u"\n"_S));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Range_expansion#Python
def rangeexpand(txt):
    lst : List[int] = []
    for r in txt.split(','):
        if '-' in r[1:]:
            rr = r[1:].split('-', 1)
            lst += range(int(r[0] + '' + rr[0]), int(rr[1]) + 1)
        else:
            lst.append(int(r))
    return lst

print(rangeexpand('-6,-3--1,3-5,7-11,14,15,17-20'))
===
F rangeexpand(txt)
   [Int] lst
   L(r) txt.split(‘,’)
      I ‘-’ C r[1..]
         V rr = r[1..].split(‘-’, 1 + 1)
         lst [+]= Int(r[0]‘’rr[0]) .. Int(rr[1])
      E
         lst.append(Int(r))
   R lst

print(rangeexpand(‘-6,-3--1,3-5,7-11,14,15,17-20’))
===
template <typename T1> auto rangeexpand(const T1 &txt)
{
    Array<int> lst;
    for (auto &&r : txt.split(u","_S))
        if (in(u'-'_C, r[range_ei(1)])) {
            auto rr = r[range_ei(1)].split(u"-"_S, 1 + 1);
            lst.append(range_ee(to_int(_get<0>(r) & _get<0>(rr)), to_int(_get<1>(rr))));
        }
        else
            lst.append(to_int(r));
    return lst;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(rangeexpand(u"-6,-3--1,3-5,7-11,14,15,17-20"_S));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Loops/Break#Python
import random

while True:
    a = random.randrange(20)
    print(a)
    if a == 10:
        break
    b = random.randrange(20)
    print(b)
===
L
   V a = random:(20)
   print(a)
   I a == 10
      L.break
   V b = random:(20)
   print(b)
===
struct CodeBlock1
{
    CodeBlock1()
    {
        while (true) {
            auto a = randomns::_(20);
            print(a);
            if (a == 10)
                break;
            auto b = randomns::_(20);
            print(b);
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Execute_Brain****/Python
import sys, collections

def bf(source):
    loop_ptrs : Dict[int, int] = {}
    loop_stack : List[int] = []
    for ptr, opcode in enumerate(source):
        if opcode == '[': loop_stack.append(ptr)
        if opcode == ']':
            sptr = loop_stack.pop()
            loop_ptrs[ptr] = sptr
            loop_ptrs[sptr] = ptr

    tape = collections.defaultdict(int) # int
    cell = 0
    ptr = 0
    while ptr < len(source):
        opcode = source[ptr]
        if   opcode == '>': cell += 1
        elif opcode == '<': cell -= 1
        elif opcode == '+': tape[cell] += 1
        elif opcode == '-': tape[cell] -= 1
        elif opcode == '.': sys.stdout.write(chr(tape[cell]))
        elif opcode == ',': tape[cell] = ord(sys.stdin.read(1))
        elif (opcode == '[' and not tape[cell]) or \
             (opcode == ']' and tape[cell]): ptr = loop_ptrs[ptr]
        ptr += 1

bf('++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.')
===
F bf(source)
   [Int = Int] loop_ptrs
   [Int] loop_stack
   L(opcode) source
      V ptr = L.index
      I opcode == ‘[’
         loop_stack.append(ptr)
      I opcode == ‘]’
         V sptr = loop_stack.pop()
         loop_ptrs[ptr] = sptr
         loop_ptrs[sptr] = ptr

   V tape = DefaultDict[Int, Int]()
   V cell = 0
   V ptr = 0
   L ptr < source.len
      V opcode = source[ptr]
      I opcode == ‘>’
         cell++
      E I opcode == ‘<’
         cell--
      E I opcode == ‘+’
         tape[cell]++
      E I opcode == ‘-’
         tape[cell]--
      E I opcode == ‘.’
         :stdout.write(Char(code' tape[cell]))
      E I opcode == ‘,’
         tape[cell] = :stdin.read(1).code
      E I (opcode == ‘[’ & !tape[cell]) | (opcode == ‘]’ & tape[cell])
         ptr = loop_ptrs[ptr]
      ptr++

bf(‘++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.’)
===
template <typename T1> auto bf(const T1 &source)
{
    Dict<int, int> loop_ptrs;
    Array<int> loop_stack;
    {int Lindex = 0;
    for (auto &&opcode : source) {
        auto ptr = Lindex;
        if (opcode == u'[')
            loop_stack.append(ptr);
        if (opcode == u']') {
            auto sptr = loop_stack.pop();
            loop_ptrs.set(ptr, sptr);
            loop_ptrs.set(sptr, ptr);
        }
        Lindex++;
    }}

    auto tape = DefaultDict<int, int>();
    auto cell = 0;
    auto ptr = 0;
    while (ptr < source.len()) {
        auto opcode = source[ptr];
        if (opcode == u'>')
            cell++;
        else if (opcode == u'<')
            cell--;
        else if (opcode == u'+')
            tape[cell]++;
        else if (opcode == u'-')
            tape[cell]--;
        else if (opcode == u'.')
            _stdout.write(Char(tape[cell]));
        else if (opcode == u',')
            tape.set(cell, _stdin.read(1).code);
        else if ((opcode == u'[' && !tape[cell]) || (opcode == u']' && tape[cell]))
            ptr = loop_ptrs[ptr];
        ptr++;
    }
}

struct CodeBlock1
{
    CodeBlock1()
    {
        bf(u"++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++."_S);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Execute_Brain****
import sys, collections

def bf(source):
    tape = collections.defaultdict(int) # int
    cell = 0
    ptr = 0
    while ptr < len(source):
        opcode = source[ptr]
        if   opcode == '>': cell += 1
        elif opcode == '<': cell -= 1
        elif opcode == '+': tape[cell] += 1
        elif opcode == '-': tape[cell] -= 1
        elif opcode == '.': sys.stdout.write(chr(tape[cell]))
        elif opcode == ',': tape[cell] = ord(sys.stdin.read(1))
        elif opcode == '[':
            if tape[cell] == 0:
                nesting_level = 0
                while True:
                    ch = source[ptr]
                    if ch == '[':
                        nesting_level += 1
                    elif ch == ']':
                        nesting_level -= 1
                        if nesting_level == 0:
                            break
                    ptr += 1
        elif opcode == ']':
            if tape[cell] != 0:
                nesting_level = 0
                while True:
                    ch = source[ptr]
                    if ch == '[':
                        nesting_level -= 1
                        if nesting_level == 0:
                            break
                    elif ch == ']':
                        nesting_level += 1
                    ptr -= 1
        ptr += 1

bf('++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.')
===
F bf(source)
   V tape = DefaultDict[Int, Int]()
   V cell = 0
   V ptr = 0
   L ptr < source.len
      S source[ptr]
         ‘>’
            cell++
         ‘<’
            cell--
         ‘+’
            tape[cell]++
         ‘-’
            tape[cell]--
         ‘.’
            :stdout.write(Char(code' tape[cell]))
         ‘,’
            tape[cell] = :stdin.read(1).code
         ‘[’
            I tape[cell] == 0
               V nesting_level = 0
               L
                  S source[ptr]
                     ‘[’
                        nesting_level++
                     ‘]’
                        I --nesting_level == 0
                           L.break
                  ptr++
         ‘]’
            I tape[cell] != 0
               V nesting_level = 0
               L
                  S source[ptr]
                     ‘[’
                        I --nesting_level == 0
                           L.break
                     ‘]’
                        nesting_level++
                  ptr--
      ptr++

bf(‘++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.’)
===
template <typename T1> auto bf(const T1 &source)
{
    auto tape = DefaultDict<int, int>();
    auto cell = 0;
    auto ptr = 0;
    while (ptr < source.len()) {
        switch (source[ptr])
        {
        case u'>':
            cell++;
            break;
        case u'<':
            cell--;
            break;
        case u'+':
            tape[cell]++;
            break;
        case u'-':
            tape[cell]--;
            break;
        case u'.':
            _stdout.write(Char(tape[cell]));
            break;
        case u',':
            tape.set(cell, _stdin.read(1).code);
            break;
        case u'[':
            if (tape[cell] == 0) {
                auto nesting_level = 0;
                while (true) {
                    switch (source[ptr])
                    {
                    case u'[':
                        nesting_level++;
                        break;
                    case u']':
                        if (--nesting_level == 0)
                            goto break_;
                        break;
                    }
                    ptr++;
                }
                break_:;
            }
            break;
        case u']':
            if (tape[cell] != 0) {
                auto nesting_level = 0;
                while (true) {
                    switch (source[ptr])
                    {
                    case u'[':
                        if (--nesting_level == 0)
                            goto break_1;
                        break;
                    case u']':
                        nesting_level++;
                        break;
                    }
                    ptr--;
                }
                break_1:;
            }
            break;
        }
        ptr++;
    }
}

struct CodeBlock1
{
    CodeBlock1()
    {
        bf(u"++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++."_S);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/LZW_compression#Python
import sys
from typing import List

def compress(uncompressed):
    dict_size = 256
    dictionary = dict((str(chr(i)), i) for i in range(dict_size))

    w = ""
    result : List[int] = []
    for c in uncompressed:
        wc = w + c
        if wc in dictionary:
            w = wc
        else:
            result.append(dictionary[w])
            # Add wc to the dictionary.
            dictionary[wc] = dict_size
            dict_size += 1
            w = c

    # Output the code for w.
    if len(w):
        result.append(dictionary[w])
    return result

def decompress(compressed : List[int]):
    dict_size = 256
    dictionary = dict((i, str(chr(i))) for i in range(dict_size))

    result = ''
    w = str(chr(compressed.pop(0)))
    result += w
    for k in compressed:
        entry = ''
        if k in dictionary:
            entry = dictionary[k]
        elif k == dict_size:
            entry = w + w[0]
        else:
            sys.exit('Bad compressed k: '+str(k))
        result += entry

        dictionary[dict_size] = w + entry[0]
        dict_size += 1

        w = entry
    return result

compressed = compress('TOBEORNOTTOBEORTOBEORNOT')
print(compressed)
print(decompress(compressed))
===
F compress(uncompressed)
   V dict_size = 256
   V dictionary = Dict((0 .< dict_size).map(i -> (String(Char(code' i)), i)))

   V w = ‘’
   [Int] result
   L(c) uncompressed
      V wc = w‘’c
      I wc C dictionary
         w = wc
      E
         result.append(dictionary[w])
         dictionary[wc] = dict_size
         dict_size++
         w = c

   I !w.empty
      result.append(dictionary[w])
   R result

F decompress([Int] &compressed)
   V dict_size = 256
   V dictionary = Dict((0 .< dict_size).map(i -> (i, String(Char(code' i)))))

   V result = ‘’
   V w = String(Char(code' compressed.pop(0)))
   result ‘’= w
   L(k) compressed
      V entry = ‘’
      I k C dictionary
         entry = dictionary[k]
      E I k == dict_size
         entry = w‘’w[0]
      E
         exit(‘Bad compressed k: ’String(k))
      result ‘’= entry

      dictionary[dict_size] = w‘’entry[0]
      dict_size++

      w = entry
   R result

V compressed = compress(‘TOBEORNOTTOBEORTOBEORNOT’)
print(compressed)
print(decompress(&compressed))
===
template <typename T1> auto compress(const T1 &uncompressed)
{
    auto dict_size = 256;
    auto dictionary = create_dict(range_el(0, dict_size).map([](const auto &i){return make_tuple(String(Char(i)), i);}));

    auto w = u""_S;
    Array<int> result;
    for (auto &&c : uncompressed) {
        auto wc = w & c;
        if (in(wc, dictionary))
            w = wc;
        else {
            result.append(dictionary[w]);
            dictionary.set(wc, dict_size);
            dict_size++;
            w = c;
        }
    }

    if (!w.empty())
        result.append(dictionary[w]);
    return result;
}

auto decompress(Array<int> &compressed)
{
    auto dict_size = 256;
    auto dictionary = create_dict(range_el(0, dict_size).map([](const auto &i){return make_tuple(i, String(Char(i)));}));

    auto result = u""_S;
    auto w = String(Char(compressed.pop(0)));
    result &= w;
    for (auto &&k : compressed) {
        auto entry = u""_S;
        if (in(k, dictionary))
            entry = dictionary[k];
        else if (k == dict_size)
            entry = w & _get<0>(w);
        else
            exit(u"Bad compressed k: "_S & String(k));
        result &= entry;

        dictionary.set(dict_size, w & _get<0>(entry));
        dict_size++;

        w = entry;
    }
    return result;
}

auto compressed = compress(u"TOBEORNOTTOBEORTOBEORNOT"_S);

struct CodeBlock1
{
    CodeBlock1()
    {
        print(compressed);
        print(decompress(compressed));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/100_doors#Python
# Please take solution from '../parser/Rosetta Code.txt'
doors = [False] * 100
for i in range(100):
   for j in range(i, 100, i+1):
       doors[j] = not doors[j]
   print('Door ' + str(i+1) + ': '+ ('open' if doors[i] else 'close'))
===
V doors = [0B] * 100
L(i) 100
   L(j) (i .< 100).step(i + 1)
      doors[j] = !doors[j]
   print(‘Door ’String(i + 1)‘: ’(I doors[i] {‘open’} E ‘close’))
===
auto doors = create_array({false}) * 100;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (int i = 0; i < 100; i++) {
            for (auto j : range_el(i, 100).step(i + 1))
                doors.set(j, !doors[j]);
            print(u"Door "_S & String(i + 1) & u": "_S & (doors[i] ? u"open"_S : u"close"_S));
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/A%2BB#Python
print(sum(map(lambda i: int(i), input().split())))
===
print(sum(input().split_py().map(i -> Int(i))))
===
struct CodeBlock1
{
    CodeBlock1()
    {
        print(sum_map(input().split_py(), [](const auto &i){return to_int(i);}));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/ABC_Problem#Python:_Iterative.2C_with_tests
def can_make_word(word):
    if word == '':
        return False

    blocks_remaining = 'BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM'.split(' ')

    for ch in word.upper():
        for block in blocks_remaining:
            if ch in block:
                blocks_remaining.remove(block)
                break
        else:
            return False
    return True

print(', '.join("'" + w + "': " + str(can_make_word(w)) for w in ['', 'a', 'baRk', 'booK', 'treat', 'COMMON', 'squad', 'Confused']))
===
F can_make_word(word)
   I word == ‘’
      R 0B

   V blocks_remaining = ‘BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM’.split(‘ ’)

   L(ch) word.uppercase()
      L(block) blocks_remaining
         I ch C block
            blocks_remaining.remove(block)
            L.break
      L.was_no_break
         R 0B
   R 1B

print([‘’, ‘a’, ‘baRk’, ‘booK’, ‘treat’, ‘COMMON’, ‘squad’, ‘Confused’].map(w -> ‘'’w‘': ’String(can_make_word(w))).join(‘, ’))
===
template <typename T1> auto can_make_word(const T1 &word)
{
    if (word == u"")
        return false;

    auto blocks_remaining = u"BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM"_S.split(u" "_S);

    for (auto &&ch : word.uppercase()) {
        for (auto &&block : blocks_remaining)
            if (in(ch, block)) {
                blocks_remaining.remove(block);
                goto break_;
            }
        return false;
        break_:;
    }
    return true;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(create_array({u""_S, u"a"_S, u"baRk"_S, u"booK"_S, u"treat"_S, u"COMMON"_S, u"squad"_S, u"Confused"_S}).map([](const auto &w){return u"'"_S & w & u"': "_S & String(can_make_word(w));}).join(u", "_S));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Abundant,_deficient_and_perfect_number_classifications#Kotlin
# Please take solution from '../parser/Rosetta Code.txt'
def sum_proper_divisors(n):
    return 0 if n < 2 else sum(filter(lambda it: (n % it) == 0, range(1, n // 2 + 1)))

deficient = 0
perfect = 0
abundant = 0

for n in range(1, 20000+1):
    sp = sum_proper_divisors(n)
    if sp < n: deficient += 1
    elif sp == n: perfect += 1
    elif sp > n : abundant += 1

print("Deficient = " + str(deficient))
print("Perfect   = " + str(perfect))
print("Abundant  = " + str(abundant))
===
F sum_proper_divisors(n)
   R I n < 2 {0} E sum((1 .. n I/ 2).filter(it -> (@n % it) == 0))

V deficient = 0
V perfect = 0
V abundant = 0

L(n) 1 .. 20000
   V sp = sum_proper_divisors(n)
   I sp < n
      deficient++
   E I sp == n
      perfect++
   E I sp > n
      abundant++

print(‘Deficient = ’String(deficient))
print(‘Perfect   = ’String(perfect))
print(‘Abundant  = ’String(abundant))
===
template <typename T1> auto sum_proper_divisors(const T1 &n)
{
    return n < 2 ? 0 : sum(range_ee(1, idiv(n, 2)).filter([&n](const auto &it){return (mod(n, it)) == 0;}));
}

auto deficient = 0;
auto perfect = 0;
auto abundant = 0;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto n : range_ee(1, 20000)) {
            auto sp = sum_proper_divisors(n);
            if (sp < n)
                deficient++;
            else if (sp == n)
                perfect++;
            else if (sp > n)
                abundant++;
        }

        print(u"Deficient = "_S & String(deficient));
        print(u"Perfect   = "_S & String(perfect));
        print(u"Abundant  = "_S & String(abundant));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Align_columns#Python
from typing import Callable

txt = R"""Given$a$txt$file$of$many$lines,$where$fields$within$a$line$
are$delineated$by$a$single$'dollar'$character,$write$a$program
that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$
column$are$separated$by$at$least$one$space.
Further,$allow$for$each$word$in$a$column$to$be$either$left$
justified,$right$justified,$or$center$justified$within$its$column."""

parts = [line.rstrip("$").split("$") for line in txt.split("\n")]

max_widths = [0] * len(parts[0])
for line in parts:
    for i, word in enumerate(line):
        max_widths[i] = max(max_widths[i], len(word))

ljust : Callable[[str, int], str] = lambda s, w: s + ' '*(w-len(s))
centr : Callable[[str, int], str] = lambda s, w: ' '*(w-len(s) - (w//2 - len(s)//2)) + s + ' '*(w//2 - len(s)//2)
rjust : Callable[[str, int], str] = lambda s, w: ' '*(w-len(s)) + s
for i, justify in enumerate([ljust, centr, rjust]):
    print(["Left", "Center", "Right"][i] + " column-aligned output:")
    for line in parts:
        for j, word in enumerate(line):
            print(justify(word, max_widths[j]), end = ' ')
        print()
    print("- " * 52)
===
V txt = ‘Given$a$txt$file$of$many$lines,$where$fields$within$a$line$
are$delineated$by$a$single$'dollar'$character,$write$a$program
that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$
column$are$separated$by$at$least$one$space.
Further,$allow$for$each$word$in$a$column$to$be$either$left$
justified,$right$justified,$or$center$justified$within$its$column.’

V parts = txt.split("\n").map(line -> line.rtrim(‘$’).split(‘$’))

V max_widths = [0] * parts[0].len
L(line) parts
   L(word) line
      V i = L.index
      max_widths[i] = max(max_widths[i], word.len)

((String, Int) -> String) ljust = (s, w) -> s‘’(‘ ’ * (w - s.len))
((String, Int) -> String) centr = (s, w) -> (‘ ’ * (w - s.len - (w I/ 2 - s.len I/ 2)))‘’s‘’(‘ ’ * (w I/ 2 - s.len I/ 2))
((String, Int) -> String) rjust = (s, w) -> (‘ ’ * (w - s.len))‘’s
L(justify) [ljust, centr, rjust]
   V i = L.index
   print([‘Left’, ‘Center’, ‘Right’][i]‘ column-aligned output:’)
   L(line) parts
      L(word) line
         V j = L.index
         print(justify(word, max_widths[j]), end' ‘ ’)
      print()
   print(‘- ’ * 52)
===
auto txt = uR"(Given$a$txt$file$of$many$lines,$where$fields$within$a$line$
are$delineated$by$a$single$'dollar'$character,$write$a$program
that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$
column$are$separated$by$at$least$one$space.
Further,$allow$for$each$word$in$a$column$to$be$either$left$
justified,$right$justified,$or$center$justified$within$its$column.)"_S;

auto parts = txt.split(u"\n"_S).map([](const auto &line){return line.rtrim(u"$"_S).split(u"$"_S);});

auto max_widths = create_array({0}) * _get<0>(parts).len();

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&line : parts)
            {int Lindex = 0;
            for (auto &&word : line) {
                auto i = Lindex;
                max_widths.set(i, max(max_widths[i], word.len()));
                Lindex++;
            }}
    }
} code_block_1;

std::function<String(const String&, const int)> ljust = [](const auto &s, const auto &w){return s & (u" "_S * (w - s.len()));};
std::function<String(const String&, const int)> centr = [](const auto &s, const auto &w){return (u" "_S * (w - s.len() - (idiv(w, 2) - idiv(s.len(), 2)))) & s & (u" "_S * (idiv(w, 2) - idiv(s.len(), 2)));};
std::function<String(const String&, const int)> rjust = [](const auto &s, const auto &w){return (u" "_S * (w - s.len())) & s;};

struct CodeBlock2
{
    CodeBlock2()
    {
        {int Lindex = 0;
        for (auto &&justify : create_array({ljust, centr, rjust})) {
            auto i = Lindex;
            print(create_array({u"Left"_S, u"Center"_S, u"Right"_S})[i] & u" column-aligned output:"_S);
            for (auto &&line : parts) {
                {int Lindex = 0;
                for (auto &&word : line) {
                    auto j = Lindex;
                    print(justify(word, max_widths[j]), u" "_S);
                    Lindex++;
                }}
                print();
            }
            print(u"- "_S * 52);
            Lindex++;
        }}
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Almost_prime#Kotlin
def k_prime(k, n):
    f = 0
    p = 2
    while f < k and p * p <= n:
        while n % p == 0:
            n /= p
            f += 1
        p += 1
    return f + (1 if n > 1 else 0) == k

def primes(k, n):
    i = 2
    list : List[int] = []
    while len(list) < n:
        if k_prime(k, i):
            list.append(i)
        i += 1
    return list

for k in range(1, 6):
    print('k = '+str(k)+': '+str(primes(k, 10)))
===
F k_prime(k, =n)
   V f = 0
   V p = 2
   L f < k & p * p <= n
      L n % p == 0
         n /= p
         f++
      p++
   R f + (I n > 1 {1} E 0) == k

F primes(k, n)
   V i = 2
   [Int] list
   L list.len < n
      I k_prime(k, i)
         list.append(i)
      i++
   R list

L(k) 1..5
   print(‘k = ’String(k)‘: ’String(primes(k, 10)))
===
template <typename T1, typename T2> auto k_prime(const T1 &k, T2 n)
{
    auto f = 0;
    auto p = 2;
    while (f < k && p * p <= n) {
        while (mod(n, p) == 0) {
            n /= p;
            f++;
        }
        p++;
    }
    return f + (n > 1 ? 1 : 0) == k;
}

template <typename T1, typename T2> auto primes(const T1 &k, const T2 &n)
{
    auto i = 2;
    Array<int> list;
    while (list.len() < n) {
        if (k_prime(k, i))
            list.append(i);
        i++;
    }
    return list;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto k : range_ee(1, 5))
            print(u"k = "_S & String(k) & u": "_S & String(primes(k, 10)));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Anagrams#Python
import collections
from typing import List, DefaultDict

anagram : DefaultDict[str, List[str]] = collections.defaultdict(list)
for word in open('unixdict.txt').read().split("\n"):
    anagram[''.join(sorted(word))].append(word)

count = max(len(ana) for ana in anagram.values())

for ana in anagram.values():
    if len(ana) == count:
        print(ana)
===
DefaultDict[String, [String]] anagram
L(word) File(‘unixdict.txt’).read().split("\n")
   anagram[sorted(word).join(‘’)].append(word)

V count = max(anagram.values().map(ana -> ana.len))

L(ana) anagram.values()
   I ana.len == count
      print(ana)
===
DefaultDict<String, Array<String>> anagram;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&word : File(u"unixdict.txt"_S).read().split(u"\n"_S))
            anagram[sorted(word).join(u""_S)].append(word);
    }
} code_block_1;

auto count = max_map(anagram.values(), [](const auto &ana){return ana.len();});

struct CodeBlock2
{
    CodeBlock2()
    {
        for (auto &&ana : anagram.values())
            if (ana.len() == count)
                print(ana);
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Anagrams/Deranged_anagrams#Kotlin
from typing import Dict, List

def is_not_deranged(s1, s2):
    for i in range(len(s1)):
        if s1[i] == s2[i]:
            return True
    return False

anagram : Dict[str, List[str]] = {}
count = 0
for word in open('unixdict.txt').read().split("\n"):
    a = ''.join(sorted(word))
    if a not in anagram:
        anagram[a] = [word]
    else:
        for ana in anagram[a]:
            if is_not_deranged(ana, word):
                break
        else:
            anagram[a].append(word)
            count = max(count, len(word))

for ana in anagram.values():
    if len(ana) > 1 and len(ana[0]) == count:
        print(ana)
===
F is_not_deranged(s1, s2)
   L(i) 0 .< s1.len
      I s1[i] == s2[i]
         R 1B
   R 0B

[String = [String]] anagram
V count = 0
L(word) File(‘unixdict.txt’).read().split("\n")
   V a = sorted(word).join(‘’)
   I a !C anagram
      anagram[a] = [word]
   E
      L(ana) anagram[a]
         I is_not_deranged(ana, word)
            L.break
      L.was_no_break
         anagram[a].append(word)
         count = max(count, word.len)

L(ana) anagram.values()
   I ana.len > 1 & ana[0].len == count
      print(ana)
===
template <typename T1, typename T2> auto is_not_deranged(const T1 &s1, const T2 &s2)
{
    for (auto i : range_el(0, s1.len()))
        if (s1[i] == s2[i])
            return true;
    return false;
}

Dict<String, Array<String>> anagram;
auto count = 0;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&word : File(u"unixdict.txt"_S).read().split(u"\n"_S)) {
            auto a = sorted(word).join(u""_S);
            if (!in(a, anagram))
                anagram.set(a, create_array({word}));
            else {
                for (auto &&ana : anagram[a])
                    if (is_not_deranged(ana, word))
                        goto break_;
                anagram[a].append(word);
                count = max(count, word.len());
                break_:;
            }
        }

        for (auto &&ana : anagram.values())
            if (ana.len() > 1 && _get<0>(ana).len() == count)
                print(ana);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Anonymous_recursion#C.2B.2B
def fib(n):
    def f(n : int) -> int:
        if n < 2:
            return n
        return f(n-1) + f(n-2)
    return f(n)

for i in range(21):
    print(fib(i), end = ' ')
===
F fib(n)
   F f(Int n) -> Int
      I n < 2
         R n
      R @f(n - 1) + @f(n - 2)
   R f(n)

L(i) 21
   print(fib(i), end' ‘ ’)
===
template <typename T1> auto fib(const T1 &n)
{
    std::function<int(int)> f = [&f](const int n)
    {
        if (n < 2)
            return n;
        return f(n - 1) + f(n - 2);
    };
    return f(n);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (int i = 0; i < 21; i++)
            print(fib(i), u" "_S);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Anti-primes
max_divisors = 0
c = 0
n = 1
while True:
    divisors = 1
    for i in range(1, n // 2 + 1):
        if n % i == 0:
            divisors += 1

    if divisors > max_divisors:
        max_divisors = divisors
        print(n, end = ' ')
        c += 1
        if c == 20:
            break

    n += 1
===
V max_divisors = 0
V c = 0
V n = 1
L
   V divisors = 1
   L(i) 1 .. n I/ 2
      I n % i == 0
         divisors++

   I divisors > max_divisors
      max_divisors = divisors
      print(n, end' ‘ ’)
      c++
      I c == 20
         L.break

   n++
===
auto max_divisors = 0;
auto c = 0;
auto n = 1;

struct CodeBlock1
{
    CodeBlock1()
    {
        while (true) {
            auto divisors = 1;
            for (auto i : range_ee(1, idiv(n, 2)))
                if (mod(n, i) == 0)
                    divisors++;

            if (divisors > max_divisors) {
                max_divisors = divisors;
                print(n, u" "_S);
                c++;
                if (c == 20)
                    break;
            }

            n++;
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Apply_a_callback_to_an_array#Kotlin
array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
arrsq = list(map(lambda i: i*i, array))
print(arrsq)
===
V array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
V arrsq = array.map(i -> i * i)
print(arrsq)
===
auto array = create_array({1, 2, 3, 4, 5, 6, 7, 8, 9, 10});
auto arrsq = array.map([](const auto &i){return i * i;});

struct CodeBlock1
{
    CodeBlock1()
    {
        print(arrsq);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Arithmetic-geometric_mean#Python
import math

def agm(a0, g0, tolerance = 1e-10):
    an = (a0 + g0) / 2.0
    gn = math.sqrt(a0 * g0)
    while abs(an - gn) > tolerance:
        (an, gn) = ((an + gn) / 2.0, math.sqrt(an * gn))
    return an

print(agm(1, 1 / math.sqrt(2)))
===
F agm(a0, g0, tolerance = 1e-10)
   V an = (a0 + g0) / 2.0
   V gn = sqrt(a0 * g0)
   L abs(an - gn) > tolerance
      (an, gn) = ((an + gn) / 2.0, sqrt(an * gn))
   R an

print(agm(1, 1 / sqrt(2)))
===
template <typename T1, typename T2, typename T3 = decltype(1e-10)> auto agm(const T1 &a0, const T2 &g0, const T3 &tolerance = 1e-10)
{
    auto an = (a0 + g0) / 2.0;
    auto gn = sqrt(a0 * g0);
    while (abs(an - gn) > tolerance)
        assign_from_tuple(an, gn, make_tuple((an + gn) / 2.0, sqrt(an * gn)));
    return an;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(agm(1, 1.0 / sqrt(2)));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Arithmetic_evaluation
import re
from typing import Callable, Dict, List, Optional

def move(obj):
    return obj

# class T_shared_ASTNode:
#     pass

class Symbol:
    id : str
    lbp : int
    nud_bp : int
    led_bp : int
    nud : Callable[['ASTNode'], 'ASTNode']
    led : Callable[['ASTNode', 'ASTNode'], 'ASTNode']

    def set_nud_bp(self, nud_bp, nud):
        self.nud_bp = nud_bp
        self.nud    = nud

    def set_led_bp(self, led_bp, led):
        self.led_bp = led_bp
        self.led    = led

class ASTNode:
    symbol : Symbol # &
    value : int
    first_child : Optional['ASTNode'] = None
    second_child : Optional['ASTNode'] = None

    def eval(self):
        sid = self.symbol.id
        if sid == '(number)':
            return self.value
        elif sid == '+':
            return self.first_child.eval() + self.second_child.eval()
        elif sid == '-':
            return -self.first_child.eval() if self.second_child is None else self.first_child.eval() - self.second_child.eval()
        elif sid == '*':
            return self.first_child.eval() * self.second_child.eval()
        elif sid == '/':
            return self.first_child.eval() / self.second_child.eval()
        elif sid == '(': # )
            return self.first_child.eval()
        else:
            assert(False)
            return 0

symbol_table : Dict[str, Symbol] = {}
tokens : List[str]
tokeni = -1
token_node : ASTNode

def advance(sid = ''):
    global token_node, tokeni
    if sid != '':
        assert(token_node.symbol.id == sid)
    tokeni += 1
    token_node = ASTNode()
    if tokeni == len(tokens):
        token_node.symbol = symbol_table['(end)']
        return
    token = tokens[tokeni]
    token_node.symbol = symbol_table['(number)' if token.isdigit() else token]
    if token.isdigit():
        token_node.value = int(token)

def expression(rbp = 0):
    t : ASTNode = move(token_node)
    advance()
    left = t.symbol.nud(move(t))
    while rbp < token_node.symbol.lbp:
        t = move(token_node)
        advance()
        left = t.symbol.led(t, move(left))
    return left

def parse(expr_str) -> ASTNode:
    global tokens, tokeni
    tokens = re.findall(R'\s*(\d+|.)', expr_str)
    tokeni = -1
    advance()
    return expression()

def symbol(id, bp = 0): # -> &
    if not id in symbol_table: # Bool was_added
        s = Symbol()           # V &s = :symbol_table.add(id, &was_added)
        s.id = id              # I was_added
        s.lbp = bp             #    s.id = id
        symbol_table[id] = s   #    s.lbp = bp
    return symbol_table[id]    # R s

def infix(id, bp):
    def led(self : ASTNode, left : ASTNode):
        self.first_child = left
        self.second_child = expression(self.symbol.led_bp)
        return self
    symbol(id, bp).set_led_bp(bp, led)

def prefix(id, bp):
    def nud(self : ASTNode):
        self.first_child = expression(self.symbol.nud_bp)
        return self
    symbol(id).set_nud_bp(bp, nud)

infix('+', 1)
infix('-', 1)
infix('*', 2)
infix('/', 2)
prefix('-', 3)

def nud(self : ASTNode):
    return self
symbol('(number)').nud = nud
symbol('(end)')

def nud_parens(self : ASTNode):
    expr = expression() # (
    advance(')')
    return expr
symbol('(').nud = nud_parens
symbol(')')

for expr_str in ['-2 / 2 + 4 + 3 * 2',
                 '2 * (3 + (4 * 5 + (6 * 7) * 8) - 9) * 10']:
    print(expr_str + ' = ' + str(parse(expr_str).eval()))
===
T Symbol
   String id
   Int lbp
   Int nud_bp
   Int led_bp
   (ASTNode -> ASTNode) nud
   ((ASTNode, ASTNode) -> ASTNode) led

   F set_nud_bp(nud_bp, nud)
      .nud_bp = nud_bp
      .nud = nud

   F set_led_bp(led_bp, led)
      .led_bp = led_bp
      .led = led

T ASTNode
   Symbol& symbol
   Int value
   ASTNode? first_child
   ASTNode? second_child

   F eval()
      S .symbol.id
         ‘(number)’
            R .value
         ‘+’
            R .first_child.eval() + .second_child.eval()
         ‘-’
            R I .second_child == N {-.first_child.eval()} E .first_child.eval() - .second_child.eval()
         ‘*’
            R .first_child.eval() * .second_child.eval()
         ‘/’
            R .first_child.eval() / .second_child.eval()
         ‘(’
            R .first_child.eval()
         E
            assert(0B)
            R 0

[String = Symbol] symbol_table
[String] tokens
V tokeni = -1
ASTNode token_node

F advance(sid = ‘’)
   I sid != ‘’
      assert(:token_node.symbol.id == sid)
   :tokeni++
   :token_node = ASTNode()
   I :tokeni == :tokens.len
      :token_node.symbol = :symbol_table[‘(end)’]
      R
   V token = :tokens[:tokeni]
   :token_node.symbol = :symbol_table[I token.is_digit() {‘(number)’} E token]
   I token.is_digit()
      :token_node.value = Int(token)

F expression(rbp = 0)
   ASTNode t = move(:token_node)
   advance()
   V left = t.symbol.nud(move(t))
   L rbp < :token_node.symbol.lbp
      t = move(:token_node)
      advance()
      left = t.symbol.led(t, move(left))
   R left

F parse(expr_str) -> ASTNode
   :tokens = re:‘\s*(\d+|.)’.find_strings(expr_str)
   :tokeni = -1
   advance()
   R expression()

F symbol(id, bp = 0) -> &
   I !(id C :symbol_table)
      V s = Symbol()
      s.id = id
      s.lbp = bp
      :symbol_table[id] = s
   R :symbol_table[id]

F infix(id, bp)
   F led(ASTNode self, ASTNode left)
      self.first_child = left
      self.second_child = expression(self.symbol.led_bp)
      R self
   symbol(id, bp).set_led_bp(bp, led)

F prefix(id, bp)
   F nud(ASTNode self)
      self.first_child = expression(self.symbol.nud_bp)
      R self
   symbol(id).set_nud_bp(bp, nud)

infix(‘+’, 1)
infix(‘-’, 1)
infix(‘*’, 2)
infix(‘/’, 2)
prefix(‘-’, 3)

F nud(ASTNode self)
   R self
symbol(‘(number)’).nud = nud
symbol(‘(end)’)

F nud_parens(ASTNode self)
   V expr = expression()
   advance(‘)’)
   R expr
symbol(‘(’).nud = nud_parens
symbol(‘)’)

L(expr_str) [‘-2 / 2 + 4 + 3 * 2’, ‘2 * (3 + (4 * 5 + (6 * 7) * 8) - 9) * 10’]
   print(expr_str‘ = ’String(parse(expr_str).eval()))
===
class ASTNode;

class Symbol
{
public:
    String id;
    int lbp;
    int nud_bp;
    int led_bp;
    std::function<std::unique_ptr<ASTNode>(std::unique_ptr<ASTNode>)> nud;
    std::function<std::unique_ptr<ASTNode>(std::unique_ptr<ASTNode>, std::unique_ptr<ASTNode>)> led;

    template <typename T1, typename T2> auto set_nud_bp(const T1 &nud_bp, const T2 &nud)
    {
        this->nud_bp = nud_bp;
        this->nud = nud;
    }

    template <typename T1, typename T2> auto set_led_bp(const T1 &led_bp, const T2 &led)
    {
        this->led_bp = led_bp;
        this->led = led;
    }
};

class ASTNode
{
public:
    Symbol *symbol;
    int value;
    std::unique_ptr<ASTNode> first_child;
    std::unique_ptr<ASTNode> second_child;

    auto eval()
    {
        if (symbol->id == u"(number)"_S)
            return value;
        else if (symbol->id == u'+')
            return first_child->eval() + second_child->eval();
        else if (symbol->id == u'-')
            return second_child == nullptr ? -first_child->eval() : first_child->eval() - second_child->eval();
        else if (symbol->id == u'*')
            return first_child->eval() * second_child->eval();
        else if (symbol->id == u'/')
            return first_child->eval() / second_child->eval();
        else if (symbol->id == u'(')
            return first_child->eval();
        else {
            assert(false);
            return 0;
        }
    }
};

Dict<String, Symbol> symbol_table;
Array<String> tokens;
auto tokeni = -1;
std::unique_ptr<ASTNode> token_node;

template <typename T1 = decltype(u""_S)> auto advance(const T1 &sid = u""_S)
{
    if (sid != u"")
        assert(::token_node->symbol->id == sid);
    ::tokeni++;
    ::token_node = std::make_unique<ASTNode>();
    if (::tokeni == ::tokens.len()) {
        ::token_node->symbol = &::symbol_table[u"(end)"_S];
        return;
    }
    auto token = ::tokens[::tokeni];
    ::token_node->symbol = &::symbol_table[token.is_digit() ? u"(number)"_S : token];
    if (token.is_digit())
        ::token_node->value = to_int(token);
}

template <typename T1 = decltype(0)> auto expression(const T1 &rbp = 0)
{
    std::unique_ptr<ASTNode> t = std::move(::token_node);
    advance();
    auto left = t->symbol->nud(std::move(t));
    while (rbp < ::token_node->symbol->lbp) {
        t = std::move(::token_node);
        advance();
        left = t->symbol->led(std::move(t), std::move(left));
    }
    return left;
}

template <typename T1> std::unique_ptr<ASTNode> parse(const T1 &expr_str)
{
    ::tokens = re::_(uR"(\s*(\d+|.))"_S).find_strings(expr_str);
    ::tokeni = -1;
    advance();
    return expression();
}

template <typename T1, typename T2 = decltype(0)> auto& symbol(const T1 &id, const T2 &bp = 0)
{
    if (!(in(id, ::symbol_table))) {
        auto s = Symbol();
        s.id = id;
        s.lbp = bp;
        ::symbol_table.set(id, s);
    }
    return ::symbol_table[id];
}

template <typename T1, typename T2> auto infix(const T1 &id, const T2 &bp)
{
    auto led = [](std::unique_ptr<ASTNode> self, std::unique_ptr<ASTNode> left)
    {
        self->first_child = std::move(left);
        self->second_child = expression(self->symbol->led_bp);
        return std::move(self);
    };
    symbol(id, bp).set_led_bp(bp, led);
}

template <typename T1, typename T2> auto prefix(const T1 &id, const T2 &bp)
{
    auto nud = [](std::unique_ptr<ASTNode> self)
    {
        self->first_child = expression(self->symbol->nud_bp);
        return std::move(self);
    };
    symbol(id).set_nud_bp(bp, nud);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        infix(u"+"_S, 1);
        infix(u"-"_S, 1);
        infix(u"*"_S, 2);
        infix(u"/"_S, 2);
        prefix(u"-"_S, 3);
    }
} code_block_1;

auto nud(std::unique_ptr<ASTNode> self)
{
    return std::move(self);
}

struct CodeBlock2
{
    CodeBlock2()
    {
        symbol(u"(number)"_S).nud = nud;
        symbol(u"(end)"_S);
    }
} code_block_2;

auto nud_parens(std::unique_ptr<ASTNode> self)
{
    auto expr = expression();
    advance(u")"_S);
    return expr;
}

struct CodeBlock3
{
    CodeBlock3()
    {
        symbol(u"("_S).nud = nud_parens;
        symbol(u")"_S);

        for (auto &&expr_str : create_array({u"-2 / 2 + 4 + 3 * 2"_S, u"2 * (3 + (4 * 5 + (6 * 7) * 8) - 9) * 10"_S}))
            print(expr_str & u" = "_S & String(parse(expr_str)->eval()));
    }
} code_block_3;


# https://www.rosettacode.org/wiki/Associative_array/Iteration#Python
d = {'key1': 'value1', 'key2': 'value2'}

for key, value in d.items():
    print(key + ' = ' + value)

for key in d.keys():
    print(key)

for value in d.values():
    print(value)
===
V d = [‘key1’ = ‘value1’, ‘key2’ = ‘value2’]

L(key, value) d
   print(key‘ = ’value)

L(key) d.keys()
   print(key)

L(value) d.values()
   print(value)
===
auto d = create_dict(dict_of(u"key1"_S, u"value1"_S)(u"key2"_S, u"value2"_S));

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&[key, value] : d)
            print(key & u" = "_S & value);

        for (auto &&key : d.keys())
            print(key);

        for (auto &&value : d.values())
            print(value);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Averages/Arithmetic_mean#Python
def average(x):
    return sum(x)/float(len(x))# if x else 0
print (average([0,0,3,1,4,1,5,9,0,0]))
===
F average(x)
   R sum(x) / Float(x.len)
print(average([0, 0, 3, 1, 4, 1, 5, 9, 0, 0]))
===
template <typename T1> auto average(const T1 &x)
{
    return sum(x) / to_float(x.len());
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(average(create_array({0, 0, 3, 1, 4, 1, 5, 9, 0, 0})));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Averages/Mean_angle#C.23
import math

def mean_angle(angles):
    x = sum(math.cos(math.radians(a)) for a in angles) / len(angles)
    y = sum(math.sin(math.radians(a)) for a in angles) / len(angles)
    return math.degrees(math.atan2(y, x))

print(mean_angle([350, 10]))
print(mean_angle([90, 180, 270, 360]))
print(mean_angle([10, 20, 30]))
===
F mean_angle(angles)
   V x = sum(angles.map(a -> cos(radians(a)))) / angles.len
   V y = sum(angles.map(a -> sin(radians(a)))) / angles.len
   R degrees(atan2(y, x))

print(mean_angle([350, 10]))
print(mean_angle([90, 180, 270, 360]))
print(mean_angle([10, 20, 30]))
===
template <typename T1> auto mean_angle(const T1 &angles)
{
    auto x = sum_map(angles, [](const auto &a){return cos(radians(a));}) / angles.len();
    auto y = sum_map(angles, [](const auto &a){return sin(radians(a));}) / angles.len();
    return degrees(atan2(y, x));
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(mean_angle(create_array({350, 10})));
        print(mean_angle(create_array({90, 180, 270, 360})));
        print(mean_angle(create_array({10, 20, 30})));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Averages/Mean_time_of_day#Python
import math

def mean_angle(angles):
    x = sum(math.cos(math.radians(a)) for a in angles) / len(angles)
    y = sum(math.sin(math.radians(a)) for a in angles) / len(angles)
    return math.degrees(math.atan2(y, x))

def mean_time(times):
    t = (time.split(':') for time in times)
    seconds = ((float(hms[2]) + int(hms[1]) * 60 + int(hms[0]) * 3600)
               for hms in t)
    day = 24 * 60 * 60
    to_angles = [s * 360.0 / day for s in seconds]
    mean_as_angle = mean_angle(to_angles)
    mean_seconds = round(mean_as_angle * day / 360.0)
    if mean_seconds < 0:
        mean_seconds += day
    h = mean_seconds // 3600
    m = mean_seconds % 3600
    s = m % 60
    m = m // 60
    #return str(h).zfill(2)+':'+str(m).zfill(2)+':'+str(s).zfill(2)
    return '%02d:%02d:%02d' % (h, m, s)

print(mean_time(['23:00:17', '23:40:20', '00:12:45', '00:17:19']))
===
F mean_angle(angles)
   V x = sum(angles.map(a -> cos(radians(a)))) / angles.len
   V y = sum(angles.map(a -> sin(radians(a)))) / angles.len
   R degrees(atan2(y, x))

F mean_time(times)
   V t = (times.map(time -> time.split(‘:’)))
   V seconds = (t.map(hms -> (Float(hms[2]) + Int(hms[1]) * 60 + Int(hms[0]) * 3600)))
   V day = 24 * 60 * 60
   V to_angles = seconds.map(s -> s * 360.0 / @day)
   V mean_as_angle = mean_angle(to_angles)
   V mean_seconds = round(mean_as_angle * day / 360.0)
   I mean_seconds < 0
      mean_seconds += day
   V h = mean_seconds I/ 3600
   V m = mean_seconds % 3600
   V s = m % 60
   m = m I/ 60
   R ‘#02:#02:#02’.format(h, m, s)

print(mean_time([‘23:00:17’, ‘23:40:20’, ‘00:12:45’, ‘00:17:19’]))
===
template <typename T1> auto mean_angle(const T1 &angles)
{
    auto x = sum_map(angles, [](const auto &a){return cos(radians(a));}) / angles.len();
    auto y = sum_map(angles, [](const auto &a){return sin(radians(a));}) / angles.len();
    return degrees(atan2(y, x));
}

template <typename T1> auto mean_time(const T1 &times)
{
    auto t = (times.map([](const auto &time){return time.split(u":"_S);}));
    auto seconds = (t.map([](const auto &hms){return (to_float(_get<2>(hms)) + to_int(_get<1>(hms)) * 60 + to_int(_get<0>(hms)) * 3600);}));
    auto day = 24 * 60 * 60;
    auto to_angles = seconds.map([&day](const auto &s){return s * 360.0 / day;});
    auto mean_as_angle = mean_angle(to_angles);
    auto mean_seconds = round(mean_as_angle * day / 360.0);
    if (mean_seconds < 0)
        mean_seconds += day;
    auto h = idiv(mean_seconds, 3600);
    auto m = mod(mean_seconds, 3600);
    auto s = mod(m, 60);
    m = idiv(m, 60);
    return u"#02:#02:#02"_S.format(h, m, s);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(mean_time(create_array({u"23:00:17"_S, u"23:40:20"_S, u"00:12:45"_S, u"00:17:19"_S})));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Averages/Median#Python
def median(aray):
    srtd = sorted(aray)
    alen = len(srtd)
    return 0.5*(srtd[(alen-1)//2] + srtd[alen//2])

print(median([4.1, 5.6, 7.2, 1.7, 9.3, 4.4, 3.2]))
print(median([4.1, 7.2, 1.7, 9.3, 4.4, 3.2]))
===
F median(aray)
   V srtd = sorted(aray)
   V alen = srtd.len
   R 0.5 * (srtd[(alen - 1) I/ 2] + srtd[alen I/ 2])

print(median([4.1, 5.6, 7.2, 1.7, 9.3, 4.4, 3.2]))
print(median([4.1, 7.2, 1.7, 9.3, 4.4, 3.2]))
===
template <typename T1> auto median(const T1 &aray)
{
    auto srtd = sorted(aray);
    auto alen = srtd.len();
    return 0.5 * (srtd[idiv((alen - 1), 2)] + srtd[idiv(alen, 2)]);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(median(create_array({4.1, 5.6, 7.2, 1.7, 9.3, 4.4, 3.2})));
        print(median(create_array({4.1, 7.2, 1.7, 9.3, 4.4, 3.2})));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Averages/Mode#Python
import collections

def modes(values):
    count = collections.defaultdict(int) # int
    for v in values:
        count[v] += 1
    best = max(count.values())
    return [kv[0] for kv in count.items() if kv[1] == best]

print(modes([1,3,6,6,6,6,7,7,12,12,17]))
print(modes([1,1,2,4,4]))
===
F modes(values)
   V count = DefaultDict[Int, Int]()
   L(v) values
      count[v]++
   V best = max(count.values())
   R count.filter(kv -> kv[1] == @best).map(kv -> kv[0])

print(modes([1, 3, 6, 6, 6, 6, 7, 7, 12, 12, 17]))
print(modes([1, 1, 2, 4, 4]))
===
template <typename T1> auto modes(const T1 &values)
{
    auto count = DefaultDict<int, int>();
    for (auto &&v : values)
        count[v]++;
    auto best = max(count.values());
    return count.filter([&best](const auto &kv){return _get<1>(kv) == best;}).map([](const auto &kv){return _get<0>(kv);});
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(modes(create_array({1, 3, 6, 6, 6, 6, 7, 7, 12, 12, 17})));
        print(modes(create_array({1, 1, 2, 4, 4})));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Averages/Root_mean_square#Python
import math

def qmean(num):
    return math.sqrt(sum(n*n for n in num)/float(len(num)))

print(qmean(range(1,11)))
===
F qmean(num)
   R sqrt(sum(num.map(n -> n * n)) / Float(num.len))

print(qmean(1..10))
===
template <typename T1> auto qmean(const T1 &num)
{
    return sqrt(sum_map(num, [](const auto &n){return n * n;}) / to_float(num.len()));
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(qmean(range_ee(1, 10)));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Averages/Simple_moving_average#D
from typing import List

class SMA:
    data : List[float]
    sum = 0.0
    index = 0
    n_filled = 0
    period : int # Why not `period = 0`? Because `Int period` means that `period` must be initialized in constructor.

    def __init__(self, period):
        self.period = period
        self.data = [0.0] * period

    def add(self, v):
        self.sum += v - self.data[self.index]
        self.data[self.index] = v
        self.index = (self.index + 1) % self.period
        self.n_filled = min(self.period, self.n_filled + 1)
        return self.sum / self.n_filled

sma3 = SMA(3)
sma5 = SMA(5)

for e in [1, 2, 3, 4, 5, 5, 4, 3, 2, 1]:
    print('Added %d, sma(3) = %f, sma(5) = %f' % (e, sma3.add(e), sma5.add(e)))
===
T SMA
   [Float] data
   sum = 0.0
   index = 0
   n_filled = 0
   Int period

   F (period)
      .period = period
      .data = [0.0] * period

   F add(v)
      .sum += v - .data[.index]
      .data[.index] = v
      .index = (.index + 1) % .period
      .n_filled = min(.period, .n_filled + 1)
      R .sum / .n_filled

V sma3 = SMA(3)
V sma5 = SMA(5)

L(e) [1, 2, 3, 4, 5, 5, 4, 3, 2, 1]
   print(‘Added #., sma(3) = #.6, sma(5) = #.6’.format(e, sma3.add(e), sma5.add(e)))
===
class SMA
{
public:
    Array<double> data;
    decltype(0.0) sum = 0.0;
    decltype(0) index = 0;
    decltype(0) n_filled = 0;
    int period;

    template <typename T1> SMA(const T1 &period) :
        period(period)
    {
        data = create_array({0.0}) * period;
    }

    template <typename T1> auto add(const T1 &v)
    {
        sum += v - data[index];
        data.set(index, v);
        index = mod((index + 1), period);
        n_filled = min(period, n_filled + 1);
        return sum / n_filled;
    }
};

auto sma3 = SMA(3);
auto sma5 = SMA(5);

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&e : create_array({1, 2, 3, 4, 5, 5, 4, 3, 2, 1}))
            print(u"Added #., sma(3) = #.6, sma(5) = #.6"_S.format(e, sma3.add(e), sma5.add(e)));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Balanced_brackets#Python
import random

def gen(n):
    txt = ['[', ']'] * n
    random.shuffle(txt)
    return ''.join(txt)

def is_balanced(s):
    nesting_level = 0
    for c in s:
        if c == '[':
            nesting_level += 1
        elif c == ']':
            nesting_level -= 1
            if nesting_level < 0:
                return False
    return True

for n in range(10):
    s = gen(n)
    print(s + ' '*(20-len(s)) + 'is ' + ('balanced' if is_balanced(s) else 'not balanced'))
===
F gen(n)
   V txt = [‘[’, ‘]’] * n
   random:shuffle(&txt)
   R txt.join(‘’)

F is_balanced(s)
   V nesting_level = 0
   L(c) s
      I c == ‘[’
         nesting_level++
      E I c == ‘]’
         nesting_level--
         I nesting_level < 0
            R 0B
   R 1B

L(n) 10
   V s = gen(n)
   print(s‘’(‘ ’ * (20 - s.len))‘is ’(I is_balanced(s) {‘balanced’} E ‘not balanced’))
===
template <typename T1> auto gen(const T1 &n)
{
    auto txt = create_array({u'['_C, u']'_C}) * n;
    randomns::shuffle(txt);
    return txt.join(u""_S);
}

template <typename T1> auto is_balanced(const T1 &s)
{
    auto nesting_level = 0;
    for (auto &&c : s)
        if (c == u'[')
            nesting_level++;
        else if (c == u']') {
            nesting_level--;
            if (nesting_level < 0)
                return false;
        }
    return true;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (int n = 0; n < 10; n++) {
            auto s = gen(n);
            print(s & (u" "_S * (20 - s.len())) & u"is "_S & (is_balanced(s) ? u"balanced"_S : u"not balanced"_S));
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Benford%27s_law#D
import math

def get_fibs():
    a = 1.0
    b = 1.0
    r : List[float] = []
    for i in range(1000):
        r.append(a)
        (a, b) = (b, a + b)
    return r

def benford(seq):
    freqs = [(0.0, 0.0)] * 9
    seq_len = 0
    for d in seq:
        if d != 0:
            i = ord(str(d)[0]) - ord('1')
            freqs[i] = (freqs[i][0], freqs[i][1] + 1)
            seq_len += 1

    for i in range(len(freqs)):
        freqs[i] = (math.log10(1.0 + 1.0 / (i + 1)), freqs[i][1] / seq_len)

    return freqs

print('%9s %9s %9s' % ('Actual', 'Expected', 'Deviation'))
for i, p in enumerate(benford(get_fibs())):
    print('%d: %5.2f%% | %5.2f%% | %5.4f%%' % (i+1, p[1] * 100, p[0] * 100, abs(p[1] - p[0]) * 100))
===
F get_fibs()
   V a = 1.0
   V b = 1.0
   [Float] r
   L(i) 1000
      r.append(a)
      (a, b) = (b, a + b)
   R r

F benford(seq)
   V freqs = [(0.0, 0.0)] * 9
   V seq_len = 0
   L(d) seq
      I d != 0
         V i = String(d)[0].code - ‘1’.code
         freqs[i] = (freqs[i][0], freqs[i][1] + 1)
         seq_len++

   L(i) 0 .< freqs.len
      freqs[i] = (log10(1.0 + 1.0 / (i + 1)), freqs[i][1] / seq_len)

   R freqs

print(‘#9 #9 #9’.format(‘Actual’, ‘Expected’, ‘Deviation’))
L(p) benford(get_fibs())
   V i = L.index
   print(‘#.: #2.2% | #2.2% | #.4%’.format(i + 1, p[1] * 100, p[0] * 100, abs(p[1] - p[0]) * 100))
===
auto get_fibs()
{
    auto a = 1.0;
    auto b = 1.0;
    Array<double> r;
    for (int i = 0; i < 1000; i++) {
        r.append(a);
        assign_from_tuple(a, b, make_tuple(b, a + b));
    }
    return r;
}

template <typename T1> auto benford(const T1 &seq)
{
    auto freqs = create_array({make_tuple(0.0, 0.0)}) * 9;
    auto seq_len = 0;
    for (auto &&d : seq)
        if (d != 0) {
            auto i = _get<0>(String(d)).code - u'1'_C.code;
            freqs.set(i, make_tuple(_get<0>(freqs[i]), _get<1>(freqs[i]) + 1));
            seq_len++;
        }

    for (auto i : range_el(0, freqs.len()))
        freqs.set(i, make_tuple(log10(1.0 + 1.0 / (i + 1)), _get<1>(freqs[i]) / seq_len));

    return freqs;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"#9 #9 #9"_S.format(u"Actual"_S, u"Expected"_S, u"Deviation"_S));
        {int Lindex = 0;
        for (auto &&p : benford(get_fibs())) {
            auto i = Lindex;
            print(u"#.: #2.2% | #2.2% | #.4%"_S.format(i + 1, _get<1>(p) * 100, _get<0>(p) * 100, abs(_get<1>(p) - _get<0>(p)) * 100));
            Lindex++;
        }}
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Box_the_compass#Python
majors   = 'north east south west'.split(' ')
majors   *= 2 # no need for modulo later
quarter1 = 'N,N by E,N-NE,NE by N,NE,NE by E,E-NE,E by N'.split(',')
quarter2 = [p.replace('NE','EN') for p in quarter1]

def degrees2compasspoint(d):
    d = (d % 360) + 360/64
    majorindex = int(d / 90)
    minorindex  = int( (d % 90 *4) // 45 )
    p1 = majors[majorindex]
    p2 = majors[majorindex+1]
    q : List[str]
    if p1 in ('north', 'south'):
        q = quarter1
    else:
        q = quarter2
    return q[minorindex].replace('N', p1).replace('E', p2).capitalize()

if __name__ == '__main__':
    for i in range(33):
        d = i * 11.25
        m = i % 3
        if   m == 1: d += 5.62
        elif m == 2: d -= 5.62
        n = i % 32 + 1
        print( '%2i %-18s %7.2f°' % (n, degrees2compasspoint(d), d) )
===
V majors = ‘north east south west’.split(‘ ’)
majors *= 2
V quarter1 = ‘N,N by E,N-NE,NE by N,NE,NE by E,E-NE,E by N’.split(‘,’)
V quarter2 = quarter1.map(p -> p.replace(‘NE’, ‘EN’))

F degrees2compasspoint(=d)
   d = (d % 360) + 360 / 64
   V majorindex = Int(d / 90)
   V minorindex = Int((d % 90 * 4) I/ 45)
   V p1 = :majors[majorindex]
   V p2 = :majors[majorindex + 1]
   [String] q
   I p1 C (‘north’, ‘south’)
      q = :quarter1
   E
      q = :quarter2
   R q[minorindex].replace(‘N’, p1).replace(‘E’, p2).capitalize()

:start:
L(i) 33
   V d = i * 11.25
   S i % 3
      1
         d += 5.62
      2
         d -= 5.62
   V n = i % 32 + 1
   print(‘#2 #<18 #4.2°’.format(n, degrees2compasspoint(d), d))
===
auto majors = u"north east south west"_S.split(u" "_S);

struct CodeBlock1
{
    CodeBlock1()
    {
        majors *= 2;
    }
} code_block_1;

auto quarter1 = u"N,N by E,N-NE,NE by N,NE,NE by E,E-NE,E by N"_S.split(u","_S);
auto quarter2 = quarter1.map([](const auto &p){return p.replace(u"NE"_S, u"EN"_S);});

template <typename T1> auto degrees2compasspoint(T1 d)
{
    d = (mod(d, 360)) + 360.0 / 64;
    auto majorindex = to_int(d / 90.0);
    auto minorindex = to_int(idiv((mod(d, 90) * 4), 45));
    auto p1 = ::majors[majorindex];
    auto p2 = ::majors[majorindex + 1];
    Array<String> q;
    if (in(p1, make_tuple(u"north"_S, u"south"_S)))
        q = ::quarter1;
    else
        q = ::quarter2;
    return q[minorindex].replace(u"N"_S, p1).replace(u"E"_S, p2).capitalize();
}

int main()
{
    for (int i = 0; i < 33; i++) {
        auto d = i * 11.25;
        switch (mod(i, 3))
        {
        case 1:
            d += 5.62;
            break;
        case 2:
            d -= 5.62;
            break;
        }
        auto n = mod(i, 32) + 1;
        print(u"#2 #<18 #4.2°"_S.format(n, degrees2compasspoint(d), d));
    }
}


# https://www.rosettacode.org/wiki/Brace_expansion#Python
def getitem(s, depth = 0):
    out = ['']
    while s != '':
        c = str(s[0])
        if depth and (c == ',' or c == '}'):
            return (out, s)
        if c == '{':
            global getgroup # to suppress error 'undefined identifier' in `x = getgroup(s[1:], depth+1)`
            x = getgroup(s[1:], depth+1) #                                     ^^^^^^^^
            if len(x[0]):
                #nout : List[str] = []
                #for a in out:
                #    for b in x[0]:
                #        nout.append(a + '' + b)
                #out = nout
                out = [a + '' + b for a in out for b in x[0]]
                s = x[1]
                continue
        if c == '\\' and len(s) > 1:
            (s, c) = (s[1:], c + s[1])

        out = [a+c for a in out]
        s = s[1:]

    return (out, s)

def getgroup(s, depth):
    out : List[str] = []
    comma = False
    while s != '':
        gs = getitem(s, depth)
        s = gs[1]
        if s == '': break
        out += gs[0]

        if s[0] == '}':
            if comma: return (out, s[1:])
            return (['{' + a + '}' for a in out], s[1:])

        if s[0] == ',':
            (comma, s) = (True, s[1:])

    return (['']*0, '')

# stolen cowbells from perl6 example
for s in R'''~/{Downloads,Pictures}/*.{jpg,gif,png}
It{{em,alic}iz,erat}e{d,}, please.
{,{,gotta have{ ,\, again\, }}more }cowbell!
{}} some }{,{\\{ edge, edge} \,}{ cases, {here} \\\\\}'''.split('\n'):
    print("\n\t".join([s] + getitem(s)[0]) + "\n")
===
F getitem(=s, depth = 0)
   V out = [‘’]
   L s != ‘’
      V c = String(s[0])
      I depth & (c == ‘,’ | c == ‘}’)
         R (out, s)
      I c == ‘{’
         V x = getgroup(s[1..], depth + 1)
         I !x[0].empty
            out = multiloop(out, x[0], (a, b) -> a‘’b)
            s = x[1]
            L.continue
      I c == ‘\’ & s.len > 1
         (s, c) = (s[1..], c‘’s[1])

      out = out.map(a -> a‘’@c)
      s = s[1..]

   R (out, s)

F getgroup(=s, depth)
   [String] out
   V comma = 0B
   L s != ‘’
      V gs = getitem(s, depth)
      s = gs[1]
      I s == ‘’
         L.break
      out [+]= gs[0]

      I s[0] == ‘}’
         I comma
            R (out, s[1..])
         R (out.map(a -> ‘{’a‘}’), s[1..])

      I s[0] == ‘,’
         (comma, s) = (1B, s[1..])

   R ([‘’] * 0, ‘’)

L(s) ‘~/{Downloads,Pictures}/*.{jpg,gif,png}
It{{em,alic}iz,erat}e{d,}, please.
{,{,gotta have{ ,\, again\, }}more }cowbell!
{}} some }{,{\\{ edge, edge} \,}{ cases, {here} \\\\\}’.split("\n")
   print(([s] [+] getitem(s)[0]).join("\n\t")"\n")
===
template <typename T1, typename T2 = decltype(0)> auto getitem(T1 s, const T2 &depth = 0)
{
    auto out = create_array({u""_S});
    while (s != u"") {
        auto c = String(_get<0>(s));
        if (depth && (c == u',' || c == u'}'))
            return make_tuple(out, s);
        if (c == u'{') {
            auto x = getgroup(s[range_ei(1)], depth + 1);
            if (!_get<0>(x).empty()) {
                out = multiloop(out, _get<0>(x), [](const auto &a, const auto &b){return a & b;});
                s = _get<1>(x);
                continue;
            }
        }
        if (c == u'\\' && s.len() > 1)
            assign_from_tuple(s, c, make_tuple(s[range_ei(1)], c & _get<1>(s)));

        out = out.map([&c](const auto &a){return a & c;});
        s = s[range_ei(1)];
    }

    return make_tuple(out, s);
}

template <typename T1, typename T2> auto getgroup(T1 s, const T2 &depth)
{
    Array<String> out;
    auto comma = false;
    while (s != u"") {
        auto gs = getitem(s, depth);
        s = _get<1>(gs);
        if (s == u"")
            break;
        out.append(_get<0>(gs));

        if (_get<0>(s) == u'}') {
            if (comma)
                return make_tuple(out, s[range_ei(1)]);
            return make_tuple(out.map([](const auto &a){return u"{"_S & a & u"}"_S;}), s[range_ei(1)]);
        }

        if (_get<0>(s) == u',')
            assign_from_tuple(comma, s, make_tuple(true, s[range_ei(1)]));
    }

    return make_tuple(create_array({u""_S}) * 0, u""_S);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&s : uR"(~/{Downloads,Pictures}/*.{jpg,gif,png}
It{{em,alic}iz,erat}e{d,}, please.
{,{,gotta have{ ,\, again\, }}more }cowbell!
{}} some }{,{\\{ edge, edge} \,}{ cases, {here} \\\\\})"_S.split(u"\n"_S))
            print((create_array({s}) + _get<0>(getitem(s))).join(u"\n\t"_S) & u"\n"_S);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Calculating_the_value_of_e#Python
import math
#Implementation of Brother's formula
e0 = 0.0
e = 2.0
n = 0
fact = 1
while(e-e0 > 1e-15):
    e0 = e
    n += 1
    fact *= 2*n*(2*n+1)
    e += (2.0*n+2)/fact

print("Computed e = "+str(e))
print("Real e = "+str(math.e))
print("Error = "+str(math.e-e))
print("Number of iterations = "+str(n))
===
V e0 = 0.0
V e = 2.0
V n = 0
V fact = 1
L (e - e0 > 1e-15)
   e0 = e
   n++
   fact *= 2 * n * (2 * n + 1)
   e += (2.0 * n + 2) / fact

print(‘Computed e = ’String(e))
print(‘Real e = ’String(math:e))
print(‘Error = ’String(math:e - e))
print(‘Number of iterations = ’String(n))
===
auto e0 = 0.0;
auto e = 2.0;
auto n = 0;
auto fact = 1;

struct CodeBlock1
{
    CodeBlock1()
    {
        while ((e - e0 > 1e-15)) {
            e0 = e;
            n++;
            fact *= 2 * n * (2 * n + 1);
            e += (2.0 * n + 2) / fact;
        }

        print(u"Computed e = "_S & String(e));
        print(u"Real e = "_S & String(math::e));
        print(u"Error = "_S & String(math::e - e));
        print(u"Number of iterations = "_S & String(n));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Cantor_set#Python
WIDTH = 81
HEIGHT = 5

def cantor(start, len, index):
    global lines
    seg = len // 3
    if seg == 0:
        return
    for it in range(HEIGHT-index):
        i = index + it
        for jt in range(seg):
            j = start + seg + jt
            pos = i * WIDTH + j
            lines[pos] = ' '
    cantor(start,           seg, index + 1)
    cantor(start + seg * 2, seg, index + 1)

lines = ['*'] * (WIDTH*HEIGHT)
cantor(0, WIDTH, 1)

for i in range(HEIGHT):
    beg = WIDTH * i
    print(''.join(lines[beg : beg+WIDTH]))
===
V WIDTH = 81
V HEIGHT = 5

F cantor(start, len, index)
   V seg = len I/ 3
   I seg == 0
      R
   L(it) 0 .< :HEIGHT - index
      V i = index + it
      L(jt) 0 .< seg
         V j = start + seg + jt
         V pos = i * :WIDTH + j
         :lines[pos] = ‘ ’
   cantor(start, seg, index + 1)
   cantor(start + seg * 2, seg, index + 1)

V lines = [‘*’] * (WIDTH * HEIGHT)
cantor(0, WIDTH, 1)

L(i) 0 .< HEIGHT
   V beg = WIDTH * i
   print((lines[beg .< beg + WIDTH]).join(‘’))
===
auto WIDTH = 81;
auto HEIGHT = 5;

template <typename T1, typename T2, typename T3> auto cantor(const T1 &start, const T2 &len, const T3 &index)
{
    auto seg = idiv(len, 3);
    if (seg == 0)
        return;
    for (auto it : range_el(0, ::HEIGHT - index)) {
        auto i = index + it;
        for (auto jt : range_el(0, seg)) {
            auto j = start + seg + jt;
            auto pos = i * ::WIDTH + j;
            ::lines.set(pos, u' '_C);
        }
    }
    cantor(start, seg, index + 1);
    cantor(start + seg * 2, seg, index + 1);
}

auto lines = create_array({u'*'_C}) * (WIDTH * HEIGHT);

struct CodeBlock1
{
    CodeBlock1()
    {
        cantor(0, WIDTH, 1);

        for (auto i : range_el(0, HEIGHT)) {
            auto beg = WIDTH * i;
            print((lines[range_el(beg, beg + WIDTH)]).join(u""_S));
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Cartesian_product_of_two_or_more_lists#Go
from typing import List

def cart_prod(a, b):
    p = [(0, 0)] * (len(a) * len(b))
    i = 0
    for aa in a:
        for bb in b:
            p[i] = (aa, bb)
            i += 1
    return p

print(cart_prod([1, 2], [3, 4]))
print(cart_prod([3, 4], [1, 2]))
empty_array : List[int]
print(cart_prod([1, 2], empty_array))
print(cart_prod(empty_array, [1, 2]))
===
F cart_prod(a, b)
   V p = [(0, 0)] * (a.len * b.len)
   V i = 0
   L(aa) a
      L(bb) b
         p[i] = (aa, bb)
         i++
   R p

print(cart_prod([1, 2], [3, 4]))
print(cart_prod([3, 4], [1, 2]))
[Int] empty_array
print(cart_prod([1, 2], empty_array))
print(cart_prod(empty_array, [1, 2]))
===
template <typename T1, typename T2> auto cart_prod(const T1 &a, const T2 &b)
{
    auto p = create_array({make_tuple(0, 0)}) * (a.len() * b.len());
    auto i = 0;
    for (auto &&aa : a)
        for (auto &&bb : b) {
            p.set(i, make_tuple(aa, bb));
            i++;
        }
    return p;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(cart_prod(create_array({1, 2}), create_array({3, 4})));
        print(cart_prod(create_array({3, 4}), create_array({1, 2})));
    }
} code_block_1;

Array<int> empty_array;

struct CodeBlock2
{
    CodeBlock2()
    {
        print(cart_prod(create_array({1, 2}), empty_array));
        print(cart_prod(empty_array, create_array({1, 2})));
    }
} code_block_2;


def cart_prod(a, b):
    p : List[Tuple[int, int]] = []
    for i in a:
        for j in b:
            p += [(i, j)]
    return p
===
F cart_prod(a, b)
   [(Int, Int)] p
   L(i) a
      L(j) b
         p [+]= (i, j)
   R p
===
template <typename T1, typename T2> auto cart_prod(const T1 &a, const T2 &b)
{
    Array<ivec2> p;
    for (auto &&i : a)
        for (auto &&j : b)
            p.append(make_tuple(i, j));
    return p;
}


def cart_prod(a, b):
    return [(aa, bb) for aa in a for bb in b]
===
F cart_prod(a, b)
   R multiloop(a, b, (aa, bb) -> (aa, bb))
===
template <typename T1, typename T2> auto cart_prod(const T1 &a, const T2 &b)
{
    return multiloop(a, b, [](const auto &aa, const auto &bb){return make_tuple(aa, bb);});
}


# https://www.rosettacode.org/wiki/Catalan_numbers
c = 1
for n in range(1, 16):
    print(c)
    c = 2*(2*n - 1) * c // (n + 1)
===
V c = 1
L(n) 1..15
   print(c)
   c = 2 * (2 * n - 1) * c I/ (n + 1)
===
auto c = 1;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto n : range_ee(1, 15)) {
            print(c);
            c = idiv(2 * (2 * n - 1) * c, (n + 1));
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Catalan_numbers/Pascal%27s_triangle#Python
n = 15
t = [0] * (n + 2)
t[1] = 1
for i in range(1, n + 1):
    for j in range(i, 1, -1): t[j] += t[j - 1]
    t[i + 1] = t[i]
    for j in range(i + 1, 1, -1): t[j] += t[j - 1]
    print(t[i+1] - t[i], end=' ')
===
V n = 15
V t = [0] * (n + 2)
t[1] = 1
L(i) 1 .. n
   L(j) (i .< 1).step(-1)
      t[j] += t[j - 1]
   t[i + 1] = t[i]
   L(j) (i + 1 .< 1).step(-1)
      t[j] += t[j - 1]
   print(t[i + 1] - t[i], end' ‘ ’)
===
auto n = 15;
auto t = create_array({0}) * (n + 2);

struct CodeBlock1
{
    CodeBlock1()
    {
        _set<1>(t, 1);
        for (auto i : range_ee(1, n)) {
            for (auto j : range_el(i, 1).step(-1))
                t[j] += t[j - 1];
            t.set(i + 1, t[i]);
            for (auto j : range_el(i + 1, 1).step(-1))
                t[j] += t[j - 1];
            print(t[i + 1] - t[i], u" "_S);
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Catamorphism
from functools import reduce

print(reduce(lambda x, y: x + y, range(1, 4)))
print(reduce(lambda x, y: x + y, range(1, 4), 3))
print(reduce(lambda x, y: x + y, [1, 1, 3]))
print(reduce(lambda x, y: x + y, [1, 1, 3], 2))
===
print((1..3).reduce((x, y) -> x + y))
print((1..3).reduce(3, (x, y) -> x + y))
print([1, 1, 3].reduce((x, y) -> x + y))
print([1, 1, 3].reduce(2, (x, y) -> x + y))
===
struct CodeBlock1
{
    CodeBlock1()
    {
        print(range_ee(1, 3).reduce([](const auto &x, const auto &y){return x + y;}));
        print(range_ee(1, 3).reduce(3, [](const auto &x, const auto &y){return x + y;}));
        print(create_array({1, 1, 3}).reduce([](const auto &x, const auto &y){return x + y;}));
        print(create_array({1, 1, 3}).reduce(2, [](const auto &x, const auto &y){return x + y;}));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Character_codes#Python
print(ord('a')) # prints "97"
print(chr(97))  # prints "a"
===
print(‘a’.code)
print(Char(code' 97))
===
struct CodeBlock1
{
    CodeBlock1()
    {
        print(u'a'_C.code);
        print(Char(97));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Check_that_file_exists#Python
import os

os.path.isfile("input.txt")
os.path.isfile("/input.txt")
os.path.isdir("docs")
os.path.isdir("/docs")
===
fs:is_file(‘input.txt’)
fs:is_file(‘/input.txt’)
fs:is_dir(‘docs’)
fs:is_dir(‘/docs’)
===
struct CodeBlock1
{
    CodeBlock1()
    {
        fs::is_file(u"input.txt"_S);
        fs::is_file(u"/input.txt"_S);
        fs::is_dir(u"docs"_S);
        fs::is_dir(u"/docs"_S);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Chinese_remainder_theorem#Python
from functools import reduce

def mul_inv(a, b):
    b0 = b
    x0 = 0
    x1 = 1
    if b == 1: return 1
    while a > 1:
        q = a // b
        (a, b) = (b, a%b)
        (x0, x1) = (x1 - q * x0, x0)
    if x1 < 0: x1 += b0
    return x1

def chinese_remainder(n, a):
    sum = 0
    prod = reduce(lambda a, b: a*b, n)
    for n_i, a_i in zip(n, a):
        p = prod // n_i
        sum += a_i * mul_inv(p, n_i) * p
    return sum % prod

n = [3, 5, 7]
a = [2, 3, 2]
print(chinese_remainder(n, a))
===
F mul_inv(=a, =b)
   V b0 = b
   V x0 = 0
   V x1 = 1
   I b == 1
      R 1
   L a > 1
      V q = a I/ b
      (a, b) = (b, a % b)
      (x0, x1) = (x1 - q * x0, x0)
   I x1 < 0
      x1 += b0
   R x1

F chinese_remainder(n, a)
   V sum = 0
   V prod = n.reduce((a, b) -> a * b)
   L(n_i, a_i) zip(n, a)
      V p = prod I/ n_i
      sum += a_i * mul_inv(p, n_i) * p
   R sum % prod

V n = [3, 5, 7]
V a = [2, 3, 2]
print(chinese_remainder(n, a))
===
template <typename T1, typename T2> auto mul_inv(T1 a, T2 b)
{
    auto b0 = b;
    auto x0 = 0;
    auto x1 = 1;
    if (b == 1)
        return 1;
    while (a > 1) {
        auto q = idiv(a, b);
        assign_from_tuple(a, b, make_tuple(b, mod(a, b)));
        assign_from_tuple(x0, x1, make_tuple(x1 - q * x0, x0));
    }
    if (x1 < 0)
        x1 += b0;
    return x1;
}

template <typename T1, typename T2> auto chinese_remainder(const T1 &n, const T2 &a)
{
    auto sum = 0;
    auto prod = n.reduce([](const auto &a, const auto &b){return a * b;});
    for (auto &&[n_i, a_i] : zip(n, a)) {
        auto p = idiv(prod, n_i);
        sum += a_i * mul_inv(p, n_i) * p;
    }
    return mod(sum, prod);
}

auto n = create_array({3, 5, 7});
auto a = create_array({2, 3, 2});

struct CodeBlock1
{
    CodeBlock1()
    {
        print(chinese_remainder(n, a));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Compare_a_list_of_strings#D
for strings_s in ['AA AA AA AA', 'AA ACB BB CC']:
    strings = strings_s.split(' ')
    print(strings)
    print(all(a[0] == a[1] for a in zip(strings, strings[1:]))) # All equal
    print(all(a[0]  < a[1] for a in zip(strings, strings[1:]))) # Strictly ascending
    print()
===
L(strings_s) [‘AA AA AA AA’, ‘AA ACB BB CC’]
   V strings = strings_s.split(‘ ’)
   print(strings)
   print(all(zip(strings, strings[1..]).map(a -> a[0] == a[1])))
   print(all(zip(strings, strings[1..]).map(a -> a[0] < a[1])))
   print()
===
struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&strings_s : create_array({u"AA AA AA AA"_S, u"AA ACB BB CC"_S})) {
            auto strings = strings_s.split(u" "_S);
            print(strings);
            print(all_map(zip(strings, strings[range_ei(1)]), [](const auto &a){return _get<0>(a) == _get<1>(a);}));
            print(all_map(zip(strings, strings[range_ei(1)]), [](const auto &a){return _get<0>(a) < _get<1>(a);}));
            print();
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Continued_fraction#C
def calc(f_a, f_b, n = 1000):
    r = 0.0
    while n > 0:
        r = f_b(n) / (f_a(n) + r)
        n -= 1
    return f_a(0) + r

print(calc(lambda n: 2 if n > 0 else 1, lambda n: 1))
print(calc(lambda n: n if n > 0 else 2, lambda n: n - 1 if n > 1 else 1))
print(calc(lambda n: 6 if n > 0 else 3, lambda n: (2 * n - 1) ** 2))
===
F calc(f_a, f_b, =n = 1000)
   V r = 0.0
   L n > 0
      r = f_b(n) / (f_a(n) + r)
      n--
   R f_a(0) + r

print(calc(n -> I n > 0 {2} E 1, n -> 1))
print(calc(n -> I n > 0 {n} E 2, n -> I n > 1 {n - 1} E 1))
print(calc(n -> I n > 0 {6} E 3, n -> (2 * n - 1) ^ 2))
===
template <typename T1, typename T2, typename T3 = decltype(1000)> auto calc(const T1 &f_a, const T2 &f_b, T3 n = 1000)
{
    auto r = 0.0;
    while (n > 0) {
        r = f_b(n) / (f_a(n) + r);
        n--;
    }
    return f_a(0) + r;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(calc([](const auto &n){return n > 0 ? 2 : 1;}, [](const auto &n){return 1;}));
        print(calc([](const auto &n){return n > 0 ? n : 2;}, [](const auto &n){return n > 1 ? n - 1 : 1;}));
        print(calc([](const auto &n){return n > 0 ? 6 : 3;}, [](const auto &n){return square((2 * n - 1));}));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Convert_seconds_to_compound_duration#Julia
def duration(sec):
    t : List[int] = []
    for dm in [60, 60, 24, 7]:
        (sec, m) = (sec // dm, sec % dm)
        t.insert(0, m)
    t.insert(0, sec)
    return ', '.join(str(num_unit[0]) + ' ' + str(num_unit[1]) for num_unit in zip(t, ['wk', 'd', 'hr', 'min', 'sec']) if num_unit[0] > 0)

print(duration(7259))
print(duration(86400))
print(duration(6000000))
===
F duration(=sec)
   [Int] t
   L(dm) [60, 60, 24, 7]
      (sec, V m) = (sec I/ dm, sec % dm)
      t.insert(0, m)
   t.insert(0, sec)
   R zip(t, [‘wk’, ‘d’, ‘hr’, ‘min’, ‘sec’]).filter(num_unit -> num_unit[0] > 0).map(num_unit -> String(num_unit[0])‘ ’String(num_unit[1])).join(‘, ’)

print(duration(7259))
print(duration(86400))
print(duration(6000000))
===
template <typename T1> auto duration(T1 sec)
{
    Array<int> t;
    for (auto &&dm : create_array({60, 60, 24, 7})) {
        TUPLE_ELEMENT_T(1, make_tuple(idiv(sec, dm), mod(sec, dm))) m;
        assign_from_tuple(sec, m, make_tuple(idiv(sec, dm), mod(sec, dm)));
        t.insert(0, m);
    }
    t.insert(0, sec);
    return zip(t, create_array({u"wk"_S, u"d"_S, u"hr"_S, u"min"_S, u"sec"_S})).filter([](const auto &num_unit){return _get<0>(num_unit) > 0;}).map([](const auto &num_unit){return String(_get<0>(num_unit)) & u" "_S & String(_get<1>(num_unit));}).join(u", "_S);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(duration(7259));
        print(duration(86400));
        print(duration(6000000));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Conway%27s_Game_of_Life#Python
import collections

cellcountx = 6
cellcounty = 5
celltable = {
 (1, 2): 1,
 (1, 3): 1,
 (0, 3): 1,
}

universe = collections.defaultdict(int) # Tuple[int, int]
universe[(1, 1)] = 1
universe[(2, 1)] = 1
universe[(3, 1)] = 1
universe[(1, 4)] = 1
universe[(2, 4)] = 1
universe[(3, 4)] = 1

for i in range(4):
    print("\nGeneration " + str(i) + ':')
    for row in range(cellcounty):
        print('  ' + ''.join(['. ', 'O '][universe[(row, col)]] for col in range(cellcountx)))
    nextgeneration = collections.defaultdict(int) # Tuple[int, int]
    for row in range(cellcounty):
        for col in range(cellcountx):
            nextgeneration[(row, col)] = celltable.get(
                ( universe[(row, col)],
                 -universe[(row, col)] + sum(universe[(r, c)]
                                             for r in range(row-1, row+2)
                                             for c in range(col-1, col+2))
                ), 0)
    universe = nextgeneration
===
V cellcountx = 6
V cellcounty = 5
V celltable = [(1, 2) = 1, (1, 3) = 1, (0, 3) = 1]

V universe = DefaultDict[(Int, Int), Int]()
universe[(1, 1)] = 1
universe[(2, 1)] = 1
universe[(3, 1)] = 1
universe[(1, 4)] = 1
universe[(2, 4)] = 1
universe[(3, 4)] = 1

L(i) 4
   print("\nGeneration "String(i)‘:’)
   L(row) 0 .< cellcounty
      print(‘  ’(0 .< cellcountx).map(col -> [‘. ’, ‘O ’][:universe[(@row, col)]]).join(‘’))
   V nextgeneration = DefaultDict[(Int, Int), Int]()
   L(row) 0 .< cellcounty
      L(col) 0 .< cellcountx
         nextgeneration[(row, col)] = celltable.get((universe[(row, col)], -universe[(row, col)] + sum(multiloop((row - 1 .< row + 2), (col - 1 .< col + 2), (r, c) -> :universe[(r, c)]))), 0)
   universe = nextgeneration
===
auto cellcountx = 6;
auto cellcounty = 5;
auto celltable = create_dict(dict_of(make_tuple(1, 2), 1)(make_tuple(1, 3), 1)(make_tuple(0, 3), 1));

auto universe = DefaultDict<ivec2, int>();

struct CodeBlock1
{
    CodeBlock1()
    {
        universe.set(make_tuple(1, 1), 1);
        universe.set(make_tuple(2, 1), 1);
        universe.set(make_tuple(3, 1), 1);
        universe.set(make_tuple(1, 4), 1);
        universe.set(make_tuple(2, 4), 1);
        universe.set(make_tuple(3, 4), 1);

        for (int i = 0; i < 4; i++) {
            print(u"\nGeneration "_S & String(i) & u":"_S);
            for (auto row : range_el(0, cellcounty))
                print(u"  "_S & range_el(0, cellcountx).map([&row](const auto &col){return create_array({u". "_S, u"O "_S})[::universe[make_tuple(row, col)]];}).join(u""_S));
            auto nextgeneration = DefaultDict<ivec2, int>();
            for (auto row : range_el(0, cellcounty))
                for (auto col : range_el(0, cellcountx))
                    nextgeneration.set(make_tuple(row, col), celltable.get(make_tuple(universe[make_tuple(row, col)], -universe[make_tuple(row, col)] + sum(multiloop(range_el(row - 1, row + 2), range_el(col - 1, col + 2), [](const auto &r, const auto &c){return ::universe[make_tuple(r, c)];}))), 0));
            universe = nextgeneration;
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Count_the_coins#Python
Int64 = int

def changes(amount, coins):
    ways = [Int64(0)] * (amount + 1)
    ways[0] = 1
    for coin in coins:
        for j in range(coin, amount + 1):
            ways[j] += ways[j - coin]
    return ways[amount]

print(changes(100, [1, 5, 10, 25]))
print(changes(100000, [1, 5, 10, 25, 50, 100]))
===
F changes(amount, coins)
   V ways = [Int64(0)] * (amount + 1)
   ways[0] = 1
   L(coin) coins
      L(j) coin .. amount
         ways[j] += ways[j - coin]
   R ways[amount]

print(changes(100, [1, 5, 10, 25]))
print(changes(100000, [1, 5, 10, 25, 50, 100]))
===
template <typename T1, typename T2> auto changes(const T1 &amount, const T2 &coins)
{
    auto ways = create_array({to_int64(0)}) * (amount + 1);
    _set<0>(ways, 1);
    for (auto &&coin : coins)
        for (auto j : range_ee(coin, amount))
            ways[j] += ways[j - coin];
    return ways[amount];
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(changes(100, create_array({1, 5, 10, 25})));
        print(changes(100000, create_array({1, 5, 10, 25, 50, 100})));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/CRC-32#C
UInt32 = int

crc_table = [0] * 256
for i in range(256):
    rem : UInt32 = i
    for j in range(8):
        if rem & 1 != 0:
            rem >>= 1
            rem ^= 0xEDB88320
        else:
            rem >>= 1
    crc_table[i] = rem

def crc32(buf, crc = UInt32(0)):
    crc ^= 0xFFFFFFFF
    for k in buf:
        crc = (crc >> 8) ^ crc_table[(crc & 0xFF) ^ ord(k)]
    return crc ^ 0xFFFFFFFF

print(hex(crc32('The quick brown fox jumps over the lazy dog'))[2:].upper())
===
V crc_table = [0] * 256
L(i) 256
   UInt32 rem = i
   L(j) 8
      I rem [&] 1 != 0
         rem >>= 1
         rem (+)= EDB8'8320
      E
         rem >>= 1
   crc_table[i] = rem

F crc32(buf, =crc = UInt32(0))
   crc (+)= FFFF'FFFF
   L(k) buf
      crc = (crc >> 8) (+) :crc_table[(crc [&] F'F) (+) k.code]
   R crc (+) FFFF'FFFF

print(hex(crc32(‘The quick brown fox jumps over the lazy dog’)))
===
auto crc_table = create_array({0}) * 256;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (int i = 0; i < 256; i++) {
            uint32_t rem = i;
            for (int j = 0; j < 8; j++)
                if ((rem & 1) != 0) {
                    rem >>= 1;
                    rem ^= 0xEDB8'8320;
                }
                else
                    rem >>= 1;
            crc_table.set(i, rem);
        }
    }
} code_block_1;

template <typename T1, typename T2 = decltype(to_uint32(0))> auto crc32(const T1 &buf, T2 crc = to_uint32(0))
{
    crc ^= 0xFFFF'FFFF;
    for (auto &&k : buf)
        crc = (crc >> 8) ^ ::crc_table[(crc & 0xFF) ^ k.code];
    return crc ^ 0xFFFF'FFFF;
}

struct CodeBlock2
{
    CodeBlock2()
    {
        print(hex(crc32(u"The quick brown fox jumps over the lazy dog"_S)));
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Cumulative_standard_deviation#Python:_Callable_class
import math

class SD:
    sum = 0.0
    sum2 = 0.0
    n = 0.0

    def __call__(self, x):
        self.sum  += x
        self.sum2 += x**2
        self.n    += 1.0
        return math.sqrt(self.sum2/self.n - (self.sum / self.n) ** 2)

sd_inst = SD()
for value in [2,4,4,4,5,5,7,9]:
    print(str(value) + ' ' + str(sd_inst(value)))
===
T SD
   sum = 0.0
   sum2 = 0.0
   n = 0.0

   F ()(x)
      .sum += x
      .sum2 += x ^ 2
      .n += 1.0
      R sqrt(.sum2 / .n - (.sum / .n) ^ 2)

V sd_inst = SD()
L(value) [2, 4, 4, 4, 5, 5, 7, 9]
   print(String(value)‘ ’String(sd_inst(value)))
===
class SD
{
public:
    decltype(0.0) sum = 0.0;
    decltype(0.0) sum2 = 0.0;
    decltype(0.0) n = 0.0;

    template <typename T1> auto operator()(const T1 &x)
    {
        sum += x;
        sum2 += square(x);
        n += 1.0;
        return sqrt(sum2 / n - square((sum / n)));
    }
};

auto sd_inst = SD();

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&value : create_array({2, 4, 4, 4, 5, 5, 7, 9}))
            print(String(value) & u" "_S & String(sd_inst(value)));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Damm_algorithm#Python
matrix = [
    [0, 3, 1, 7, 5, 9, 8, 6, 4, 2],
    [7, 0, 9, 2, 1, 5, 4, 8, 6, 3],
    [4, 2, 0, 6, 8, 7, 1, 3, 5, 9],
    [1, 7, 5, 0, 9, 8, 3, 4, 2, 6],
    [6, 1, 2, 3, 0, 4, 5, 9, 7, 8],
    [3, 6, 7, 4, 2, 0, 9, 5, 8, 1],
    [5, 8, 6, 9, 7, 2, 0, 1, 3, 4],
    [8, 9, 4, 5, 3, 6, 2, 0, 1, 7],
    [9, 4, 3, 8, 6, 1, 7, 2, 0, 5],
    [2, 5, 8, 1, 4, 3, 6, 7, 9, 0]
]

def damm(num: int) -> bool:
    row = 0
    for digit in str(num):
        row = matrix[row][int(digit)]
    return row == 0

for test in [5724, 5727, 112946]:
    print(test + "\t Validates as: " + damm(test))
===
V matrix = [[0, 3, 1, 7, 5, 9, 8, 6, 4, 2], [7, 0, 9, 2, 1, 5, 4, 8, 6, 3], [4, 2, 0, 6, 8, 7, 1, 3, 5, 9], [1, 7, 5, 0, 9, 8, 3, 4, 2, 6], [6, 1, 2, 3, 0, 4, 5, 9, 7, 8], [3, 6, 7, 4, 2, 0, 9, 5, 8, 1], [5, 8, 6, 9, 7, 2, 0, 1, 3, 4], [8, 9, 4, 5, 3, 6, 2, 0, 1, 7], [9, 4, 3, 8, 6, 1, 7, 2, 0, 5], [2, 5, 8, 1, 4, 3, 6, 7, 9, 0]]

F damm(Int num) -> Bool
   V row = 0
   L(digit) String(num)
      row = :matrix[row][Int(digit)]
   R row == 0

L(test) [5724, 5727, 112946]
   print(test"\t Validates as: "damm(test))
===
auto matrix = create_array({create_array({0, 3, 1, 7, 5, 9, 8, 6, 4, 2}), create_array({7, 0, 9, 2, 1, 5, 4, 8, 6, 3}), create_array({4, 2, 0, 6, 8, 7, 1, 3, 5, 9}), create_array({1, 7, 5, 0, 9, 8, 3, 4, 2, 6}), create_array({6, 1, 2, 3, 0, 4, 5, 9, 7, 8}), create_array({3, 6, 7, 4, 2, 0, 9, 5, 8, 1}), create_array({5, 8, 6, 9, 7, 2, 0, 1, 3, 4}), create_array({8, 9, 4, 5, 3, 6, 2, 0, 1, 7}), create_array({9, 4, 3, 8, 6, 1, 7, 2, 0, 5}), create_array({2, 5, 8, 1, 4, 3, 6, 7, 9, 0})});

bool damm(const int num)
{
    auto row = 0;
    for (auto &&digit : String(num))
        row = ::matrix[row][to_int(digit)];
    return row == 0;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&test : create_array({5724, 5727, 112946}))
            print(test & u"\t Validates as: "_S & damm(test));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Delete_a_file#Python
import os
# current directory
os.remove("output.txt")
os.rmdir("docs")
# root directory
os.remove("/output.txt")
os.rmdir("/docs")
===
fs:remove_file(‘output.txt’)
fs:remove_dir(‘docs’)
fs:remove_file(‘/output.txt’)
fs:remove_dir(‘/docs’)
===
struct CodeBlock1
{
    CodeBlock1()
    {
        fs::remove_file(u"output.txt"_S);
        fs::remove_dir(u"docs"_S);
        fs::remove_file(u"/output.txt"_S);
        fs::remove_dir(u"/docs"_S);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Digital_root#Python
Int64 = int

def digital_root (n):
    ap = 0
    while n >= 10:
        n = sum(int(digit) for digit in str(n))
        ap += 1
    return (ap, n)

for n in [Int64(627615), 39390, 588225, 393900588225, 55]:
    persistance : Int64
    root : Int64
    (persistance, root) = digital_root(n)
    print("%12i has additive persistance %2i and digital root %i."
          % (n, persistance, root))
===
F digital_root(=n)
   V ap = 0
   L n >= 10
      n = sum(String(n).map(digit -> Int(digit)))
      ap++
   R (ap, n)

L(n) [Int64(627615), 39390, 588225, 393900588225, 55]
   Int64 persistance
   Int64 root
   (persistance, root) = digital_root(n)
   print(‘#12 has additive persistance #2 and digital root #..’.format(n, persistance, root))
===
template <typename T1> auto digital_root(T1 n)
{
    auto ap = 0;
    while (n >= 10) {
        n = sum_map(String(n), [](const auto &digit){return to_int(digit);});
        ap++;
    }
    return make_tuple(ap, n);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&n : create_array<Int64>({to_int64(627615), 39390, 588225, 393900588225, 55})) {
            Int64 persistance;
            Int64 root;
            assign_from_tuple(persistance, root, digital_root(n));
            print(u"#12 has additive persistance #2 and digital root #.."_S.format(n, persistance, root));
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Digital_root/Multiplicative_digital_root#Python
def mdroot(n):
    count = 0
    mdr = n
    while mdr > 9:
        m = mdr
        digits_mul = 1
        while m != 0:
            digits_mul *= m % 10
            m = m // 10
        mdr = digits_mul
        count += 1
    return (count, mdr)

print('Number: (MP, MDR)')
print('======  =========')
for n in (123321, 7739, 893, 899998):
    print('%6i: ' % (n), end = '')
    print(mdroot(n))

table = [[0]*0 for i in range(10)]
n = 0
while min(len(row) for row in table) < 5:
    table[mdroot(n)[1]].append(n)
    n += 1

print('')
print('MP: [n0..n4]')
print('==  ========')
for mp, val in enumerate(table):
    print('%2i: ' % (mp), end = '')
    print(val[:5])
===
F mdroot(n)
   V count = 0
   V mdr = n
   L mdr > 9
      V m = mdr
      V digits_mul = 1
      L m != 0
         digits_mul *= m % 10
         m = m I/ 10
      mdr = digits_mul
      count++
   R (count, mdr)

print(‘Number: (MP, MDR)’)
print(‘======  =========’)
L(n) (123321, 7739, 893, 899998)
   print(‘#6: ’.format(n), end' ‘’)
   print(mdroot(n))

V table = [[Int]()] * 10
V n = 0
L min(table.map(row -> row.len)) < 5
   table[mdroot(n)[1]].append(n)
   n++

print(‘’)
print(‘MP: [n0..n4]’)
print(‘==  ========’)
L(val) table
   V mp = L.index
   print(‘#2: ’.format(mp), end' ‘’)
   print(val[0.<5])
===
template <typename T1> auto mdroot(const T1 &n)
{
    auto count = 0;
    auto mdr = n;
    while (mdr > 9) {
        auto m = mdr;
        auto digits_mul = 1;
        while (m != 0) {
            digits_mul *= mod(m, 10);
            m = idiv(m, 10);
        }
        mdr = digits_mul;
        count++;
    }
    return make_tuple(count, mdr);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"Number: (MP, MDR)"_S);
        print(u"======  ========="_S);
        for (auto &&n : make_tuple(123321, 7739, 893, 899998)) {
            print(u"#6: "_S.format(n), u""_S);
            print(mdroot(n));
        }
    }
} code_block_1;

auto table = create_array({Array<int>()}) * 10;
auto n = 0;

struct CodeBlock2
{
    CodeBlock2()
    {
        while (min_map(table, [](const auto &row){return row.len();}) < 5) {
            table[_get<1>(mdroot(n))].append(n);
            n++;
        }

        print(u""_S);
        print(u"MP: [n0..n4]"_S);
        print(u"==  ========"_S);
        {int Lindex = 0;
        for (auto &&val : table) {
            auto mp = Lindex;
            print(u"#2: "_S.format(mp), u""_S);
            print(val[range_el(0, 5)]);
            Lindex++;
        }}
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Display_a_linear_combination#Python
def linear(x):
    a = ['%se(%i)' % ('-' if v == -1 else '' if v == 1 else str(v) + '*', i + 1) for i, v in enumerate(x) if v != 0]
    return ' + '.join(a if len(a) else [str('0')]).replace(' + -', ' - ')

for x in [[1, 2, 3], [0, 1, 2, 3], [1, 0, 3, 4], [1, 2, 0], [0, 0, 0], [0], [1, 1, 1], [-1, -1, -1], [-1, -2, 0, 3], [-1]]:
    print(linear(x))
===
F linear(x)
   V a = enumerate(x).filter((i, v) -> v != 0).map((i, v) -> ‘#.e(#.)’.format(I v == -1 {‘-’} E I v == 1 {‘’} E String(v)‘*’, i + 1))
   R (I !a.empty {a} E [String(‘0’)]).join(‘ + ’).replace(‘ + -’, ‘ - ’)

L(x) [[1, 2, 3], [0, 1, 2, 3], [1, 0, 3, 4], [1, 2, 0], [0, 0, 0], [0], [1, 1, 1], [-1, -1, -1], [-1, -2, 0, 3], [-1]]
   print(linear(x))
===
template <typename T1> auto linear(const T1 &x)
{
    auto a = enumerate(x).filter([](const auto &i, const auto &v){return v != 0;}).map([](const auto &i, const auto &v){return u"#.e(#.)"_S.format(v == -1 ? u"-"_S : v == 1 ? u""_S : String(v) & u"*"_S, i + 1);});
    return (!a.empty() ? a : create_array({String(u"0"_S)})).join(u" + "_S).replace(u" + -"_S, u" - "_S);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&x : create_array({create_array({1, 2, 3}), create_array({0, 1, 2, 3}), create_array({1, 0, 3, 4}), create_array({1, 2, 0}), create_array({0, 0, 0}), create_array({0}), create_array({1, 1, 1}), create_array({-1, -1, -1}), create_array({-1, -2, 0, 3}), create_array({-1})}))
            print(linear(x));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Entropy
import collections, math

def entropy(source):
    hist = collections.defaultdict(int) # Char
    for c in source:
        hist[c] += 1
    r = 0.0
    for v in hist.values():
        c = float(v) / len(source)
        r -= c * math.log2(c)
    return r

print(entropy('1223334444'))
===
F entropy(source)
   V hist = DefaultDict[Char, Int]()
   L(c) source
      hist[c]++
   V r = 0.0
   L(v) hist.values()
      V c = Float(v) / source.len
      r -= c * log2(c)
   R r

print(entropy(‘1223334444’))
===
template <typename T1> auto entropy(const T1 &source)
{
    auto hist = DefaultDict<Char, int>();
    for (auto &&c : source)
        hist[c]++;
    auto r = 0.0;
    for (auto &&v : hist.values()) {
        auto c = to_float(v) / source.len();
        r -= c * log2(c);
    }
    return r;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(entropy(u"1223334444"_S));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Equilibrium_index#Multi_Pass
def eqindex(arr):
    return [i for i in range(len(arr)) if sum(arr[:i]) == sum(arr[i+1:])]

print(eqindex([-7, 1, 5, 2, -4, 3, 0]))
===
F eqindex(arr)
   R (0 .< arr.len).filter(i -> sum(@arr[0 .< i]) == sum(@arr[i + 1 ..]))

print(eqindex([-7, 1, 5, 2, -4, 3, 0]))
===
template <typename T1> auto eqindex(const T1 &arr)
{
    return range_el(0, arr.len()).filter([&arr](const auto &i){return sum(arr[range_el(0, i)]) == sum(arr[range_ei(i + 1)]);});
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(eqindex(create_array({-7, 1, 5, 2, -4, 3, 0})));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Ethiopian_multiplication#Python
def halve(x):
    return x // 2

def double(x):
    return x * 2

def even(x):
    return not x % 2

def ethiopian(multiplier, multiplicand):
    result = 0

    while multiplier >= 1:
        if not even(multiplier):
            result += multiplicand
        multiplier   = halve(multiplier)
        multiplicand = double(multiplicand)

    return result

print(ethiopian(17, 34))
===
F halve(x)
   R x I/ 2

F double(x)
   R x * 2

F even(x)
   R !(x % 2)

F ethiopian(=multiplier, =multiplicand)
   V result = 0

   L multiplier >= 1
      I !even(multiplier)
         result += multiplicand
      multiplier = halve(multiplier)
      multiplicand = double(multiplicand)

   R result

print(ethiopian(17, 34))
===
template <typename T1> auto halve(const T1 &x)
{
    return idiv(x, 2);
}

template <typename T1> auto _double_(const T1 &x)
{
    return x * 2;
}

template <typename T1> auto even(const T1 &x)
{
    return !(mod(x, 2));
}

template <typename T1, typename T2> auto ethiopian(T1 multiplier, T2 multiplicand)
{
    auto result = 0;

    while (multiplier >= 1) {
        if (!even(multiplier))
            result += multiplicand;
        multiplier = halve(multiplier);
        multiplicand = _double_(multiplicand);
    }

    return result;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(ethiopian(17, 34));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Euler_method#Python
def euler(f, y0, a, b, h):
    t = a
    y = y0
    while t <= b:
        print("%6.3f %6.3f" % (t, y))
        t += h
        y += h * f(t, y)

newtoncooling = lambda time, temp: -0.07 * (temp - 20)

euler(newtoncooling, 100.0, 0.0, 100.0, 10.0)
===
F euler(f, y0, a, b, h)
   V t = a
   V y = y0
   L t <= b
      print(‘#2.3 #2.3’.format(t, y))
      t += h
      y += h * f(t, y)

V newtoncooling = (time, temp) -> -0.07 * (temp - 20)

euler(newtoncooling, 100.0, 0.0, 100.0, 10.0)
===
template <typename T1, typename T2, typename T3, typename T4, typename T5> auto euler(const T1 &f, const T2 &_y0_, const T3 &a, const T4 &b, const T5 &h)
{
    auto t = a;
    auto y = _y0_;
    while (t <= b) {
        print(u"#2.3 #2.3"_S.format(t, y));
        t += h;
        y += h * f(t, y);
    }
}

auto newtoncooling = [](const auto &time, const auto &temp){return -0.07 * (temp - 20);};

struct CodeBlock1
{
    CodeBlock1()
    {
        euler(newtoncooling, 100.0, 0.0, 100.0, 10.0);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Euler%27s_sum_of_powers_conjecture#Python
import time

Int64 = int

#def pow5(x):
#    r = x
#    r *= r
#    r *= r
#    return r * x

def eulers_sum_of_powers():
    max_n = 150
    pow_5 = [Int64(n)**5 for n in range(max_n)]
    pow5_to_n = {Int64(n)**5: n for n in range(max_n)}
    #pow5_to_n : Dict[Int64, int] = {}
    #for n in range(max_n):
    #    pow5_to_n[n**5] = n
    for x0 in range(1, max_n):
        for x1 in range(1, x0):
            for x2 in range(1, x1):
                for x3 in range(1, x2):
                                                                              # Python | C++   [with max_n = 150]
                    #pow_5_sum = sum(pow_5[i] for i in (x0, x1, x2, x3))      # 46.9 s | -----
                    #pow_5_sum = sum(pow_5[i] for i in [x0, x1, x2, x3])      # 51.4 s | 3.7 s
                    pow_5_sum = pow_5[x0] + pow_5[x1] + pow_5[x2] + pow_5[x3] # 11.8 s | 0.6 s
                    #pow_5_sum = x0**5 + x1**5 + x2**5 + x3**5                # 72.1 s | 2.0 s
                    #pow_5_sum = pow5(x0) + pow5(x1) + pow5(x2) + pow5(x3)    # 54.1 s | 0.6 s
                    if pow_5_sum in pow5_to_n:
                        y = pow5_to_n[pow_5_sum]
                        return (x0, x1, x2, x3, y)

#s = time.perf_counter()
r = eulers_sum_of_powers()
#print('Elapsed: ' + str(time.perf_counter() - s))

print("%i^5 + %i^5 + %i^5 + %i^5 = %i^5" % (r[0], r[1], r[2], r[3], r[4]))
===
F eulers_sum_of_powers()
   V max_n = 150
   V pow_5 = (0 .< max_n).map(n -> Int64(n) ^ 5)
   V pow5_to_n = Dict(0 .< max_n, n -> (Int64(n) ^ 5, n))
   L(x0) 1 .< max_n
      L(x1) 1 .< x0
         L(x2) 1 .< x1
            L(x3) 1 .< x2
               V pow_5_sum = pow_5[x0] + pow_5[x1] + pow_5[x2] + pow_5[x3]
               I pow_5_sum C pow5_to_n
                  V y = pow5_to_n[pow_5_sum]
                  R (x0, x1, x2, x3, y)

V r = eulers_sum_of_powers()

print(‘#.^5 + #.^5 + #.^5 + #.^5 = #.^5’.format(r[0], r[1], r[2], r[3], r[4]))
===
auto eulers_sum_of_powers()
{
    auto max_n = 150;
    auto pow_5 = range_el(0, max_n).map([](const auto &n){return pow(to_int64(n), 5);});
    auto pow5_to_n = create_dict(range_el(0, max_n), [](const auto &n){return make_tuple(pow(to_int64(n), 5), n);});
    for (auto x0 : range_el(1, max_n))
        for (auto x1 : range_el(1, x0))
            for (auto x2 : range_el(1, x1))
                for (auto x3 : range_el(1, x2)) {
                    auto pow_5_sum = pow_5[x0] + pow_5[x1] + pow_5[x2] + pow_5[x3];
                    if (in(pow_5_sum, pow5_to_n)) {
                        auto y = pow5_to_n[pow_5_sum];
                        return make_tuple(x0, x1, x2, x3, y);
                    }
                }
}

auto r = eulers_sum_of_powers();

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"#.^5 + #.^5 + #.^5 + #.^5 = #.^5"_S.format(_get<0>(r), _get<1>(r), _get<2>(r), _get<3>(r), _get<4>(r)));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Evaluate_binomial_coefficients#Python
def binomial_coeff(n, k):
    result = 1
    for i in range(1, k+1):
        result = result * (n-i+1) / i
    return result

print(binomial_coeff(5, 3))
===
F binomial_coeff(n, k)
   V result = 1
   L(i) 1 .. k
      result = result * (n - i + 1) / i
   R result

print(binomial_coeff(5, 3))
===
template <typename T1, typename T2> auto binomial_coeff(const T1 &n, const T2 &k)
{
    auto result = 1;
    for (auto i : range_ee(1, k))
        result = result * (n - i + 1) / i;
    return result;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(binomial_coeff(5, 3));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Exceptions#Python
class SillyError(Exception):
    message : str
    def __init__(self, message):
         self.message = message

try:
   raise SillyError('egg')
except SillyError as se:
   print(se.message)
===
T SillyError
   String message
   F (message)
      .message = message

X.try
   X SillyError(‘egg’)
X.catch SillyError se
   print(se.message)
===
class SillyError
{
public:
    String message;
    template <typename T1> SillyError(const T1 &message) :
        message(message)
    {
    }
};

struct CodeBlock1
{
    CodeBlock1()
    {
        try
        {
            throw SillyError(u"egg"_S);
        }
        catch (const SillyError& se)
        {
            print(se.message);
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Exceptions/Catch_an_exception_thrown_in_a_nested_call#Python
class U0(Exception): pass
class U1(Exception): pass

def baz(i):
    if i == 0:
        raise U0()
    else:
        raise U1()

def bar(i):
    baz(i) # Nest those calls

def foo():
    for i in range(2):
        try:
            bar(i)
        except U0:
            print("Function foo caught exception U0")

foo()
===
T U0
{
}
T U1
{
}

F baz(i)
   I i == 0
      X U0()
   E
      X U1()

F bar(i)
   baz(i)

F foo()
   L(i) 2
      X.try
         bar(i)
      X.catch U0
         print(‘Function foo caught exception U0’)

foo()
===
class U0
{
};

class U1
{
};

template <typename T1> auto baz(const T1 &i)
{
    if (i == 0)
        throw U0();
    else
        throw U1();
}

template <typename T1> auto bar(const T1 &i)
{
    baz(i);
}

auto foo()
{
    for (int i = 0; i < 2; i++) {
        try
        {
            bar(i);
        }
        catch (const U0&)
        {
            print(u"Function foo caught exception U0"_S);
        }
    }
}

struct CodeBlock1
{
    CodeBlock1()
    {
        foo();
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Execute_SNUSP#Python
import sys
Byte = int

HW = r'''
/++++!/===========?\>++.>+.+++++++..+++\
\+++\ | /+>+++++++>/ /++++++++++<<.++>./
$+++/ | \+++++++++>\ \+++++.>.+++.-----\
      \==-<<<<+>+++/ /=.>.+>.--------.-/'''

def snusp(store, code):
    ds = [Byte(0)] * store # data store
    dp = 0                 # data pointer
    cs = code.split("\n")  # 2 dimensional code store
    ipr = 0                # instruction pointers in row ...
    ipc = 0                # ... and column
    for r, row in enumerate(cs):
        ipc = row.find('$')
        if ipc != -1:
            ipr = r
            break
    id = 0  # instruction direction.  starting direction is always rt
    def step():
        nonlocal ipr, ipc
        if id&1:
            ipr += 1 - (id&2)
        else:
            ipc += 1 - (id&2)
    while ipr >= 0 and ipr < len(cs) and ipc >= 0 and ipc < len(cs[ipr]):
        op = cs[ipr][ipc]
        if op == '>':
            dp += 1
        elif op == '<':
            dp -= 1
        elif op == '+':
            ds[dp] += 1
        elif op == '-':
            ds[dp] -= 1
        elif op == '.':
            sys.stdout.write(chr(ds[dp]))
        elif op == ',':
            ds[dp] = Byte(ord(sys.stdin.read(1)))
        elif op == '/':
            id = ~id
        elif op == '\\':
            id ^= 1
        elif op == '!':
            step()
        elif op == '?':
            if not ds[dp]:
                step()
        step()

snusp(5, HW)
===
V HW = ‘
/++++!/===========?\>++.>+.+++++++..+++\
\+++\ | /+>+++++++>/ /++++++++++<<.++>./
$+++/ | \+++++++++>\ \+++++.>.+++.-----\
      \==-<<<<+>+++/ /=.>.+>.--------.-/’

F snusp(store, code)
   V ds = [Byte(0)] * store
   V dp = 0
   V cs = code.split("\n")
   V ipr = 0
   V ipc = 0
   L(row) cs
      V r = L.index
      ipc = row.findi(‘$’)
      I ipc != -1
         ipr = r
         L.break
   V id = 0
   F step()
      I @id [&] 1
         @ipr += 1 - (@id [&] 2)
      E
         @ipc += 1 - (@id [&] 2)
   L ipr >= 0 & ipr < cs.len & ipc >= 0 & ipc < cs[ipr].len
      S cs[ipr][ipc]
         ‘>’
            dp++
         ‘<’
            dp--
         ‘+’
            ds[dp]++
         ‘-’
            ds[dp]--
         ‘.’
            :stdout.write(Char(code' ds[dp]))
         ‘,’
            ds[dp] = Byte(:stdin.read(1).code)
         ‘/’
            id = (-)id
         ‘\’
            id (+)= 1
         ‘!’
            step()
         ‘?’
            I !ds[dp]
               step()
      step()

snusp(5, HW)
===
auto HW = uR"(
/++++!/===========?\>++.>+.+++++++..+++\
\+++\ | /+>+++++++>/ /++++++++++<<.++>./
$+++/ | \+++++++++>\ \+++++.>.+++.-----\
      \==-<<<<+>+++/ /=.>.+>.--------.-/)"_S;

template <typename T1, typename T2> auto snusp(const T1 &store, const T2 &code)
{
    auto ds = create_array({Byte(0)}) * store;
    auto dp = 0;
    auto cs = code.split(u"\n"_S);
    auto ipr = 0;
    auto ipc = 0;
    {int Lindex = 0;
    for (auto &&row : cs) {
        auto r = Lindex;
        ipc = row.findi(u"$"_S);
        if (ipc != -1) {
            ipr = r;
            break;
        }
        Lindex++;
    }}
    auto id = 0;
    auto step = [&id, &ipc, &ipr]()
    {
        if (id & 1)
            ipr += 1 - (id & 2);
        else
            ipc += 1 - (id & 2);
    };
    while (ipr >= 0 && ipr < cs.len() && ipc >= 0 && ipc < cs[ipr].len()) {
        switch (cs[ipr][ipc])
        {
        case u'>':
            dp++;
            break;
        case u'<':
            dp--;
            break;
        case u'+':
            ds[dp]++;
            break;
        case u'-':
            ds[dp]--;
            break;
        case u'.':
            _stdout.write(Char(ds[dp]));
            break;
        case u',':
            ds.set(dp, Byte(_stdin.read(1).code));
            break;
        case u'/':
            id = ~id;
            break;
        case u'\\':
            id ^= 1;
            break;
        case u'!':
            step();
            break;
        case u'?':
            if (!ds[dp])
                step();
            break;
        }
        step();
    }
}

struct CodeBlock1
{
    CodeBlock1()
    {
        snusp(5, HW);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Exponentiation_order
print(5**3**2)
print((5**3)**2)
print(5**(3**2))
===
print(5 ^ 3 ^ 2)
print((5 ^ 3) ^ 2)
print(5 ^ (3 ^ 2))
===
struct CodeBlock1
{
    CodeBlock1()
    {
        print(pow(5, square(3)));
        print(square((cube(5))));
        print(pow(5, (square(3))));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Extract_file_extension#Python
import re

def extract_ext(path):
    m = re.search(r'\.[A-Za-z0-9]+$', path)
    return m.group(0) if m else ""

paths = ['http://example.com/download.tar.gz',
         'CharacterModel.3DS',
         '.desktop',
         'document',
         'document.txt_backup',
         '/etc/pam.d/login']

for path in paths:
    print(path.rjust(max(map(lambda p: len(p), paths))) + ' -> ' + extract_ext(path))
===
F extract_ext(path)
   V m = re:‘\.[A-Za-z0-9]+$’.search(path)
   R I m {m.group(0)} E ‘’

V paths = [‘http://example.com/download.tar.gz’, ‘CharacterModel.3DS’, ‘.desktop’, ‘document’, ‘document.txt_backup’, ‘/etc/pam.d/login’]

L(path) paths
   print(path.rjust(max(paths.map(p -> p.len)))‘ -> ’extract_ext(path))
===
template <typename T1> auto extract_ext(const T1 &path)
{
    auto m = re::_(uR"(\.[A-Za-z0-9]+$)"_S).search(path);
    return m ? m.group(0) : u""_S;
}

auto paths = create_array({u"http://example.com/download.tar.gz"_S, u"CharacterModel.3DS"_S, u".desktop"_S, u"document"_S, u"document.txt_backup"_S, u"/etc/pam.d/login"_S});

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&path : paths)
            print(path.rjust(max_map(paths, [](const auto &p){return p.len();})) & u" -> "_S & extract_ext(path));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Factors_of_an_integer#Python
import math

def factor(n):
  factors = set() # int
  for x in range(1, int(math.sqrt(n)) + 1):
    if n % x == 0:
      factors.add(x)
      factors.add(n//x)
  return sorted(list(factors))

for i in (45, 53, 64):
  print(str(i) + ": factors: " + str(factor(i)))
===
F factor(n)
   V factors = Set[Int]()
   L(x) 1 .. Int(sqrt(n))
      I n % x == 0
         factors.add(x)
         factors.add(n I/ x)
   R sorted(Array(factors))

L(i) (45, 53, 64)
   print(String(i)‘: factors: ’String(factor(i)))
===
template <typename T1> auto factor(const T1 &n)
{
    auto factors = Set<int>();
    for (auto x : range_ee(1, to_int(sqrt(n))))
        if (mod(n, x) == 0) {
            factors.add(x);
            factors.add(idiv(n, x));
        }
    return sorted(create_array(factors));
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&i : make_tuple(45, 53, 64))
            print(String(i) & u": factors: "_S & String(factor(i)));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Farey_sequence#Lua
def farey(n):
    a = 0
    b = 1
    c = 1
    d = n
    far = '0/1 '
    farn = 1
    while c <= n:
        k = (n + b) // d
        (a, b, c, d) = (c, d, k * c - a, k * d - b)
        far += str(a) + '/' + str(b) + ' '
        farn += 1
    return (far, farn)

for i in range(1, 11+1):
    print(str(i) + ": " + farey(i)[0])

for i in range(100, 1000+100, 100):
    print(str(i) + ": " + str(farey(i)[1]) + " items")
===
F farey(n)
   V a = 0
   V b = 1
   V c = 1
   V d = n
   V far = ‘0/1 ’
   V farn = 1
   L c <= n
      V k = (n + b) I/ d
      (a, b, c, d) = (c, d, k * c - a, k * d - b)
      far ‘’= String(a)‘/’String(b)‘ ’
      farn++
   R (far, farn)

L(i) 1 .. 11
   print(String(i)‘: ’farey(i)[0])

L(i) (100 .< 1000 + 100).step(100)
   print(String(i)‘: ’String(farey(i)[1])‘ items’)
===
template <typename T1> auto farey(const T1 &n)
{
    auto a = 0;
    auto b = 1;
    auto c = 1;
    auto d = n;
    auto far = u"0/1 "_S;
    auto farn = 1;
    while (c <= n) {
        auto k = idiv((n + b), d);
        assign_from_tuple(a, b, c, d, make_tuple(c, d, k * c - a, k * d - b));
        far &= String(a) & u"/"_S & String(b) & u" "_S;
        farn++;
    }
    return make_tuple(far, farn);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto i : range_ee(1, 11))
            print(String(i) & u": "_S & _get<0>(farey(i)));

        for (auto i : range_el(100, 1000 + 100).step(100))
            print(String(i) & u": "_S & String(_get<1>(farey(i))) & u" items"_S);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Fast_Fourier_transform#Python
import math
import cmath

def fft(x):
    n = len(x)
    if n <= 1: return x
    even = fft(x[0::2])
    odd =  fft(x[1::2])
    t = [cmath.exp(-2j*math.pi*k/n)*odd[k] for k in range(n//2)]
    return [even[k] + t[k] for k in range(n//2)] + \
           [even[k] - t[k] for k in range(n//2)]

print( ' '.join("%5.3f" % (abs(f))
                for f in fft([complex(1.0), 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0])) )
===
F fft(x)
   V n = x.len
   I n <= 1
      R x
   V even = fft(x[(0..).step(2)])
   V odd = fft(x[(1..).step(2)])
   V t = (0 .< n I/ 2).map(k -> exp(-2i * math:pi * k / @n) * @odd[k])
   R (0 .< n I/ 2).map(k -> @even[k] + @t[k]) [+] (0 .< n I/ 2).map(k -> @even[k] - @t[k])

print(fft([Complex(1.0), 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]).map(f -> ‘#.3’.format(abs(f))).join(‘ ’))
===
template <typename T1> auto fft(const T1 &x)
{
    auto n = x.len();
    if (n <= 1)
        return x;
    auto even = fft(x[range_ei(0).step(2)]);
    auto odd = fft(x[range_ei(1).step(2)]);
    auto t = range_el(0, idiv(n, 2)).map([&n, &odd](const auto &k){return exp(-2i * math::pi * k / n) * odd[k];});
    return range_el(0, idiv(n, 2)).map([&even, &t](const auto &k){return even[k] + t[k];}) + range_el(0, idiv(n, 2)).map([&even, &t](const auto &k){return even[k] - t[k];});
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(fft(create_array<Complex>({Complex(1.0), 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0})).map([](const auto &f){return u"#.3"_S.format(abs(f));}).join(u" "_S));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/FASTA_format#Python [-Note that a high-quality implementation will not hold the entire file in memory at once; real FASTA files can be multiple gigabytes in size.-]
instr = \
'''>Rosetta_Example_1
THERECANBENOSPACE
>Rosetta_Example_2
THERECANBESEVERAL
LINESBUTTHEYALLMUST
BECONCATENATED'''

def fasta_parse(instr):
    r : List[Tuple[str, str]] = []
    key = ''
    val = ''
    for line in instr.split("\n"):
        if line.startswith('>'):
            if key != '':
                r.append((key, val))
            (key, val) = (line[1:].split()[0], '')
        elif key != '':
            val += line
    if key != '':
        r.append((key, val))
    return r

print("\n".join(key + ': ' + val for key, val in fasta_parse(instr)))
===
V instr = ‘>Rosetta_Example_1
THERECANBENOSPACE
>Rosetta_Example_2
THERECANBESEVERAL
LINESBUTTHEYALLMUST
BECONCATENATED’

F fasta_parse(instr)
   [(String, String)] r
   V key = ‘’
   V val = ‘’
   L(line) instr.split("\n")
      I line.starts_with(‘>’)
         I key != ‘’
            r.append((key, val))
         (key, val) = (line[1..].split_py()[0], ‘’)
      E I key != ‘’
         val ‘’= line
   I key != ‘’
      r.append((key, val))
   R r

print(fasta_parse(instr).map((key, val) -> key‘: ’val).join("\n"))
===
auto instr = uR"(>Rosetta_Example_1
THERECANBENOSPACE
>Rosetta_Example_2
THERECANBESEVERAL
LINESBUTTHEYALLMUST
BECONCATENATED)"_S;

template <typename T1> auto fasta_parse(const T1 &instr)
{
    Array<Tuple<String, String>> r;
    auto key = u""_S;
    auto val = u""_S;
    for (auto &&line : instr.split(u"\n"_S))
        if (line.starts_with(u">"_S)) {
            if (key != u"")
                r.append(make_tuple(key, val));
            assign_from_tuple(key, val, make_tuple(_get<0>(line[range_ei(1)].split_py()), u""_S));
        }
        else if (key != u"")
            val &= line;
    if (key != u"")
        r.append(make_tuple(key, val));
    return r;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(fasta_parse(instr).map([](const auto &key, const auto &val){return key & u": "_S & val;}).join(u"\n"_S));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Feigenbaum_constant_calculation#Python
max_it = 13
max_it_j = 10
a1 = 1.0
a2 = 0.0
d1 = 3.2
a = 0.0

print(" i       d")
for i in range(2, max_it + 1):
    a = a1 + (a1 - a2) / d1
    for j in range(1, max_it_j + 1):
        x = 0.0
        y = 0.0
        for k in range(1, (1 << i) + 1):
            y = 1.0 - 2.0 * y * x
            x = a - x * x
        a = a - x / y
    d = (a1 - a2) / (a - a1)
    print("%2d    %.8f" % (i, d))
    d1 = d
    a2 = a1
    a1 = a
===
V max_it = 13
V max_it_j = 10
V a1 = 1.0
V a2 = 0.0
V d1 = 3.2
V a = 0.0

print(‘ i       d’)
L(i) 2 .. max_it
   a = a1 + (a1 - a2) / d1
   L(j) 1 .. max_it_j
      V x = 0.0
      V y = 0.0
      L(k) 1 .. (1 << i)
         y = 1.0 - 2.0 * y * x
         x = a - x * x
      a = a - x / y
   V d = (a1 - a2) / (a - a1)
   print(‘#2    #.8’.format(i, d))
   d1 = d
   a2 = a1
   a1 = a
===
auto max_it = 13;
auto max_it_j = 10;
auto a1 = 1.0;
auto a2 = 0.0;
auto d1 = 3.2;
auto a = 0.0;

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u" i       d"_S);
        for (auto i : range_ee(2, max_it)) {
            a = a1 + (a1 - a2) / d1;
            for (auto j : range_ee(1, max_it_j)) {
                auto x = 0.0;
                auto y = 0.0;
                for (auto k : range_ee(1, (1 << i))) {
                    y = 1.0 - 2.0 * y * x;
                    x = a - x * x;
                }
                a = a - x / y;
            }
            auto d = (a1 - a2) / (a - a1);
            print(u"#2    #.8"_S.format(i, d));
            d1 = d;
            a2 = a1;
            a1 = a;
        }
    }
} code_block_1;


# https://rosettacode.org/wiki/Euler%27s_identity#Python
import math
print(math.e ** (math.pi * 1j) + 1)
===
print(math:e ^ (math:pi * 1i) + 1)
===
struct CodeBlock1
{
    CodeBlock1()
    {
        print(pow(math::e, (math::pi * 1i)) + 1);
    }
} code_block_1;


# https://rosettacode.org/wiki/Arithmetic/Complex#Python
z1 = 1.5 + 3j
z2 = 1.5 + 1.5j
print(z1 + z2)        # (3+4.5j)
print(z1 - z2)        # 1.5j
print(z1 * z2)        # (-2.25+6.75j)
print(z1 / z2)        # (1.5+0.5j)
print(- z1)           # (-1.5-3j)
print(z1.conjugate()) # (1.5-3j)
print(abs(z1))        # 3.3541019662496847
print(z1 ** z2)       # (-1.1024829553277784-0.38306415117199333j)
print(z1.real)        # 1.5
print(z1.imag)        # 3.0
===
V z1 = 1.5 + 3i
V z2 = 1.5 + 1.5i
print(z1 + z2)
print(z1 - z2)
print(z1 * z2)
print(z1 / z2)
print(-z1)
print(conjugate(z1))
print(abs(z1))
print(z1 ^ z2)
print(z1.real)
print(z1.imag)
===
auto z1 = 1.5 + 3i;
auto z2 = 1.5 + 1.5i;

struct CodeBlock1
{
    CodeBlock1()
    {
        print(z1 + z2);
        print(z1 - z2);
        print(z1 * z2);
        print(z1 / z2);
        print(-z1);
        print(conjugate(z1));
        print(abs(z1));
        print(pow(z1, z2));
        print(z1.real());
        print(z1.imag());
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Fibonacci_n-step_number_sequences#Python:_Callable_class
from typing import List

class Fiblike:
    addnum : int
    memo : List[int]

    def __init__(self, start):
        self.addnum = len(start)
        self.memo = start[:]

    def __call__(self, n):
        try:
            return self.memo[n]
        except IndexError:
            ans = sum(self(i) for i in range(n-self.addnum, n))
            self.memo.append(ans)
            return ans

fibo = Fiblike([1,1])
print([fibo(i) for i in range(10)]) # [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
lucas = Fiblike([2,1])
print([lucas(i) for i in range(10)]) # [2, 1, 3, 4, 7, 11, 18, 29, 47, 76]
for n, name in zip(range(2,11), 'fibo tribo tetra penta hexa hepta octo nona deca'.split()) :
    fibber = Fiblike([1] + [int(2**i) for i in range(n-1)])
    print('n=%2i, %5snacci -> %s ...' % (n, name, ' '.join(str(fibber(i)) for i in range(15))))
===
T Fiblike
   Int addnum
   [Int] memo

   F (start)
      .addnum = start.len
      .memo = copy(start)

   F ()(n)
      X.try
         R .memo[n]
      X.catch IndexError
         V ans = sum((n - .addnum .< n).map(i -> (.)(i)))
         .memo.append(ans)
         R ans

V fibo = Fiblike([1, 1])
print((0.<10).map(i -> fibo(i)))
V lucas = Fiblike([2, 1])
print((0.<10).map(i -> lucas(i)))
L(n, name) zip(2..10, ‘fibo tribo tetra penta hexa hepta octo nona deca’.split_py())
   V fibber = Fiblike([1] [+] (0 .< n - 1).map(i -> Int(2 ^ i)))
   print(‘n=#2, #5nacci -> #. ...’.format(n, name, (0.<15).map(i -> String(@fibber(i))).join(‘ ’)))
===
class Fiblike
{
public:
    int addnum;
    Array<int> memo;

    template <typename T1> Fiblike(const T1 &start)
    {
        addnum = start.len();
        memo = copy(start);
    }

    template <typename T1> auto operator()(const T1 &n)
    {
        try
        {
            return memo[n];
        }
        catch (const IndexError&)
        {
            auto ans = sum_map(range_el(n - addnum, n), [this](const auto &i){return (*this)(i);});
            memo.append(ans);
            return ans;
        }
    }
};

auto fibo = Fiblike(create_array({1, 1}));

struct CodeBlock1
{
    CodeBlock1()
    {
        print(range_el(0, 10).map([](const auto &i){return fibo(i);}));
    }
} code_block_1;

auto lucas = Fiblike(create_array({2, 1}));

struct CodeBlock2
{
    CodeBlock2()
    {
        print(range_el(0, 10).map([](const auto &i){return lucas(i);}));
        for (auto &&[n, name] : zip(range_ee(2, 10), u"fibo tribo tetra penta hexa hepta octo nona deca"_S.split_py())) {
            auto fibber = Fiblike(create_array({1}) + range_el(0, n - 1).map([](const auto &i){return to_int(pow(2, i));}));
            print(u"n=#2, #5nacci -> #. ..."_S.format(n, name, range_el(0, 15).map([&fibber](const auto &i){return String(fibber(i));}).join(u" "_S)));
        }
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Fibonacci_sequence#Iterative_63 [Python]
def fib_iter(n):
    if n < 2:
        return n
    fib_prev = 1
    fib = 1
    for num in range(2, n):
        (fib_prev, fib) = (fib, fib + fib_prev)
    return fib

for i in range(1, 21):
    print(fib_iter(i), end = ' ')
print()
===
F fib_iter(n)
   I n < 2
      R n
   V fib_prev = 1
   V fib = 1
   L(num) 2 .< n
      (fib_prev, fib) = (fib, fib + fib_prev)
   R fib

L(i) 1..20
   print(fib_iter(i), end' ‘ ’)
print()
===
template <typename T1> auto fib_iter(const T1 &n)
{
    if (n < 2)
        return n;
    auto fib_prev = 1;
    auto fib = 1;
    for (auto num : range_el(2, n))
        assign_from_tuple(fib_prev, fib, make_tuple(fib, fib + fib_prev));
    return fib;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto i : range_ee(1, 20))
            print(fib_iter(i), u" "_S);
        print();
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Fibonacci_word#Python
import math

def entropy(s):
    if len(s) <= 1:
        return 0.0
    lns = float(len(s))
    count0 = s.count('0')
    return -sum(count/lns * math.log(count/lns, 2) for count in (count0, len(s) - count0))

nmax = 37
fwords = [str('1'), '0']
print('%-3s %10s %-10s %s' % ('N', 'Length', 'Entropy', 'Fibword'))
for n in range(1, nmax+1):
    while len(fwords) < n:
        fwords += [''.join(fwords[-2:][::-1])]
    v = fwords[n-1]
    print('%3i %10i %10.7f %s' % (n, len(v), entropy(v), v if len(v) < 56 else '<too long>'))
===
F entropy(s)
   I s.len <= 1
      R 0.0
   V lns = Float(s.len)
   V count0 = s.count(‘0’)
   R -sum((count0, s.len - count0).map(count -> count / @lns * log(count / @lns, 2)))

V nmax = 37
V fwords = [String(‘1’), ‘0’]
print(‘#<3 #10 #<10 #.’.format(‘N’, ‘Length’, ‘Entropy’, ‘Fibword’))
L(n) 1 .. nmax
   L fwords.len < n
      fwords [+]= (reversed(fwords[(len)-2 ..])).join(‘’)
   V v = fwords[n - 1]
   print(‘#3 #10 #2.7 #.’.format(n, v.len, entropy(v), I v.len < 56 {v} E ‘<too long>’))
===
template <typename T1> auto entropy(const T1 &s)
{
    if (s.len() <= 1)
        return 0.0;
    auto lns = to_float(s.len());
    auto count0 = s.count(u"0"_S);
    return -sum_map(make_tuple(count0, s.len() - count0), [&lns](const auto &count){return count / lns * log(count / lns, 2);});
}

auto nmax = 37;
auto fwords = create_array<String>({String(u"1"_S), u"0"_S});

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"#<3 #10 #<10 #."_S.format(u"N"_S, u"Length"_S, u"Entropy"_S, u"Fibword"_S));
        for (auto n : range_ee(1, nmax)) {
            while (fwords.len() < n)
                fwords.append((reversed(fwords[range_elen_i( - 2)])).join(u""_S));
            auto v = fwords[n - 1];
            print(u"#3 #10 #2.7 #."_S.format(n, v.len(), entropy(v), v.len() < 56 ? v : u"<too long>"_S));
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/File_extension_is_in_extensions_list#Python
def is_ext(file_name, extensions):
    return any(map(lambda e: file_name.lower().endswith("." + e.lower()), extensions))

def test(file_names, extensions):
    for file_name in file_names:
        print(file_name.ljust(max(len(f_n) for f_n in file_names)) + ' ' + str(is_ext(file_name, extensions)))

test([
    'MyData.a##',
    'MyData.tar.Gz',
    'MyData.gzip',
    'MyData.7z.backup',
    'MyData...',
    'MyData'
], ['zip', 'rar', '7z', 'gz', 'archive', 'A##', 'tar.bz2'])

test([
    'MyData_v1.0.tar.bz2',
    'MyData_v1.0.bz2'
], ['tar.bz2'])
===
F is_ext(file_name, extensions)
   R any(extensions.map(e -> @file_name.lowercase().ends_with(‘.’e.lowercase())))

F test(file_names, extensions)
   L(file_name) file_names
      print(file_name.ljust(max(file_names.map(f_n -> f_n.len)))‘ ’String(is_ext(file_name, extensions)))

test([‘MyData.a##’, ‘MyData.tar.Gz’, ‘MyData.gzip’, ‘MyData.7z.backup’, ‘MyData...’, ‘MyData’], [‘zip’, ‘rar’, ‘7z’, ‘gz’, ‘archive’, ‘A##’, ‘tar.bz2’])

test([‘MyData_v1.0.tar.bz2’, ‘MyData_v1.0.bz2’], [‘tar.bz2’])
===
template <typename T1, typename T2> auto is_ext(const T1 &file_name, const T2 &extensions)
{
    return any_map(extensions, [&file_name](const auto &e){return file_name.lowercase().ends_with(u"."_S & e.lowercase());});
}

template <typename T1, typename T2> auto test(const T1 &file_names, const T2 &extensions)
{
    for (auto &&file_name : file_names)
        print(file_name.ljust(max_map(file_names, [](const auto &f_n){return f_n.len();})) & u" "_S & String(is_ext(file_name, extensions)));
}

struct CodeBlock1
{
    CodeBlock1()
    {
        test(create_array({u"MyData.a##"_S, u"MyData.tar.Gz"_S, u"MyData.gzip"_S, u"MyData.7z.backup"_S, u"MyData..."_S, u"MyData"_S}), create_array({u"zip"_S, u"rar"_S, u"7z"_S, u"gz"_S, u"archive"_S, u"A##"_S, u"tar.bz2"_S}));

        test(create_array({u"MyData_v1.0.tar.bz2"_S, u"MyData_v1.0.bz2"_S}), create_array({u"tar.bz2"_S}));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Filter
array = list(range(1, 11))
even = filter(lambda n: n % 2 == 0, array)
print(even)
===
V array = Array(1..10)
V even = array.filter(n -> n % 2 == 0)
print(even)
===
auto array = create_array(range_ee(1, 10));
auto even = array.filter([](const auto &n){return mod(n, 2) == 0;});

struct CodeBlock1
{
    CodeBlock1()
    {
        print(even);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Find_common_directory_path#C
def find_common_directory_path(paths, sep = '/'):
    pos = 0
    while True:
        for path in paths:
            if pos < len(path) and path[pos] == paths[0][pos]:
                continue

            while pos > 0:
                pos -= 1
                if paths[0][pos] == sep:
                    break
            return paths[0][:pos]
        pos += 1

print(find_common_directory_path([
    "/home/user1/tmp/coverage/test",
    "/home/user1/tmp/covert/operator",
    "/home/user1/tmp/coven/members"]))
===
F find_common_directory_path(paths, sep = ‘/’)
   V pos = 0
   L
      L(path) paths
         I pos < path.len & path[pos] == paths[0][pos]
            L.continue

         L pos > 0
            pos--
            I paths[0][pos] == sep
               L.break
         R paths[0][0 .< pos]
      pos++

print(find_common_directory_path([‘/home/user1/tmp/coverage/test’, ‘/home/user1/tmp/covert/operator’, ‘/home/user1/tmp/coven/members’]))
===
template <typename T1, typename T2 = decltype(u"/"_S)> auto find_common_directory_path(const T1 &paths, const T2 &sep = u"/"_S)
{
    auto pos = 0;
    while (true) {
        for (auto &&path : paths) {
            if (pos < path.len() && path[pos] == _get<0>(paths)[pos])
                continue;

            while (pos > 0) {
                pos--;
                if (_get<0>(paths)[pos] == sep)
                    break;
            }
            return _get<0>(paths)[range_el(0, pos)];
        }
        pos++;
    }
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(find_common_directory_path(create_array({u"/home/user1/tmp/coverage/test"_S, u"/home/user1/tmp/covert/operator"_S, u"/home/user1/tmp/coven/members"_S})));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Find_palindromic_numbers_in_both_binary_and_ternary_bases#Python
Int64 = int

digits = "0123456789abcdefghijklmnopqrstuvwxyz"

def baseN(num, b):
    if num == 0: return "0"
    result = ""
    while num != 0:
        (num, d) = divmod(num, b)
        result += digits[int(d)]
    return result[::-1] # reverse [+TODO: replace `result[::-1]` with `result[((len)-1..0).step(-1)]` or `reversed(result)`+]

def pal2(num):
    if num == 0 or num == 1: return True
    based = bin(num)[2:]
    return based == based[::-1]

def pal_23(limit):
    r = [Int64(0), 1]
    n = 1
    while True:
        n += 1
        b = baseN(n, 3)
        revb = b[::-1]
        #if len(b) > 12: break
        for trial in (b + ''  + revb, b + '0' + revb,
                      b + '1' + revb, b + '2' + revb):
            t = Int64(trial, 3)
            if pal2(t):
                r.append(t)
                if len(r) == limit:
                    return r

for pal23 in pal_23(6):
    print(str(pal23) + ' ' + baseN(pal23, 3) + ' ' + baseN(pal23, 2))
===
V digits = ‘0123456789abcdefghijklmnopqrstuvwxyz’

F baseN(=num, b)
   I num == 0
      R ‘0’
   V result = ‘’
   L num != 0
      (num, V d) = divmod(num, b)
      result ‘’= :digits[Int(d)]
   R reversed(result)

F pal2(num)
   I num == 0 | num == 1
      R 1B
   V based = bin(num)
   R based == reversed(based)

F pal_23(limit)
   V r = [Int64(0), 1]
   V n = 1
   L
      n++
      V b = baseN(n, 3)
      V revb = reversed(b)
      L(trial) (b‘’revb, b‘0’revb, b‘1’revb, b‘2’revb)
         V t = Int64(trial, radix' 3)
         I pal2(t)
            r.append(t)
            I r.len == limit
               R r

L(pal23) pal_23(6)
   print(String(pal23)‘ ’baseN(pal23, 3)‘ ’baseN(pal23, 2))
===
auto digits = u"0123456789abcdefghijklmnopqrstuvwxyz"_S;

template <typename T1, typename T2> auto baseN(T1 num, const T2 &b)
{
    if (num == 0)
        return u"0"_S;
    auto result = u""_S;
    while (num != 0) {
        TUPLE_ELEMENT_T(1, divmod(num, b)) d;
        assign_from_tuple(num, d, divmod(num, b));
        result &= ::digits[to_int(d)];
    }
    return reversed(result);
}

template <typename T1> auto pal2(const T1 &num)
{
    if (num == 0 || num == 1)
        return true;
    auto based = bin(num);
    return based == reversed(based);
}

template <typename T1> auto pal_23(const T1 &limit)
{
    auto r = create_array<Int64>({to_int64(0), 1});
    auto n = 1;
    while (true) {
        n++;
        auto b = baseN(n, 3);
        auto revb = reversed(b);
        for (auto &&trial : make_tuple(b & revb, b & u"0"_S & revb, b & u"1"_S & revb, b & u"2"_S & revb)) {
            auto t = to_int64(trial, 3);
            if (pal2(t)) {
                r.append(t);
                if (r.len() == limit)
                    return r;
            }
        }
    }
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&pal23 : pal_23(6))
            print(String(pal23) & u" "_S & baseN(pal23, 3) & u" "_S & baseN(pal23, 2));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Find_the_missing_permutation#C
import math

perms = [
    'ABCD', 'CABD', 'ACDB', 'DACB', 'BCDA', 'ACBD', 'ADCB', 'CDAB',
    'DABC', 'BCAD', 'CADB', 'CDBA', 'CBAD', 'ABDC', 'ADBC', 'BDCA',
    'DCBA', 'BACD', 'BADC', 'BDAC', 'CBDA', 'DBCA', 'DCAB',
]

missing = ''
for i in range(4):
    cnt = [0] * 4
    for j in range(len(perms)):
        cnt[ord(perms[j][i]) - ord('A')] += 1
    for j in range(4):
        if cnt[j] != math.factorial(4-1):
            missing += chr(ord('A') + j)
            break

print(missing)
===
V perms = [‘ABCD’, ‘CABD’, ‘ACDB’, ‘DACB’, ‘BCDA’, ‘ACBD’, ‘ADCB’, ‘CDAB’, ‘DABC’, ‘BCAD’, ‘CADB’, ‘CDBA’, ‘CBAD’, ‘ABDC’, ‘ADBC’, ‘BDCA’, ‘DCBA’, ‘BACD’, ‘BADC’, ‘BDAC’, ‘CBDA’, ‘DBCA’, ‘DCAB’]

V missing = ‘’
L(i) 4
   V cnt = [0] * 4
   L(j) 0 .< perms.len
      cnt[perms[j][i].code - ‘A’.code]++
   L(j) 4
      I cnt[j] != factorial(4 - 1)
         missing ‘’= Char(code' ‘A’.code + j)
         L.break

print(missing)
===
auto perms = create_array({u"ABCD"_S, u"CABD"_S, u"ACDB"_S, u"DACB"_S, u"BCDA"_S, u"ACBD"_S, u"ADCB"_S, u"CDAB"_S, u"DABC"_S, u"BCAD"_S, u"CADB"_S, u"CDBA"_S, u"CBAD"_S, u"ABDC"_S, u"ADBC"_S, u"BDCA"_S, u"DCBA"_S, u"BACD"_S, u"BADC"_S, u"BDAC"_S, u"CBDA"_S, u"DBCA"_S, u"DCAB"_S});

auto missing = u""_S;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (int i = 0; i < 4; i++) {
            auto cnt = create_array({0}) * 4;
            for (auto j : range_el(0, perms.len()))
                cnt[perms[j][i].code - u'A'_C.code]++;
            for (int j = 0; j < 4; j++)
                if (cnt[j] != factorial(4 - 1)) {
                    missing &= Char(u'A'_C.code + j);
                    break;
                }
        }

        print(missing);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Five_weekends
import datetime

def five_weekends_per_month(years):
    dates : List[datetime.date] = []
    for year in years:
        for month in range(1, 13):
            sd = datetime.date(year, month, 1)
            d = sd
            c = [0] * 7
            while int(d.strftime('%m')) == month:
                c[int(d.strftime('%w'))] += 1
                d += datetime.timedelta(days = 1)
            if c[0] == 5 and c[5] == 5 and c[6] == 5:
                dates += [sd]
    return dates

dates = five_weekends_per_month(range(2000, 2101))

print('There are %s months of which the first and last five are:' % (len(dates)))
indent = '  '
fmt = '%Y %m(%B)'
print(indent +('\n'+indent).join(d.strftime(fmt) for d in dates[:5]))
print(indent +'...')
print(indent +('\n'+indent).join(d.strftime(fmt) for d in dates[-5:]))

print('\nThere are %i years in the range that do not have months with five weekends'
      % (len(set(range(2000, 2101)) - {int(d.strftime('%Y')) for d in dates})))
===
F five_weekends_per_month(years)
   [Time] dates
   L(year) years
      L(month) 1..12
         V sd = Time(year, month, 1)
         V d = sd
         V c = [0] * 7
         L Int(d.strftime(‘%m’)) == month
            c[Int(d.strftime(‘%w’))]++
            d += TimeDelta(days' 1)
         I c[0] == 5 & c[5] == 5 & c[6] == 5
            dates [+]= sd
   R dates

V dates = five_weekends_per_month(2000..2100)

print(‘There are #. months of which the first and last five are:’.format(dates.len))
V indent = ‘  ’
V fmt = ‘%Y %m(%B)’
print(indent‘’dates[0.<5].map(d -> d.strftime(:fmt)).join("\n"indent))
print(indent‘...’)
print(indent‘’dates[(len)-5 ..].map(d -> d.strftime(:fmt)).join("\n"indent))

print("\nThere are #. years in the range that do not have months with five weekends".format((Set(2000..2100) - Set(dates.map(d -> Int(d.strftime(‘%Y’))))).len))
===
template <typename T1> auto five_weekends_per_month(const T1 &years)
{
    Array<Time> dates;
    for (auto &&year : years)
        for (auto month : range_ee(1, 12)) {
            auto sd = Time(year, month, 1);
            auto d = sd;
            auto c = create_array({0}) * 7;
            while (to_int(d.strftime(u"%m"_S)) == month) {
                c[to_int(d.strftime(u"%w"_S))]++;
                d += TimeDelta(1);
            }
            if (_get<0>(c) == 5 && _get<5>(c) == 5 && _get<6>(c) == 5)
                dates.append(sd);
        }
    return dates;
}

auto dates = five_weekends_per_month(range_ee(2000, 2100));

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"There are #. months of which the first and last five are:"_S.format(dates.len()));
    }
} code_block_1;

auto indent = u"  "_S;
auto fmt = u"%Y %m(%B)"_S;

struct CodeBlock2
{
    CodeBlock2()
    {
        print(indent & dates[range_el(0, 5)].map([](const auto &d){return d.strftime(::fmt);}).join(u"\n"_S & indent));
        print(indent & u"..."_S);
        print(indent & dates[range_elen_i( - 5)].map([](const auto &d){return d.strftime(::fmt);}).join(u"\n"_S & indent));

        print(u"\nThere are #. years in the range that do not have months with five weekends"_S.format((create_set(range_ee(2000, 2100)) - create_set(dates.map([](const auto &d){return to_int(d.strftime(u"%Y"_S));}))).len()));
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Fivenum#Python
import math

def fivenum(array):
    n = len(array)
    x = sorted(array)

    n4 = math.floor((n+3.0)/2.0)/2.0
    d = [1.0, n4, (n+1)/2, n+1-n4, float(n)]
    sum_array : List[float] = []

    for e in range(5):
        fl = int(math.floor(d[e] - 1))
        ce = int(math.ceil(d[e] - 1))
        sum_array.append(0.5 * (x[fl] + x[ce]))

    return sum_array

x = [0.14082834, 0.09748790, 1.73131507, 0.87636009, -1.95059594, 0.73438555, -0.03035726, 1.46675970,
-0.74621349, -0.72588772, 0.63905160, 0.61501527, -0.98983780, -1.00447874, -0.62759469, 0.66206163,
1.04312009, -0.10305385, 0.75775634, 0.32566578]

print(fivenum(x))
===
F fivenum(array)
   V n = array.len
   V x = sorted(array)

   V n4 = floor((n + 3.0) / 2.0) / 2.0
   V d = [1.0, n4, (n + 1) / 2, n + 1 - n4, Float(n)]
   [Float] sum_array

   L(e) 5
      V fl = Int(floor(d[e] - 1))
      V ce = Int(ceil(d[e] - 1))
      sum_array.append(0.5 * (x[fl] + x[ce]))

   R sum_array

V x = [0.14082834, 0.09748790, 1.73131507, 0.87636009, -1.95059594, 0.73438555, -0.03035726, 1.46675970, -0.74621349, -0.72588772, 0.63905160, 0.61501527, -0.98983780, -1.00447874, -0.62759469, 0.66206163, 1.04312009, -0.10305385, 0.75775634, 0.32566578]

print(fivenum(x))
===
template <typename T1> auto fivenum(const T1 &array)
{
    auto n = array.len();
    auto x = sorted(array);

    auto n4 = floor((n + 3.0) / 2.0) / 2.0;
    auto d = create_array({1.0, n4, (n + 1) / 2.0, n + 1 - n4, to_float(n)});
    Array<double> sum_array;

    for (int e = 0; e < 5; e++) {
        auto fl = to_int(floor(d[e] - 1));
        auto ce = to_int(ceil(d[e] - 1));
        sum_array.append(0.5 * (x[fl] + x[ce]));
    }

    return sum_array;
}

auto x = create_array({0.14082834, 0.09748790, 1.73131507, 0.87636009, -1.95059594, 0.73438555, -0.03035726, 1.46675970, -0.74621349, -0.72588772, 0.63905160, 0.61501527, -0.98983780, -1.00447874, -0.62759469, 0.66206163, 1.04312009, -0.10305385, 0.75775634, 0.32566578});

struct CodeBlock1
{
    CodeBlock1()
    {
        print(fivenum(x));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Floyd%27s_triangle#Python
def floyd(rowcount):
    rows = [[1]]
    while len(rows) < rowcount:
        n = rows[-1][-1] + 1
        rows.append(list(range(n, n + len(rows[-1]) + 1)))
    return rows

def pfloyd(rows):
    colspace = [len(str(n)) for n in rows[-1]]
    for row in rows:
        print(' '.join(str(n).rjust(space) for space, n in zip(colspace, row)))

pfloyd(floyd(5))
pfloyd(floyd(14))
===
F floyd(rowcount)
   V rows = [[1]]
   L rows.len < rowcount
      V n = rows.last.last + 1
      rows.append(Array(n .. n + rows.last.len))
   R rows

F pfloyd(rows)
   V colspace = rows.last.map(n -> String(n).len)
   L(row) rows
      print(zip(colspace, row).map((space, n) -> String(n).rjust(space)).join(‘ ’))

pfloyd(floyd(5))
pfloyd(floyd(14))
===
template <typename T1> auto floyd(const T1 &rowcount)
{
    auto rows = create_array({create_array({1})});
    while (rows.len() < rowcount) {
        auto n = rows.last().last() + 1;
        rows.append(create_array(range_ee(n, n + rows.last().len())));
    }
    return rows;
}

template <typename T1> auto pfloyd(const T1 &rows)
{
    auto colspace = rows.last().map([](const auto &n){return String(n).len();});
    for (auto &&row : rows)
        print(zip(colspace, row).map([](const auto &space, const auto &n){return String(n).rjust(space);}).join(u" "_S));
}

struct CodeBlock1
{
    CodeBlock1()
    {
        pfloyd(floyd(5));
        pfloyd(floyd(14));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Floyd-Warshall_algorithm#Python
from itertools import product

def floyd_warshall(n, edge):
    rn = range(n)
    dist = [[1_000_000] * n for i in rn]
    nxt  = [[0]         * n for i in rn]
    for i in rn:
        dist[i][i] = 0
    for u, v, w in edge:
        dist[u-1][v-1] = w
        nxt[u-1][v-1] = v-1
    for k, i, j in product(rn, rn, rn):
        sum_ik_kj = dist[i][k] + dist[k][j]
        if dist[i][j] > sum_ik_kj:
            dist[i][j] = sum_ik_kj
            nxt[i][j]  = nxt[i][k]
    print("pair      dist     path")
    for i, j in product(rn, rn):
        if i != j:
            path = [i]
            while path[-1] != j:
                path.append(nxt[path[-1]][j])
            print("%d -> %d  %4d       %s"
                  % (i + 1, j + 1, dist[i][j],
                     ' -> '.join(str(p + 1) for p in path)))

floyd_warshall(4, [(1, 3, -2), (2, 1, 4), (2, 3, 3), (3, 4, 2), (4, 2, -1)])
===
F floyd_warshall(n, edge)
   V rn = 0 .< n
   V dist = rn.map(i -> [1'000'000] * @n)
   V nxt = rn.map(i -> [0] * @n)
   L(i) rn
      dist[i][i] = 0
   L(u, v, w) edge
      dist[u - 1][v - 1] = w
      nxt[u - 1][v - 1] = v - 1
   L(k, i, j) cart_product(rn, rn, rn)
      V sum_ik_kj = dist[i][k] + dist[k][j]
      I dist[i][j] > sum_ik_kj
         dist[i][j] = sum_ik_kj
         nxt[i][j] = nxt[i][k]
   print(‘pair      dist     path’)
   L(i, j) cart_product(rn, rn)
      I i != j
         V path = [i]
         L path.last != j
            path.append(nxt[path.last][j])
         print(‘#. -> #.  #4       #.’.format(i + 1, j + 1, dist[i][j], path.map(p -> String(p + 1)).join(‘ -> ’)))

floyd_warshall(4, [(1, 3, -2), (2, 1, 4), (2, 3, 3), (3, 4, 2), (4, 2, -1)])
===
template <typename T1, typename T2> auto floyd_warshall(const T1 &n, const T2 &edge)
{
    auto rn = range_el(0, n);
    auto dist = rn.map([&n](const auto &i){return create_array({1'000'000}) * n;});
    auto nxt = rn.map([&n](const auto &i){return create_array({0}) * n;});
    for (auto &&i : rn)
        dist[i].set(i, 0);
    for (auto &&[u, v, w] : edge) {
        dist[u - 1].set(v - 1, w);
        nxt[u - 1].set(v - 1, v - 1);
    }
    for (auto &&[k, i, j] : cart_product(rn, rn, rn)) {
        auto sum_ik_kj = dist[i][k] + dist[k][j];
        if (dist[i][j] > sum_ik_kj) {
            dist[i].set(j, sum_ik_kj);
            nxt[i].set(j, nxt[i][k]);
        }
    }
    print(u"pair      dist     path"_S);
    for (auto &&[i, j] : cart_product(rn, rn))
        if (i != j) {
            auto path = create_array({i});
            while (path.last() != j)
                path.append(nxt[path.last()][j]);
            print(u"#. -> #.  #4       #."_S.format(i + 1, j + 1, dist[i][j], path.map([](const auto &p){return String(p + 1);}).join(u" -> "_S)));
        }
}

struct CodeBlock1
{
    CodeBlock1()
    {
        floyd_warshall(4, create_array({make_tuple(1, 3, -2), make_tuple(2, 1, 4), make_tuple(2, 3, 3), make_tuple(3, 4, 2), make_tuple(4, 2, -1)}));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Formatted_numeric_output
print('%09.3f' % (7.125))
===
print(‘#05.3’.format(7.125))
===
struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"#05.3"_S.format(7.125));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Forward_difference#Python
from typing import List

dif = lambda s: [x-s[i] for i,x in enumerate(s[1:])]
def difn(s, n) -> List[int]:
    return difn(dif(s), n-1) if n != 0 else s

s = [90, 47, 58, 29, 22, 32, 55, 5, 55, 73]
for i in range(10):
    print(difn(s, i))
===
V dif = s -> enumerate(s[1..]).map((i, x) -> x - @s[i])
F difn(s, n) -> [Int]
   R I n != 0 {difn(dif(s), n - 1)} E s

V s = [90, 47, 58, 29, 22, 32, 55, 5, 55, 73]
L(i) 10
   print(difn(s, i))
===
auto dif = [](const auto &s){return enumerate(s[range_ei(1)]).map([&s](const auto &i, const auto &x){return x - s[i];});};
template <typename T1, typename T2> Array<int> difn(const T1 &s, const T2 &n)
{
    return n != 0 ? difn(dif(s), n - 1) : s;
}

auto s = create_array({90, 47, 58, 29, 22, 32, 55, 5, 55, 73});

struct CodeBlock1
{
    CodeBlock1()
    {
        for (int i = 0; i < 10; i++)
            print(difn(s, i));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Four_bit_adder#Python
def xor_(a, b): return (a and not b) or (b and not a)

def ha(a, b): return (xor_(a, b), a and b)     # sum, carry

def fa(a, b, ci):
    (s0, c0) = ha(ci, a)
    (s1, c1) = ha(s0, b)
    return (s1, c0 or c1)     # sum, carry

def fa4(a, b):
    width = 4
    ci = [False] * width
    co = [False] * width
    s  = [False] * width
    for i in range(width):
        (s[i], co[i]) = fa(a[i], b[i], co[i-1] if i != 0 else 0)
    return (s, co[-1])

def int2bus(n, width=4):
    return [int(c) for c in bin(n)[2:].zfill(width)[::-1]]

def bus2int(b):
    return sum(1 << i for i, bit in enumerate(b) if bit)

width = 4
tot = [False] * (width + 1)
for a in range(2**width):
    for b in range(2**width):
        (ta, tlast) = fa4(int2bus(a), int2bus(b))
     #[-(ta, tot[width]) = fa4(int2bus(a), int2bus(b))-]
        for i in range(width):
            tot[i] = ta[i]
        tot[width] = tlast
        assert a + b == bus2int(tot), "totals don't match: %i + %i != %s" % (a, b, tot)
===
F xor_(a, b)
   R (a & !b) | (b & !a)

F ha(a, b)
   R (xor_(a, b), a & b)

F fa(a, b, ci)
   V (s0, c0) = ha(ci, a)
   V (s1, c1) = ha(s0, b)
   R (s1, c0 | c1)

F fa4(a, b)
   V width = 4
   V ci = [0B] * width
   V co = [0B] * width
   V s = [0B] * width
   L(i) 0 .< width
      (s[i], co[i]) = fa(a[i], b[i], I i != 0 {co[i - 1]} E 0)
   R (s, co.last)

F int2bus(n, width = 4)
   R reversed(bin(n).zfill(width)).map(c -> Int(c))

F bus2int(b)
   R sum(enumerate(b).filter((i, bit) -> bit).map((i, bit) -> 1 << i))

V width = 4
V tot = [0B] * (width + 1)
L(a) 0 .< 2 ^ width
   L(b) 0 .< 2 ^ width
      V (ta, tlast) = fa4(int2bus(a), int2bus(b))
      L(i) 0 .< width
         tot[i] = ta[i]
      tot[width] = tlast
      assert(a + b == bus2int(tot), ‘totals don't match: #. + #. != #.’.format(a, b, tot))
===
template <typename T1, typename T2> auto xor_(const T1 &a, const T2 &b)
{
    return (a && !b) || (b && !a);
}

template <typename T1, typename T2> auto ha(const T1 &a, const T2 &b)
{
    return make_tuple(xor_(a, b), a && b);
}

template <typename T1, typename T2, typename T3> auto fa(const T1 &a, const T2 &b, const T3 &ci)
{
    auto [s0, c0] = ha(ci, a);
    auto [s1, c1] = ha(s0, b);
    return make_tuple(s1, c0 || c1);
}

template <typename T1, typename T2> auto fa4(const T1 &a, const T2 &b)
{
    auto width = 4;
    auto ci = create_array({false}) * width;
    auto co = create_array({false}) * width;
    auto s = create_array({false}) * width;
    for (auto i : range_el(0, width))
        assign_from_tuple(s[i], co[i], fa(a[i], b[i], i != 0 ? co[i - 1] : 0));
    return make_tuple(s, co.last());
}

template <typename T1, typename T2 = decltype(4)> auto int2bus(const T1 &n, const T2 &width = 4)
{
    return reversed(bin(n).zfill(width)).map([](const auto &c){return to_int(c);});
}

template <typename T1> auto bus2int(const T1 &b)
{
    return sum_map(enumerate(b).filter([](const auto &i, const auto &bit){return bit;}), [](const auto &i, const auto &bit){return 1 << i;});
}

auto width = 4;
auto tot = create_array({false}) * (width + 1);

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto a : range_el(0, pow(2, width)))
            for (auto b : range_el(0, pow(2, width))) {
                auto [ta, tlast] = fa4(int2bus(a), int2bus(b));
                for (auto i : range_el(0, width))
                    tot.set(i, ta[i]);
                tot.set(width, tlast);
                assert(a + b == bus2int(tot), u"totals don't match: #. + #. != #."_S.format(a, b, tot));
            }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Fractran#D
def fractran(prog, val, limit):
    fracts = [[int(i) for i in p.split('/')] for p in prog.split(' ')]
    r : List[float] = []
    for n in range(limit):
        r += [val]
        for p in fracts:
            if val % p[1] == 0:
                val = p[0] * val / p[1]
                break
    return r

print(fractran("17/91 78/85 19/51 23/38 29/33 77/29 95/23 77/19 1/17 11/13 13/11 15/14 15/2 55/1", 2, 15))
===
F fractran(prog, =val, limit)
   V fracts = prog.split(‘ ’).map(p -> p.split(‘/’).map(i -> Int(i)))
   [Float] r
   L(n) 0 .< limit
      r [+]= val
      L(p) fracts
         I val % p[1] == 0
            val = p[0] * val / p[1]
            L.break
   R r

print(fractran(‘17/91 78/85 19/51 23/38 29/33 77/29 95/23 77/19 1/17 11/13 13/11 15/14 15/2 55/1’, 2, 15))
===
template <typename T1, typename T2, typename T3> auto fractran(const T1 &prog, T2 val, const T3 &limit)
{
    auto fracts = prog.split(u" "_S).map([](const auto &p){return p.split(u"/"_S).map([](const auto &i){return to_int(i);});});
    Array<double> r;
    for (auto n : range_el(0, limit)) {
        r.append(val);
        for (auto &&p : fracts)
            if (mod(val, _get<1>(p)) == 0) {
                val = _get<0>(p) * val / _get<1>(p);
                break;
            }
    }
    return r;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(fractran(u"17/91 78/85 19/51 23/38 29/33 77/29 95/23 77/19 1/17 11/13 13/11 15/14 15/2 55/1"_S, 2, 15));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Function_composition#Python
import math

compose = lambda f, g: (lambda x: f( g(x) ))
sin_asin = compose(lambda x: math.sin(x), lambda x: math.asin(x))
print(sin_asin(0.5))
===
V compose = (f, g) -> (x -> @f(@g(x)))
V sin_asin = compose(x -> sin(x), x -> asin(x))
print(sin_asin(0.5))
===
auto compose = [](const auto &f, const auto &g){return ([&f, &g](const auto &x){return f(g(x));});};
auto sin_asin = compose([](const auto &x){return sin(x);}, [](const auto &x){return asin(x);});

struct CodeBlock1
{
    CodeBlock1()
    {
        print(sin_asin(0.5));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Fusc_sequence#Kotlin
def fusc(n):
    res = [0] * n
    res[1] = 1
    for i in range(2, n):
        res[i] = res[i // 2] if i % 2 == 0 else res[(i-1) // 2] + res[(i+1) // 2]
    return res

print('First 61 terms:')
print(fusc(61))

print()
print('Points in the sequence where an item has more digits than any previous items:')
f = fusc(20_000_000)
max_len = 0
for i in range(len(f)):
    if len(str(f[i])) > max_len:
        max_len = len(str(f[i]))
        print((i, f[i]))
===
F fusc(n)
   V res = [0] * n
   res[1] = 1
   L(i) 2 .< n
      res[i] = I i % 2 == 0 {res[i I/ 2]} E res[(i - 1) I/ 2] + res[(i + 1) I/ 2]
   R res

print(‘First 61 terms:’)
print(fusc(61))

print()
print(‘Points in the sequence where an item has more digits than any previous items:’)
V f = fusc(20'000'000)
V max_len = 0
L(i) 0 .< f.len
   I String(f[i]).len > max_len
      max_len = String(f[i]).len
      print((i, f[i]))
===
template <typename T1> auto fusc(const T1 &n)
{
    auto res = create_array({0}) * n;
    _set<1>(res, 1);
    for (auto i : range_el(2, n))
        res.set(i, mod(i, 2) == 0 ? res[idiv(i, 2)] : res[idiv((i - 1), 2)] + res[idiv((i + 1), 2)]);
    return res;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"First 61 terms:"_S);
        print(fusc(61));

        print();
        print(u"Points in the sequence where an item has more digits than any previous items:"_S);
    }
} code_block_1;

auto f = fusc(20'000'000);
auto max_len = 0;

struct CodeBlock2
{
    CodeBlock2()
    {
        for (auto i : range_el(0, f.len()))
            if (String(f[i]).len() > max_len) {
                max_len = String(f[i]).len();
                print(make_tuple(i, f[i]));
            }
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Gamma_function#Python
_a =    [ 1.00000000000000000000, 0.57721566490153286061, -0.65587807152025388108,
         -0.04200263503409523553, 0.16653861138229148950, -0.04219773455554433675,
         -0.00962197152787697356, 0.00721894324666309954, -0.00116516759185906511,
         -0.00021524167411495097, 0.00012805028238811619, -0.00002013485478078824,
         -0.00000125049348214267, 0.00000113302723198170, -0.00000020563384169776,
          0.00000000611609510448, 0.00000000500200764447, -0.00000000118127457049,
          0.00000000010434267117, 0.00000000000778226344, -0.00000000000369680562,
          0.00000000000051003703, -0.00000000000002058326, -0.00000000000000534812,
          0.00000000000000122678, -0.00000000000000011813, 0.00000000000000000119,
          0.00000000000000000141, -0.00000000000000000023, 0.00000000000000000002
       ]
def gamma (x):
   y  = x - 1.0
   sm = _a[-1]
   for n in range(len(_a)-2, -1, -1):
      sm = sm * y + _a[n]
   return 1.0 / sm

for i in range(1,11):
    print("%.14f" % (gamma(i/3.0)))
===
V _a = [1.00000000000000000000, 0.57721566490153286061, -0.65587807152025388108, -0.04200263503409523553, 0.16653861138229148950, -0.04219773455554433675, -0.00962197152787697356, 0.00721894324666309954, -0.00116516759185906511, -0.00021524167411495097, 0.00012805028238811619, -0.00002013485478078824, -0.00000125049348214267, 0.00000113302723198170, -0.00000020563384169776, 0.00000000611609510448, 0.00000000500200764447, -0.00000000118127457049, 0.00000000010434267117, 0.00000000000778226344, -0.00000000000369680562, 0.00000000000051003703, -0.00000000000002058326, -0.00000000000000534812, 0.00000000000000122678, -0.00000000000000011813, 0.00000000000000000119, 0.00000000000000000141, -0.00000000000000000023, 0.00000000000000000002]
F gamma(x)
   V y = x - 1.0
   V sm = :_a.last
   L(n) (:_a.len - 2 .< -1).step(-1)
      sm = sm * y + :_a[n]
   R 1.0 / sm

L(i) 1..10
   print(‘#.14’.format(gamma(i / 3.0)))
===
auto _a = create_array({1.00000000000000000000, 0.57721566490153286061, -0.65587807152025388108, -0.04200263503409523553, 0.16653861138229148950, -0.04219773455554433675, -0.00962197152787697356, 0.00721894324666309954, -0.00116516759185906511, -0.00021524167411495097, 0.00012805028238811619, -0.00002013485478078824, -0.00000125049348214267, 0.00000113302723198170, -0.00000020563384169776, 0.00000000611609510448, 0.00000000500200764447, -0.00000000118127457049, 0.00000000010434267117, 0.00000000000778226344, -0.00000000000369680562, 0.00000000000051003703, -0.00000000000002058326, -0.00000000000000534812, 0.00000000000000122678, -0.00000000000000011813, 0.00000000000000000119, 0.00000000000000000141, -0.00000000000000000023, 0.00000000000000000002});
template <typename T1> auto gamma(const T1 &x)
{
    auto y = x - 1.0;
    auto sm = ::_a.last();
    for (auto n : range_el(::_a.len() - 2, -1).step(-1))
        sm = sm * y + ::_a[n];
    return 1.0 / sm;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto i : range_ee(1, 10))
            print(u"#.14"_S.format(gamma(i / 3.0)));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/General_FizzBuzz#Python
def genfizzbuzz(factorwords, numbers):
    sfactorwords = sorted(factorwords, key=lambda p: p[0])
    lines : List[str] = []
    for num in numbers:
        words = ''.join(wrd for fact, wrd in sfactorwords if (num % fact) == 0)
        lines.append(words if words != '' else str(num))
    return '\n'.join(lines)

print(genfizzbuzz([(5, 'Buzz'), (3, 'Fizz'), (7, 'Baxx')], range(1, 21)))
===
F genfizzbuzz(factorwords, numbers)
   V sfactorwords = sorted(factorwords, key' p -> p[0])
   [String] lines
   L(num) numbers
      V words = sfactorwords.filter((fact, wrd) -> (@num % fact) == 0).map((fact, wrd) -> wrd).join(‘’)
      lines.append(I words != ‘’ {words} E String(num))
   R lines.join("\n")

print(genfizzbuzz([(5, ‘Buzz’), (3, ‘Fizz’), (7, ‘Baxx’)], 1..20))
===
template <typename T1, typename T2> auto genfizzbuzz(const T1 &factorwords, const T2 &numbers)
{
    auto sfactorwords = sorted(factorwords, [](const auto &p){return _get<0>(p);});
    Array<String> lines;
    for (auto &&num : numbers) {
        auto words = sfactorwords.filter([&num](const auto &fact, const auto &wrd){return (mod(num, fact)) == 0;}).map([](const auto &fact, const auto &wrd){return wrd;}).join(u""_S);
        lines.append(words != u"" ? words : String(num));
    }
    return lines.join(u"\n"_S);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(genfizzbuzz(create_array({make_tuple(5, u"Buzz"_S), make_tuple(3, u"Fizz"_S), make_tuple(7, u"Baxx"_S)}), range_ee(1, 20)));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Greatest_common_divisor#Python
def gcd(u, v):
    while v != 0:
        (u, v) = (v, u % v)
    return abs(u)

print(gcd(0,0))
print(gcd(0, 10))
print(gcd(0, -10))
print(gcd(9, 6))
print(gcd(6, 9))
print(gcd(-6, 9))
print(gcd(8, 45))
print(gcd(40902, 24140))
===
F gcd(=u, =v)
   L v != 0
      (u, v) = (v, u % v)
   R abs(u)

print(gcd(0, 0))
print(gcd(0, 10))
print(gcd(0, -10))
print(gcd(9, 6))
print(gcd(6, 9))
print(gcd(-6, 9))
print(gcd(8, 45))
print(gcd(40902, 24140))
===
template <typename T1, typename T2> auto gcd(T1 u, T2 v)
{
    while (v != 0)
        assign_from_tuple(u, v, make_tuple(v, mod(u, v)));
    return abs(u);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(gcd(0, 0));
        print(gcd(0, 10));
        print(gcd(0, -10));
        print(gcd(9, 6));
        print(gcd(6, 9));
        print(gcd(-6, 9));
        print(gcd(8, 45));
        print(gcd(40902, 24140));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Greatest_subsequential_sum#Python
def maxsumseq(sequence):
    (start, end, sum_start) = (-1, -1, -1)
    (maxsum_, sum_) = (0, 0)
    for i, x in enumerate(sequence):
        sum_ += x
        if maxsum_ < sum_: # found maximal subsequence so far
            maxsum_ = sum_
            (start, end) = (sum_start, i)
        elif sum_ < 0: # start new sequence
            sum_ = 0
            sum_start = i
    assert maxsum_ == sum(sequence[start + 1:end + 1])
    return sequence[start + 1:end + 1]

print(maxsumseq([-1, 2, -1]))
print(maxsumseq([-1, 2, -1, 3, -1]))
print(maxsumseq([-1, 1, 2, -5, -6]))
print(maxsumseq([-1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1]))
===
F maxsumseq(sequence)
   V (start, end, sum_start) = (-1, -1, -1)
   V (maxsum_, sum_) = (0, 0)
   L(x) sequence
      V i = L.index
      sum_ += x
      I maxsum_ < sum_
         maxsum_ = sum_
         (start, end) = (sum_start, i)
      E I sum_ < 0
         sum_ = 0
         sum_start = i
   assert(maxsum_ == sum(sequence[start + 1 .< end + 1]))
   R sequence[start + 1 .< end + 1]

print(maxsumseq([-1, 2, -1]))
print(maxsumseq([-1, 2, -1, 3, -1]))
print(maxsumseq([-1, 1, 2, -5, -6]))
print(maxsumseq([-1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1]))
===
template <typename T1> auto maxsumseq(const T1 &sequence)
{
    auto [start, end, sum_start] = make_tuple(-1, -1, -1);
    auto [maxsum_, sum_] = make_tuple(0, 0);
    {int Lindex = 0;
    for (auto &&x : sequence) {
        auto i = Lindex;
        sum_ += x;
        if (maxsum_ < sum_) {
            maxsum_ = sum_;
            assign_from_tuple(start, end, make_tuple(sum_start, i));
        }
        else if (sum_ < 0) {
            sum_ = 0;
            sum_start = i;
        }
        Lindex++;
    }}
    assert(maxsum_ == sum(sequence[range_el(start + 1, end + 1)]));
    return sequence[range_el(start + 1, end + 1)];
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(maxsumseq(create_array({-1, 2, -1})));
        print(maxsumseq(create_array({-1, 2, -1, 3, -1})));
        print(maxsumseq(create_array({-1, 1, 2, -5, -6})));
        print(maxsumseq(create_array({-1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1})));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Guess_the_number#Python
import random
t=random.randint(1,10)
g=int(input("Guess a number that's between 1 and 10: "))
while t!=g:g=int(input("Guess again! "))
print("That's right!")
===
V t = random:(1 .. 10)
V g = Int(input(‘Guess a number that's between 1 and 10: ’))
L t != g
   g = Int(input(‘Guess again! ’))
print(‘That's right!’)
===
auto t = randomns::_(range_ee(1, 10));
auto g = to_int(input(u"Guess a number that's between 1 and 10: "_S));

struct CodeBlock1
{
    CodeBlock1()
    {
        while (t != g)
            g = to_int(input(u"Guess again! "_S));
        print(u"That's right!"_S);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Hailstone_sequence#Python
def hailstone(n):
    seq = [n]
    while n>1:
        n = 3*n + 1 if n % 2 != 0 else n//2
        seq.append(n)
    return seq

h = hailstone(27)
assert len(h)==112 and h[:4]==[27, 82, 41, 124] and h[-4:]==[8, 4, 2, 1]
m = max((len(hailstone(i)), i) for i in range(1,100000))
print("Maximum length %i was found for hailstone(%i) for numbers <100,000" % (m[0], m[1]))
===
F hailstone(=n)
   V seq = [n]
   L n > 1
      n = I n % 2 != 0 {3 * n + 1} E n I/ 2
      seq.append(n)
   R seq

V h = hailstone(27)
assert(h.len == 112 & h[0.<4] == [27, 82, 41, 124] & h[(len)-4 ..] == [8, 4, 2, 1])
V m = max((1..99999).map(i -> (hailstone(i).len, i)))
print(‘Maximum length #. was found for hailstone(#.) for numbers <100,000’.format(m[0], m[1]))
===
template <typename T1> auto hailstone(T1 n)
{
    auto seq = create_array({n});
    while (n > 1) {
        n = mod(n, 2) != 0 ? 3 * n + 1 : idiv(n, 2);
        seq.append(n);
    }
    return seq;
}

auto h = hailstone(27);

struct CodeBlock1
{
    CodeBlock1()
    {
        assert(h.len() == 112 && h[range_el(0, 4)] == create_array({27, 82, 41, 124}) && h[range_elen_i( - 4)] == create_array({8, 4, 2, 1}));
    }
} code_block_1;

auto m = max_map(range_ee(1, 99999), [](const auto &i){return make_tuple(hailstone(i).len(), i);});

struct CodeBlock2
{
    CodeBlock2()
    {
        print(u"Maximum length #. was found for hailstone(#.) for numbers <100,000"_S.format(_get<0>(m), _get<1>(m)));
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Hamming_numbers#Python
def hamming(limit):
    h = [1] * limit
    (x2, x3, x5) = (2, 3, 5)
    i = 0
    j = 0
    k = 0

    for n in range(1, limit):
        h[n] = min(x2, x3, x5)
        if x2 == h[n]:
            i += 1
            x2 = 2 * h[i]
        if x3 == h[n]:
            j += 1
            x3 = 3 * h[j]
        if x5 == h[n]:
            k += 1
            x5 = 5 * h[k]

    return h[-1]

print([hamming(i) for i in range(1, 21)])
print(hamming(1691))
===
F hamming(limit)
   V h = [1] * limit
   V (x2, x3, x5) = (2, 3, 5)
   V i = 0
   V j = 0
   V k = 0

   L(n) 1 .< limit
      h[n] = min(x2, x3, x5)
      I x2 == h[n]
         i++
         x2 = 2 * h[i]
      I x3 == h[n]
         j++
         x3 = 3 * h[j]
      I x5 == h[n]
         k++
         x5 = 5 * h[k]

   R h.last

print((1..20).map(i -> hamming(i)))
print(hamming(1691))
===
template <typename T1> auto hamming(const T1 &limit)
{
    auto h = create_array({1}) * limit;
    auto [x2, x3, x5] = make_tuple(2, 3, 5);
    auto i = 0;
    auto j = 0;
    auto k = 0;

    for (auto n : range_el(1, limit)) {
        h.set(n, min(x2, x3, x5));
        if (x2 == h[n]) {
            i++;
            x2 = 2 * h[i];
        }
        if (x3 == h[n]) {
            j++;
            x3 = 3 * h[j];
        }
        if (x5 == h[n]) {
            k++;
            x5 = 5 * h[k];
        }
    }

    return h.last();
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(range_ee(1, 20).map([](const auto &i){return hamming(i);}));
        print(hamming(1691));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Happy_numbers#Python
def happy(n):
    past = set() # int
    while n != 1:
        n = sum(int(c)**2 for c in str(n))
        if n in past:
            return False
        past.add(n)
    return True

print([x for x in range(500) if happy(x)][:8])
===
F happy(=n)
   V past = Set[Int]()
   L n != 1
      n = sum(String(n).map(c -> Int(c) ^ 2))
      I n C past
         R 0B
      past.add(n)
   R 1B

print((0.<500).filter(x -> happy(x))[0.<8])
===
template <typename T1> auto happy(T1 n)
{
    auto past = Set<int>();
    while (n != 1) {
        n = sum_map(String(n), [](const auto &c){return square(to_int(c));});
        if (in(n, past))
            return false;
        past.add(n);
    }
    return true;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(range_el(0, 500).filter([](const auto &x){return happy(x);})[range_el(0, 8)]);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Harshad_or_Niven_series#Python
import itertools

def is_harshad(n):
    return n % sum(int(ch) for ch in str(n)) == 0

def harshad(num):
    r : List[int] = []
    for n in itertools.count(1):
        if is_harshad(n):
            r += [n]
            if len(r) == num:
                return r

print(harshad(20))

for n in itertools.count(1001):
    if is_harshad(n):
        print(n)
        break
===
F is_harshad(n)
   R n % sum(String(n).map(ch -> Int(ch))) == 0

F harshad(num)
   [Int] r
   L(n) 1..
      I is_harshad(n)
         r [+]= n
         I r.len == num
            R r

print(harshad(20))

L(n) 1001..
   I is_harshad(n)
      print(n)
      L.break
===
template <typename T1> auto is_harshad(const T1 &n)
{
    return mod(n, sum_map(String(n), [](const auto &ch){return to_int(ch);})) == 0;
}

template <typename T1> auto harshad(const T1 &num)
{
    Array<int> r;
    for (auto n : range_ei(1))
        if (is_harshad(n)) {
            r.append(n);
            if (r.len() == num)
                return r;
        }
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(harshad(20));

        for (auto n : range_ei(1001))
            if (is_harshad(n)) {
                print(n);
                break;
            }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Hash_from_two_arrays#Python
keys = ['a', 'b', 'c']
values = [1, 2, 3]
hash_ = dict(zip(keys, values))
print(hash_)
===
V keys = [‘a’, ‘b’, ‘c’]
V values = [1, 2, 3]
V hash_ = Dict(zip(keys, values))
print(hash_)
===
auto keys = create_array({u'a'_C, u'b'_C, u'c'_C});
auto values = create_array({1, 2, 3});
auto hash_ = create_dict(zip(keys, values));

struct CodeBlock1
{
    CodeBlock1()
    {
        print(hash_);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Hash_join#Python
import collections

def hash_join(table1, table2):
    h : DefaultDict[str, List[Tuple[int, str]]] = collections.defaultdict(list)
    # hash phase
    for s in table1:
        h[s[1]].append(s)
    # join phase
    res : List[Tuple[Tuple[int, str], Tuple[str, str]]] = []
    for r in table2:
        for s in h[r[0]]:
            res += [(s, r)]
    return res

table1 = [(27, "Jonah"),
          (18, "Alan"),
          (28, "Glory"),
          (18, "Popeye"),
          (28, "Alan")]
table2 = [("Jonah", "Whales"),
          ("Jonah", "Spiders"),
          ("Alan", "Ghosts"),
          ("Alan", "Zombies"),
          ("Glory", "Buffy")]

for row in hash_join(table1, table2):
    print(row)
===
F hash_join(table1, table2)
   DefaultDict[String, [(Int, String)]] h
   L(s) table1
      h[s[1]].append(s)
   [((Int, String), (String, String))] res
   L(r) table2
      L(s) h[r[0]]
         res [+]= (s, r)
   R res

V table1 = [(27, ‘Jonah’), (18, ‘Alan’), (28, ‘Glory’), (18, ‘Popeye’), (28, ‘Alan’)]
V table2 = [(‘Jonah’, ‘Whales’), (‘Jonah’, ‘Spiders’), (‘Alan’, ‘Ghosts’), (‘Alan’, ‘Zombies’), (‘Glory’, ‘Buffy’)]

L(row) hash_join(table1, table2)
   print(row)
===
template <typename T1, typename T2> auto hash_join(const T1 &table1, const T2 &table2)
{
    DefaultDict<String, Array<Tuple<int, String>>> h;
    for (auto &&s : table1)
        h[_get<1>(s)].append(s);
    Array<Tuple<Tuple<int, String>, Tuple<String, String>>> res;
    for (auto &&r : table2)
        for (auto &&s : h[_get<0>(r)])
            res.append(make_tuple(s, r));
    return res;
}

auto table1 = create_array({make_tuple(27, u"Jonah"_S), make_tuple(18, u"Alan"_S), make_tuple(28, u"Glory"_S), make_tuple(18, u"Popeye"_S), make_tuple(28, u"Alan"_S)});
auto table2 = create_array({make_tuple(u"Jonah"_S, u"Whales"_S), make_tuple(u"Jonah"_S, u"Spiders"_S), make_tuple(u"Alan"_S, u"Ghosts"_S), make_tuple(u"Alan"_S, u"Zombies"_S), make_tuple(u"Glory"_S, u"Buffy"_S)});

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&row : hash_join(table1, table2))
            print(row);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Heronian_triangles#Python
from typing import List, Tuple
import math

def gcd(u, v):
    while v != 0:
        (u, v) = (v, u % v)
    return abs(u)

def hero(a, b, c):
    s = (a + b + c) / 2
    a2 = s * (s - a) * (s - b) * (s - c)
    return math.sqrt(a2) if a2 > 0 else 0

def is_heronian(a, b, c):
    x = hero(a, b, c)
    return x > 0 and x.is_integer()

def gcd3(x, y, z):
    return gcd(gcd(x, y), z)

MAXSIDE = 200

h : List[Tuple[int, int, int]] = []
for x in range(1, MAXSIDE + 1):
    for y in range(x, MAXSIDE + 1):
        for z in range(y, MAXSIDE + 1):
            if (x + y > z) and gcd3(x, y, z) == 1 and is_heronian(x, y, z):
                h += [(x, y, z)]

# By increasing area, perimeter, then sides
h = sorted(h, key=lambda x: (hero(x[0], x[1], x[2]), sum(x), (x[2], x[1], x[0])))

print(
    'Primitive Heronian triangles with sides up to %i: %i' % (MAXSIDE, len(h))
)
print('\nFirst ten when ordered by increasing area, then perimeter, then maximum sides:')
print('\n'.join('  %14s perim: %3i area: %i'
                % ((x, y, z), x + y + z, hero(x, y, z)) for x, y, z in h[:10]))
print('\nAll with area 210 subject to the previous ordering:')
print('\n'.join('  %14s perim: %3i area: %i'
                % ((x, y, z), x + y + z, hero(x, y, z)) for x, y, z in h
                if hero(x, y, z) == 210))
===
F gcd(=u, =v)
   L v != 0
      (u, v) = (v, u % v)
   R abs(u)

F hero(a, b, c)
   V s = (a + b + c) / 2
   V a2 = s * (s - a) * (s - b) * (s - c)
   R I a2 > 0 {sqrt(a2)} E 0

F is_heronian(a, b, c)
   V x = hero(a, b, c)
   R x > 0 & fract(x) == 0

F gcd3(x, y, z)
   R gcd(gcd(x, y), z)

V MAXSIDE = 200

[(Int, Int, Int)] h
L(x) 1 .. MAXSIDE
   L(y) x .. MAXSIDE
      L(z) y .. MAXSIDE
         I (x + y > z) & gcd3(x, y, z) == 1 & is_heronian(x, y, z)
            h [+]= (x, y, z)

h = sorted(h, key' x -> (hero(x[0], x[1], x[2]), sum(x), (x[2], x[1], x[0])))

print(‘Primitive Heronian triangles with sides up to #.: #.’.format(MAXSIDE, h.len))
print("\nFirst ten when ordered by increasing area, then perimeter, then maximum sides:")
print(h[0.<10].map((x, y, z) -> ‘  #14 perim: #3 area: #.’.format((x, y, z), x + y + z, hero(x, y, z))).join("\n"))
print("\nAll with area 210 subject to the previous ordering:")
print(h.filter((x, y, z) -> hero(x, y, z) == 210).map((x, y, z) -> ‘  #14 perim: #3 area: #.’.format((x, y, z), x + y + z, hero(x, y, z))).join("\n"))
===
template <typename T1, typename T2> auto gcd(T1 u, T2 v)
{
    while (v != 0)
        assign_from_tuple(u, v, make_tuple(v, mod(u, v)));
    return abs(u);
}

template <typename T1, typename T2, typename T3> auto hero(const T1 &a, const T2 &b, const T3 &c)
{
    auto s = (a + b + c) / 2.0;
    auto a2 = s * (s - a) * (s - b) * (s - c);
    return a2 > 0 ? sqrt(a2) : 0;
}

template <typename T1, typename T2, typename T3> auto is_heronian(const T1 &a, const T2 &b, const T3 &c)
{
    auto x = hero(a, b, c);
    return x > 0 && fract(x) == 0;
}

template <typename T1, typename T2, typename T3> auto gcd3(const T1 &x, const T2 &y, const T3 &z)
{
    return gcd(gcd(x, y), z);
}

auto MAXSIDE = 200;

Array<ivec3> h;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto x : range_ee(1, MAXSIDE))
            for (auto y : range_ee(x, MAXSIDE))
                for (auto z : range_ee(y, MAXSIDE))
                    if ((x + y > z) && gcd3(x, y, z) == 1 && is_heronian(x, y, z))
                        h.append(make_tuple(x, y, z));

        h = sorted(h, [](const auto &x){return make_tuple(hero(_get<0>(x), _get<1>(x), _get<2>(x)), sum(x), make_tuple(_get<2>(x), _get<1>(x), _get<0>(x)));});

        print(u"Primitive Heronian triangles with sides up to #.: #."_S.format(MAXSIDE, h.len()));
        print(u"\nFirst ten when ordered by increasing area, then perimeter, then maximum sides:"_S);
        print(h[range_el(0, 10)].map([](const auto &x, const auto &y, const auto &z){return u"  #14 perim: #3 area: #."_S.format(make_tuple(x, y, z), x + y + z, hero(x, y, z));}).join(u"\n"_S));
        print(u"\nAll with area 210 subject to the previous ordering:"_S);
        print(h.filter([](const auto &x, const auto &y, const auto &z){return hero(x, y, z) == 210;}).map([](const auto &x, const auto &y, const auto &z){return u"  #14 perim: #3 area: #."_S.format(make_tuple(x, y, z), x + y + z, hero(x, y, z));}).join(u"\n"_S));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Higher-order_functions#Python
def first(function):
    return function()

def second():
    return "second"

result = first(second)
print(result)
===
F first(function)
   R function()

F second()
   R ‘second’

V result = first(second)
print(result)
===
template <typename T1> auto first(const T1 &function)
{
    return function();
}

auto second()
{
    return u"second"_S;
}

auto result = first(second);

struct CodeBlock1
{
    CodeBlock1()
    {
        print(result);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Hofstadter_Figure-Figure_sequences#Python
cR = [1]
cS = [2]

def extend_RS():
    global cS
    x = cR[len(cR) - 1] + cS[len(cR) - 1]
    cR.append(x)
    cS += range(cS[-1] + 1, x)
    cS.append(x + 1)

def ff_R(n):
    assert(n > 0)
    while n > len(cR): extend_RS()
    return cR[n - 1]

def ff_S(n):
    assert(n > 0)
    while n > len(cS): extend_RS()
    return cS[n - 1]

# tests
print([ ff_R(i) for i in range(1, 11) ])

arr = [0]*1001
for i in range(40, 0, -1):
    arr[ff_R(i)] += 1
for i in range(960, 0, -1):
    arr[ff_S(i)] += 1
if all(a == 1 for a in arr[1:1001]):
    print("All Integers 1..1000 found OK")
else:
    print("All Integers 1..1000 NOT found only once: ERROR")
===
V cR = [1]
V cS = [2]

F extend_RS()
   V x = :cR[:cR.len - 1] + :cS[:cR.len - 1]
   :cR.append(x)
   :cS [+]= :cS.last + 1 .< x
   :cS.append(x + 1)

F ff_R(n)
   assert(n > 0)
   L n > :cR.len
      extend_RS()
   R :cR[n - 1]

F ff_S(n)
   assert(n > 0)
   L n > :cS.len
      extend_RS()
   R :cS[n - 1]

print((1..10).map(i -> ff_R(i)))

V arr = [0] * 1001
L(i) (40.<0).step(-1)
   arr[ff_R(i)]++
L(i) (960.<0).step(-1)
   arr[ff_S(i)]++
I all(arr[1.<1001].map(a -> a == 1))
   print(‘All Integers 1..1000 found OK’)
E
   print(‘All Integers 1..1000 NOT found only once: ERROR’)
===
auto cR = create_array({1});
auto cS = create_array({2});

auto extend_RS()
{
    auto x = ::cR[::cR.len() - 1] + ::cS[::cR.len() - 1];
    ::cR.append(x);
    ::cS.append(range_el(::cS.last() + 1, x));
    ::cS.append(x + 1);
}

template <typename T1> auto ff_R(const T1 &n)
{
    assert(n > 0);
    while (n > ::cR.len())
        extend_RS();
    return ::cR[n - 1];
}

template <typename T1> auto ff_S(const T1 &n)
{
    assert(n > 0);
    while (n > ::cS.len())
        extend_RS();
    return ::cS[n - 1];
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(range_ee(1, 10).map([](const auto &i){return ff_R(i);}));
    }
} code_block_1;

auto arr = create_array({0}) * 1001;

struct CodeBlock2
{
    CodeBlock2()
    {
        for (auto i : range_el(40, 0).step(-1))
            arr[ff_R(i)]++;
        for (auto i : range_el(960, 0).step(-1))
            arr[ff_S(i)]++;
        if (all_map(arr[range_el(1, 1001)], [](const auto &a){return a == 1;}))
            print(u"All Integers 1..1000 found OK"_S);
        else
            print(u"All Integers 1..1000 NOT found only once: ERROR"_S);
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Hofstadter_Q_sequence#C
qseq = [0] * 100001
qseq[1] = 1
qseq[2] = 1

for i in range(3, len(qseq)):
    qseq[i] = qseq[i - qseq[i - 1]] + qseq[i - qseq[i - 2]]

print('The first 10 terms are: ' + ', '.join(str(q) for q in qseq[1:11]))
print("The 1000'th term is " + str(qseq[1000]))

less_than_preceding = 0
for i in range(2, len(qseq)):
    if qseq[i] < qseq[i-1]:
        less_than_preceding += 1
print('Times a member of the sequence is less than its preceding term: ' + str(less_than_preceding))
===
V qseq = [0] * 100001
qseq[1] = 1
qseq[2] = 1

L(i) 3 .< qseq.len
   qseq[i] = qseq[i - qseq[i - 1]] + qseq[i - qseq[i - 2]]

print(‘The first 10 terms are: ’qseq[1.<11].map(q -> String(q)).join(‘, ’))
print(‘The 1000'th term is ’String(qseq[1000]))

V less_than_preceding = 0
L(i) 2 .< qseq.len
   I qseq[i] < qseq[i - 1]
      less_than_preceding++
print(‘Times a member of the sequence is less than its preceding term: ’String(less_than_preceding))
===
auto qseq = create_array({0}) * 100001;

struct CodeBlock1
{
    CodeBlock1()
    {
        _set<1>(qseq, 1);
        _set<2>(qseq, 1);

        for (auto i : range_el(3, qseq.len()))
            qseq.set(i, qseq[i - qseq[i - 1]] + qseq[i - qseq[i - 2]]);

        print(u"The first 10 terms are: "_S & qseq[range_el(1, 11)].map([](const auto &q){return String(q);}).join(u", "_S));
        print(u"The 1000'th term is "_S & String(_get<1000>(qseq)));
    }
} code_block_1;

auto less_than_preceding = 0;

struct CodeBlock2
{
    CodeBlock2()
    {
        for (auto i : range_el(2, qseq.len()))
            if (qseq[i] < qseq[i - 1])
                less_than_preceding++;
        print(u"Times a member of the sequence is less than its preceding term: "_S & String(less_than_preceding));
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Hofstadter-Conway_$10,000_sequence#Nim
last = 1 << 20
a_list = [0] * (last+1)
a_list[0] = -50_000
a_list[1] = 1
a_list[2] = 1

v    = a_list[2]
k1   = 2
lg2  = 1
amax = 0.0

for n in range(3, last+1):
    v = a_list[v] + a_list[n-v]
    a_list[n] = v
    amax = max(amax, float(v) / n)
    if (k1 & n) == 0:
        print("Maximum between 2^%i and 2^%i was %f" % (lg2, lg2+1, amax))
        amax = 0
        lg2 += 1
    k1 = n
===
V last = 1 << 20
V a_list = [0] * (last + 1)
a_list[0] = -50'000
a_list[1] = 1
a_list[2] = 1

V v = a_list[2]
V k1 = 2
V lg2 = 1
V amax = 0.0

L(n) 3 .. last
   v = a_list[v] + a_list[n - v]
   a_list[n] = v
   amax = max(amax, Float(v) / n)
   I (k1 [&] n) == 0
      print(‘Maximum between 2^#. and 2^#. was #.6’.format(lg2, lg2 + 1, amax))
      amax = 0
      lg2++
   k1 = n
===
auto last = 1 << 20;
auto a_list = create_array({0}) * (last + 1);

struct CodeBlock1
{
    CodeBlock1()
    {
        _set<0>(a_list, -50'000);
        _set<1>(a_list, 1);
        _set<2>(a_list, 1);
    }
} code_block_1;

auto v = _get<2>(a_list);
auto k1 = 2;
auto lg2 = 1;
auto amax = 0.0;

struct CodeBlock2
{
    CodeBlock2()
    {
        for (auto n : range_ee(3, last)) {
            v = a_list[v] + a_list[n - v];
            a_list.set(n, v);
            amax = max(amax, to_float(v) / n);
            if ((k1 & n) == 0) {
                print(u"Maximum between 2^#. and 2^#. was #.6"_S.format(lg2, lg2 + 1, amax));
                amax = 0;
                lg2++;
            }
            k1 = n;
        }
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Horner%27s_rule_for_polynomial_evaluation#Python
def horner(coeffs, x):
    acc = 0
    for c in reversed(coeffs):
        acc = acc * x + c
    return acc

print(horner([-19, 7, -4, 6], 3))
===
F horner(coeffs, x)
   V acc = 0
   L(c) reversed(coeffs)
      acc = acc * x + c
   R acc

print(horner([-19, 7, -4, 6], 3))
===
template <typename T1, typename T2> auto horner(const T1 &coeffs, const T2 &x)
{
    auto acc = 0;
    for (auto &&c : reversed(coeffs))
        acc = acc * x + c;
    return acc;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(horner(create_array({-19, 7, -4, 6}), 3));
    }
} code_block_1;


# SKIPPY (takes too much time)
# https://www.rosettacode.org/wiki/Humble_numbers#C.2B.2B
import collections

def is_humble(i):
    if i <= 1: return True
    if i % 2 == 0: return is_humble(i // 2)
    if i % 3 == 0: return is_humble(i // 3)
    if i % 5 == 0: return is_humble(i // 5)
    if i % 7 == 0: return is_humble(i // 7)
    return False

humble = collections.defaultdict(int) # int
limit = 0x7FFF
count = 0
num = 1

while count < limit:
    if is_humble(num):
        humble[len(str(num))] += 1
        if count < 50:
            print(num, end = ' ')
        count += 1
    num += 1

print()
print()
print('Of the first ' + str(count) + ' humble numbers:')

for num in range(1, len(humble) - 1):
    if num not in humble:
        break
    print("%5d have %d digits" % (humble[num], num))
===
F is_humble(i)
   I i <= 1
      R 1B
   I i % 2 == 0
      R is_humble(i I/ 2)
   I i % 3 == 0
      R is_humble(i I/ 3)
   I i % 5 == 0
      R is_humble(i I/ 5)
   I i % 7 == 0
      R is_humble(i I/ 7)
   R 0B

V humble = DefaultDict[Int, Int]()
V limit = 7F'FF
V count = 0
V num = 1

L count < limit
   I is_humble(num)
      humble[String(num).len]++
      I count < 50
         print(num, end' ‘ ’)
      count++
   num++

print()
print()
print(‘Of the first ’String(count)‘ humble numbers:’)

L(num) 1 .< humble.len - 1
   I num !C humble
      L.break
   print(‘#5 have #. digits’.format(humble[num], num))
===
template <typename T1> auto is_humble(const T1 &i)
{
    if (i <= 1)
        return true;
    if (mod(i, 2) == 0)
        return is_humble(idiv(i, 2));
    if (mod(i, 3) == 0)
        return is_humble(idiv(i, 3));
    if (mod(i, 5) == 0)
        return is_humble(idiv(i, 5));
    if (mod(i, 7) == 0)
        return is_humble(idiv(i, 7));
    return false;
}

auto humble = DefaultDict<int, int>();
auto limit = 0x7F'FF;
auto count = 0;
auto num = 1;

struct CodeBlock1
{
    CodeBlock1()
    {
        while (count < limit) {
            if (is_humble(num)) {
                humble[String(num).len()]++;
                if (count < 50)
                    print(num, u" "_S);
                count++;
            }
            num++;
        }

        print();
        print();
        print(u"Of the first "_S & String(count) & u" humble numbers:"_S);

        for (auto num : range_el(1, humble.len() - 1)) {
            if (!in(num, humble))
                break;
            print(u"#5 have #. digits"_S.format(humble[num], num));
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Identity_matrix#Python
def identity_matrix(size):
    matrix = [[0]*size for i in range(size)]
    #matrix = [[0] * size] * size    #Has a flaw. See http://stackoverflow.com/questions/240178/unexpected-feature-in-a-python-list-of-lists

    for i in range(size):
        matrix[i][i] = 1

    return matrix

for row in identity_matrix(3):
    print(row)
===
F identity_matrix(size)
   V matrix = [[0] * size] * size

   L(i) 0 .< size
      matrix[i][i] = 1

   R matrix

L(row) identity_matrix(3)
   print(row)
===
template <typename T1> auto identity_matrix(const T1 &size)
{
    auto matrix = create_array({create_array({0}) * size}) * size;

    for (auto i : range_el(0, size))
        matrix[i].set(i, 1);

    return matrix;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&row : identity_matrix(3))
            print(row);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/IBAN#Python
import re

def mod97(numberstring):
    segstart = 0
    step = 9
    prepended = ''
    number = 0
    while segstart < len(numberstring) - step:
        number = int(prepended + numberstring[segstart:segstart+step])
        remainder = number % 97
        prepended =  str(remainder)
        if remainder < 10:
            prepended = "0" + prepended
        segstart += step
        step = 7
    number = int(prepended + numberstring[segstart:])
    return number % 97

country2length = {'IS': 26, 'IT': 27, 'MT': 31, 'MU': 30, 'MR': 27, 'MK': 19, 'IE': 22, 'MD': 24,
                  'ME': 22, 'MC': 27, 'IL': 23, 'DE': 22, 'DO': 28, 'DK': 18, 'PK': 24, 'HR': 21,
                  'HU': 28, 'FI': 18, 'LU': 20, 'LT': 20, 'LV': 21, 'KW': 30, 'LI': 21, 'PS': 29,
                  'PT': 25, 'LB': 28, 'GB': 22, 'GE': 22, 'CR': 21, 'TR': 26, 'GI': 23, 'GL': 18,
                  'CY': 28, 'CZ': 24, 'GR': 27, 'GT': 28, 'KZ': 20, 'TN': 24, 'CH': 21, 'SE': 24,
                  'SA': 24, 'SM': 27, 'SI': 19, 'SK': 24, 'PL': 28, 'BR': 29, 'FR': 27, 'FO': 18,
                  'BA': 20, 'BG': 22, 'BE': 16, 'BH': 22, 'VG': 24, 'RO': 24, 'RS': 22, 'NO': 15,
                  'NL': 18, 'AZ': 28, 'EE': 20, 'AT': 20, 'ES': 24, 'AL': 28, 'AD': 24, 'AE': 23}

def valid_iban(iban_):
    # Ensure upper alphanumeric input.
    iban = iban_.replace(' ','').replace('\t','')
    if not re.match(r'[\dA-Z]+$', iban):
        return False
    # Validate country code against expected length.
    if len(iban) != country2length[iban[:2]]:
        return False
    # Shift and convert.
    iban = iban[4:] + '' + iban[:4]
    return mod97(''.join(str(int(ch, 36)) for ch in iban)) == 1 #BASE 36: 0..9,A..Z -> 0..35

for account in ["GB82 WEST 1234 5698 7654 32", "GB82 TEST 1234 5698 7654 32"]:
    print('%s validation is: %s' % (account, valid_iban(account)))
===
F mod97(numberstring)
   V segstart = 0
   V step = 9
   V prepended = ‘’
   V number = 0
   L segstart < numberstring.len - step
      number = Int(prepended‘’numberstring[segstart .< segstart + step])
      V remainder = number % 97
      prepended = String(remainder)
      I remainder < 10
         prepended = ‘0’prepended
      segstart += step
      step = 7
   number = Int(prepended‘’numberstring[segstart ..])
   R number % 97

V country2length = [‘IS’ = 26, ‘IT’ = 27, ‘MT’ = 31, ‘MU’ = 30, ‘MR’ = 27, ‘MK’ = 19, ‘IE’ = 22, ‘MD’ = 24, ‘ME’ = 22, ‘MC’ = 27, ‘IL’ = 23, ‘DE’ = 22, ‘DO’ = 28, ‘DK’ = 18, ‘PK’ = 24, ‘HR’ = 21, ‘HU’ = 28, ‘FI’ = 18, ‘LU’ = 20, ‘LT’ = 20, ‘LV’ = 21, ‘KW’ = 30, ‘LI’ = 21, ‘PS’ = 29, ‘PT’ = 25, ‘LB’ = 28, ‘GB’ = 22, ‘GE’ = 22, ‘CR’ = 21, ‘TR’ = 26, ‘GI’ = 23, ‘GL’ = 18, ‘CY’ = 28, ‘CZ’ = 24, ‘GR’ = 27, ‘GT’ = 28, ‘KZ’ = 20, ‘TN’ = 24, ‘CH’ = 21, ‘SE’ = 24, ‘SA’ = 24, ‘SM’ = 27, ‘SI’ = 19, ‘SK’ = 24, ‘PL’ = 28, ‘BR’ = 29, ‘FR’ = 27, ‘FO’ = 18, ‘BA’ = 20, ‘BG’ = 22, ‘BE’ = 16, ‘BH’ = 22, ‘VG’ = 24, ‘RO’ = 24, ‘RS’ = 22, ‘NO’ = 15, ‘NL’ = 18, ‘AZ’ = 28, ‘EE’ = 20, ‘AT’ = 20, ‘ES’ = 24, ‘AL’ = 28, ‘AD’ = 24, ‘AE’ = 23]

F valid_iban(iban_)
   V iban = iban_.replace(‘ ’, ‘’).replace("\t", ‘’)
   I !re:‘[\dA-Z]+’.match(iban)
      R 0B
   I iban.len != :country2length[iban[0.<2]]
      R 0B
   iban = iban[4..]‘’iban[0.<4]
   R mod97(iban.map(ch -> String(Int(ch, radix' 36))).join(‘’)) == 1

L(account) [‘GB82 WEST 1234 5698 7654 32’, ‘GB82 TEST 1234 5698 7654 32’]
   print(‘#. validation is: #.’.format(account, valid_iban(account)))
===
template <typename T1> auto mod97(const T1 &numberstring)
{
    auto segstart = 0;
    auto step = 9;
    auto prepended = u""_S;
    auto number = 0;
    while (segstart < numberstring.len() - step) {
        number = to_int(prepended & numberstring[range_el(segstart, segstart + step)]);
        auto remainder = mod(number, 97);
        prepended = String(remainder);
        if (remainder < 10)
            prepended = u"0"_S & prepended;
        segstart += step;
        step = 7;
    }
    number = to_int(prepended & numberstring[range_ei(segstart)]);
    return mod(number, 97);
}

auto country2length = create_dict(dict_of(u"IS"_S, 26)(u"IT"_S, 27)(u"MT"_S, 31)(u"MU"_S, 30)(u"MR"_S, 27)(u"MK"_S, 19)(u"IE"_S, 22)(u"MD"_S, 24)(u"ME"_S, 22)(u"MC"_S, 27)(u"IL"_S, 23)(u"DE"_S, 22)(u"DO"_S, 28)(u"DK"_S, 18)(u"PK"_S, 24)(u"HR"_S, 21)(u"HU"_S, 28)(u"FI"_S, 18)(u"LU"_S, 20)(u"LT"_S, 20)(u"LV"_S, 21)(u"KW"_S, 30)(u"LI"_S, 21)(u"PS"_S, 29)(u"PT"_S, 25)(u"LB"_S, 28)(u"GB"_S, 22)(u"GE"_S, 22)(u"CR"_S, 21)(u"TR"_S, 26)(u"GI"_S, 23)(u"GL"_S, 18)(u"CY"_S, 28)(u"CZ"_S, 24)(u"GR"_S, 27)(u"GT"_S, 28)(u"KZ"_S, 20)(u"TN"_S, 24)(u"CH"_S, 21)(u"SE"_S, 24)(u"SA"_S, 24)(u"SM"_S, 27)(u"SI"_S, 19)(u"SK"_S, 24)(u"PL"_S, 28)(u"BR"_S, 29)(u"FR"_S, 27)(u"FO"_S, 18)(u"BA"_S, 20)(u"BG"_S, 22)(u"BE"_S, 16)(u"BH"_S, 22)(u"VG"_S, 24)(u"RO"_S, 24)(u"RS"_S, 22)(u"NO"_S, 15)(u"NL"_S, 18)(u"AZ"_S, 28)(u"EE"_S, 20)(u"AT"_S, 20)(u"ES"_S, 24)(u"AL"_S, 28)(u"AD"_S, 24)(u"AE"_S, 23));

template <typename T1> auto valid_iban(const T1 &iban_)
{
    auto iban = iban_.replace(u" "_S, u""_S).replace(u"\t"_S, u""_S);
    if (!re::_(uR"([\dA-Z]+)"_S).match(iban))
        return false;
    if (iban.len() != ::country2length[iban[range_el(0, 2)]])
        return false;
    iban = iban[range_ei(4)] & iban[range_el(0, 4)];
    return mod97(iban.map([](const auto &ch){return String(to_int(ch, 36));}).join(u""_S)) == 1;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&account : create_array({u"GB82 WEST 1234 5698 7654 32"_S, u"GB82 TEST 1234 5698 7654 32"_S}))
            print(u"#. validation is: #."_S.format(account, valid_iban(account)));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Infinity#Python
print(float('infinity'))
===
print(Float.infinity)
===
struct CodeBlock1
{
    CodeBlock1()
    {
        print(std::numeric_limits<double>::infinity());
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Index_finite_lists_of_positive_integers#Python
def rank(x): return int('a'.join(map(str, [1] + x)), 11)

def unrank(n):
    s = ''
    while n != 0: (s,n) = ("0123456789a"[n%11] + s, n//11)
    return list(map(int, s.split('a')))[1:]

l = [1, 2, 3, 10, 100, 987654321]
print(l)
n = rank(l)
print(n)
l = unrank(n)
print(l)
===
F rank(x)
   R Int(([1] [+] x).map(String).join(‘a’), radix' 11)

F unrank(=n)
   V s = ‘’
   L n != 0
      (s, n) = (‘0123456789a’[n % 11]‘’s, n I/ 11)
   R s.split(‘a’).map(Int)[1..]

V l = [1, 2, 3, 10, 100, 987654321]
print(l)
V n = rank(l)
print(n)
l = unrank(n)
print(l)
===
template <typename T1> auto rank(const T1 &x)
{
    return to_int((create_array({1}) + x).map([](const auto &x){return String(x);}).join(u"a"_S), 11);
}

template <typename T1> auto unrank(T1 n)
{
    auto s = u""_S;
    while (n != 0)
        assign_from_tuple(s, n, make_tuple(u"0123456789a"_S[mod(n, 11)] & s, idiv(n, 11)));
    return s.split(u"a"_S).map([](const auto &x){return to_int(x);})[range_ei(1)];
}

auto l = create_array({1, 2, 3, 10, 100, 987654321});

struct CodeBlock1
{
    CodeBlock1()
    {
        print(l);
    }
} code_block_1;

auto n = rank(l);

struct CodeBlock2
{
    CodeBlock2()
    {
        print(n);
        l = unrank(n);
        print(l);
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Jacobi_symbol#Python
def jacobi(a, n):
    if n <= 0:
        raise ValueError("'n' must be a positive integer.")
    if n % 2 == 0:
        raise ValueError("'n' must be odd.")
    a %= n
    result = 1
    while a != 0:
        while a % 2 == 0:
            a /= 2
            n_mod_8 = n % 8
            if n_mod_8 in (3, 5):
                result = -result
        (a, n) = (n, a)
        if a % 4 == 3 and n % 4 == 3:
            result = -result
        a %= n
    if n == 1:
        return result
    else:
        return 0

# https://www.rosettacode.org/wiki/Jacobi_symbol#C
print(R'n\k|', end = '')
kmax = 21
for k in range(kmax):
    print('%3d' % k, end = '')
print("\n----", end = '')
for k in range(kmax):
    print(end = '---')
print()
for n in range(1, 22, 2):
    print('%-2d |' % n, end = '')
    for k in range(kmax):
        print('%3d' % jacobi(k, n), end = '')
    print()
===
F jacobi(=a, =n)
   I n <= 0
      X ValueError(‘'n' must be a positive integer.’)
   I n % 2 == 0
      X ValueError(‘'n' must be odd.’)
   a %= n
   V result = 1
   L a != 0
      L a % 2 == 0
         a /= 2
         V n_mod_8 = n % 8
         I n_mod_8 C (3, 5)
            result = -result
      swap(&a, &n)
      I a % 4 == 3 & n % 4 == 3
         result = -result
      a %= n
   I n == 1
      R result
   E
      R 0

print(‘n\k|’, end' ‘’)
V kmax = 21
L(k) 0 .< kmax
   print(‘#3’.format(k), end' ‘’)
print("\n----", end' ‘’)
L(k) 0 .< kmax
   print(end' ‘---’)
print()
L(n) (1.<22).step(2)
   print(‘#<2 |’.format(n), end' ‘’)
   L(k) 0 .< kmax
      print(‘#3’.format(jacobi(k, n)), end' ‘’)
   print()
===
template <typename T1, typename T2> auto jacobi(T1 a, T2 n)
{
    if (n <= 0)
        throw ValueError(u"'n' must be a positive integer."_S);
    if (mod(n, 2) == 0)
        throw ValueError(u"'n' must be odd."_S);
    a %= n;
    auto result = 1;
    while (a != 0) {
        while (mod(a, 2) == 0) {
            a /= 2;
            auto n_mod_8 = mod(n, 8);
            if (in(n_mod_8, make_tuple(3, 5)))
                result = -result;
        }
        swap(a, n);
        if (mod(a, 4) == 3 && mod(n, 4) == 3)
            result = -result;
        a %= n;
    }
    if (n == 1)
        return result;
    else
        return 0;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(uR"(n\k|)"_S, u""_S);
    }
} code_block_1;

auto kmax = 21;

struct CodeBlock2
{
    CodeBlock2()
    {
        for (auto k : range_el(0, kmax))
            print(u"#3"_S.format(k), u""_S);
        print(u"\n----"_S, u""_S);
        for (auto k : range_el(0, kmax))
            print(u""_S, u"---"_S);
        print();
        for (auto n : range_el(1, 22).step(2)) {
            print(u"#<2 |"_S.format(n), u""_S);
            for (auto k : range_el(0, kmax))
                print(u"#3"_S.format(jacobi(k, n)), u""_S);
            print();
        }
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Jaro-Winkler_distance#Python
WORDS = open("linuxwords.txt").read().split("\n")
MISSPELLINGS = [
    "accomodate",
    "definately",
    "goverment"
]

def jaro_winkler_distance(st1, st2):
    if len(st1) < len(st2):
        (st1, st2) = (st2, st1)
    len1 = len(st1)
    len2 = len(st2)
    if len2 == 0:
        return 0.0
    delta = max(0, len2 // 2 - 1)
    flag = [False for _ in range(len2)]  # flags for possible transpositions
    ch1_match : List[Char] = []
    for idx1, ch1 in enumerate(st1):
        for idx2, ch2 in enumerate(st2):
            if idx2 <= idx1 + delta and idx2 >= idx1 - delta and ch1 == ch2 and not flag[idx2]:
                flag[idx2] = True
                ch1_match.append(ch1)
                break

    matches = len(ch1_match)
    if matches == 0:
        return 1.0
    transpositions = 0
    idx1 = 0
    for idx2, ch2 in enumerate(st2):
        if flag[idx2]:
            transpositions += (ch2 != ch1_match[idx1])
            idx1 += 1

    jaro = (float(matches) / len1 + float(matches) / len2 + (matches - transpositions/2) / matches) / 3.0
    commonprefix = 0
    for i in range(min(4, len2)):
        commonprefix += (st1[i] == st2[i])

    return 1.0 - (jaro + commonprefix * 0.1 * (1 - jaro))

def within_distance(maxdistance, stri, maxtoreturn):
    arr = [w for w in WORDS if jaro_winkler_distance(stri, w) <= maxdistance]
    arr.sort(key=lambda x: jaro_winkler_distance(stri, x))
    return arr if len(arr) <= maxtoreturn else arr[:maxtoreturn]

for STR in MISSPELLINGS:
    print('\nClose dictionary words ( distance < 0.15 using Jaro-Winkler distance) to "',
          STR, '" are:\n        Word   | Distance')
    for w in within_distance(0.15, STR, 5):
        print('%14s | %6.4f' % (w, jaro_winkler_distance(STR, w)))
===
V WORDS = File(‘linuxwords.txt’).read().split("\n")
V MISSPELLINGS = [‘accomodate’, ‘definately’, ‘goverment’]

F jaro_winkler_distance(=st1, =st2)
   I st1.len < st2.len
      swap(&st1, &st2)
   V len1 = st1.len
   V len2 = st2.len
   I len2 == 0
      R 0.0
   V delta = max(0, len2 I/ 2 - 1)
   V flag = (0 .< len2).map(_ -> 0B)
   [Char] ch1_match
   L(ch1) st1
      V idx1 = L.index
      L(ch2) st2
         V idx2 = L.index
         I idx2 <= idx1 + delta & idx2 >= idx1 - delta & ch1 == ch2 & !flag[idx2]
            flag[idx2] = 1B
            ch1_match.append(ch1)
            L.break

   V matches = ch1_match.len
   I matches == 0
      R 1.0
   V transpositions = 0
   V idx1 = 0
   L(ch2) st2
      V idx2 = L.index
      I flag[idx2]
         transpositions += (ch2 != ch1_match[idx1])
         idx1++

   V jaro = (Float(matches) / len1 + Float(matches) / len2 + (matches - transpositions / 2) / matches) / 3.0
   V commonprefix = 0
   L(i) 0 .< min(4, len2)
      commonprefix += (st1[i] == st2[i])

   R 1.0 - (jaro + commonprefix * 0.1 * (1 - jaro))

F within_distance(maxdistance, stri, maxtoreturn)
   V arr = :WORDS.filter(w -> jaro_winkler_distance(@stri, w) <= @maxdistance)
   arr.sort(key' x -> jaro_winkler_distance(@stri, x))
   R I arr.len <= maxtoreturn {arr} E arr[0 .< maxtoreturn]

L(STR) MISSPELLINGS
   print("\nClose dictionary words ( distance < 0.15 using Jaro-Winkler distance) to \" "STR" \" are:\n        Word   | Distance")
   L(w) within_distance(0.15, STR, 5)
      print(‘#14 | #.4’.format(w, jaro_winkler_distance(STR, w)))
===
auto WORDS = File(u"linuxwords.txt"_S).read().split(u"\n"_S);
auto MISSPELLINGS = create_array({u"accomodate"_S, u"definately"_S, u"goverment"_S});

template <typename T1, typename T2> auto jaro_winkler_distance(T1 st1, T2 st2)
{
    if (st1.len() < st2.len())
        swap(st1, st2);
    auto len1 = st1.len();
    auto len2 = st2.len();
    if (len2 == 0)
        return 0.0;
    auto delta = max(0, idiv(len2, 2) - 1);
    auto flag = range_el(0, len2).map([](const auto &_){return false;});
    Array<Char> ch1_match;
    {int Lindex = 0;
    for (auto &&ch1 : st1) {
        auto idx1 = Lindex;
        {int Lindex = 0;
        for (auto &&ch2 : st2) {
            auto idx2 = Lindex;
            if (idx2 <= idx1 + delta && idx2 >= idx1 - delta && ch1 == ch2 && !flag[idx2]) {
                flag.set(idx2, true);
                ch1_match.append(ch1);
                break;
            }
            Lindex++;
        }}
        Lindex++;
    }}

    auto matches = ch1_match.len();
    if (matches == 0)
        return 1.0;
    auto transpositions = 0;
    auto idx1 = 0;
    {int Lindex = 0;
    for (auto &&ch2 : st2) {
        auto idx2 = Lindex;
        if (flag[idx2]) {
            transpositions += (ch2 != ch1_match[idx1]);
            idx1++;
        }
        Lindex++;
    }}

    auto jaro = (to_float(matches) / len1 + to_float(matches) / len2 + (matches - transpositions / 2.0) / matches) / 3.0;
    auto commonprefix = 0;
    for (auto i : range_el(0, min(4, len2)))
        commonprefix += (st1[i] == st2[i]);

    return 1.0 - (jaro + commonprefix * 0.1 * (1 - jaro));
}

template <typename T1, typename T2, typename T3> auto within_distance(const T1 &maxdistance, const T2 &stri, const T3 &maxtoreturn)
{
    auto arr = ::WORDS.filter([&maxdistance, &stri](const auto &w){return jaro_winkler_distance(stri, w) <= maxdistance;});
    arr.sort([&stri](const auto &x){return jaro_winkler_distance(stri, x);});
    return arr.len() <= maxtoreturn ? arr : arr[range_el(0, maxtoreturn)];
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&STR : MISSPELLINGS) {
            print(u"\nClose dictionary words ( distance < 0.15 using Jaro-Winkler distance) to \" "_S & STR & u" \" are:\n        Word   | Distance"_S);
            for (auto &&w : within_distance(0.15, STR, 5))
                print(u"#14 | #.4"_S.format(w, jaro_winkler_distance(STR, w)));
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/JortSort#Python
def jortsort(sequence):
    return list(sequence) == sorted(sequence)

def print_for_seq(seq):
    print('jortsort(%s) is %s' % (seq, jortsort(seq)))

print_for_seq([1, 2, 4, 3])
print_for_seq([14, 6, 8])
print_for_seq(['a', 'c'])
print_for_seq('CVGH')
print_for_seq('PQRST')
===
F jortsort(sequence)
   R Array(sequence) == sorted(sequence)

F print_for_seq(seq)
   print(‘jortsort(#.) is #.’.format(seq, jortsort(seq)))

print_for_seq([1, 2, 4, 3])
print_for_seq([14, 6, 8])
print_for_seq([‘a’, ‘c’])
print_for_seq(‘CVGH’)
print_for_seq(‘PQRST’)
===
template <typename T1> auto jortsort(const T1 &sequence)
{
    return create_array(sequence) == sorted(sequence);
}

template <typename T1> auto print_for_seq(const T1 &seq)
{
    print(u"jortsort(#.) is #."_S.format(seq, jortsort(seq)));
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print_for_seq(create_array({1, 2, 4, 3}));
        print_for_seq(create_array({14, 6, 8}));
        print_for_seq(create_array({u'a'_C, u'c'_C}));
        print_for_seq(u"CVGH"_S);
        print_for_seq(u"PQRST"_S);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Knapsack_problem/Bounded#Python
from typing import Dict, Tuple, List

items = {
        "sandwich":     (50,    60,     2),
        "map":          (9,     150,    1),
        "compass":      (13,    35,     1),
        "water":        (153,   200,    3),
        "glucose":      (15,    60,     2),
        "tin":          (68,    45,     3),
        "banana":       (27,    60,     3),
        "apple":        (39,    40,     3),
        "cheese":       (23,    30,     1),
        "beer":         (52,    10,     3),
        "suntan cream": (11,    70,     1),
        "camera":       (32,    30,     1),
        "t-shirt":      (24,    15,     2),
        "trousers":     (48,    10,     2),
        "umbrella":     (73,    40,     1),
        "w-trousers":   (42,    70,     1),
        "w-overcoat":   (43,    75,     1),
        "note-case":    (22,    80,     1),
        "sunglasses":   (7,     20,     1),
        "towel":        (18,    12,     2),
        "socks":        (4,     50,     1),
        "book":         (30,    10,     2),
}

item_keys = list(items.keys())

cache : Dict[Tuple[int, int], Tuple[int, List[Tuple[int, str]]]] = {}
def choose_item(weight, idx):
    best_list : List[Tuple[int, str]] = []
    if idx < 0: return (0, best_list)

    k = (weight, idx)
    if k in cache: return cache[k]

    name = item_keys[idx]
    (w, v, qty) = items[name]
    best_v = 0

    for i in range(0, qty + 1):
        wlim = weight - i * w
        if wlim < 0: break

        (val, taken) = choose_item(wlim, idx - 1)
        if val + i * v > best_v:
            best_v = val + i * v
            best_list = taken[:]
            best_list.append((i, name))

    cache[k] = (best_v, best_list)
    return (best_v, best_list)

(v, lst) = choose_item(400, len(items) - 1)
w = 0
for cnt, name in lst:
    if cnt > 0:
        print(cnt, name)
        w = w + items[name][0] * cnt

print("Total weight:", w, "Value:", v)
===
V items = [‘sandwich’ = (50, 60, 2), ‘map’ = (9, 150, 1), ‘compass’ = (13, 35, 1), ‘water’ = (153, 200, 3), ‘glucose’ = (15, 60, 2), ‘tin’ = (68, 45, 3), ‘banana’ = (27, 60, 3), ‘apple’ = (39, 40, 3), ‘cheese’ = (23, 30, 1), ‘beer’ = (52, 10, 3), ‘suntan cream’ = (11, 70, 1), ‘camera’ = (32, 30, 1), ‘t-shirt’ = (24, 15, 2), ‘trousers’ = (48, 10, 2), ‘umbrella’ = (73, 40, 1), ‘w-trousers’ = (42, 70, 1), ‘w-overcoat’ = (43, 75, 1), ‘note-case’ = (22, 80, 1), ‘sunglasses’ = (7, 20, 1), ‘towel’ = (18, 12, 2), ‘socks’ = (4, 50, 1), ‘book’ = (30, 10, 2)]

V item_keys = Array(items.keys())

[(Int, Int) = (Int, [(Int, String)])] cache
F choose_item(weight, idx)
   [(Int, String)] best_list
   I idx < 0
      R (0, best_list)

   V k = (weight, idx)
   I k C :cache
      R :cache[k]

   V name = :item_keys[idx]
   V (w, v, qty) = :items[name]
   V best_v = 0

   L(i) 0 .. qty
      V wlim = weight - i * w
      I wlim < 0
         L.break

      V (val, taken) = choose_item(wlim, idx - 1)
      I val + i * v > best_v
         best_v = val + i * v
         best_list = copy(taken)
         best_list.append((i, name))

   :cache[k] = (best_v, best_list)
   R (best_v, best_list)

V (v, lst) = choose_item(400, items.len - 1)
V w = 0
L(cnt, name) lst
   I cnt > 0
      print(cnt‘ ’name)
      w = w + items[name][0] * cnt

print(‘Total weight: ’w‘ Value: ’v)
===
auto items = create_dict(dict_of(u"sandwich"_S, make_tuple(50, 60, 2))(u"map"_S, make_tuple(9, 150, 1))(u"compass"_S, make_tuple(13, 35, 1))(u"water"_S, make_tuple(153, 200, 3))(u"glucose"_S, make_tuple(15, 60, 2))(u"tin"_S, make_tuple(68, 45, 3))(u"banana"_S, make_tuple(27, 60, 3))(u"apple"_S, make_tuple(39, 40, 3))(u"cheese"_S, make_tuple(23, 30, 1))(u"beer"_S, make_tuple(52, 10, 3))(u"suntan cream"_S, make_tuple(11, 70, 1))(u"camera"_S, make_tuple(32, 30, 1))(u"t-shirt"_S, make_tuple(24, 15, 2))(u"trousers"_S, make_tuple(48, 10, 2))(u"umbrella"_S, make_tuple(73, 40, 1))(u"w-trousers"_S, make_tuple(42, 70, 1))(u"w-overcoat"_S, make_tuple(43, 75, 1))(u"note-case"_S, make_tuple(22, 80, 1))(u"sunglasses"_S, make_tuple(7, 20, 1))(u"towel"_S, make_tuple(18, 12, 2))(u"socks"_S, make_tuple(4, 50, 1))(u"book"_S, make_tuple(30, 10, 2)));

auto item_keys = create_array(items.keys());

Dict<ivec2, Tuple<int, Array<Tuple<int, String>>>> cache;
template <typename T1, typename T2> auto choose_item(const T1 &weight, const T2 &idx)
{
    Array<Tuple<int, String>> best_list;
    if (idx < 0)
        return make_tuple(0, best_list);

    auto k = make_tuple(weight, idx);
    if (in(k, ::cache))
        return ::cache[k];

    auto name = ::item_keys[idx];
    auto [w, v, qty] = ::items[name];
    auto best_v = 0;

    for (auto i : range_ee(0, qty)) {
        auto wlim = weight - i * w;
        if (wlim < 0)
            break;
        auto [val, taken] = choose_item(wlim, idx - 1);
        if (val + i * v > best_v) {
            best_v = val + i * v;
            best_list = copy(taken);
            best_list.append(make_tuple(i, name));
        }
    }

    ::cache.set(k, make_tuple(best_v, best_list));
    return make_tuple(best_v, best_list);
}
auto [v, lst] = choose_item(400, items.len() - 1);
auto w = 0;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&[cnt, name] : lst)
            if (cnt > 0) {
                print(cnt & u" "_S & name);
                w = w + _get<0>(items[name]) * cnt;
            }

        print(u"Total weight: "_S & w & u" Value: "_S & v);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Kronecker_product#Python
# Sample 1
a1 = [[1, 2], [3, 4]]
b1 = [[0, 5], [6, 7]]

# Sample 2
a2 = [[0, 1, 0], [1, 1, 1], [0, 1, 0]]
b2 = [[1, 1, 1, 1], [1, 0, 0, 1], [1, 1, 1, 1]]

def kronecker(matrix1, matrix2):
    final_list : List[List[int]] = []
    sub_list : List[int] = []

    count = len(matrix2)

    for elem1 in matrix1:
        counter = 0
        check = 0
        while check < count:
            for num1 in elem1:
                for num2 in matrix2[counter]:
                    sub_list.append(num1 * num2)
            counter += 1
            final_list.append(sub_list)
            sub_list = []
            check +=1

    return final_list

# Result 1
result1 = kronecker(a1, b1)
for elem in result1:
    print(elem)

print("")

# Result 2
result2 = kronecker(a2, b2)
for elem in result2:
    print(elem)
===
V a1 = [[1, 2], [3, 4]]
V b1 = [[0, 5], [6, 7]]

V a2 = [[0, 1, 0], [1, 1, 1], [0, 1, 0]]
V b2 = [[1, 1, 1, 1], [1, 0, 0, 1], [1, 1, 1, 1]]

F kronecker(matrix1, matrix2)
   [[Int]] final_list
   [Int] sub_list

   V count = matrix2.len

   L(elem1) matrix1
      V counter = 0
      V check = 0
      L check < count
         L(num1) elem1
            L(num2) matrix2[counter]
               sub_list.append(num1 * num2)
         counter++
         final_list.append(sub_list)
         sub_list.drop()
         check++

   R final_list

V result1 = kronecker(a1, b1)
L(elem) result1
   print(elem)

print(‘’)

V result2 = kronecker(a2, b2)
L(elem) result2
   print(elem)
===
auto a1 = create_array({create_array({1, 2}), create_array({3, 4})});
auto b1 = create_array({create_array({0, 5}), create_array({6, 7})});

auto a2 = create_array({create_array({0, 1, 0}), create_array({1, 1, 1}), create_array({0, 1, 0})});
auto b2 = create_array({create_array({1, 1, 1, 1}), create_array({1, 0, 0, 1}), create_array({1, 1, 1, 1})});

template <typename T1, typename T2> auto kronecker(const T1 &matrix1, const T2 &matrix2)
{
    Array<Array<int>> final_list;
    Array<int> sub_list;

    auto count = matrix2.len();

    for (auto &&elem1 : matrix1) {
        auto counter = 0;
        auto check = 0;
        while (check < count) {
            for (auto &&num1 : elem1)
                for (auto &&num2 : matrix2[counter])
                    sub_list.append(num1 * num2);
            counter++;
            final_list.append(sub_list);
            sub_list.drop();
            check++;
        }
    }

    return final_list;
}

auto result1 = kronecker(a1, b1);

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&elem : result1)
            print(elem);

        print(u""_S);
    }
} code_block_1;

auto result2 = kronecker(a2, b2);

struct CodeBlock2
{
    CodeBlock2()
    {
        for (auto &&elem : result2)
            print(elem);
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Last_letter-first_letter#Python
import collections

def order_words(words):
    byfirst : DefaultDict[Char, Set[str]] = collections.defaultdict(set)
    for word in words:
        byfirst[word[0]].add( word )
    #byfirst = dict(byfirst)
    return byfirst

def linkfirst(byfirst : DefaultDict[Char, Set[str]], sofar):
    assert len(sofar) != 0
    chmatch = sofar[-1][-1]
    options = byfirst[chmatch] - set(sofar)
    #print('  linkfirst options: %r %r' % (chmatch, options))
    if len(options) == 0:
        return sofar
    else:
        alternatives = ( linkfirst(byfirst, list(sofar) + [word])
                         for word in options )
        mx = max( alternatives, key = lambda s: len(s) )
        #input('linkfirst: %r' % mx)
        return mx

def llfl(words):
    byfirst = order_words(words)
    return max( (linkfirst(byfirst, [word]) for word in words), key = lambda s: len(s) )

pokemon_str = '''audino bagon baltoy banette bidoof braviary bronzor carracosta charmeleon
cresselia croagunk darmanitan deino emboar emolga exeggcute gabite
girafarig gulpin haxorus heatmor heatran ivysaur jellicent jumpluff kangaskhan
kricketune landorus ledyba loudred lumineon lunatone machamp magnezone mamoswine
nosepass petilil pidgeotto pikachu pinsir poliwrath poochyena porygon2
porygonz registeel relicanth remoraid rufflet sableye scolipede scrafty seaking
sealeo silcoon simisear snivy snorlax spoink starly tirtouga trapinch treecko
tyrogue vigoroth vulpix wailord wartortle whismur wingull yamask'''
pokemon = pokemon_str.split()
l = llfl(pokemon)
for i in range(0, len(l), 8): print(' '.join(l[i:i+8]))
print(len(l))
===
F order_words(words)
   DefaultDict[Char, Set[String]] byfirst
   L(word) words
      byfirst[word[0]].add(word)
   R byfirst

F linkfirst(DefaultDict[Char, Set[String]] &byfirst; sofar)
   assert(!sofar.empty)
   V chmatch = sofar.last.last
   V options = byfirst[chmatch] - Set(sofar)
   I options.empty
      R sofar
   E
      V alternatives = (options.map(word -> linkfirst(&@byfirst, Array(@sofar) [+] [word])))
      V mx = max(alternatives, key' s -> s.len)
      R mx

F llfl(words)
   V byfirst = order_words(words)
   R max((words.map(word -> linkfirst(&@byfirst, [word]))), key' s -> s.len)

V pokemon_str = ‘audino bagon baltoy banette bidoof braviary bronzor carracosta charmeleon
cresselia croagunk darmanitan deino emboar emolga exeggcute gabite
girafarig gulpin haxorus heatmor heatran ivysaur jellicent jumpluff kangaskhan
kricketune landorus ledyba loudred lumineon lunatone machamp magnezone mamoswine
nosepass petilil pidgeotto pikachu pinsir poliwrath poochyena porygon2
porygonz registeel relicanth remoraid rufflet sableye scolipede scrafty seaking
sealeo silcoon simisear snivy snorlax spoink starly tirtouga trapinch treecko
tyrogue vigoroth vulpix wailord wartortle whismur wingull yamask’
V pokemon = pokemon_str.split_py()
V l = llfl(pokemon)
L(i) (0 .< l.len).step(8)
   print((l[i .< i + 8]).join(‘ ’))
print(l.len)
===
template <typename T1> auto order_words(const T1 &words)
{
    DefaultDict<Char, Set<String>> byfirst;
    for (auto &&word : words)
        byfirst[_get<0>(word)].add(word);
    return byfirst;
}

template <typename T2> auto linkfirst(DefaultDict<Char, Set<String>> &byfirst, const T2 &sofar)
{
    assert(!sofar.empty());
    auto chmatch = sofar.last().last();
    auto options = byfirst[chmatch] - create_set(sofar);
    if (options.empty())
        return sofar;
    else {
        auto alternatives = (options.map([&byfirst, &sofar](const auto &word){return linkfirst(byfirst, create_array(sofar) + create_array({word}));}));
        auto mx = max_with_key(alternatives, [](const auto &s){return s.len();});
        return mx;
    }
}

template <typename T1> auto llfl(const T1 &words)
{
    auto byfirst = order_words(words);
    return max_with_key((words.map([&byfirst](const auto &word){return linkfirst(byfirst, create_array({word}));})), [](const auto &s){return s.len();});
}

auto pokemon_str = uR"(audino bagon baltoy banette bidoof braviary bronzor carracosta charmeleon
cresselia croagunk darmanitan deino emboar emolga exeggcute gabite
girafarig gulpin haxorus heatmor heatran ivysaur jellicent jumpluff kangaskhan
kricketune landorus ledyba loudred lumineon lunatone machamp magnezone mamoswine
nosepass petilil pidgeotto pikachu pinsir poliwrath poochyena porygon2
porygonz registeel relicanth remoraid rufflet sableye scolipede scrafty seaking
sealeo silcoon simisear snivy snorlax spoink starly tirtouga trapinch treecko
tyrogue vigoroth vulpix wailord wartortle whismur wingull yamask)"_S;
auto pokemon = pokemon_str.split_py();
auto l = llfl(pokemon);

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto i : range_el(0, l.len()).step(8))
            print((l[range_el(i, i + 8)]).join(u" "_S));
        print(l.len());
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Law_of_cosines_-_triples#Python
import math

n = 13

def method1(n):
    squares = [x**2 for x in range(0, n+1)]
    sqrset = set(squares)
    tri90  = set() # Tuple[int, int, int]
    tri60  = set() # Tuple[int, int, int]
    tri120 = set() # Tuple[int, int, int]
    for a in range(1, n+1):
        a2 = squares[a]
        for b in range(1, a + 1):
            b2 = squares[b]
            c2 = a2 + b2
            if c2 in sqrset:
                tri90.add(tuple(sorted((a, b, int(math.sqrt(c2))))))
            ab = a * b
            c2 -= ab
            if c2 in sqrset:
                tri60.add(tuple(sorted((a, b, int(math.sqrt(c2))))))
            c2 += 2 * ab
            if c2 in sqrset:
                tri120.add(tuple(sorted((a, b, int(math.sqrt(c2))))))
    return [sorted(list(tri90)),
            sorted(list(tri60)),
            sorted(list(tri120))]

print('Integer triangular triples for sides 1..%d:' % n)
for angle, triples in zip([90, 60, 120], method1(n)):
    print('  %3d° has %d solutions:\n    %s' % (angle, len(triples), triples))
t60 = method1(10_000)[1]
notsame = sum(1 for a, b, c in t60 if a != b or b != c)
print('Extra credit:', notsame)
===
V n = 13

F method1(n)
   V squares = (0 .. n).map(x -> x ^ 2)
   V sqrset = Set(squares)
   V tri90 = Set[(Int, Int, Int)]()
   V tri60 = Set[(Int, Int, Int)]()
   V tri120 = Set[(Int, Int, Int)]()
   L(a) 1 .. n
      V a2 = squares[a]
      L(b) 1 .. a
         V b2 = squares[b]
         V c2 = a2 + b2
         I c2 C sqrset
            tri90.add(tuple_sorted((a, b, Int(sqrt(c2)))))
         V ab = a * b
         c2 -= ab
         I c2 C sqrset
            tri60.add(tuple_sorted((a, b, Int(sqrt(c2)))))
         c2 += 2 * ab
         I c2 C sqrset
            tri120.add(tuple_sorted((a, b, Int(sqrt(c2)))))
   R [sorted(Array(tri90)), sorted(Array(tri60)), sorted(Array(tri120))]

print(‘Integer triangular triples for sides 1..#.:’.format(n))
L(angle, triples) zip([90, 60, 120], method1(n))
   print("  #3° has #. solutions:\n    #.".format(angle, triples.len, triples))
V t60 = method1(10'000)[1]
V notsame = sum(t60.filter((a, b, c) -> a != b | b != c).map((a, b, c) -> 1))
print(‘Extra credit: ’notsame)
===
auto n = 13;

template <typename T1> auto method1(const T1 &n)
{
    auto squares = range_ee(0, n).map([](const auto &x){return square(x);});
    auto sqrset = create_set(squares);
    auto tri90 = Set<ivec3>();
    auto tri60 = Set<ivec3>();
    auto tri120 = Set<ivec3>();
    for (auto a : range_ee(1, n)) {
        auto a2 = squares[a];
        for (auto b : range_ee(1, a)) {
            auto b2 = squares[b];
            auto c2 = a2 + b2;
            if (in(c2, sqrset))
                tri90.add(tuple_sorted(make_tuple(a, b, to_int(sqrt(c2)))));
            auto ab = a * b;
            c2 -= ab;
            if (in(c2, sqrset))
                tri60.add(tuple_sorted(make_tuple(a, b, to_int(sqrt(c2)))));
            c2 += 2 * ab;
            if (in(c2, sqrset))
                tri120.add(tuple_sorted(make_tuple(a, b, to_int(sqrt(c2)))));
        }
    }
    return create_array({sorted(create_array(tri90)), sorted(create_array(tri60)), sorted(create_array(tri120))});
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"Integer triangular triples for sides 1..#.:"_S.format(n));
        for (auto &&[angle, triples] : zip(create_array({90, 60, 120}), method1(n)))
            print(u"  #3° has #. solutions:\n    #."_S.format(angle, triples.len(), triples));
    }
} code_block_1;

auto t60 = _get<1>(method1(10'000));
auto notsame = sum_map(t60.filter([](const auto &a, const auto &b, const auto &c){return a != b || b != c;}), [](const auto &a, const auto &b, const auto &c){return 1;});

struct CodeBlock2
{
    CodeBlock2()
    {
        print(u"Extra credit: "_S & notsame);
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Letter_frequency#Python
import sys, collections

def countletters(s):
    results = collections.defaultdict(int) # Char
    for char in s:
        c = char.lower()
        if 'a' <= c <= 'z':
            results[c] += 1
    return results

if __name__ == '__main__':
  for letter, count in countletters(open(sys.argv[1]).read()).items():
      print("%s=%s" % (letter, count))
===
F countletters(s)
   V results = DefaultDict[Char, Int]()
   L(char) s
      V c = char.lowercase()
      I c C ‘a’..‘z’
         results[c]++
   R results

:start:
L(letter, count) countletters(File(:argv[1]).read())
   print(‘#.=#.’.format(letter, count))
===
Array<String> argv;

template <typename T1> auto countletters(const T1 &s)
{
    auto results = DefaultDict<Char, int>();
    for (auto &&_char_ : s) {
        auto c = _char_.lowercase();
        if (in(c, range_ee(u'a'_C, u'z'_C)))
            results[c]++;
    }
    return results;
}

int MAIN_WITH_ARGV()
{
    INIT_ARGV();

    for (auto &&[letter, count] : countletters(File(_get<1>(::argv)).read()))
        print(u"#.=#."_S.format(letter, count));
}


# https://www.rosettacode.org/wiki/Long_multiplication#Python
from typing import List
Char = str

def add_with_carry(result : List[Char], addend, addendpos):
    while True:
        while len(result) < addendpos + 1:
            result.append('0')
        addend_result = str(int(addend) + int(result[addendpos]))
        addend_digits = list(addend_result)
        result[addendpos] = addend_digits.pop()

        if len(addend_digits) == 0:
            break
        addend = addend_digits.pop()
        addendpos += 1

def longhand_multiplication(multiplicand, multiplier):
    result : List[Char] = []
    for multiplicand_offset, multiplicand_digit in enumerate(reversed(multiplicand)):
        for multiplier_offset, multiplier_digit in enumerate(reversed(multiplier), start=multiplicand_offset):
            multiplication_result = str(int(multiplicand_digit) * int(multiplier_digit))

            for addend_offset, result_digit_addend in enumerate(reversed(multiplication_result), start=multiplier_offset):
                add_with_carry(result, result_digit_addend, addend_offset)

    result.reverse()
    return ''.join(result)

sixtyfour = "18446744073709551616"
print(longhand_multiplication(sixtyfour, sixtyfour))
===
F add_with_carry([Char] &result; =addend, =addendpos)
   L
      L result.len < addendpos + 1
         result.append(‘0’)
      V addend_result = String(Int(addend) + Int(result[addendpos]))
      V addend_digits = Array(addend_result)
      result[addendpos] = addend_digits.pop()

      I addend_digits.empty
         L.break
      addend = addend_digits.pop()
      addendpos++

F longhand_multiplication(multiplicand, multiplier)
   [Char] result
   L(multiplicand_digit) reversed(multiplicand)
      V multiplicand_offset = L.index
      L(multiplier_digit) reversed(multiplier)
         V multiplier_offset = L.index + multiplicand_offset
         V multiplication_result = String(Int(multiplicand_digit) * Int(multiplier_digit))

         L(result_digit_addend) reversed(multiplication_result)
            V addend_offset = L.index + multiplier_offset
            add_with_carry(&result, result_digit_addend, addend_offset)

   result.reverse()
   R result.join(‘’)

V sixtyfour = ‘18446744073709551616’
print(longhand_multiplication(sixtyfour, sixtyfour))
===
template <typename T2, typename T3> auto add_with_carry(Array<Char> &result, T2 addend, T3 addendpos)
{
    while (true) {
        while (result.len() < addendpos + 1)
            result.append(u"0"_S);
        auto addend_result = String(to_int(addend) + to_int(result[addendpos]));
        auto addend_digits = create_array(addend_result);
        result.set(addendpos, addend_digits.pop());

        if (addend_digits.empty())
            break;
        addend = addend_digits.pop();
        addendpos++;
    }
}

template <typename T1, typename T2> auto longhand_multiplication(const T1 &multiplicand, const T2 &multiplier)
{
    Array<Char> result;
    {int Lindex = 0;
    for (auto &&multiplicand_digit : reversed(multiplicand)) {
        auto multiplicand_offset = Lindex;
        {int Lindex = 0;
        for (auto &&multiplier_digit : reversed(multiplier)) {
            auto multiplier_offset = Lindex + multiplicand_offset;
            auto multiplication_result = String(to_int(multiplicand_digit) * to_int(multiplier_digit));
            {int Lindex = 0;

            for (auto &&result_digit_addend : reversed(multiplication_result)) {
                auto addend_offset = Lindex + multiplier_offset;
                add_with_carry(result, result_digit_addend, addend_offset);
                Lindex++;
            }}
            Lindex++;
        }}
        Lindex++;
    }}

    result.reverse();
    return result.join(u""_S);
}

auto sixtyfour = u"18446744073709551616"_S;

struct CodeBlock1
{
    CodeBlock1()
    {
        print(longhand_multiplication(sixtyfour, sixtyfour));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Look-and-say_sequence#Python
def lookandsay(number):
    result = ""

    repeat = number[0]
    number = number[1:]+" "
    times = 1

    for actual in number:
        if actual != repeat:
            result += str(times)+repeat
            times = 1
            repeat = actual
        else:
            times += 1

    return result

num = "1"

for i in range(10):
    print(num)
    num = lookandsay(num)
===
F lookandsay(=number)
   V result = ‘’

   V repeat = number[0]
   number = number[1..]‘ ’
   V times = 1

   L(actual) number
      I actual != repeat
         result ‘’= String(times)‘’repeat
         times = 1
         repeat = actual
      E
         times++

   R result

V num = ‘1’

L(i) 10
   print(num)
   num = lookandsay(num)
===
template <typename T1> auto lookandsay(T1 number)
{
    auto result = u""_S;

    auto repeat = _get<0>(number);
    number = number[range_ei(1)] & u" "_S;
    auto times = 1;

    for (auto &&actual : number)
        if (actual != repeat) {
            result &= String(times) & repeat;
            times = 1;
            repeat = actual;
        }
        else
            times++;

    return result;
}

auto num = u"1"_S;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (int i = 0; i < 10; i++) {
            print(num);
            num = lookandsay(num);
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Lychrel_numbers#Python
def reverse_int(num):
    return int(str(num)[::-1])

def move(obj):
    return obj

def add_reverse(num, max_iter=1000):
    (i, nums) = (0, {num})
    while True:
        (i, num) = (i+1, num + reverse_int(num))
        nums.add(num)
        if reverse_int(num) == num or i >= max_iter:
            break
    return move(nums)

def ref(obj):
    return obj

def split_roots_from_relateds(roots_and_relateds):
    roots = roots_and_relateds[:]
    i = 1
    while i < len(roots):
        this = ref(roots[i])
        if any(len(this.intersection(prev)) != 0 for prev in roots[:i]):
            roots.pop(i)
        else:
            i += 1
    root = [min(each_set) for each_set in roots]
    related = [min(each_set) for each_set in roots_and_relateds]
    related = [n for n in related if n not in root]
    return (root, related)

def find_lychrel(maxn, max_reversions):
    'Lychrel number generator'
    series = [add_reverse(n, max_reversions*2) for n in range(1, maxn + 1)]
    roots_and_relateds = [s for s in series if len(s) > max_reversions]
    return split_roots_from_relateds(roots_and_relateds)

maxn = 10000
reversion_limit = 500
print("Calculations using n = 1..%i and limiting each search to 2*%i reverse-digits-and-adds"
      % (maxn, reversion_limit))
(lychrel, l_related) = find_lychrel(maxn, reversion_limit)
print('  Number of Lychrel numbers:', len(lychrel))
print('    Lychrel numbers:', ', '.join(str(n) for n in lychrel))
print('  Number of Lychrel related:', len(l_related))
pals = [x for x in lychrel + l_related  if x == reverse_int(x)]
print('  Number of Lychrel palindromes:', len(pals))
print('    Lychrel palindromes:', ', '.join(str(n) for n in pals))
===
F reverse_int(num)
   R Int(reversed(String(num)))

F add_reverse(=num, max_iter = 1000)
   V (i, nums) = (0, Set([num]))
   L
      (i, num) = (i + 1, num + reverse_int(num))
      nums.add(num)
      I reverse_int(num) == num | i >= max_iter
         L.break
   R move(nums)

F split_roots_from_relateds(roots_and_relateds)
   V roots = copy(roots_and_relateds)
   V i = 1
   L i < roots.len
      V& this = roots[i]
      I any(roots[0 .< i].map(prev -> !@this.intersection(prev).empty))
         roots.pop(i)
      E
         i++
   V root = roots.map(each_set -> min(each_set))
   V related = roots_and_relateds.map(each_set -> min(each_set))
   related = related.filter(n -> n !C @root)
   R (root, related)

F find_lychrel(maxn, max_reversions)
   ‘Lychrel number generator’
   V series = (1 .. maxn).map(n -> add_reverse(n, @max_reversions * 2))
   V roots_and_relateds = series.filter(s -> s.len > @max_reversions)
   R split_roots_from_relateds(roots_and_relateds)

V maxn = 10000
V reversion_limit = 500
print(‘Calculations using n = 1..#. and limiting each search to 2*#. reverse-digits-and-adds’.format(maxn, reversion_limit))
V (lychrel, l_related) = find_lychrel(maxn, reversion_limit)
print(‘  Number of Lychrel numbers: ’lychrel.len)
print(‘    Lychrel numbers: ’lychrel.map(n -> String(n)).join(‘, ’))
print(‘  Number of Lychrel related: ’l_related.len)
V pals = lychrel + l_related.filter(x -> x == reverse_int(x))
print(‘  Number of Lychrel palindromes: ’pals.len)
print(‘    Lychrel palindromes: ’pals.map(n -> String(n)).join(‘, ’))
===
template <typename T1> auto reverse_int(const T1 &num)
{
    return to_int(reversed(String(num)));
}

template <typename T1, typename T2 = decltype(1000)> auto add_reverse(T1 num, const T2 &max_iter = 1000)
{
    auto [i, nums] = make_tuple(0, create_set({num}));
    while (true) {
        assign_from_tuple(i, num, make_tuple(i + 1, num + reverse_int(num)));
        nums.add(num);
        if (reverse_int(num) == num || i >= max_iter)
            break;
    }
    return std::move(nums);
}

template <typename T1> auto split_roots_from_relateds(const T1 &roots_and_relateds)
{
    auto roots = copy(roots_and_relateds);
    auto i = 1;
    while (i < roots.len()) {
        auto& _this_ = roots[i];
        if (any_map(roots[range_el(0, i)], [&_this_](const auto &prev){return !_this_.intersection(prev).empty();}))
            roots.pop(i);
        else
            i++;
    }
    auto root = roots.map([](const auto &each_set){return min(each_set);});
    auto related = roots_and_relateds.map([](const auto &each_set){return min(each_set);});
    related = related.filter([&root](const auto &n){return !in(n, root);});
    return make_tuple(root, related);
}

template <typename T1, typename T2> auto find_lychrel(const T1 &maxn, const T2 &max_reversions)
{
    u"Lychrel number generator"_S;
    auto series = range_ee(1, maxn).map([&max_reversions](const auto &n){return add_reverse(n, max_reversions * 2);});
    auto roots_and_relateds = series.filter([&max_reversions](const auto &s){return s.len() > max_reversions;});
    return split_roots_from_relateds(roots_and_relateds);
}

auto maxn = 10000;
auto reversion_limit = 500;

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"Calculations using n = 1..#. and limiting each search to 2*#. reverse-digits-and-adds"_S.format(maxn, reversion_limit));
    }
} code_block_1;

auto [lychrel, l_related] = find_lychrel(maxn, reversion_limit);

struct CodeBlock2
{
    CodeBlock2()
    {
        print(u"  Number of Lychrel numbers: "_S & lychrel.len());
        print(u"    Lychrel numbers: "_S & lychrel.map([](const auto &n){return String(n);}).join(u", "_S));
        print(u"  Number of Lychrel related: "_S & l_related.len());
    }
} code_block_2;

auto pals = lychrel + l_related.filter([](const auto &x){return x == reverse_int(x);});

struct CodeBlock3
{
    CodeBlock3()
    {
        print(u"  Number of Lychrel palindromes: "_S & pals.len());
        print(u"    Lychrel palindromes: "_S & pals.map([](const auto &n){return String(n);}).join(u", "_S));
    }
} code_block_3;


# https://www.rosettacode.org/wiki/Mandelbrot_set#Python
from functools import reduce

def mandelbrot(a):
    return reduce(lambda z, _: z * z + a, range(50), 0j)

def step(start, step, iterations):
    return (start + (i * step) for i in range(iterations))

rows = ((("*" if abs(mandelbrot(x + 1j*y)) < 2 else " ")
        for x in step(-2.0, 0.0315, 80))
        for y in step(1, -0.05, 41))

print("\n".join("".join(row) for row in rows))
===
F mandelbrot(a)
   R (0.<50).reduce(0i, (z, _) -> z * z + @a)

F step(start, step, iterations)
   R ((0 .< iterations).map(i -> @start + (i * @step)))

V rows = (step(1, -0.05, 41).map(y -> (step(-2.0, 0.0315, 80).map(x -> (I abs(mandelbrot(x + 1i * @y)) < 2 {‘*’} E ‘ ’)))))

print(rows.map(row -> row.join(‘’)).join("\n"))
===
template <typename T1> auto mandelbrot(const T1 &a)
{
    return range_el(0, 50).reduce(0i, [&a](const auto &z, const auto &_){return z * z + a;});
}

template <typename T1, typename T2, typename T3> auto step(const T1 &start, const T2 &step, const T3 &iterations)
{
    return (range_el(0, iterations).map([&start, &step](const auto &i){return start + (i * step);}));
}

auto rows = (step(1, -0.05, 41).map([](const auto &y){return (step(-2.0, 0.0315, 80).map([&y](const auto &x){return (abs(mandelbrot(x + 1i * y)) < 2 ? u"*"_S : u" "_S);}));}));

struct CodeBlock1
{
    CodeBlock1()
    {
        print(rows.map([](const auto &row){return row.join(u""_S);}).join(u"\n"_S));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Maze_generation#Python
import random

def make_maze(w = 16, h = 8):
    vis = [[0] * w + [1] for _ in range(h)] + [[1] * (w + 1)]
    ver = [["|  "] * w + [str('|')] for _ in range(h)] + [['']*0]
    hor = [["+--"] * w + [str('+')] for _ in range(h + 1)]

    def walk(x : int, y : int) -> None:
        vis[y][x] = 1

        d = [(x - 1, y), (x, y + 1), (x + 1, y), (x, y - 1)]
        random.shuffle(d)
        for xx, yy in d:
            if yy == -1: yy = len(vis) - 1
            if xx == -1: xx = len(vis[yy]) - 1
            if vis[yy][xx]: continue
            if xx == x: hor[max(y, yy)][x] = "+  "
            if yy == y: ver[y][max(x, xx)] = "   "
            walk(xx, yy)

    walk(random.randrange(w), random.randrange(h))

    s = ""
    for a, b in zip(hor, ver):
        s += ''.join(a + [str('\n')] + b + [str('\n')])
    return s

print(make_maze())
===
F make_maze(w = 16, h = 8)
   V vis = (0 .< h).map(_ -> [0] * @w [+] [1]) [+] [[1] * (w + 1)]
   V ver = (0 .< h).map(_ -> [‘|  ’] * @w [+] [String(‘|’)]) [+] [[‘’] * 0]
   V hor = (0 .. h).map(_ -> [‘+--’] * @w [+] [String(‘+’)])

   F walk(Int x, Int y) -> N
      @vis[y][x] = 1

      V d = [(x - 1, y), (x, y + 1), (x + 1, y), (x, y - 1)]
      random:shuffle(&d)
      L(=xx, =yy) d
         I yy == -1
            yy = @vis.len - 1
         I xx == -1
            xx = @vis[yy].len - 1
         I @vis[yy][xx]
            L.continue
         I xx == x
            @hor[max(y, yy)][x] = ‘+  ’
         I yy == y
            @ver[y][max(x, xx)] = ‘   ’
         @walk(xx, yy)

   walk(random:(w), random:(h))

   V s = ‘’
   L(a, b) zip(hor, ver)
      s ‘’= (a [+] [String("\n")] [+] b [+] [String("\n")]).join(‘’)
   R s

print(make_maze())
===
template <typename T1 = decltype(16), typename T2 = decltype(8)> auto make_maze(const T1 &w = 16, const T2 &h = 8)
{
    auto vis = range_el(0, h).map([&w](const auto &_){return create_array({0}) * w + create_array({1});}) + create_array({create_array({1}) * (w + 1)});
    auto ver = range_el(0, h).map([&w](const auto &_){return create_array({u"|  "_S}) * w + create_array({String(u"|"_S)});}) + create_array({create_array({u""_S}) * 0});
    auto hor = range_ee(0, h).map([&w](const auto &_){return create_array({u"+--"_S}) * w + create_array({String(u"+"_S)});});

    std::function<void(int, int)> walk = [&hor, &ver, &vis, &walk](const int x, const int y)
    {
        vis[y].set(x, 1);

        auto d = create_array({make_tuple(x - 1, y), make_tuple(x, y + 1), make_tuple(x + 1, y), make_tuple(x, y - 1)});
        randomns::shuffle(d);
        for (auto [xx, yy] : d) {
            if (yy == -1)
                yy = vis.len() - 1;
            if (xx == -1)
                xx = vis[yy].len() - 1;
            if (vis[yy][xx])
                continue;
            if (xx == x)
                hor[max(y, yy)].set(x, u"+  "_S);
            if (yy == y)
                ver[y].set(max(x, xx), u"   "_S);
            walk(xx, yy);
        }
    };

    walk(randomns::_(w), randomns::_(h));

    auto s = u""_S;
    for (auto &&[a, b] : zip(hor, ver))
        s &= (a + create_array({String(u"\n"_S)}) + b + create_array({String(u"\n"_S)})).join(u""_S);
    return s;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(make_maze());
    }
} code_block_1;


# https://www.rosettacode.org/wiki/McNuggets_problem#Python
from itertools import product
nuggets = set(range(101))
for s, n, t in product(range(100//6+1), range(100//9+1), range(100//20+1)):
    nuggets.discard(6*s + 9*n + 20*t)

print(max(nuggets))
===
V nuggets = Set(0.<101)
L(s, n, t) cart_product(0 .. 100 I/ 6, 0 .. 100 I/ 9, 0 .. 100 I/ 20)
   nuggets.discard(6 * s + 9 * n + 20 * t)

print(max(nuggets))
===
auto nuggets = create_set(range_el(0, 101));

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&[s, n, t] : cart_product(range_ee(0, idiv(100, 6)), range_ee(0, idiv(100, 9)), range_ee(0, idiv(100, 20))))
            nuggets.discard(6 * s + 9 * n + 20 * t);

        print(max(nuggets));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Middle_three_digits#Python # `.+`
def middle_three_digits(i):
    s = str(abs(i))
    assert len(s) >= 3 and len(s) % 2 == 1, "Need odd and >= 3 digits"
    mid = len(s) // 2
    return s[mid-1:mid+2]

passing = [123, 12345, 1234567, 987654321, 10001, -10001, -123, -100, 100, -12345]
failing = [1, 2, -1, -10, 2002, -2002, 0]
for x in passing + failing:
    try:
        answer = middle_three_digits(x)
        print("middle_three_digits(%s) returned: %s" % (x, answer))
    except AssertionError as error:
        print("middle_three_digits(%s) returned error: " % x + str(error))
===
F middle_three_digits(i)
   V s = String(abs(i))
   assert(s.len >= 3 & s.len % 2 == 1, ‘Need odd and >= 3 digits’)
   V mid = s.len I/ 2
   R s[mid - 1 .< mid + 2]

V passing = [123, 12345, 1234567, 987654321, 10001, -10001, -123, -100, 100, -12345]
V failing = [1, 2, -1, -10, 2002, -2002, 0]
L(x) passing [+] failing
   X.try
      V answer = middle_three_digits(x)
      print(‘middle_three_digits(#.) returned: #.’.format(x, answer))
   X.catch AssertionError error
      print(‘middle_three_digits(#.) returned error: ’.format(x)‘’String(error))
===
template <typename T1> auto middle_three_digits(const T1 &i)
{
    auto s = String(abs(i));
    assert(s.len() >= 3 && mod(s.len(), 2) == 1, u"Need odd and >= 3 digits"_S);
    auto mid = idiv(s.len(), 2);
    return s[range_el(mid - 1, mid + 2)];
}

auto passing = create_array({123, 12345, 1234567, 987654321, 10001, -10001, -123, -100, 100, -12345});
auto failing = create_array({1, 2, -1, -10, 2002, -2002, 0});

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&x : passing + failing) {
            try
            {
                auto answer = middle_three_digits(x);
                print(u"middle_three_digits(#.) returned: #."_S.format(x, answer));
            }
            catch (const AssertionError& error)
            {
                print(u"middle_three_digits(#.) returned error: "_S.format(x) & String(error));
            }
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Mind_boggling_card_trick#Python
from typing import List
import random

## 1. Cards
n = 52
Black = 'Black'
Red = 'Red'
blacks = [Black] * (n // 2)
reds = [Red] * (n // 2)
pack = blacks + reds
# Give the pack a good shuffle.
random.shuffle(pack)

## 2. Deal from the randomised pack into three stacks
black_stack : List[str] = []
red_stack : List[str] = []
discard : List[str] = []
while len(pack):
    top = pack.pop()
    if top == Black:
        black_stack.append(pack.pop())
    else:
        red_stack.append(pack.pop())
    discard.append(top)
print('(Discards:', ' '.join(d[0] for d in discard), ')\n')

## 3. Swap the same, random, number of cards between the two stacks.
# We can't swap more than the number of cards in a stack.
max_swaps = min(len(black_stack), len(red_stack))
# Randomly choose the number of cards to swap.
swap_count = random.randint(0, max_swaps)
print('Swapping', swap_count)
# Randomly choose that number of cards out of each stack to swap.
def random_partition(stack, count):
    "Partition the stack into 'count' randomly selected members and the rest"
    stack_copy = stack[:]
    random.shuffle(stack_copy)
    return (stack_copy[count:], stack_copy[:count])
    #sample = random.sample(stack, count)
    #rest = stack[:]
    #for card in sample:
    #    rest.remove(card)
    #return (rest, sample)

(black_stack, black_swap) = random_partition(black_stack, swap_count)
(red_stack, red_swap) = random_partition(red_stack, swap_count)

# Perform the swap.
black_stack += red_swap
red_stack += black_swap

## 4. Order from randomness?
if black_stack.count(Black) == red_stack.count(Red):
    print('Yeha! The mathematicians assertion is correct.')
else:
    print('Whoops - The mathematicians (or my card manipulations) are flakey')
===
V n = 52
V Black = ‘Black’
V Red = ‘Red’
V blacks = [Black] * (n I/ 2)
V reds = [Red] * (n I/ 2)
V pack = blacks [+] reds
random:shuffle(&pack)

[String] black_stack
[String] red_stack
[String] discard
L !pack.empty
   V top = pack.pop()
   I top == Black
      black_stack.append(pack.pop())
   E
      red_stack.append(pack.pop())
   discard.append(top)
print(‘(Discards: ’discard.map(d -> d[0]).join(‘ ’)" )\n")

V max_swaps = min(black_stack.len, red_stack.len)
V swap_count = random:(0 .. max_swaps)
print(‘Swapping ’swap_count)
F random_partition(stack, count)
   ‘Partition the stack into 'count' randomly selected members and the rest’
   V stack_copy = copy(stack)
   random:shuffle(&stack_copy)
   R (stack_copy[count ..], stack_copy[0 .< count])

(black_stack, V black_swap) = random_partition(black_stack, swap_count)
(red_stack, V red_swap) = random_partition(red_stack, swap_count)

black_stack [+]= red_swap
red_stack [+]= black_swap

I black_stack.count(Black) == red_stack.count(Red)
   print(‘Yeha! The mathematicians assertion is correct.’)
E
   print(‘Whoops - The mathematicians (or my card manipulations) are flakey’)
===
auto n = 52;
auto Black = u"Black"_S;
auto Red = u"Red"_S;
auto blacks = create_array({Black}) * (idiv(n, 2));
auto reds = create_array({Red}) * (idiv(n, 2));
auto pack = blacks + reds;

struct CodeBlock1
{
    CodeBlock1()
    {
        randomns::shuffle(pack);
    }
} code_block_1;

Array<String> black_stack;
Array<String> red_stack;
Array<String> discard;

struct CodeBlock2
{
    CodeBlock2()
    {
        while (!pack.empty()) {
            auto top = pack.pop();
            if (top == Black)
                black_stack.append(pack.pop());
            else
                red_stack.append(pack.pop());
            discard.append(top);
        }
        print(u"(Discards: "_S & discard.map([](const auto &d){return _get<0>(d);}).join(u" "_S) & u" )\n"_S);
    }
} code_block_2;

auto max_swaps = min(black_stack.len(), red_stack.len());
auto swap_count = randomns::_(range_ee(0, max_swaps));

struct CodeBlock3
{
    CodeBlock3()
    {
        print(u"Swapping "_S & swap_count);
    }
} code_block_3;

template <typename T1, typename T2> auto random_partition(const T1 &stack, const T2 &count)
{
    u"Partition the stack into 'count' randomly selected members and the rest"_S;
    auto stack_copy = copy(stack);
    randomns::shuffle(stack_copy);
    return make_tuple(stack_copy[range_ei(count)], stack_copy[range_el(0, count)]);
}

struct CodeBlock4
{
    CodeBlock4()
    {
        TUPLE_ELEMENT_T(1, random_partition(black_stack, swap_count)) black_swap;
        assign_from_tuple(black_stack, black_swap, random_partition(black_stack, swap_count));
        TUPLE_ELEMENT_T(1, random_partition(red_stack, swap_count)) red_swap;
        assign_from_tuple(red_stack, red_swap, random_partition(red_stack, swap_count));

        black_stack.append(red_swap);
        red_stack.append(black_swap);

        if (black_stack.count(Black) == red_stack.count(Red))
            print(u"Yeha! The mathematicians assertion is correct."_S);
        else
            print(u"Whoops - The mathematicians (or my card manipulations) are flakey"_S);
    }
} code_block_4;


# https://www.rosettacode.org/wiki/Modulinos
def meaning_of_life():
    return ord('*')

if __name__ == "__main__":
    print("Main: The meaning of life is %s" % meaning_of_life())
===
F meaning_of_life()
   R ‘*’.code

:start:
print(‘Main: The meaning of life is #.’.format(meaning_of_life()))
===
auto meaning_of_life()
{
    return u'*'_C.code;
}

int main()
{
    print(u"Main: The meaning of life is #."_S.format(meaning_of_life()));
}


# https://www.rosettacode.org/wiki/Monty_Hall_problem#Python
import random
#1 represents a car
#0 represent a goat

stay = 0  #amount won if stay in the same position
switch = 0 # amount won if you switch

for i in range(1000):
    lst = [1,0,0]           # one car and two goats
    random.shuffle(lst)     # shuffles the list randomly

    ran = random.randrange(3) # gets a random number for the random guess

    user = lst[ran] #storing the random guess

    lst.pop(ran) # deleting the random guess

    huh = 0
    for i in lst: # getting a value 0 and deleting it
        if i ==0:
            lst.pop(huh) # deletes a goat when it finds it
            break
        huh+=1

    if user == 1: # if the original choice is 1 then stay adds 1
        stay+=1

    if lst[0] == 1: # if the switched value is 1 then switch adds 1
        switch+=1

print("Stay =", stay)
print("Switch =", switch)
===
V stay = 0
V _switch_ = 0

L(i) 1000
   V lst = [1, 0, 0]
   random:shuffle(&lst)

   V ran = random:(3)

   V user = lst[ran]

   lst.pop(ran)

   V huh = 0
   L(i) lst
      I i == 0
         lst.pop(huh)
         L.break
      huh++

   I user == 1
      stay++

   I lst[0] == 1
      _switch_++

print(‘Stay = ’stay)
print(‘Switch = ’_switch_)
===
auto stay = 0;
auto _switch_ = 0;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (int i = 0; i < 1000; i++) {
            auto lst = create_array({1, 0, 0});
            randomns::shuffle(lst);

            auto ran = randomns::_(3);

            auto user = lst[ran];

            lst.pop(ran);

            auto huh = 0;
            for (auto &&i : lst) {
                if (i == 0) {
                    lst.pop(huh);
                    break;
                }
                huh++;
            }

            if (user == 1)
                stay++;

            if (_get<0>(lst) == 1)
                _switch_++;
        }

        print(u"Stay = "_S & stay);
        print(u"Switch = "_S & _switch_);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Multiplication_tables#C
n = 12
for j in range(1, n + 1):
    print('%3d' % j, end = ' ')
print('│')
for j in range(n):
    print('────', end = '')
print('┼───')

for i in range(1, n + 1):
    for j in range(1, n + 1):
        print('    ' if j < i else "%3d " % (i * j), end = '')
    print('│', i)
===
V n = 12
L(j) 1 .. n
   print(‘#3’.format(j), end' ‘ ’)
print(‘│’)
L(j) 0 .< n
   print(‘────’, end' ‘’)
print(‘┼───’)

L(i) 1 .. n
   L(j) 1 .. n
      print(I j < i {‘    ’} E ‘#3 ’.format(i * j), end' ‘’)
   print(‘│ ’i)
===
auto n = 12;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto j : range_ee(1, n))
            print(u"#3"_S.format(j), u" "_S);
        print(u"│"_S);
        for (auto j : range_el(0, n))
            print(u"────"_S, u""_S);
        print(u"┼───"_S);

        for (auto i : range_ee(1, n)) {
            for (auto j : range_ee(1, n))
                print(j < i ? u"    "_S : u"#3 "_S.format(i * j), u""_S);
            print(u"│ "_S & i);
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Parsing/RPN_calculator_algorithm#Python
from typing import List, Dict, Callable

a:List[float]=[]
b:Dict[str, Callable[[float, float], float]] = {}
b['+'] = lambda x,y: y+x
b['-'] = lambda x,y: y-x
b['*'] = lambda x,y: y*x
b['/'] = lambda x,y: y/x
b['^'] = lambda x,y:y**x

for c in '3 4 2 * 1 5 - 2 3 ^ ^ / +'.split(' '):
    if c in b:
        #a.append(b[c](a.pop(), a.pop()))
        first  = a.pop()
        second = a.pop()
        a.append(b[c](first, second))
    else:
        a.append(float(c))
    print(c, a)
===
[Float] a
[String = ((Float, Float) -> Float)] b
b[‘+’] = (x, y) -> y + x
b[‘-’] = (x, y) -> y - x
b[‘*’] = (x, y) -> y * x
b[‘/’] = (x, y) -> y / x
b[‘^’] = (x, y) -> y ^ x

L(c) ‘3 4 2 * 1 5 - 2 3 ^ ^ / +’.split(‘ ’)
   I c C b
      V first = a.pop()
      V second = a.pop()
      a.append(b[c](first, second))
   E
      a.append(Float(c))
   print(c‘ ’a)
===
Array<double> a;
Dict<String, std::function<double(const double, const double)>> b;

struct CodeBlock1
{
    CodeBlock1()
    {
        b.set(u"+"_S, [](const auto &x, const auto &y){return y + x;});
        b.set(u"-"_S, [](const auto &x, const auto &y){return y - x;});
        b.set(u"*"_S, [](const auto &x, const auto &y){return y * x;});
        b.set(u"/"_S, [](const auto &x, const auto &y){return y / x;});
        b.set(u"^"_S, [](const auto &x, const auto &y){return pow(y, x);});

        for (auto &&c : u"3 4 2 * 1 5 - 2 3 ^ ^ / +"_S.split(u" "_S)) {
            if (in(c, b)) {
                auto first = a.pop();
                auto second = a.pop();
                a.append(b[c](first, second));
            }
            else
                a.append(to_float(c));
            print(c & u" "_S & a);
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Pascal%27s_triangle#Python
def pascal(n):
   row = [1]
   k = [0]
   for x in range(max(n,0)):
      print(' '.join(map(str, row)).center(16))
      row=[l+r for l,r in zip(row+k,k+row)]

pascal(7)
===
F pascal(n)
   V row = [1]
   V k = [0]
   L(x) 0 .< max(n, 0)
      print(row.map(String).join(‘ ’).center(16))
      row = zip(row [+] k, k [+] row).map((l, r) -> l + r)

pascal(7)
===
template <typename T1> auto _pascal_(const T1 &n)
{
    auto row = create_array({1});
    auto k = create_array({0});
    for (auto x : range_el(0, max(n, 0))) {
        print(row.map([](const auto &x){return String(x);}).join(u" "_S).center(16));
        row = zip(row + k, k + row).map([](const auto &l, const auto &r){return l + r;});
    }
}

struct CodeBlock1
{
    CodeBlock1()
    {
        _pascal_(7);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Perlin_noise#Python
p = [-1] * 512
permutation = [151,160,137,91,90,15,
   131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
   190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,
   88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,
   77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,
   102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,
   135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,
   5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,
   223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,
   129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,
   251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,
   49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,
   138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180]
for i in range(256):
    p[256+i] = p[i] = permutation[i]

def fade(t):
    return t ** 3 * (t * (t * 6 - 15) + 10)

def linerp(t, a, b):
    return a + t * (b - a)

def grad(hash, x, y, z):
    h = hash & 15                      # CONVERT LO 4 BITS OF HASH CODE
    u = x if h<8 else y                # INTO 12 GRADIENT DIRECTIONS.
    v = y if h<4 else (x if h in (12, 14) else z)
    return (u if (h&1) == 0 else -u) + (v if (h&2) == 0 else -v)

def perlin_noise(x, y, z):
    X = int(x) & 255                  # FIND UNIT CUBE THAT
    Y = int(y) & 255                  # CONTAINS POINT.
    Z = int(z) & 255
    x -= int(x)                                # FIND RELATIVE X,Y,Z
    y -= int(y)                                # OF POINT IN CUBE.
    z -= int(z)
    u = fade(x)                                # COMPUTE FADE CURVES
    v = fade(y)                                # FOR EACH OF X,Y,Z.
    w = fade(z)
    A = p[X  ]+Y; AA = p[A]+Z; AB = p[A+1]+Z      # HASH COORDINATES OF
    B = p[X+1]+Y; BA = p[B]+Z; BB = p[B+1]+Z      # THE 8 CUBE CORNERS,

    return linerp(w, linerp(v, linerp(u, grad(p[AA  ], x  , y  , z   ),  # AND ADD
                                         grad(p[BA  ], x-1, y  , z   )), # BLENDED
                               linerp(u, grad(p[AB  ], x  , y-1, z   ),  # RESULTS
                                         grad(p[BB  ], x-1, y-1, z   ))),# FROM  8
                     linerp(v, linerp(u, grad(p[AA+1], x  , y  , z-1 ),  # CORNERS
                                         grad(p[BA+1], x-1, y  , z-1 )), # OF CUBE
                               linerp(u, grad(p[AB+1], x  , y-1, z-1 ),
                                         grad(p[BB+1], x-1, y-1, z-1 ))))

print("%1.17f" % perlin_noise(3.14, 42, 7))
===
V p = [-1] * 512
V permutation = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180]
L(i) 256
   p[256 + i] = p[i] = permutation[i]

F fade(t)
   R t ^ 3 * (t * (t * 6 - 15) + 10)

F linerp(t, a, b)
   R a + t * (b - a)

F grad(hash, x, y, z)
   V h = hash [&] 15
   V u = I h < 8 {x} E y
   V v = I h < 4 {y} E (I h C (12, 14) {x} E z)
   R (I (h [&] 1) == 0 {u} E -u) + (I (h [&] 2) == 0 {v} E -v)

F perlin_noise(=x, =y, =z)
   V _x_ = Int(x) [&] 255
   V Y = Int(y) [&] 255
   V Z = Int(z) [&] 255
   x -= Int(x)
   y -= Int(y)
   z -= Int(z)
   V u = fade(x)
   V v = fade(y)
   V w = fade(z)
   V A = :p[_x_] + Y
   V AA = :p[A] + Z
   V AB = :p[A + 1] + Z
   V B = :p[_x_ + 1] + Y
   V BA = :p[B] + Z
   V BB = :p[B + 1] + Z

   R linerp(w, linerp(v, linerp(u, grad(:p[AA], x, y, z), grad(:p[BA], x - 1, y, z)), linerp(u, grad(:p[AB], x, y - 1, z), grad(:p[BB], x - 1, y - 1, z))), linerp(v, linerp(u, grad(:p[AA + 1], x, y, z - 1), grad(:p[BA + 1], x - 1, y, z - 1)), linerp(u, grad(:p[AB + 1], x, y - 1, z - 1), grad(:p[BB + 1], x - 1, y - 1, z - 1))))

print(‘#.17’.format(perlin_noise(3.14, 42, 7)))
===
auto p = create_array({-1}) * 512;
auto permutation = create_array({151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180});

struct CodeBlock1
{
    CodeBlock1()
    {
        for (int i = 0; i < 256; i++)
            p.set(256 + i, p.set(i, permutation[i]));
    }
} code_block_1;

template <typename T1> auto fade(const T1 &t)
{
    return cube(t) * (t * (t * 6 - 15) + 10);
}

template <typename T1, typename T2, typename T3> auto linerp(const T1 &t, const T2 &a, const T3 &b)
{
    return a + t * (b - a);
}

template <typename T1, typename T2, typename T3, typename T4> auto grad(const T1 &hash, const T2 &x, const T3 &y, const T4 &z)
{
    auto h = hash & 15;
    auto u = h < 8 ? x : y;
    auto v = h < 4 ? y : (in(h, make_tuple(12, 14)) ? x : z);
    return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);
}

template <typename T1, typename T2, typename T3> auto perlin_noise(T1 x, T2 y, T3 z)
{
    auto _x_ = to_int(x) & 255;
    auto Y = to_int(y) & 255;
    auto Z = to_int(z) & 255;
    x -= to_int(x);
    y -= to_int(y);
    z -= to_int(z);
    auto u = fade(x);
    auto v = fade(y);
    auto w = fade(z);
    auto A = ::p[_x_] + Y;
    auto AA = ::p[A] + Z;
    auto AB = ::p[A + 1] + Z;
    auto B = ::p[_x_ + 1] + Y;
    auto BA = ::p[B] + Z;
    auto BB = ::p[B + 1] + Z;

    return linerp(w, linerp(v, linerp(u, grad(::p[AA], x, y, z), grad(::p[BA], x - 1, y, z)), linerp(u, grad(::p[AB], x, y - 1, z), grad(::p[BB], x - 1, y - 1, z))), linerp(v, linerp(u, grad(::p[AA + 1], x, y, z - 1), grad(::p[BA + 1], x - 1, y, z - 1)), linerp(u, grad(::p[AB + 1], x, y - 1, z - 1), grad(::p[BB + 1], x - 1, y - 1, z - 1))));
}

struct CodeBlock2
{
    CodeBlock2()
    {
        print(u"#.17"_S.format(perlin_noise(3.14, 42, 7)));
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Permutations_by_swapping#Python:_Iterative_version_of_the_recursive
def s_permutations(seq):
    empty_list : List[int] = []
    items = [empty_list]
    for j in seq:
        new_items : List[List[int]] = []
        for i, item in enumerate(items):
            if i % 2:
                # step up
                new_items += [item[:i] + [j] + item[i:]
                              for i in range(len(item) + 1)]
            else:
                # step down
                new_items += [item[:i] + [j] + item[i:]
                              for i in range(len(item), -1, -1)]
        items = new_items

    return [(item, -1 if i % 2 else 1)
            for i, item in enumerate(items)]

for n in (3, 4):
    print('Permutations and sign of %i items' % n)
    for perm, sgn in s_permutations(list(range(n))):
        print('Perm: %s Sign: %2i' % (perm, sgn))
    print()
===
F s_permutations(seq)
   [Int] empty_list
   V items = [empty_list]
   L(j) seq
      [[Int]] new_items
      L(item) items
         V i = L.index
         I i % 2
            new_items [+]= (0 .. item.len).map(i -> @item[0 .< i] [+] [@j] [+] @item[i ..])
         E
            new_items [+]= (item.len .< -1).step(-1).map(i -> @item[0 .< i] [+] [@j] [+] @item[i ..])
      items = new_items

   R enumerate(items).map((i, item) -> (item, I i % 2 {-1} E 1))

L(n) (3, 4)
   print(‘Permutations and sign of #. items’.format(n))
   L(perm, sgn) s_permutations(Array(0 .< n))
      print(‘Perm: #. Sign: #2’.format(perm, sgn))
   print()
===
template <typename T1> auto s_permutations(const T1 &seq)
{
    Array<int> empty_list;
    auto items = create_array({empty_list});
    for (auto &&j : seq) {
        Array<Array<int>> new_items;
        {int Lindex = 0;
        for (auto &&item : items) {
            auto i = Lindex;
            if (mod(i, 2))
                new_items.append(range_ee(0, item.len()).map([&item, &j](const auto &i){return item[range_el(0, i)] + create_array({j}) + item[range_ei(i)];}));
            else
                new_items.append(range_el(item.len(), -1).step(-1).map([&item, &j](const auto &i){return item[range_el(0, i)] + create_array({j}) + item[range_ei(i)];}));
            Lindex++;
        }}
        items = new_items;
    }

    return enumerate(items).map([](const auto &i, const auto &item){return make_tuple(item, mod(i, 2) ? -1 : 1);});
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&n : make_tuple(3, 4)) {
            print(u"Permutations and sign of #. items"_S.format(n));
            for (auto &&[perm, sgn] : s_permutations(create_array(range_el(0, n))))
                print(u"Perm: #. Sign: #2"_S.format(perm, sgn));
            print();
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Polynomial_long_division#Python
import sys

def degree(poly : list):
    while len(poly) != 0 and poly[-1] == 0:
        poly.pop()   # normalize
    return len(poly)-1

def poly_div(n : list, D : list):
    dD = degree(D)
    dN = degree(n)
    if dD < 0: sys.exit(1)
    q : List[float]
    if dN >= dD:
        q = [0.0] * dN
        while dN >= dD:
            d = [0.0]*(dN - dD) + D
            mult = n[-1] / float(d[-1])
            q[dN - dD] = mult
            d = [coeff*mult for coeff in d]
            n = [coeffN - coeffd for coeffN, coeffd in zip(n, d)]
            dN = degree(n)
    else:
        q = [0.0]
    return (q, n)

print("POLYNOMIAL LONG DIVISION")
n = [-42.0, 0.0, -12.0, 1.0]
D = [-3.0, 1.0, 0.0, 0.0]
print("  %s / %s =" % (n,D), end=' ')
(q, r) = poly_div(n, D)
print("%s remainder %s" % (q, r))
===
F degree(&poly)
   L !poly.empty & poly.last == 0
      poly.pop()
   R poly.len - 1

F poly_div(&n, &D)
   V dD = degree(&D)
   V dN = degree(&n)
   I dD < 0
      exit(1)
   [Float] q
   I dN >= dD
      q = [0.0] * dN
      L dN >= dD
         V d = [0.0] * (dN - dD) [+] D
         V mult = n.last / Float(d.last)
         q[dN - dD] = mult
         d = d.map(coeff -> coeff * @mult)
         n = zip(n, d).map((coeffN, coeffd) -> coeffN - coeffd)
         dN = degree(&n)
   E
      q = [0.0]
   R (q, n)

print(‘POLYNOMIAL LONG DIVISION’)
V n = [-42.0, 0.0, -12.0, 1.0]
V D = [-3.0, 1.0, 0.0, 0.0]
print(‘  #. / #. =’.format(n, D), end' ‘ ’)
V (q, r) = poly_div(&n, &D)
print(‘#. remainder #.’.format(q, r))
===
template <typename T1> auto degree(T1 &poly)
{
    while (!poly.empty() && poly.last() == 0)
        poly.pop();
    return poly.len() - 1;
}

template <typename T1, typename T2> auto poly_div(T1 &n, T2 &D)
{
    auto dD = degree(D);
    auto dN = degree(n);
    if (dD < 0)
        exit(1);
    Array<double> q;
    if (dN >= dD) {
        q = create_array({0.0}) * dN;
        while (dN >= dD) {
            auto d = create_array({0.0}) * (dN - dD) + D;
            auto mult = n.last() / to_float(d.last());
            q.set(dN - dD, mult);
            d = d.map([&mult](const auto &coeff){return coeff * mult;});
            n = zip(n, d).map([](const auto &coeffN, const auto &coeffd){return coeffN - coeffd;});
            dN = degree(n);
        }
    }
    else
        q = create_array({0.0});
    return make_tuple(q, n);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"POLYNOMIAL LONG DIVISION"_S);
    }
} code_block_1;

auto n = create_array({-42.0, 0.0, -12.0, 1.0});
auto D = create_array({-3.0, 1.0, 0.0, 0.0});

struct CodeBlock2
{
    CodeBlock2()
    {
        print(u"  #. / #. ="_S.format(n, D), u" "_S);
    }
} code_block_2;

auto [q, r] = poly_div(n, D);

struct CodeBlock3
{
    CodeBlock3()
    {
        print(u"#. remainder #."_S.format(q, r));
    }
} code_block_3;


# https://www.rosettacode.org/wiki/Pseudo-random_numbers/Combined_recursive_generator_MRG32k3a#Python
from typing import List
Int64 = int

# Constants
a1 = [Int64(0), 1403580, -810728]
m1 = Int64(2)**32 - 209
#
a2 = [Int64(527612), 0, -1370589]
m2 = Int64(2)**32 - 22853
#
d = m1 + 1

class MRG32k3a:
    x1 : List[Int64]
    x2 : List[Int64]

    def __init__(self, seed_state=123):
        self.seed(seed_state)

    def seed(self, seed_state : Int64):
        assert Int64(0) <seed_state < d, "Out of Range 0 x < %d" % d
        self.x1 = [Int64(seed_state), 0, 0]
        self.x2 = [Int64(seed_state), 0, 0]

    def next_int(self):
        "return random int in range 0..d"
        x1i = (sum(aa * xx  for aa, xx in zip(a1, self.x1)) % m1 + m1) % m1
        x2i = (sum(aa * xx  for aa, xx in zip(a2, self.x2)) % m2 + m2) % m2
        self.x1 = [x1i] + self.x1[:2]
        self.x2 = [x2i] + self.x2[:2]
        z = ((x1i - x2i) % m1 + m1) % m1
        return z + 1

    def  next_float(self):
        "return random float between 0 and 1"
        return float(self.next_int()) / d

random_gen = MRG32k3a()
random_gen.seed(1234567)
for i in range(5):
    print(random_gen.next_int())

random_gen.seed(987654321)
hist = {i:0 for i in range(5)}
for i in range(100_000):
    hist[int(random_gen.next_float() *5)] += 1
print(hist)
===
V a1 = [Int64(0), 1403580, -810728]
V m1 = Int64(2) ^ 32 - 209
V a2 = [Int64(527612), 0, -1370589]
V m2 = Int64(2) ^ 32 - 22853
V d = m1 + 1

T MRG32k3a
   [Int64] x1
   [Int64] x2

   F (seed_state = 123)
      .seed(seed_state)

   F seed(Int64 seed_state)
      assert(seed_state C Int64(0) <.< :d, ‘Out of Range 0 x < #.’.format(:d))
      .x1 = [Int64(seed_state), 0, 0]
      .x2 = [Int64(seed_state), 0, 0]

   F next_int()
      ‘return random int in range 0..d’
      V x1i = (sum(zip(:a1, .x1).map((aa, xx) -> aa * xx)) % :m1 + :m1) % :m1
      V x2i = (sum(zip(:a2, .x2).map((aa, xx) -> aa * xx)) % :m2 + :m2) % :m2
      .x1 = [x1i] [+] .x1[0.<2]
      .x2 = [x2i] [+] .x2[0.<2]
      V z = ((x1i - x2i) % :m1 + :m1) % :m1
      R z + 1

   F next_float()
      ‘return random float between 0 and 1’
      R Float(.next_int()) / :d

V random_gen = MRG32k3a()
random_gen.seed(1234567)
L(i) 5
   print(random_gen.next_int())

random_gen.seed(987654321)
V hist = Dict(0.<5, i -> (i, 0))
L(i) 100'000
   hist[Int(random_gen.next_float() * 5)]++
print(hist)
===
auto a1 = create_array<Int64>({to_int64(0), 1403580, -810728});
auto m1 = pow(to_int64(2), 32) - 209;
auto a2 = create_array<Int64>({to_int64(527612), 0, -1370589});
auto m2 = pow(to_int64(2), 32) - 22853;
auto d = m1 + 1;

class MRG32k3a
{
public:
    Array<Int64> x1;
    Array<Int64> x2;

    template <typename T1 = decltype(123)> MRG32k3a(const T1 &seed_state = 123)
    {
        seed(seed_state);
    }

    auto seed(const Int64 &seed_state)
    {
        assert(in(seed_state, range_ll(to_int64(0), ::d)), u"Out of Range 0 x < #."_S.format(::d));
        x1 = create_array<Int64>({to_int64(seed_state), 0, 0});
        x2 = create_array<Int64>({to_int64(seed_state), 0, 0});
    }

    auto next_int()
    {
        u"return random int in range 0..d"_S;
        auto x1i = mod((mod(sum_map(zip(::a1, x1), [](const auto &aa, const auto &xx){return aa * xx;}), ::m1) + ::m1), ::m1);
        auto x2i = mod((mod(sum_map(zip(::a2, x2), [](const auto &aa, const auto &xx){return aa * xx;}), ::m2) + ::m2), ::m2);
        x1 = create_array({x1i}) + x1[range_el(0, 2)];
        x2 = create_array({x2i}) + x2[range_el(0, 2)];
        auto z = mod((mod((x1i - x2i), ::m1) + ::m1), ::m1);
        return z + 1;
    }

    auto next_float()
    {
        u"return random float between 0 and 1"_S;
        return to_float(next_int()) / ::d;
    }
};

auto random_gen = MRG32k3a();

struct CodeBlock1
{
    CodeBlock1()
    {
        random_gen.seed(1234567);
        for (int i = 0; i < 5; i++)
            print(random_gen.next_int());

        random_gen.seed(987654321);
    }
} code_block_1;

auto hist = create_dict(range_el(0, 5), [](const auto &i){return make_tuple(i, 0);});

struct CodeBlock2
{
    CodeBlock2()
    {
        for (int i = 0; i < 100'000; i++)
            hist[to_int(random_gen.next_float() * 5)]++;
        print(hist);
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Queue/Definition#Python
class FIFO:
    def __init__(self):
        self.contents : List[int] = []
    def push(self, item):
        self.contents.append(item)
    def pop(self):
        return self.contents.pop(0)
    def empty(self):
        return len(self.contents) == 0

# Sample usage:
f = FIFO()
f.push(3)
f.push(2)
f.push(1)
while not f.empty():
    print(f.pop())
===
T FIFO
   [Int] contents
   F ()
   {
   }
   F push(item)
      .contents.append(item)
   F pop()
      R .contents.pop(0)
   F empty()
      R .contents.empty

V f = FIFO()
f.push(3)
f.push(2)
f.push(1)
L !f.empty()
   print(f.pop())
===
class FIFO
{
public:
    Array<int> contents;
    FIFO()
    {
    }

    template <typename T1> auto push(const T1 &item)
    {
        contents.append(item);
    }
    auto pop()
    {
        return contents.pop(0);
    }
    auto empty()
    {
        return contents.empty();
    }
};

auto f = FIFO();

struct CodeBlock1
{
    CodeBlock1()
    {
        f.push(3);
        f.push(2);
        f.push(1);
        while (!f.empty())
            print(f.pop());
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Queue/Usage
import collections

my_queue = collections.deque() # str

my_queue.append('foo')
my_queue.append('bar')
my_queue.append('baz')

print(my_queue.popleft())
print(my_queue.popleft())
print(my_queue.popleft())
===
V my_queue = Deque[String]()

my_queue.append(‘foo’)
my_queue.append(‘bar’)
my_queue.append(‘baz’)

print(my_queue.pop_left())
print(my_queue.pop_left())
print(my_queue.pop_left())
===
auto my_queue = Deque<String>();

struct CodeBlock1
{
    CodeBlock1()
    {
        my_queue.append(u"foo"_S);
        my_queue.append(u"bar"_S);
        my_queue.append(u"baz"_S);

        print(my_queue.pop_left());
        print(my_queue.pop_left());
        print(my_queue.pop_left());
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Quickselect_algorithm#Python
def partition(vector : list, left, right, pivotIndex):
    pivotValue = vector[pivotIndex]
    (vector[pivotIndex], vector[right]) = (vector[right], vector[pivotIndex])  # Move pivot to end
    storeIndex = left
    for i in range(left, right):
        if vector[i] < pivotValue:
            (vector[storeIndex], vector[i]) = (vector[i], vector[storeIndex])
            storeIndex += 1
    (vector[right], vector[storeIndex]) = (vector[storeIndex], vector[right])  # Move pivot to its final place
    return storeIndex

def _select(vector : list, left, right, k):
    "Returns the k-th smallest, (k >= 0), element of vector within vector[left:right+1] inclusive."
    while True:
        pivotIndex = (left + right) // 2     # select pivotIndex between left and right
        pivotNewIndex = partition(vector, left, right, pivotIndex)
        pivotDist = pivotNewIndex - left
        if pivotDist == k:
            return vector[pivotNewIndex]
        elif k < pivotDist:
            right = pivotNewIndex - 1
        else:
            k -= pivotDist + 1
            left = pivotNewIndex + 1

def select(vector : list, k):
    """
    Returns the k-th smallest, (k >= 0), element of vector within vector[left:right+1].
    left, right default to (0, len(vector) - 1) if omitted
    """
    left = 0
    lv1 = len(vector) - 1
    right = lv1
    assert len(vector) != 0 and k >= 0, "Either null vector or k < 0 "
    assert 0 <= left <= lv1, "left is out of range"
    assert left <= right <= lv1, "right is out of range"
    return _select(vector, left, right, k)

v = [9, 8, 7, 6, 5, 0, 1, 2, 3, 4]
print([select(v, i) for i in range(10)])
===
F partition(&vector, left, right, pivotIndex)
   V pivotValue = vector[pivotIndex]
   swap(&vector[pivotIndex], &vector[right])
   V storeIndex = left
   L(i) left .< right
      I vector[i] < pivotValue
         swap(&vector[storeIndex], &vector[i])
         storeIndex++
   swap(&vector[right], &vector[storeIndex])
   R storeIndex

F _select(&vector, =left, =right, =k)
   ‘Returns the k-th smallest, (k >= 0), element of vector within vector[left:right+1] inclusive.’
   L
      V pivotIndex = (left + right) I/ 2
      V pivotNewIndex = partition(&vector, left, right, pivotIndex)
      V pivotDist = pivotNewIndex - left
      I pivotDist == k
         R vector[pivotNewIndex]
      E I k < pivotDist
         right = pivotNewIndex - 1
      E
         k -= pivotDist + 1
         left = pivotNewIndex + 1

F select(&vector, k)
   ‘
    Returns the k-th smallest, (k >= 0), element of vector within vector[left:right+1].
    left, right default to (0, len(vector) - 1) if omitted
    ’
   V left = 0
   V lv1 = vector.len - 1
   V right = lv1
   assert(!vector.empty & k >= 0, ‘Either null vector or k < 0 ’)
   assert(left C 0 .. lv1, ‘left is out of range’)
   assert(right C left .. lv1, ‘right is out of range’)
   R _select(&vector, left, right, k)

V v = [9, 8, 7, 6, 5, 0, 1, 2, 3, 4]
print((0.<10).map(i -> select(&:v, i)))
===
template <typename T1, typename T2, typename T3, typename T4> auto partition(T1 &vector, const T2 &left, const T3 &right, const T4 &pivotIndex)
{
    auto pivotValue = vector[pivotIndex];
    swap(vector[pivotIndex], vector[right]);
    auto storeIndex = left;
    for (auto i : range_el(left, right))
        if (vector[i] < pivotValue) {
            swap(vector[storeIndex], vector[i]);
            storeIndex++;
        }
    swap(vector[right], vector[storeIndex]);
    return storeIndex;
}

template <typename T1, typename T2, typename T3, typename T4> auto _select(T1 &vector, T2 left, T3 right, T4 k)
{
    u"Returns the k-th smallest, (k >= 0), element of vector within vector[left:right+1] inclusive."_S;
    while (true) {
        auto pivotIndex = idiv((left + right), 2);
        auto pivotNewIndex = partition(vector, left, right, pivotIndex);
        auto pivotDist = pivotNewIndex - left;
        if (pivotDist == k)
            return vector[pivotNewIndex];
        else if (k < pivotDist)
            right = pivotNewIndex - 1;
        else {
            k -= pivotDist + 1;
            left = pivotNewIndex + 1;
        }
    }
}

template <typename T1, typename T2> auto select(T1 &vector, const T2 &k)
{
    uR"(
    Returns the k-th smallest, (k >= 0), element of vector within vector[left:right+1].
    left, right default to (0, len(vector) - 1) if omitted
    )"_S;
    auto left = 0;
    auto lv1 = vector.len() - 1;
    auto right = lv1;
    assert(!vector.empty() && k >= 0, u"Either null vector or k < 0 "_S);
    assert(in(left, range_ee(0, lv1)), u"left is out of range"_S);
    assert(in(right, range_ee(left, lv1)), u"right is out of range"_S);
    return _select(vector, left, right, k);
}

auto v = create_array({9, 8, 7, 6, 5, 0, 1, 2, 3, 4});

struct CodeBlock1
{
    CodeBlock1()
    {
        print(range_el(0, 10).map([](const auto &i){return select(::v, i);}));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Random_Latin_squares#Python
import random
from copy import deepcopy

def _transpose(matrix):
    assert(len(matrix) == len(matrix[0]))
    r = [[0] * len(matrix) for i in range(len(matrix))]
    for i in range(len(matrix)):
        for j in range(len(matrix)):
            r[i][j] = matrix[j][i]
    return r

def _shuffle_transpose_shuffle(matrix):
    square = deepcopy(matrix)
    random.shuffle(square)
    trans = _transpose(square)
    random.shuffle(trans)
    return trans

def _rls(symbols : list):
    n = len(symbols)
    if n == 1:
        return [symbols]
    else:
        sym = random.choice(symbols)
        symbols.remove(sym)
        square = _rls(symbols)
        square.append(square[0][:])
        for i in range(n):
            square[i].insert(i, sym)
        return square

def rls(n):
    symbols = list(range(n))
    square = _rls(symbols)
    return _shuffle_transpose_shuffle(square)

def _check_rows(square):
    set_row0 = set(square[0])
    return all(len(row) == len(set(row)) and set(row) == set_row0
               for row in square)

def _check(square):
    transpose = _transpose(square)
    assert _check_rows(square) and _check_rows(transpose), "Not a Latin square"

for i in [3, 3, 5, 5]:
    square = rls(i)
    print("\n".join(' '.join(str(sym) for sym in row) for row in square))
    _check(square)
    print()
===
F _transpose(matrix)
   assert(matrix.len == matrix[0].len)
   V r = [[0] * matrix.len] * (matrix.len)
   L(i) 0 .< matrix.len
      L(j) 0 .< matrix.len
         r[i][j] = matrix[j][i]
   R r

F _shuffle_transpose_shuffle(matrix)
   V square = copy(matrix)
   random:shuffle(&square)
   V trans = _transpose(square)
   random:shuffle(&trans)
   R trans

F _rls(&symbols)
   V n = symbols.len
   I n == 1
      R [symbols]
   E
      V sym = random:choice(symbols)
      symbols.remove(sym)
      V square = _rls(&symbols)
      square.append(copy(square[0]))
      L(i) 0 .< n
         square[i].insert(i, sym)
      R square

F rls(n)
   V symbols = Array(0 .< n)
   V square = _rls(&symbols)
   R _shuffle_transpose_shuffle(square)

F _check_rows(square)
   V set_row0 = Set(square[0])
   R all(square.map(row -> row.len == Set(row).len & Set(row) == @set_row0))

F _check(square)
   V transpose = _transpose(square)
   assert(_check_rows(square) & _check_rows(transpose), ‘Not a Latin square’)

L(i) [3, 3, 5, 5]
   V square = rls(i)
   print(square.map(row -> row.map(sym -> String(sym)).join(‘ ’)).join("\n"))
   _check(square)
   print()
===
template <typename T1> auto _transpose(const T1 &matrix)
{
    assert(matrix.len() == _get<0>(matrix).len());
    auto r = create_array({create_array({0}) * matrix.len()}) * (matrix.len());
    for (auto i : range_el(0, matrix.len()))
        for (auto j : range_el(0, matrix.len()))
            r[i].set(j, matrix[j][i]);
    return r;
}

template <typename T1> auto _shuffle_transpose_shuffle(const T1 &matrix)
{
    auto square = copy(matrix);
    randomns::shuffle(square);
    auto trans = _transpose(square);
    randomns::shuffle(trans);
    return trans;
}

template <typename T1> auto _rls(T1 &symbols)
{
    auto n = symbols.len();
    if (n == 1)
        return create_array({symbols});
    else {
        auto sym = randomns::choice(symbols);
        symbols.remove(sym);
        auto square = _rls(symbols);
        square.append(copy(_get<0>(square)));
        for (auto i : range_el(0, n))
            square[i].insert(i, sym);
        return square;
    }
}

template <typename T1> auto rls(const T1 &n)
{
    auto symbols = create_array(range_el(0, n));
    auto square = _rls(symbols);
    return _shuffle_transpose_shuffle(square);
}

template <typename T1> auto _check_rows(const T1 &square)
{
    auto set_row0 = create_set(_get<0>(square));
    return all_map(square, [&set_row0](const auto &row){return row.len() == create_set(row).len() && create_set(row) == set_row0;});
}

template <typename T1> auto _check(const T1 &square)
{
    auto transpose = _transpose(square);
    assert(_check_rows(square) && _check_rows(transpose), u"Not a Latin square"_S);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&i : create_array({3, 3, 5, 5})) {
            auto square = rls(i);
            print(square.map([](const auto &row){return row.map([](const auto &sym){return String(sym);}).join(u" "_S);}).join(u"\n"_S));
            _check(square);
            print();
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Read_a_configuration_file#Python
def readconf(fname):
    ret : Dict[str, str] = {}
    for line in open(fname).readlines():
        # Assume whitespace is ignorable
        line = line.strip()
        if line == '' or line.startswith('#'): continue

        boolval = True
        # Assume leading ";" means a false boolean
        if line.startswith(';'):
            # Remove one or more leading semicolons
            line = line.lstrip(';')
            # If more than just one word, not a valid boolean
            if len(line.split()) != 1: continue
            boolval = False

        bits = line.lstrip(' ').split(' ', 1)
        k : str
        v : str
        if len(bits) == 1:
            # Assume booleans are just one standalone word
            k = bits[0]
            v = str(boolval)
        else:
            # Assume more than one word is a string value
            (k, v) = bits
        ret[k.lower()] = v
    return ret

conf = readconf('config.txt')
for k, v in sorted(conf.items()):
    print(k, '=', v)
===
F readconf(fname)
   [String = String] ret
   L(=line) File(fname).read_lines(1B)
      line = line.trim((‘ ’, "\t", "\r", "\n"))
      I line == ‘’ | line.starts_with(‘#’)
         L.continue

      V boolval = 1B
      I line.starts_with(‘;’)
         line = line.ltrim(‘;’)
         I line.split_py().len != 1
            L.continue
         boolval = 0B

      V bits = line.ltrim(‘ ’).split(‘ ’, 1 + 1)
      String k
      String v
      I bits.len == 1
         k = bits[0]
         v = String(boolval)
      E
         (k, v) = bits
      ret[k.lowercase()] = v
   R ret

V conf = readconf(‘config.txt’)
L(k, v) sorted(conf.items())
   print(k‘ = ’v)
===
template <typename T1> auto readconf(const T1 &fname)
{
    Dict<String, String> ret;
    for (auto line : File(fname).read_lines(true)) {
        line = line.trim(make_tuple(u" "_S, u"\t"_S, u"\r"_S, u"\n"_S));
        if (line == u"" || line.starts_with(u"#"_S))
            continue;

        auto boolval = true;
        if (line.starts_with(u";"_S)) {
            line = line.ltrim(u";"_S);
            if (line.split_py().len() != 1)
                continue;
            boolval = false;
        }

        auto bits = line.ltrim(u" "_S).split(u" "_S, 1 + 1);
        String k;
        String v;
        if (bits.len() == 1) {
            k = _get<0>(bits);
            v = String(boolval);
        }
        else
            assign_from_tuple(k, v, bits);
        ret.set(k.lowercase(), v);
    }
    return ret;
}

auto conf = readconf(u"config.txt"_S);

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&[k, v] : sorted(conf.items()))
            print(k & u" = "_S & v);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Recaman%27s_sequence#Python
def recamanSucc(seen, n, r):
    '''The successor for a given Recaman term,
       given the set of Recaman terms seen so far.'''
    back = r - n
    return n + r if 0 > back or (back in seen) else back

def recamanUntil(p):
    '''All terms of the Recaman series before the
       first term for which the predicate p holds.'''
    n = 1
    r = 0  # First term of series
    rs = [r]
    seen = set(rs)
    blnNew = True
    while not p(seen, n, r, blnNew):
        r = recamanSucc(seen, n, r)
        blnNew = r not in seen
        seen.add(r)
        rs.append(r)
        n = 1 + n
    return rs

def enumFromTo(m):
    '''Integer enumeration from m to n.'''
    return lambda n: range(m, 1 + n)

print(
    'First 15 Recaman:\n',
    recamanUntil(
        lambda seen, n, r, _: n == 15
    )
)
print(
    'First duplicated Recaman:\n',
    recamanUntil(
        lambda seen, n, r, blnNew: not blnNew
    )[-1]
)
setK = set(enumFromTo(0)(1000))
print(
    'Number of Recaman terms needed to generate all integers from [0..1000]:\n',
    len(recamanUntil(
        lambda seen, n, r, blnNew: (
            blnNew and r < 1001 and setK.issubset(seen)
        )
    )) - 1
)
===
F recamanSucc(seen, n, r)
   ‘The successor for a given Recaman term,
       given the set of Recaman terms seen so far.’
   V back = r - n
   R I 0 > back | (back C seen) {n + r} E back

F recamanUntil(p)
   ‘All terms of the Recaman series before the
       first term for which the predicate p holds.’
   V n = 1
   V r = 0
   V rs = [r]
   V seen = Set(rs)
   V blnNew = 1B
   L !p(seen, n, r, blnNew)
      r = recamanSucc(seen, n, r)
      blnNew = r !C seen
      seen.add(r)
      rs.append(r)
      n = 1 + n
   R rs

F enumFromTo(m)
   ‘Integer enumeration from m to n.’
   R n -> @m .< 1 + n

print("First 15 Recaman:\n "recamanUntil((seen, n, r, _) -> n == 15))
print("First duplicated Recaman:\n "recamanUntil((seen, n, r, blnNew) -> !blnNew).last)
V setK = Set(enumFromTo(0)(1000))
print("Number of Recaman terms needed to generate all integers from [0..1000]:\n "(recamanUntil((seen, n, r, blnNew) -> (blnNew & r < 1001 & :setK.is_subset(seen))).len - 1))
===
template <typename T1, typename T2, typename T3> auto recamanSucc(const T1 &seen, const T2 &n, const T3 &r)
{
    uR"(The successor for a given Recaman term,
       given the set of Recaman terms seen so far.)"_S;
    auto back = r - n;
    return 0 > back || (in(back, seen)) ? n + r : back;
}

template <typename T1> auto recamanUntil(const T1 &p)
{
    uR"(All terms of the Recaman series before the
       first term for which the predicate p holds.)"_S;
    auto n = 1;
    auto r = 0;
    auto rs = create_array({r});
    auto seen = create_set(rs);
    auto blnNew = true;
    while (!p(seen, n, r, blnNew)) {
        r = recamanSucc(seen, n, r);
        blnNew = !in(r, seen);
        seen.add(r);
        rs.append(r);
        n = 1 + n;
    }
    return rs;
}

template <typename T1> auto enumFromTo(const T1 &m)
{
    u"Integer enumeration from m to n."_S;
    return [&m](const auto &n){return range_el(m, 1 + n);};
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"First 15 Recaman:\n "_S & recamanUntil([](const auto &seen, const auto &n, const auto &r, const auto &_){return n == 15;}));
        print(u"First duplicated Recaman:\n "_S & recamanUntil([](const auto &seen, const auto &n, const auto &r, const auto &blnNew){return !blnNew;}).last());
    }
} code_block_1;

auto setK = create_set(enumFromTo(0)(1000));

struct CodeBlock2
{
    CodeBlock2()
    {
        print(u"Number of Recaman terms needed to generate all integers from [0..1000]:\n "_S & (recamanUntil([](const auto &seen, const auto &n, const auto &r, const auto &blnNew){return (blnNew && r < 1001 && ::setK.is_subset(seen));}).len() - 1));
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Resistance_calculator#Python [RPN]
Char = str
def move(obj):
    return obj

class Resistor:
    resistance : float
    voltage = 0.0
    a : 'Resistor' = None
    b : 'Resistor' = None
    symbol : Char

    def __init__(self, resistance = 0.0, a : 'Resistor' = None, b : 'Resistor' = None, symbol = Char('r')):
        self.resistance = resistance
        self.a = a
        self.b = b
        self.symbol = symbol

    def res(self) -> float: return self.resistance
    def setVoltage(self, voltage : float) -> None: self.voltage = voltage
    def current(self): return self.voltage / self.res()
    def effect(self): return self.current() * self.voltage
    def report(self,level="") -> None:
        print('%8.3f %8.3f %8.3f %8.3f  %s%s' % (self.res(), self.voltage, self.current(), self.effect(), level, self.symbol))
        if self.a is not None: self.a.report(level + "| ")
        if self.b is not None: self.b.report(level + "| ")

class Serial(Resistor):
    def __init__(self, a : Resistor, b : Resistor):
        self.a = move(b)
        self.b = a
        self.symbol = Char('+')

    def res(self): return self.a.res() + self.b.res()

    def setVoltage(self, voltage : float):
        ra = self.a.res()
        rb = self.b.res()
        self.a.setVoltage(ra/(ra+rb) * voltage)
        self.b.setVoltage(rb/(ra+rb) * voltage)
        self.voltage = voltage

class Parallel(Resistor):
    def __init__(self, a : Resistor, b : Resistor):
        self.a = move(b)
        self.b = a
        self.symbol = Char('*')

    def res(self): return 1 / (1 / self.a.res() + 1 / self.b.res())

    def setVoltage(self, voltage : float):
        self.a.setVoltage(voltage)
        self.b.setVoltage(voltage)
        self.voltage = voltage

def build(s):
    stack : List[Resistor] = []
    for word in s.split(' '):
        if   word == "+":
            p : Resistor = stack.pop()
            stack.append(Serial(p, stack.pop()))
        elif word == "*":
            p : Resistor = stack.pop()
            stack.append(Parallel(p, stack.pop()))
        else:
            stack.append(Resistor(float(word)))
    return stack.pop()

node : Resistor = build("10 2 + 6 * 8 + 6 * 4 + 8 * 4 + 8 * 6 +")
print("     Ohm     Volt   Ampere     Watt  Network tree")
node.setVoltage(18.0)
node.report()
===
T Resistor
   Float resistance
   voltage = 0.0
   Resistor? a
   Resistor? b
   Char symbol

   F (resistance = 0.0, Resistor? a = N, Resistor? b = N; symbol = Char(‘r’))
      .resistance = resistance
      .a = a
      .b = b
      .symbol = symbol

   F.virtual.new res() -> Float
      R .resistance
   F.virtual.new setVoltage(Float voltage) -> N
      .voltage = voltage
   F current()
      R .voltage / .res()
   F effect()
      R .current() * .voltage
   F report(level = ‘’) -> N
      print(‘#4.3 #4.3 #4.3 #4.3  #.#.’.format(.res(), .voltage, .current(), .effect(), level, .symbol))
      I .a != N
         .a.report(level‘| ’)
      I .b != N
         .b.report(level‘| ’)

T Serial(Resistor)
   F (Resistor a, Resistor b)
      .a = move(b)
      .b = a
      .symbol = Char(‘+’)

   F.virtual.override res() -> Float
      R .a.res() + .b.res()

   F.virtual.override setVoltage(Float voltage) -> N
      V ra = .a.res()
      V rb = .b.res()
      .a.setVoltage(ra / (ra + rb) * voltage)
      .b.setVoltage(rb / (ra + rb) * voltage)
      .voltage = voltage

T Parallel(Resistor)
   F (Resistor a, Resistor b)
      .a = move(b)
      .b = a
      .symbol = Char(‘*’)

   F.virtual.override res() -> Float
      R 1 / (1 / .a.res() + 1 / .b.res())

   F.virtual.override setVoltage(Float voltage) -> N
      .a.setVoltage(voltage)
      .b.setVoltage(voltage)
      .voltage = voltage

F build(s)
   [Resistor] stack
   L(word) s.split(‘ ’)
      I word == ‘+’
         Resistor p = stack.pop()
         stack.append(Serial(p, stack.pop()))
      E I word == ‘*’
         Resistor p = stack.pop()
         stack.append(Parallel(p, stack.pop()))
      E
         stack.append(Resistor(Float(word)))
   R stack.pop()

Resistor node = build(‘10 2 + 6 * 8 + 6 * 4 + 8 * 4 + 8 * 6 +’)
print(‘     Ohm     Volt   Ampere     Watt  Network tree’)
node.setVoltage(18.0)
node.report()
===
class Resistor
{
public:
    double resistance;
    decltype(0.0) voltage = 0.0;
    std::unique_ptr<Resistor> a;
    std::unique_ptr<Resistor> b;
    Char symbol;

    template <typename T1 = decltype(0.0), typename T4 = decltype(u'r'_C)> Resistor(const T1 &resistance = 0.0, std::unique_ptr<Resistor> a = nullptr, std::unique_ptr<Resistor> b = nullptr, const T4 &symbol = u'r'_C) :
        resistance(resistance),
        a(std::move(a)),
        b(std::move(b)),
        symbol(symbol)
    {
    }

    virtual double res()
    {
        return resistance;
    }
    virtual void setVoltage(const double &voltage)
    {
        this->voltage = voltage;
    }
    auto current()
    {
        return voltage / res();
    }
    auto effect()
    {
        return current() * voltage;
    }
    template <typename T1 = decltype(u""_S)> void report(const T1 &level = u""_S)
    {
        print(u"#4.3 #4.3 #4.3 #4.3  #.#."_S.format(res(), voltage, current(), effect(), level, symbol));
        if (a != nullptr)
            a->report(level & u"| "_S);
        if (b != nullptr)
            b->report(level & u"| "_S);
    }
};

class Serial : public Resistor
{
public:
    Serial(std::unique_ptr<Resistor> a, std::unique_ptr<Resistor> b)
    {
        this->a = std::move(b);
        this->b = std::move(a);
        symbol = u'+'_C;
    }

    virtual double res() override
    {
        return a->res() + b->res();
    }

    virtual void setVoltage(const double &voltage) override
    {
        auto ra = a->res();
        auto rb = b->res();
        a->setVoltage(ra / (ra + rb) * voltage);
        b->setVoltage(rb / (ra + rb) * voltage);
        this->voltage = voltage;
    }
};

class Parallel : public Resistor
{
public:
    Parallel(std::unique_ptr<Resistor> a, std::unique_ptr<Resistor> b)
    {
        this->a = std::move(b);
        this->b = std::move(a);
        symbol = u'*'_C;
    }

    virtual double res() override
    {
        return 1.0 / (1.0 / a->res() + 1.0 / b->res());
    }

    virtual void setVoltage(const double &voltage) override
    {
        a->setVoltage(voltage);
        b->setVoltage(voltage);
        this->voltage = voltage;
    }
};

template <typename T1> auto build(const T1 &s)
{
    Array<std::unique_ptr<Resistor>> stack;
    for (auto &&word : s.split(u" "_S))
        if (word == u'+') {
            std::unique_ptr<Resistor> p = stack.pop();
            stack.append(std::make_unique<Serial>(std::move(p), stack.pop()));
        }
        else if (word == u'*') {
            std::unique_ptr<Resistor> p = stack.pop();
            stack.append(std::make_unique<Parallel>(std::move(p), stack.pop()));
        }
        else
            stack.append(std::make_unique<Resistor>(to_float(word)));
    return stack.pop();
}

std::unique_ptr<Resistor> node = build(u"10 2 + 6 * 8 + 6 * 4 + 8 * 4 + 8 * 6 +"_S);

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"     Ohm     Volt   Ampere     Watt  Network tree"_S);
        node->setVoltage(18.0);
        node->report();
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Resistor_mesh#Python
DIFF_THRESHOLD = 1e-40

from enum import IntEnum

class Fixed(IntEnum):
    FREE = 0
    A = 1
    B = 2

class Node:
    voltage : float
    fixed : Fixed
    def __init__(self, v=0.0, f=Fixed.FREE):
        self.voltage = v
        self.fixed = f

def set_boundary(m : list):
    m[1][1] = Node( 1.0, Fixed.A)
    m[6][7] = Node(-1.0, Fixed.B)

def calc_difference(m, d : list):
    h = len(m)
    w = len(m[0])
    total = 0.0

    for i in range(h):
        for j in range(w):
            v = 0.0
            n = 0
            if i != 0:  v += m[i-1][j].voltage; n += 1
            if j != 0:  v += m[i][j-1].voltage; n += 1
            if i < h-1: v += m[i+1][j].voltage; n += 1
            if j < w-1: v += m[i][j+1].voltage; n += 1
            v = m[i][j].voltage - v / n

            d[i][j].voltage = v
            if m[i][j].fixed == Fixed.FREE:
                total += v ** 2
    return total

def iter(m : list):
    h = len(m)
    w = len(m[0])
    difference = [[Node() for j in range(w)] for i in range(h)]

    while True:
        set_boundary(m) # Enforce boundary conditions.
        if calc_difference(m, difference) < DIFF_THRESHOLD:
            break
        for i, di in enumerate(difference):
            for j, dij in enumerate(di):
                m[i][j].voltage -= dij.voltage

    cur = [0.0] * 3
    for i, di in enumerate(difference):
        for j, dij in enumerate(di):
            cur[int(m[i][j].fixed)] += (dij.voltage *
               (int(i != 0) + int(j != 0) + (i < h-1) + (j < w-1)))

    return (cur[int(Fixed.A)] - cur[int(Fixed.B)]) / 2.0

w = 10
h = 10
mesh = [[Node() for j in range(w)] for i in range(h)]
print("R = %.16f" % (2 / iter(mesh)))
===
V DIFF_THRESHOLD = 1e-40

T.enum Fixed
   FREE
   A
   B

T Node
   Float voltage
   Fixed fixed
   F (v = 0.0, f = Fixed.FREE)
      .voltage = v
      .fixed = f

F set_boundary(&m)
   m[1][1] = Node(1.0, Fixed.A)
   m[6][7] = Node(-1.0, Fixed.B)

F calc_difference(m, &d)
   V h = m.len
   V w = m[0].len
   V total = 0.0

   L(i) 0 .< h
      L(j) 0 .< w
         V v = 0.0
         V n = 0
         I i != 0
            v += m[i - 1][j].voltage
            n++
         I j != 0
            v += m[i][j - 1].voltage
            n++
         I i < h - 1
            v += m[i + 1][j].voltage
            n++
         I j < w - 1
            v += m[i][j + 1].voltage
            n++
         v = m[i][j].voltage - v / n

         d[i][j].voltage = v
         I m[i][j].fixed == FREE
            total += v ^ 2
   R total

F iter(&m)
   V h = m.len
   V w = m[0].len
   V difference = (0 .< h).map(i -> (0 .< @w).map(j -> Node()))

   L
      set_boundary(&m)
      I calc_difference(m, &difference) < :DIFF_THRESHOLD
         L.break
      L(di) difference
         V i = L.index
         L(dij) di
            V j = L.index
            m[i][j].voltage -= dij.voltage

   V cur = [0.0] * 3
   L(di) difference
      V i = L.index
      L(dij) di
         V j = L.index
         cur[Int(m[i][j].fixed)] += (dij.voltage * (Int(i != 0) + Int(j != 0) + (i < h - 1) + (j < w - 1)))

   R (cur[Int(Fixed.A)] - cur[Int(Fixed.B)]) / 2.0

V w = 10
V h = 10
V mesh = (0 .< h).map(i -> (0 .< :w).map(j -> Node()))
print(‘R = #.16’.format(2 / iter(&mesh)))
===
auto DIFF_THRESHOLD = 1e-40;
enum class Fixed {
    FREE,
    A,
    B
};

class Node
{
public:
    double voltage;
    Fixed fixed;
    template <typename T1 = decltype(0.0), typename T2 = decltype(Fixed::FREE)> Node(const T1 &v = 0.0, const T2 &f = Fixed::FREE) :
        voltage(v),
        fixed(f)
    {
    }
};

template <typename T1> auto set_boundary(T1 &m)
{
    _set<1>(_get<1>(m), Node(1.0, Fixed::A));
    _set<7>(_get<6>(m), Node(-1.0, Fixed::B));
}

template <typename T1, typename T2> auto calc_difference(const T1 &m, T2 &d)
{
    auto h = m.len();
    auto w = _get<0>(m).len();
    auto total = 0.0;

    for (auto i : range_el(0, h))
        for (auto j : range_el(0, w)) {
            auto v = 0.0;
            auto n = 0;
            if (i != 0) {
                v += m[i - 1][j].voltage;
                n++;
            }
            if (j != 0) {
                v += m[i][j - 1].voltage;
                n++;
            }
            if (i < h - 1) {
                v += m[i + 1][j].voltage;
                n++;
            }
            if (j < w - 1) {
                v += m[i][j + 1].voltage;
                n++;
            }
            v = m[i][j].voltage - v / n;

            d[i][j].voltage = v;
            if (m[i][j].fixed == TYPE_RM_REF(m[i][j].fixed)::FREE)
                total += square(v);
        }
    return total;
}

template <typename T1> auto iter(T1 &m)
{
    auto h = m.len();
    auto w = _get<0>(m).len();
    auto difference = range_el(0, h).map([&w](const auto &i){return range_el(0, w).map([](const auto &j){return Node();});});

    while (true) {
        set_boundary(m);
        if (calc_difference(m, difference) < ::DIFF_THRESHOLD)
            break;
        {int Lindex = 0;
        for (auto &&di : difference) {
            auto i = Lindex;
            {int Lindex = 0;
            for (auto &&dij : di) {
                auto j = Lindex;
                m[i][j].voltage -= dij.voltage;
                Lindex++;
            }}
            Lindex++;
        }}
    }

    auto cur = create_array({0.0}) * 3;
    {int Lindex = 0;
    for (auto &&di : difference) {
        auto i = Lindex;
        {int Lindex = 0;
        for (auto &&dij : di) {
            auto j = Lindex;
            cur[to_int(m[i][j].fixed)] += (dij.voltage * (to_int(i != 0) + to_int(j != 0) + (i < h - 1) + (j < w - 1)));
            Lindex++;
        }}
        Lindex++;
    }}

    return (cur[to_int(Fixed::A)] - cur[to_int(Fixed::B)]) / 2.0;
}

auto w = 10;
auto h = 10;
auto mesh = range_el(0, h).map([](const auto &i){return range_el(0, ::w).map([](const auto &j){return Node();});});

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"R = #.16"_S.format(2.0 / iter(mesh)));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Roots_of_unity#Python
import math

def polar(r, theta):
    return r * (math.cos(theta) + math.sin(theta) * 1j) # [https://en.cppreference.com/w/cpp/numeric/complex/polar]

def croots(n):
    return [polar(1, 2 * k * math.pi / n) for k in range(n)]

for nr in range(2, 11):
    print(nr, croots(nr))
===
F polar(r, theta)
   R r * (cos(theta) + sin(theta) * 1i)

F croots(n)
   R (0 .< n).map(k -> polar(1, 2 * k * math:pi / @n))

L(nr) 2..10
   print(nr‘ ’croots(nr))
===
template <typename T1, typename T2> auto polar(const T1 &r, const T2 &theta)
{
    return r * (cos(theta) + sin(theta) * 1i);
}

template <typename T1> auto croots(const T1 &n)
{
    return range_el(0, n).map([&n](const auto &k){return polar(1, 2 * k * math::pi / n);});
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto nr : range_ee(2, 10))
            print(nr & u" "_S & croots(nr));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Semordnilap#Python
wordset = set(open('unixdict.txt').read().split("\n"))

revlist = (word[::-1] for word in wordset)
pairs   = set((wrd, rev) for wrd, rev in zip(wordset, revlist)
                 if wrd < rev and rev in wordset)

print(len(pairs))
print(sorted(list(pairs), key=lambda p: (len(p[0]), p))[-5:])
===
V wordset = Set(File(‘unixdict.txt’).read().split("\n"))

V revlist = (wordset.map(word -> reversed(word)))
V pairs = Set(zip(wordset, revlist).filter((wrd, rev) -> wrd < rev & rev C :wordset))

print(pairs.len)
print(sorted(Array(pairs), key' p -> (p[0].len, p))[(len)-5 ..])
===
auto wordset = create_set(File(u"unixdict.txt"_S).read().split(u"\n"_S));

auto revlist = (wordset.map([](const auto &word){return reversed(word);}));
auto pairs = create_set(zip(wordset, revlist).filter([](const auto &wrd, const auto &rev){return wrd < rev && in(rev, ::wordset);}));

struct CodeBlock1
{
    CodeBlock1()
    {
        print(pairs.len());
        print(sorted(create_array(pairs), [](const auto &p){return make_tuple(_get<0>(p).len(), p);})[range_elen_i( - 5)]);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Set#Python
s1 = {1, 2, 3, 4}
s2 = {3, 4, 5, 6}
print(s1.union(s2))
print(s1.intersection(s2))
print(s1.difference(s2))
print(s1 < s1)
print({3, 1} < s1)
print(s1 <= s1)
print({3, 1} <= s1)
print({3, 2, 4, 1} == s1)
print(s1 == s2)
print(2 in s1)
print(10 not in s1)
print({1, 2, 3, 4, 5} > s1)
print({1, 2, 3, 4} > s1)
print({1, 2, 3, 4} >= s1)
print(s1.symmetric_difference(s2))
print(len(s1))
s1.add(99)
print(s1)
s1.discard(99)
print(s1)
===
V s1 = Set([1, 2, 3, 4])
V s2 = Set([3, 4, 5, 6])
print(s1.union(s2))
print(s1.intersection(s2))
print(s1.difference(s2))
print(s1 < s1)
print(Set([3, 1]) < s1)
print(s1 <= s1)
print(Set([3, 1]) <= s1)
print(Set([3, 2, 4, 1]) == s1)
print(s1 == s2)
print(2 C s1)
print(10 !C s1)
print(Set([1, 2, 3, 4, 5]) > s1)
print(Set([1, 2, 3, 4]) > s1)
print(Set([1, 2, 3, 4]) >= s1)
print(s1.symmetric_difference(s2))
print(s1.len)
s1.add(99)
print(s1)
s1.discard(99)
print(s1)
===
auto s1 = create_set({1, 2, 3, 4});
auto s2 = create_set({3, 4, 5, 6});

struct CodeBlock1
{
    CodeBlock1()
    {
        print(s1.set_union(s2));
        print(s1.intersection(s2));
        print(s1.difference(s2));
        print(s1 < s1);
        print(create_set({3, 1}) < s1);
        print(s1 <= s1);
        print(create_set({3, 1}) <= s1);
        print(create_set({3, 2, 4, 1}) == s1);
        print(s1 == s2);
        print(in(2, s1));
        print(!in(10, s1));
        print(create_set({1, 2, 3, 4, 5}) > s1);
        print(create_set({1, 2, 3, 4}) > s1);
        print(create_set({1, 2, 3, 4}) >= s1);
        print(s1.symmetric_difference(s2));
        print(s1.len());
        s1.add(99);
        print(s1);
        s1.discard(99);
        print(s1);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Seven-sided_dice_from_five-sided_dice#Python
# https://www.rosettacode.org/wiki/Verify_distribution_uniformity/Naive#Python
import random, collections

def dice5():
    return random.randint(1, 5)

def dice7() -> int:
    r = dice5() + dice5() * 5 - 6
    return (r % 7) + 1 if r < 21 else dice7()

def distcheck(func, repeats, delta):
    bin = collections.defaultdict(int) # int
    for i in range(repeats):
        bin[func()] += 1
    target = repeats // len(bin)
    deltacount = int(delta / 100.0 * target)
    assert all( abs(target - count) < deltacount
                for count in bin.values() ), "Bin distribution skewed from %i +/- %i: %s" % (
                    target, deltacount, [ (key, target - count)
                                          for key, count in sorted(bin.items()) ]
                    )
    print(bin)

distcheck(dice5, 1000000, 1)
distcheck(dice7, 1000000, 1)
===
F dice5()
   R random:(1 .. 5)

F dice7() -> Int
   V r = dice5() + dice5() * 5 - 6
   R I r < 21 {(r % 7) + 1} E dice7()

F distcheck(func, repeats, delta)
   V bin = DefaultDict[Int, Int]()
   L(i) 0 .< repeats
      bin[func()]++
   V target = repeats I/ bin.len
   V deltacount = Int(delta / 100.0 * target)
   assert(all(bin.values().map(count -> abs(@target - count) < @deltacount)), ‘Bin distribution skewed from #. +/- #.: #.’.format(target, deltacount, sorted(bin.items()).map((key, count) -> (key, @target - count))))
   print(bin)

distcheck(dice5, 1000000, 1)
distcheck(dice7, 1000000, 1)
===
auto dice5()
{
    return randomns::_(range_ee(1, 5));
}

int dice7()
{
    auto r = dice5() + dice5() * 5 - 6;
    return r < 21 ? (mod(r, 7)) + 1 : dice7();
}

template <typename T1, typename T2, typename T3> auto distcheck(const T1 &func, const T2 &repeats, const T3 &delta)
{
    auto bin = DefaultDict<int, int>();
    for (auto i : range_el(0, repeats))
        bin[func()]++;
    auto target = idiv(repeats, bin.len());
    auto deltacount = to_int(delta / 100.0 * target);
    assert(all_map(bin.values(), [&deltacount, &target](const auto &count){return abs(target - count) < deltacount;}), u"Bin distribution skewed from #. +/- #.: #."_S.format(target, deltacount, sorted(bin.items()).map([&target](const auto &key, const auto &count){return make_tuple(key, target - count);})));
    print(bin);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        distcheck(dice5, 1000000, 1);
        distcheck(dice7, 1000000, 1);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Solve_a_Hidato_puzzle#Python
from typing import List

board : List[List[int]] = []
given : List[int] = []
start = (-1, -1)

def setup(s):
    global board, given, start
    lines = s.split("\n")
    ncols = len(lines[0].split())
    nrows = len(lines)
    board = [[-1] * (ncols + 2) for _ in range(nrows + 2)]

    for r, row in enumerate(lines):
        for c, cell in enumerate(row.split()):
            if cell == "__" :
                board[r + 1][c + 1] = 0
                continue
            elif cell == ".":
                continue # -1
            else:
                val = int(cell)
                board[r + 1][c + 1] = val
                given.append(val)
                if val == 1:
                    start = (r + 1, c + 1)
    given.sort()

def solve(r, c, n, next=0):
    if n > given[-1]:
        return True
    if board[r][c] and board[r][c] != n:
        return False
    if board[r][c] == 0 and given[next] == n:
        return False

    back = 0
    if board[r][c] == n:
        next += 1
        back = n

    board[r][c] = n
    for i in range(-1, 2):
        for j in range(-1, 2):
            if solve(r + i, c + j, n + 1, next):
                return True
    board[r][c] = back
    return False

def print_board():
    d = {-1: "  ", 0: "__"}
    bmax = max(max(r) for r in board)
    lbmax = len(str(bmax)) + 1
    for r in board[1:-1]:
        print("".join(d.get(c, str(c)).rjust(lbmax) for c in r[1:-1]))

hi = """\
__ 33 35 __ __  .  .  .
__ __ 24 22 __  .  .  .
__ __ __ 21 __ __  .  .
__ 26 __ 13 40 11  .  .
27 __ __ __  9 __  1  .
 .  . __ __ 18 __ __  .
 .  .  .  . __  7 __ __
 .  .  .  .  .  .  5 __"""

setup(hi)
print_board()
solve(start[0], start[1], 1)
print()
print_board()
===
[[Int]] board
[Int] given
V start = (-1, -1)

F setup(s)
   V lines = s.split("\n")
   V ncols = lines[0].split_py().len
   V nrows = lines.len
   :board = [[-1] * (ncols + 2)] * (nrows + 2)

   L(row) lines
      V r = L.index
      L(cell) row.split_py()
         V c = L.index
         I cell == ‘__’
            :board[r + 1][c + 1] = 0
            L.continue
         E I cell == ‘.’
            L.continue
         E
            V val = Int(cell)
            :board[r + 1][c + 1] = val
            :given.append(val)
            I val == 1
               :start = (r + 1, c + 1)
   :given.sort()

F solve(r, c, n, =next = 0)
   I n > :given.last
      R 1B
   I :board[r][c] & :board[r][c] != n
      R 0B
   I :board[r][c] == 0 & :given[next] == n
      R 0B

   V back = 0
   I :board[r][c] == n
      next++
      back = n

   :board[r][c] = n
   L(i) -1 .< 2
      L(j) -1 .< 2
         I solve(r + i, c + j, n + 1, next)
            R 1B
   :board[r][c] = back
   R 0B

F print_board()
   V d = [-1 = ‘  ’, 0 = ‘__’]
   V bmax = max(:board.map(r -> max(r)))
   V lbmax = String(bmax).len + 1
   L(r) :board[1 .< (len)-1]
      print(r[1 .< (len)-1].map(c -> @d.get(c, String(c)).rjust(@lbmax)).join(‘’))

V hi = "\
__ 33 35 __ __  .  .  .\n\
__ __ 24 22 __  .  .  .\n\
__ __ __ 21 __ __  .  .\n\
__ 26 __ 13 40 11  .  .\n\
27 __ __ __  9 __  1  .\n\
 .  . __ __ 18 __ __  .\n\
 .  .  .  . __  7 __ __\n\
 .  .  .  .  .  .  5 __"

setup(hi)
print_board()
solve(start[0], start[1], 1)
print()
print_board()
===
Array<Array<int>> board;
Array<int> given;
auto start = make_tuple(-1, -1);

template <typename T1> auto setup(const T1 &s)
{
    auto lines = s.split(u"\n"_S);
    auto ncols = _get<0>(lines).split_py().len();
    auto nrows = lines.len();
    ::board = create_array({create_array({-1}) * (ncols + 2)}) * (nrows + 2);
    {int Lindex = 0;

    for (auto &&row : lines) {
        auto r = Lindex;
        {int Lindex = 0;
        for (auto &&cell : row.split_py()) {{
            auto c = Lindex;
            if (cell == u"__") {
                ::board[r + 1].set(c + 1, 0);
                goto on_continue;
            }
            else if (cell == u'.')
                goto on_continue;
            else {
                auto val = to_int(cell);
                ::board[r + 1].set(c + 1, val);
                ::given.append(val);
                if (val == 1)
                    ::start = make_tuple(r + 1, c + 1);
            }
} on_continue:
            Lindex++;
        }}
        Lindex++;
    }}
    ::given.sort();
}

template <typename T1, typename T2, typename T3, typename T4 = decltype(0)> auto solve(const T1 &r, const T2 &c, const T3 &n, T4 next = 0)
{
    if (n > ::given.last())
        return true;
    if (::board[r][c] && ::board[r][c] != n)
        return false;
    if (::board[r][c] == 0 && ::given[next] == n)
        return false;

    auto back = 0;
    if (::board[r][c] == n) {
        next++;
        back = n;
    }

    ::board[r].set(c, n);
    for (auto i : range_el(-1, 2))
        for (auto j : range_el(-1, 2))
            if (solve(r + i, c + j, n + 1, next))
                return true;
    ::board[r].set(c, back);
    return false;
}

auto print_board()
{
    auto d = create_dict(dict_of(-1, u"  "_S)(0, u"__"_S));
    auto bmax = max_map(::board, [](const auto &r){return max(r);});
    auto lbmax = String(bmax).len() + 1;
    for (auto &&r : ::board[range_e_llen(1,  - 1)])
        print(r[range_e_llen(1,  - 1)].map([&d, &lbmax](const auto &c){return d.get(c, String(c)).rjust(lbmax);}).join(u""_S));
}

auto hi = u"\
__ 33 35 __ __  .  .  .\n\
__ __ 24 22 __  .  .  .\n\
__ __ __ 21 __ __  .  .\n\
__ 26 __ 13 40 11  .  .\n\
27 __ __ __  9 __  1  .\n\
 .  . __ __ 18 __ __  .\n\
 .  .  .  . __  7 __ __\n\
 .  .  .  .  .  .  5 __"_S;

struct CodeBlock1
{
    CodeBlock1()
    {
        setup(hi);
        print_board();
        solve(_get<0>(start), _get<1>(start), 1);
        print();
        print_board();
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Sort_an_array_of_composite_structures#Kotlin
class Employee:
    name : str
    category : str

    def __init__(self, name, category):
        self.name = name
        self.category = category

employees = [
    Employee("David", "Manager"),
    Employee("Alice", "Sales"),
    Employee("Joanna", "Director"),
    Employee("Henry", "Admin"),
    Employee("Tim", "Sales"),
    Employee("Juan", "Admin")
]

employees.sort(key = lambda e: e.name)

for e in employees:
    print('%-6s : %s' % (e.name, e.category))
===
T Employee
   String name
   String category

   F (name, category)
      .name = name
      .category = category

V employees = [Employee(‘David’, ‘Manager’), Employee(‘Alice’, ‘Sales’), Employee(‘Joanna’, ‘Director’), Employee(‘Henry’, ‘Admin’), Employee(‘Tim’, ‘Sales’), Employee(‘Juan’, ‘Admin’)]

employees.sort(key' e -> e.name)

L(e) employees
   print(‘#<6 : #.’.format(e.name, e.category))
===
class Employee
{
public:
    String name;
    String category;

    template <typename T1, typename T2> Employee(const T1 &name, const T2 &category) :
        name(name),
        category(category)
    {
    }
};

auto employees = create_array<Employee>({Employee(u"David"_S, u"Manager"_S), Employee(u"Alice"_S, u"Sales"_S), Employee(u"Joanna"_S, u"Director"_S), Employee(u"Henry"_S, u"Admin"_S), Employee(u"Tim"_S, u"Sales"_S), Employee(u"Juan"_S, u"Admin"_S)});

struct CodeBlock1
{
    CodeBlock1()
    {
        employees.sort([](const auto &e){return e.name;});

        for (auto &&e : employees)
            print(u"#<6 : #."_S.format(e.name, e.category));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Sorting_algorithms/Bubble_sort#Python
def bubble_sort(seq : list):
    changed = True
    while changed == True:
        changed = False
        for i in range(len(seq) - 1):
            if seq[i] > seq[i+1]:
                (seq[i], seq[i+1]) = (seq[i+1], seq[i])
                changed = True

import random

testset = list(range(100))
testcase = testset[:] # make a copy
random.shuffle(testcase)
assert testcase != testset  # we've shuffled it
bubble_sort(testcase)
assert testcase == testset  # we've unshuffled it back into a copy
===
F bubble_sort(&seq)
   V changed = 1B
   L changed == 1B
      changed = 0B
      L(i) 0 .< seq.len - 1
         I seq[i] > seq[i + 1]
            swap(&seq[i], &seq[i + 1])
            changed = 1B

V testset = Array(0.<100)
V testcase = copy(testset)
random:shuffle(&testcase)
assert(testcase != testset)
bubble_sort(&testcase)
assert(testcase == testset)
===
template <typename T1> auto bubble_sort(T1 &seq)
{
    auto changed = true;
    while (changed == true) {
        changed = false;
        for (auto i : range_el(0, seq.len() - 1))
            if (seq[i] > seq[i + 1]) {
                swap(seq[i], seq[i + 1]);
                changed = true;
            }
    }
}

auto testset = create_array(range_el(0, 100));
auto testcase = copy(testset);

struct CodeBlock1
{
    CodeBlock1()
    {
        randomns::shuffle(testcase);
        assert(testcase != testset);
        bubble_sort(testcase);
        assert(testcase == testset);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Soundex#Java
from typing import Dict
Char = str

inv_code = {
    '1': ['B', 'F', 'P', 'V'],
    '2': ['C', 'G', 'J', 'K', 'Q', 'S', 'X', 'Z'],
    '3': ['D', 'T'],
    '4': ['L'],
    '5': ['M', 'N'],
    '6': ['R']
}

_code : Dict[Char, Char] = {}
for k, arr in inv_code.items():
    for el in arr:
        _code[el] = k

def soundex(s):
    code = str(s[0].upper())
    previous = _code.get(s[0].upper(), Char("\0"))

    for c in s[1:]:
        current = _code.get(c.upper(), Char("\0"))
        if current != "\0" and current != previous:
            code += current
        previous = current

    return (code + '0000')[:4]

print(soundex("Soundex"))
print(soundex("Example"))
print(soundex("Sownteks"))
print(soundex("Ekzampul"))
===
V inv_code = [‘1’ = [‘B’, ‘F’, ‘P’, ‘V’], ‘2’ = [‘C’, ‘G’, ‘J’, ‘K’, ‘Q’, ‘S’, ‘X’, ‘Z’], ‘3’ = [‘D’, ‘T’], ‘4’ = [‘L’], ‘5’ = [‘M’, ‘N’], ‘6’ = [‘R’]]

[Char = Char] _code
L(k, arr) inv_code
   L(el) arr
      _code[el] = k

F soundex(s)
   V code = String(s[0].uppercase())
   V previous = :_code.get(s[0].uppercase(), Char("\0"))

   L(c) s[1..]
      V current = :_code.get(c.uppercase(), Char("\0"))
      I current != "\0" & current != previous
         code ‘’= current
      previous = current

   R (code‘0000’)[0.<4]

print(soundex(‘Soundex’))
print(soundex(‘Example’))
print(soundex(‘Sownteks’))
print(soundex(‘Ekzampul’))
===
auto inv_code = create_dict(dict_of(u'1'_C, create_array({u'B'_C, u'F'_C, u'P'_C, u'V'_C}))(u'2'_C, create_array({u'C'_C, u'G'_C, u'J'_C, u'K'_C, u'Q'_C, u'S'_C, u'X'_C, u'Z'_C}))(u'3'_C, create_array({u'D'_C, u'T'_C}))(u'4'_C, create_array({u'L'_C}))(u'5'_C, create_array({u'M'_C, u'N'_C}))(u'6'_C, create_array({u'R'_C})));

Dict<Char, Char> _code;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&[k, arr] : inv_code)
            for (auto &&el : arr)
                _code.set(el, k);
    }
} code_block_1;

template <typename T1> auto soundex(const T1 &s)
{
    auto code = String(_get<0>(s).uppercase());
    auto previous = ::_code.get(_get<0>(s).uppercase(), u'\0'_C);

    for (auto &&c : s[range_ei(1)]) {
        auto current = ::_code.get(c.uppercase(), u'\0'_C);
        if (current != u'\0' && current != previous)
            code &= current;
        previous = current;
    }

    return (code & u"0000"_S)[range_el(0, 4)];
}

struct CodeBlock2
{
    CodeBlock2()
    {
        print(soundex(u"Soundex"_S));
        print(soundex(u"Example"_S));
        print(soundex(u"Sownteks"_S));
        print(soundex(u"Ekzampul"_S));
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Taxicab_numbers#Python
from typing import Dict, List, Tuple
Int64 = int

cubes = [Int64(x)**3 for x in range(1,1200)]
crev : Dict[Int64, Int64] = {}
# for cube root lookup
for x,x3 in enumerate(cubes): crev[x3] = x + 1

sums = sorted(x+y for x in cubes for y in cubes if y < x)

idx = 0
for i in range(1, len(sums)-1):
    if sums[i-1] != sums[i] and sums[i] == sums[i+1]:
        idx += 1
        if (idx > 25 and idx < 2000) or idx > 2006: continue

        n = sums[i]
        p : List[Tuple[Int64, Int64]] = []
        for x in cubes:
            if n-x < x: break
            if n-x in crev:
                p.append((crev[x], crev[n-x]))
        print("%4d: %10d"%(idx,n), end = ' ')
        for x1, x2 in p: print(" = %4d^3 + %4d^3" % (x1, x2), end = ' ')
        print()
===
V cubes = (1..1199).map(x -> Int64(x) ^ 3)
[Int64 = Int64] crev
L(x3) cubes
   V x = L.index
   crev[x3] = x + 1

V sums = sorted(multiloop_filtered(cubes, cubes, (x, y) -> y < x, (x, y) -> x + y))

V idx = 0
L(i) 1 .< sums.len - 1
   I sums[i - 1] != sums[i] & sums[i] == sums[i + 1]
      idx++
      I (idx > 25 & idx < 2000) | idx > 2006
         L.continue

      V n = sums[i]
      [(Int64, Int64)] p
      L(x) cubes
         I n - x < x
            L.break
         I n - x C crev
            p.append((crev[x], crev[n - x]))
      print(‘#4: #10’.format(idx, n), end' ‘ ’)
      L(x1, x2) p
         print(‘ = #4^3 + #4^3’.format(x1, x2), end' ‘ ’)
      print()
===
auto cubes = range_ee(1, 1199).map([](const auto &x){return cube(to_int64(x));});
Dict<Int64, Int64> crev;

struct CodeBlock1
{
    CodeBlock1()
    {
        {int Lindex = 0;
        for (auto &&x3 : cubes) {
            auto x = Lindex;
            crev.set(x3, x + 1);
            Lindex++;
        }}
    }
} code_block_1;

auto sums = sorted(multiloop_filtered(cubes, cubes, [](const auto &x, const auto &y){return y < x;}, [](const auto &x, const auto &y){return x + y;}));

auto idx = 0;

struct CodeBlock2
{
    CodeBlock2()
    {
        for (auto i : range_el(1, sums.len() - 1))
            if (sums[i - 1] != sums[i] && sums[i] == sums[i + 1]) {
                idx++;
                if ((idx > 25 && idx < 2000) || idx > 2006)
                    continue;

                auto n = sums[i];
                Array<llvec2> p;
                for (auto &&x : cubes) {
                    if (n - x < x)
                        break;
                    if (in(n - x, crev))
                        p.append(make_tuple(crev[x], crev[n - x]));
                }
                print(u"#4: #10"_S.format(idx, n), u" "_S);
                for (auto &&[x1, x2] : p)
                    print(u" = #4^3 + #4^3"_S.format(x1, x2), u" "_S);
                print();
            }
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Teacup_rim_text#Python
def rotated(s : str):
    return s[1:] + s[0]

s = set(open('unixdict.txt').read().rstrip("\n").split("\n"))
while len(s):
    for word_ in s:
        word = word_ # because after `s.remove(word)` `word` becomes invalid
        s.remove(word)
        if len(word) < 3:
            break

        w = word
        for i in range(len(word) - 1):
            w = rotated(w)
            if w in s:
                s.remove(w)
            else:
                break
        else:
            print(word, end = '')
            w = word
            for i in range(len(word) - 1):
                w = rotated(w)
                print(' -> ' + w, end = '')
            print()

        break
===
F rotated(String s)
   R s[1..]‘’s[0]

V s = Set(File(‘unixdict.txt’).read().rtrim("\n").split("\n"))
L !s.empty
   L(word_) s
      V word = word_
      s.remove(word)
      I word.len < 3
         L.break

      V w = word
      L(i) 0 .< word.len - 1
         w = rotated(w)
         I w C s
            s.remove(w)
         E
            L.break
      L.was_no_break
         print(word, end' ‘’)
         w = word
         L(i) 0 .< word.len - 1
            w = rotated(w)
            print(‘ -> ’w, end' ‘’)
         print()
      L.break
===
auto rotated(const String &s)
{
    return s[range_ei(1)] & _get<0>(s);
}

auto s = create_set(File(u"unixdict.txt"_S).read().rtrim(u"\n"_S).split(u"\n"_S));

struct CodeBlock1
{
    CodeBlock1()
    {
        while (!s.empty())
            for (auto &&word_ : s) {
                auto word = word_;
                s.remove(word);
                if (word.len() < 3)
                    break;

                auto w = word;
                for (auto i : range_el(0, word.len() - 1)) {
                    w = rotated(w);
                    if (in(w, s))
                        s.remove(w);
                    else
                        goto break_;
                }
                print(word, u""_S);
                w = word;
                for (auto i : range_el(0, word.len() - 1)) {
                    w = rotated(w);
                    print(u" -> "_S & w, u""_S);
                }
                print();
                break_:;
                break;
            }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Textonyms#Python
from typing import Dict
import collections
Char = str

CH2NUM : Dict[Char, str] = {}
for num, chars in enumerate('abc def ghi jkl mno pqrs tuv wxyz'.split(' '), 2):
    for ch in chars:
        CH2NUM[ch] = str(num)

def mapnum2words(words):
    number2words : DefaultDict[str, List[str]] = collections.defaultdict(list)
    reject = 0
    for word in words:
        try:
            number2words[''.join(CH2NUM[ch] for ch in word)].append(word)
        except KeyError:
            # Reject words with non a-z e.g. '10th'
            reject += 1
    return (number2words, reject)

words = open('unixdict.txt').read().rstrip("\n").split("\n")
print("Read %i words from 'unixdict.txt'" % len(words))
wordset = set(words)
(num2words, reject) = mapnum2words(words)

def interactiveconversions():
    for inp in ('rosetta', 'code', '2468', '3579'):
        print("\nType a number or a word to get the translation and textonyms:", inp)
        if all(ch in '23456789' for ch in inp):
            if inp in num2words:
                print("  Number %s has the following textonyms in the dictionary: %s" % (inp, ', '.join(
                    num2words[inp])))
            else:
                print("  Number %s has no textonyms in the dictionary." % inp)
        elif all(ch in CH2NUM for ch in inp):
            num = ''.join(CH2NUM[ch] for ch in inp)
            print("  Word %s is%s in the dictionary and is number %s with textonyms: %s" % (
                inp, ('' if inp in wordset else "n't"), num, ', '.join(num2words[num])))
        else:
            print("  I don't understand '%s'" % inp)

morethan1word = sum(1 for w in num2words.keys() if len(num2words[w]) > 1)
maxwordpernum = max(len(values) for values in num2words.values())
print("""
There are %d words in %s which can be represented by the Textonyms mapping.
They require %d digit combinations to represent them.
%d digit combinations represent Textonyms.""" % (len(words) - reject, "'unixdict.txt'", len(num2words), morethan1word))

print("\nThe numbers mapping to the most words map to %i words each:" % maxwordpernum)
maxwpn = sorted((key, val) for key, val in num2words.items() if len(val) == maxwordpernum)
for num, wrds in maxwpn:
    print("  %s maps to: %s" % (num, ', '.join(wrds)))

interactiveconversions()
===
[Char = String] CH2NUM
L(chars) ‘abc def ghi jkl mno pqrs tuv wxyz’.split(‘ ’)
   V num = L.index + 2
   L(ch) chars
      CH2NUM[ch] = String(num)

F mapnum2words(words)
   DefaultDict[String, [String]] number2words
   V reject = 0
   L(word) words
      X.try
         number2words[word.map(ch -> :CH2NUM[ch]).join(‘’)].append(word)
      X.catch KeyError
         reject++
   R (number2words, reject)

V words = File(‘unixdict.txt’).read().rtrim("\n").split("\n")
print(‘Read #. words from 'unixdict.txt'’.format(words.len))
V wordset = Set(words)
V (num2words, reject) = mapnum2words(words)

F interactiveconversions()
   L(inp) (‘rosetta’, ‘code’, ‘2468’, ‘3579’)
      print("\nType a number or a word to get the translation and textonyms: "inp)
      I all(inp.map(ch -> ch C ‘23456789’))
         I inp C :num2words
            print(‘  Number #. has the following textonyms in the dictionary: #.’.format(inp, (:num2words[inp]).join(‘, ’)))
         E
            print(‘  Number #. has no textonyms in the dictionary.’.format(inp))
      E I all(inp.map(ch -> ch C :CH2NUM))
         V num = inp.map(ch -> :CH2NUM[ch]).join(‘’)
         print(‘  Word #. is#. in the dictionary and is number #. with textonyms: #.’.format(inp, (I inp C :wordset {‘’} E ‘n't’), num, (:num2words[num]).join(‘, ’)))
      E
         print(‘  I don't understand '#.'’.format(inp))

V morethan1word = sum(num2words.keys().filter(w -> :num2words[w].len > 1).map(w -> 1))
V maxwordpernum = max(num2words.values().map(values -> values.len))
print(‘
There are #. words in #. which can be represented by the Textonyms mapping.
They require #. digit combinations to represent them.
#. digit combinations represent Textonyms.’.format(words.len - reject, ‘'unixdict.txt'’, num2words.len, morethan1word))

print("\nThe numbers mapping to the most words map to #. words each:".format(maxwordpernum))
V maxwpn = sorted(num2words.filter((key, val) -> val.len == :maxwordpernum))
L(num, wrds) maxwpn
   print(‘  #. maps to: #.’.format(num, wrds.join(‘, ’)))

interactiveconversions()
===
Dict<Char, String> CH2NUM;

struct CodeBlock1
{
    CodeBlock1()
    {
        {int Lindex = 0;
        for (auto &&chars : u"abc def ghi jkl mno pqrs tuv wxyz"_S.split(u" "_S)) {
            auto num = Lindex + 2;
            for (auto &&ch : chars)
                CH2NUM.set(ch, String(num));
            Lindex++;
        }}
    }
} code_block_1;

template <typename T1> auto mapnum2words(const T1 &words)
{
    DefaultDict<String, Array<String>> number2words;
    auto reject = 0;
    for (auto &&word : words) {
        try
        {
            number2words[word.map([](const auto &ch){return ::CH2NUM[ch];}).join(u""_S)].append(word);
        }
        catch (const KeyError&)
        {
            reject++;
        }
    }
    return make_tuple(number2words, reject);
}

auto words = File(u"unixdict.txt"_S).read().rtrim(u"\n"_S).split(u"\n"_S);

struct CodeBlock2
{
    CodeBlock2()
    {
        print(u"Read #. words from 'unixdict.txt'"_S.format(words.len()));
    }
} code_block_2;

auto wordset = create_set(words);
auto [num2words, reject] = mapnum2words(words);

auto interactiveconversions()
{
    for (auto &&inp : make_tuple(u"rosetta"_S, u"code"_S, u"2468"_S, u"3579"_S)) {
        print(u"\nType a number or a word to get the translation and textonyms: "_S & inp);
        if (all_map(inp, [](const auto &ch){return in(ch, u"23456789"_S);})) {
            if (in(inp, ::num2words))
                print(u"  Number #. has the following textonyms in the dictionary: #."_S.format(inp, (::num2words[inp]).join(u", "_S)));
            else
                print(u"  Number #. has no textonyms in the dictionary."_S.format(inp));
        }
        else if (all_map(inp, [](const auto &ch){return in(ch, ::CH2NUM);})) {
            auto num = inp.map([](const auto &ch){return ::CH2NUM[ch];}).join(u""_S);
            print(u"  Word #. is#. in the dictionary and is number #. with textonyms: #."_S.format(inp, (in(inp, ::wordset) ? u""_S : u"n't"_S), num, (::num2words[num]).join(u", "_S)));
        }
        else
            print(u"  I don't understand '#.'"_S.format(inp));
    }
}

auto morethan1word = sum_map(num2words.keys().filter([](const auto &w){return ::num2words[w].len() > 1;}), [](const auto &w){return 1;});
auto maxwordpernum = max_map(num2words.values(), [](const auto &values){return values.len();});

struct CodeBlock3
{
    CodeBlock3()
    {
        print(uR"(
There are #. words in #. which can be represented by the Textonyms mapping.
They require #. digit combinations to represent them.
#. digit combinations represent Textonyms.)"_S.format(words.len() - reject, u"'unixdict.txt'"_S, num2words.len(), morethan1word));

        print(u"\nThe numbers mapping to the most words map to #. words each:"_S.format(maxwordpernum));
    }
} code_block_3;

auto maxwpn = sorted(num2words.filter([](const auto &key, const auto &val){return val.len() == ::maxwordpernum;}));

struct CodeBlock4
{
    CodeBlock4()
    {
        for (auto &&[num, wrds] : maxwpn)
            print(u"  #. maps to: #."_S.format(num, wrds.join(u", "_S)));

        interactiveconversions();
    }
} code_block_4;


# https://www.rosettacode.org/wiki/The_Twelve_Days_of_Christmas#Python
gifts = \
'''A partridge in a pear tree.
Two turtle doves
Three french hens
Four calling birds
Five golden rings
Six geese a-laying
Seven swans a-swimming
Eight maids a-milking
Nine ladies dancing
Ten lords a-leaping
Eleven pipers piping
Twelve drummers drumming'''.split('\n')

days = 'first second third fourth fifth sixth seventh eighth ninth tenth eleventh twelfth'.split(' ')

for n, day in enumerate(days, 1):
    g = gifts[:n][::-1]
    print(('\nOn the %s day of Christmas\nMy true love gave to me:\n' % day) +
          '\n'.join(g[:-1]) +
          (' and\n' + g[-1] if n > 1 else g[-1]))
===
V gifts = ‘A partridge in a pear tree.
Two turtle doves
Three french hens
Four calling birds
Five golden rings
Six geese a-laying
Seven swans a-swimming
Eight maids a-milking
Nine ladies dancing
Ten lords a-leaping
Eleven pipers piping
Twelve drummers drumming’.split("\n")

V days = ‘first second third fourth fifth sixth seventh eighth ninth tenth eleventh twelfth’.split(‘ ’)

L(day) days
   V n = L.index + 1
   V g = reversed(gifts[0 .< n])
   print(("\nOn the #. day of Christmas\nMy true love gave to me:\n".format(day))‘’(g[0 .< (len)-1]).join("\n")‘’(I n > 1 {" and\n"g.last} E g.last))
===
auto gifts = uR"(A partridge in a pear tree.
Two turtle doves
Three french hens
Four calling birds
Five golden rings
Six geese a-laying
Seven swans a-swimming
Eight maids a-milking
Nine ladies dancing
Ten lords a-leaping
Eleven pipers piping
Twelve drummers drumming)"_S.split(u"\n"_S);

auto days = u"first second third fourth fifth sixth seventh eighth ninth tenth eleventh twelfth"_S.split(u" "_S);

struct CodeBlock1
{
    CodeBlock1()
    {
        {int Lindex = 0;

        for (auto &&day : days) {
            auto n = Lindex + 1;
            auto g = reversed(gifts[range_el(0, n)]);
            print((u"\nOn the #. day of Christmas\nMy true love gave to me:\n"_S.format(day)) & (g[range_e_llen(0,  - 1)]).join(u"\n"_S) & (n > 1 ? u" and\n"_S & g.last() : g.last()));
            Lindex++;
        }}
    }
} code_block_1;


# https://www.rosettacode.org/wiki/The_Name_Game#Python
def print_verse(n):
    l = [str('b'), 'f', 'm']
    s = n[1:]
    if n[0].lower() in l:
        l[l.index(n[0].lower())] = ''
    elif n[0] in ('A', 'E', 'I', 'O', 'U'):
        s = n.lower()
    print('{0}, {0}, bo-{2}{1}\nBanana-fana fo-{3}{1}\nFee-fi-mo-{4}{1}\n{0}!\n'.format(n, s, l[0], l[1], l[2]))
    #print('%s, %s, bo-%s%s\nBanana-fana fo-%s%s\nFee-fi-mo-%s%s\n%s!\n' % (n, n, l[0], s, l[1], s, l[2], s, n))

# Assume that the names are in title-case and they're more than one character long
for n in ['Gary', 'Earl', 'Billy', 'Felix', 'Mary']:
    print_verse(n)
===
F print_verse(n)
   V l = [String(‘b’), ‘f’, ‘m’]
   V s = n[1..]
   I n[0].lowercase() C l
      l[l.index(n[0].lowercase())] = ‘’
   E I n[0] C (‘A’, ‘E’, ‘I’, ‘O’, ‘U’)
      s = n.lowercase()
   print("#., #., bo-#.#.\nBanana-fana fo-#.#.\nFee-fi-mo-#.#.\n#.!\n".format(n, n, l[0], s, l[1], s, l[2], s, n))

L(n) [‘Gary’, ‘Earl’, ‘Billy’, ‘Felix’, ‘Mary’]
   print_verse(n)
===
template <typename T1> auto print_verse(const T1 &n)
{
    auto l = create_array<String>({String(u"b"_S), u"f"_S, u"m"_S});
    auto s = n[range_ei(1)];
    if (in(_get<0>(n).lowercase(), l))
        l.set(l.index(_get<0>(n).lowercase()), u""_S);
    else if (in(_get<0>(n), make_tuple(u"A"_S, u"E"_S, u"I"_S, u"O"_S, u"U"_S)))
        s = n.lowercase();
    print(u"#., #., bo-#.#.\nBanana-fana fo-#.#.\nFee-fi-mo-#.#.\n#.!\n"_S.format(n, n, _get<0>(l), s, _get<1>(l), s, _get<2>(l), s, n));
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&n : create_array({u"Gary"_S, u"Earl"_S, u"Billy"_S, u"Felix"_S, u"Mary"_S}))
            print_verse(n);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Thiele%27s_interpolation_formula#Python
import math

def thieleInterpolator(x, y):
    ρ = [[yi]*(len(y)-i) for i, yi in enumerate(y)]
    for i in range(len(ρ)-1):
        ρ[i][1] = (x[i] - x[i+1]) / (ρ[i][0] - ρ[i+1][0])
    for i in range(2, len(ρ)):
        for j in range(len(ρ)-i):
            ρ[j][i] = (x[j]-x[j+i]) / (ρ[j][i-1]-ρ[j+1][i-1]) + ρ[j+1][i-2]
    ρ0 = ρ[0]
    def t(xin):
        nonlocal ρ0, x, y # =
        a = 0.0
        for i in range(len(ρ0)-1, 1, -1):
            a = (xin - x[i-1]) / (ρ0[i] - ρ0[i-2] + a)
        return y[0] + (xin-x[0]) / (ρ0[1]+a)
    return t

# task 1: build 32 row trig table
xVal = [i*0.05 for i in range(32)]
tSin = [math.sin(x) for x in xVal]
tCos = [math.cos(x) for x in xVal]
tTan = [math.tan(x) for x in xVal]
# task 2: define inverses
iSin = thieleInterpolator(tSin, xVal)
iCos = thieleInterpolator(tCos, xVal)
iTan = thieleInterpolator(tTan, xVal)
# task 3: demonstrate identities
print('{:16.14f}'.format(6*iSin(0.5)))
print('{:16.14f}'.format(3*iCos(0.5)))
print('{:16.14f}'.format(4*iTan(1)))
===
F thieleInterpolator(x, y)
   V ρ = enumerate(y).map((i, yi) -> [yi] * (@y.len - i))
   L(i) 0 .< ρ.len - 1
      ρ[i][1] = (x[i] - x[i + 1]) / (ρ[i][0] - ρ[i + 1][0])
   L(i) 2 .< ρ.len
      L(j) 0 .< ρ.len - i
         ρ[j][i] = (x[j] - x[j + i]) / (ρ[j][i - 1] - ρ[j + 1][i - 1]) + ρ[j + 1][i - 2]
   V ρ0 = ρ[0]
   F t(xin)
      V a = 0.0
      L(i) (@=ρ0.len - 1 .< 1).step(-1)
         a = (xin - @=x[i - 1]) / (@=ρ0[i] - @=ρ0[i - 2] + a)
      R @=y[0] + (xin - @=x[0]) / (@=ρ0[1] + a)
   R t

V xVal = (0.<32).map(i -> i * 0.05)
V tSin = xVal.map(x -> sin(x))
V tCos = xVal.map(x -> cos(x))
V tTan = xVal.map(x -> tan(x))
V iSin = thieleInterpolator(tSin, xVal)
V iCos = thieleInterpolator(tCos, xVal)
V iTan = thieleInterpolator(tTan, xVal)
print(‘#.14’.format(6 * iSin(0.5)))
print(‘#.14’.format(3 * iCos(0.5)))
print(‘#.14’.format(4 * iTan(1)))
===
template <typename T1, typename T2> auto thieleInterpolator(const T1 &x, const T2 &y)
{
    auto ρ = enumerate(y).map([&y](const auto &i, const auto &yi){return create_array({yi}) * (y.len() - i);});
    for (auto i : range_el(0, ρ.len() - 1))
        _set<1>(ρ[i], (x[i] - x[i + 1]) / (_get<0>(ρ[i]) - _get<0>(ρ[i + 1])));
    for (auto i : range_el(2, ρ.len()))
        for (auto j : range_el(0, ρ.len() - i))
            ρ[j].set(i, (x[j] - x[j + i]) / (ρ[j][i - 1] - ρ[j + 1][i - 1]) + ρ[j + 1][i - 2]);
    auto ρ0 = _get<0>(ρ);
    auto t = [x, y, ρ0](const auto &xin)
    {
        auto a = 0.0;
        for (auto i : range_el(ρ0.len() - 1, 1).step(-1))
            a = (xin - x[i - 1]) / (ρ0[i] - ρ0[i - 2] + a);
        return _get<0>(y) + (xin - _get<0>(x)) / (_get<1>(ρ0) + a);
    };
    return t;
}

auto xVal = range_el(0, 32).map([](const auto &i){return i * 0.05;});
auto tSin = xVal.map([](const auto &x){return sin(x);});
auto tCos = xVal.map([](const auto &x){return cos(x);});
auto tTan = xVal.map([](const auto &x){return tan(x);});
auto iSin = thieleInterpolator(tSin, xVal);
auto iCos = thieleInterpolator(tCos, xVal);
auto iTan = thieleInterpolator(tTan, xVal);

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"#.14"_S.format(6 * iSin(0.5)));
        print(u"#.14"_S.format(3 * iCos(0.5)));
        print(u"#.14"_S.format(4 * iTan(1)));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Top_rank_per_group#Python
import collections
from typing import DefaultDict, List, Tuple

data = [('Tyler Bennett', 'E10297', 32000, 'D101'),
        ('John Rappl', 'E21437', 47000, 'D050'),
        ('George Woltman', 'E00127', 53500, 'D101'),
        ('Adam Smith', 'E63535', 18000, 'D202'),
        ('Claire Buckman', 'E39876', 27800, 'D202'),
        ('David McClellan', 'E04242', 41500, 'D101'),
        ('Rich Holcomb', 'E01234', 49500, 'D202'),
        ('Nathan Adams', 'E41298', 21900, 'D050'),
        ('Richard Potter', 'E43128', 15900, 'D101'),
        ('David Motsinger', 'E27002', 19250, 'D202'),
        ('Tim Sampair', 'E03033', 27000, 'D101'),
        ('Kim Arlich', 'E10001', 57000, 'D190'),
        ('Timothy Grove', 'E16398', 29900, 'D190')]

departments : DefaultDict[str, List[Tuple[str, str, int, str]]] = collections.defaultdict(list)
for rec in data:
    departments[rec[3]].append(rec)

n = 3
for department, recs in sorted(departments.items()):
    print("Department %s" % department)
    print(' %-15s  %-15s  %-15s  %-15s ' % ('Employee Name', 'Employee ID', 'Salary', 'Department'))
    for rec in sorted(recs, key = lambda rec: rec[2], reverse = True)[:n]:
        print(' %-15s  %-15s  %-15s  %-15s ' % (rec[0], rec[1], rec[2], rec[3]))
    print()
===
V data = [(‘Tyler Bennett’, ‘E10297’, 32000, ‘D101’), (‘John Rappl’, ‘E21437’, 47000, ‘D050’), (‘George Woltman’, ‘E00127’, 53500, ‘D101’), (‘Adam Smith’, ‘E63535’, 18000, ‘D202’), (‘Claire Buckman’, ‘E39876’, 27800, ‘D202’), (‘David McClellan’, ‘E04242’, 41500, ‘D101’), (‘Rich Holcomb’, ‘E01234’, 49500, ‘D202’), (‘Nathan Adams’, ‘E41298’, 21900, ‘D050’), (‘Richard Potter’, ‘E43128’, 15900, ‘D101’), (‘David Motsinger’, ‘E27002’, 19250, ‘D202’), (‘Tim Sampair’, ‘E03033’, 27000, ‘D101’), (‘Kim Arlich’, ‘E10001’, 57000, ‘D190’), (‘Timothy Grove’, ‘E16398’, 29900, ‘D190’)]

DefaultDict[String, [(String, String, Int, String)]] departments
L(rec) data
   departments[rec[3]].append(rec)

V n = 3
L(department, recs) sorted(departments.items())
   print(‘Department #.’.format(department))
   print(‘ #<15  #<15  #<15  #<15 ’.format(‘Employee Name’, ‘Employee ID’, ‘Salary’, ‘Department’))
   L(rec) sorted(recs, key' rec -> rec[2], reverse' 1B)[0 .< n]
      print(‘ #<15  #<15  #<15  #<15 ’.format(rec[0], rec[1], rec[2], rec[3]))
   print()
===
auto data = create_array({make_tuple(u"Tyler Bennett"_S, u"E10297"_S, 32000, u"D101"_S), make_tuple(u"John Rappl"_S, u"E21437"_S, 47000, u"D050"_S), make_tuple(u"George Woltman"_S, u"E00127"_S, 53500, u"D101"_S), make_tuple(u"Adam Smith"_S, u"E63535"_S, 18000, u"D202"_S), make_tuple(u"Claire Buckman"_S, u"E39876"_S, 27800, u"D202"_S), make_tuple(u"David McClellan"_S, u"E04242"_S, 41500, u"D101"_S), make_tuple(u"Rich Holcomb"_S, u"E01234"_S, 49500, u"D202"_S), make_tuple(u"Nathan Adams"_S, u"E41298"_S, 21900, u"D050"_S), make_tuple(u"Richard Potter"_S, u"E43128"_S, 15900, u"D101"_S), make_tuple(u"David Motsinger"_S, u"E27002"_S, 19250, u"D202"_S), make_tuple(u"Tim Sampair"_S, u"E03033"_S, 27000, u"D101"_S), make_tuple(u"Kim Arlich"_S, u"E10001"_S, 57000, u"D190"_S), make_tuple(u"Timothy Grove"_S, u"E16398"_S, 29900, u"D190"_S)});

DefaultDict<String, Array<Tuple<String, String, int, String>>> departments;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&rec : data)
            departments[_get<3>(rec)].append(rec);
    }
} code_block_1;

auto n = 3;

struct CodeBlock2
{
    CodeBlock2()
    {
        for (auto &&[department, recs] : sorted(departments.items())) {
            print(u"Department #."_S.format(department));
            print(u" #<15  #<15  #<15  #<15 "_S.format(u"Employee Name"_S, u"Employee ID"_S, u"Salary"_S, u"Department"_S));
            for (auto &&rec : sorted(recs, [](const auto &rec){return _get<2>(rec);}, true)[range_el(0, n)])
                print(u" #<15  #<15  #<15  #<15 "_S.format(_get<0>(rec), _get<1>(rec), _get<2>(rec), _get<3>(rec)));
            print();
        }
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Topological_sort#Python
#from functools import reduce

empty_set = set() # str
def move(obj):
    return obj

data = {
    'des_system_lib':   set('std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee'.split(' ')),
    'dw01':             set('ieee dw01 dware gtech'.split(' ')),
    'dw02':             set('ieee dw02 dware'.split(' ')),
    'dw03':             set('std synopsys dware dw03 dw02 dw01 ieee gtech'.split(' ')),
    'dw04':             set('dw04 ieee dw01 dware gtech'.split(' ')),
    'dw05':             set('dw05 ieee dware'.split(' ')),
    'dw06':             set('dw06 ieee dware'.split(' ')),
    'dw07':             set('ieee dware'.split(' ')),
    'dware':            set('ieee dware'.split(' ')),
    'gtech':            set('ieee gtech'.split(' ')),
    'ramlib':           set('std ieee'.split(' ')),
    'std_cell_lib':     set('ieee std_cell_lib'.split(' ')),
    'synopsys':         move(empty_set),
    }

# def create_empty_set():
#     empty_set = set() # str
#     return empty_set

def toposort2(data : dict):
    for k, v in data.items():
        v.discard(k) # Ignore self dependencies

    #extra_items_in_deps = reduce(lambda a, b: a.union(b), data.values()) - set(data.keys())
    extra_items_in_deps = set() # str
    for v in data.values():
        extra_items_in_deps.update(v)
    extra_items_in_deps = extra_items_in_deps - set(data.keys())

    #data.update({item:create_empty_set() for item in extra_items_in_deps})
    for item in extra_items_in_deps:
        data[item] = set() # str

    r : List[str] = []
    while True:
        #ordered = set(item for item,dep in data.items() if len(dep) == 0)
        ordered = set() # str
        for item, dep in data.items():
            if len(dep) == 0:
                ordered.add(item)
        if len(ordered) == 0:
            break
        r.append(' '.join(sorted(list(ordered))))
        #data = {item: (dep - ordered) for item,dep in data.items()
        #        if item not in ordered}
        new_data : Dict[str, Set[str]] = {}
        for item, dep in data.items():
            if item not in ordered:
                new_data[item] = dep - ordered
        data = move(new_data)
    #assert len(data) == 0, "A cyclic dependency exists amongst %s" % data
    assert len(data) == 0, "A cyclic dependency exists"
    return r

print('\n'.join( toposort2(data) ))
===
V empty_set = Set[String]()

V data = [‘des_system_lib’ = Set(‘std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee’.split(‘ ’)), ‘dw01’ = Set(‘ieee dw01 dware gtech’.split(‘ ’)), ‘dw02’ = Set(‘ieee dw02 dware’.split(‘ ’)), ‘dw03’ = Set(‘std synopsys dware dw03 dw02 dw01 ieee gtech’.split(‘ ’)), ‘dw04’ = Set(‘dw04 ieee dw01 dware gtech’.split(‘ ’)), ‘dw05’ = Set(‘dw05 ieee dware’.split(‘ ’)), ‘dw06’ = Set(‘dw06 ieee dware’.split(‘ ’)), ‘dw07’ = Set(‘ieee dware’.split(‘ ’)), ‘dware’ = Set(‘ieee dware’.split(‘ ’)), ‘gtech’ = Set(‘ieee gtech’.split(‘ ’)), ‘ramlib’ = Set(‘std ieee’.split(‘ ’)), ‘std_cell_lib’ = Set(‘ieee std_cell_lib’.split(‘ ’)), ‘synopsys’ = move(empty_set)]

F toposort2(&data)
   L(k, v) data
      v.discard(k)

   V extra_items_in_deps = Set[String]()
   L(v) data.values()
      extra_items_in_deps.update(v)
   extra_items_in_deps = extra_items_in_deps - Set(data.keys())

   L(item) extra_items_in_deps
      data[item] = Set[String]()

   [String] r
   L
      V ordered = Set[String]()
      L(item, dep) data
         I dep.empty
            ordered.add(item)
      I ordered.empty
         L.break
      r.append(sorted(Array(ordered)).join(‘ ’))
      [String = Set[String]] new_data
      L(item, dep) data
         I item !C ordered
            new_data[item] = dep - ordered
      data = move(new_data)
   assert(data.empty, ‘A cyclic dependency exists’)
   R r

print(toposort2(&data).join("\n"))
===
auto empty_set = Set<String>();

auto data = create_dict(dict_of(u"des_system_lib"_S, create_set(u"std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee"_S.split(u" "_S)))(u"dw01"_S, create_set(u"ieee dw01 dware gtech"_S.split(u" "_S)))(u"dw02"_S, create_set(u"ieee dw02 dware"_S.split(u" "_S)))(u"dw03"_S, create_set(u"std synopsys dware dw03 dw02 dw01 ieee gtech"_S.split(u" "_S)))(u"dw04"_S, create_set(u"dw04 ieee dw01 dware gtech"_S.split(u" "_S)))(u"dw05"_S, create_set(u"dw05 ieee dware"_S.split(u" "_S)))(u"dw06"_S, create_set(u"dw06 ieee dware"_S.split(u" "_S)))(u"dw07"_S, create_set(u"ieee dware"_S.split(u" "_S)))(u"dware"_S, create_set(u"ieee dware"_S.split(u" "_S)))(u"gtech"_S, create_set(u"ieee gtech"_S.split(u" "_S)))(u"ramlib"_S, create_set(u"std ieee"_S.split(u" "_S)))(u"std_cell_lib"_S, create_set(u"ieee std_cell_lib"_S.split(u" "_S)))(u"synopsys"_S, std::move(empty_set)));

template <typename T1> auto toposort2(T1 &data)
{
    for (auto &&[k, v] : data)
        v.discard(k);

    auto extra_items_in_deps = Set<String>();
    for (auto &&v : data.values())
        extra_items_in_deps.update(v);
    extra_items_in_deps = extra_items_in_deps - create_set(data.keys());

    for (auto &&item : extra_items_in_deps)
        data.set(item, Set<String>());

    Array<String> r;
    while (true) {
        auto ordered = Set<String>();
        for (auto &&[item, dep] : data)
            if (dep.empty())
                ordered.add(item);
        if (ordered.empty())
            break;
        r.append(sorted(create_array(ordered)).join(u" "_S));
        Dict<String, Set<String>> new_data;
        for (auto &&[item, dep] : data)
            if (!in(item, ordered))
                new_data.set(item, dep - ordered);
        data = std::move(new_data);
    }
    assert(data.empty(), u"A cyclic dependency exists"_S);
    return r;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(toposort2(data).join(u"\n"_S));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Tree_traversal#Python:_Class_based
import collections

class Node:
    data : int
    left : 'Node' = None
    right : 'Node' = None

    def __init__(self, data, left : 'Node' = None, right : 'Node' = None):
        self.data = data
        self.left = left
        self.right = right

    def preorder(self, visitor) -> None:
        visitor(self.data)
        if self.left is not None:
            self.left.preorder(visitor)
        if self.right is not None:
            self.right.preorder(visitor)

    def inorder(self, visitor) -> None:
        if self.left is not None:
            self.left.inorder(visitor)
        visitor(self.data)
        if self.right is not None:
            self.right.inorder(visitor)

    def postorder(self, visitor) -> None:
        if self.left is not None:
            self.left.postorder(visitor)
        if self.right is not None:
            self.right.postorder(visitor)
        visitor(self.data)

    def preorder2(self, d : dict, level = 0) -> None:
        d[level].append(self.data)
        if self.left is not None:
            self.left.preorder2(d, level + 1)
        if self.right is not None:
            self.right.preorder2(d, level + 1)

    def levelorder(self, visitor):
        d : DefaultDict[int, List[int]] = collections.defaultdict(list)
        self.preorder2(d)
        for k in sorted(d.keys()):
            for v in d[k]:
                visitor(v)

tree = Node(1,
            Node(2,
                 Node(4,
                      Node(7, None, None),
                      None),
                 Node(5, None, None)),
            Node(3,
                 Node(6,
                      Node(8, None, None),
                      Node(9, None, None)),
                 None))

def printwithspace(i : int):
    print('%i ' % i, end = '')

print('  preorder: ', end = '')
tree.preorder(printwithspace)
print()
print('   inorder: ', end = '')
tree.inorder(printwithspace)
print()
print(' postorder: ', end = '')
tree.postorder(printwithspace)
print()
print('levelorder: ', end = '')
tree.levelorder(printwithspace)
print()
===
T Node
   Int data
   Node? left
   Node? right

   F (data, Node? left = N, Node? right = N)
      .data = data
      .left = left
      .right = right

   F preorder(visitor) -> N
      visitor(.data)
      I .left != N
         .left.preorder(visitor)
      I .right != N
         .right.preorder(visitor)

   F inorder(visitor) -> N
      I .left != N
         .left.inorder(visitor)
      visitor(.data)
      I .right != N
         .right.inorder(visitor)

   F postorder(visitor) -> N
      I .left != N
         .left.postorder(visitor)
      I .right != N
         .right.postorder(visitor)
      visitor(.data)

   F preorder2(&d, level = 0) -> N
      d[level].append(.data)
      I .left != N
         .left.preorder2(d, level + 1)
      I .right != N
         .right.preorder2(d, level + 1)

   F levelorder(visitor)
      DefaultDict[Int, [Int]] d
      .preorder2(&d)
      L(k) sorted(d.keys())
         L(v) d[k]
            visitor(v)

V tree = Node(1, Node(2, Node(4, Node(7, N, N), N), Node(5, N, N)), Node(3, Node(6, Node(8, N, N), Node(9, N, N)), N))

F printwithspace(Int i)
   print(‘#. ’.format(i), end' ‘’)

print(‘  preorder: ’, end' ‘’)
tree.preorder(printwithspace)
print()
print(‘   inorder: ’, end' ‘’)
tree.inorder(printwithspace)
print()
print(‘ postorder: ’, end' ‘’)
tree.postorder(printwithspace)
print()
print(‘levelorder: ’, end' ‘’)
tree.levelorder(printwithspace)
print()
===
class Node
{
public:
    int data;
    std::unique_ptr<Node> left;
    std::unique_ptr<Node> right;

    template <typename T1> Node(const T1 &data, std::unique_ptr<Node> left = nullptr, std::unique_ptr<Node> right = nullptr) :
        data(data),
        left(std::move(left)),
        right(std::move(right))
    {
    }

    template <typename T1> void preorder(const T1 &visitor)
    {
        visitor(data);
        if (left != nullptr)
            left->preorder(visitor);
        if (right != nullptr)
            right->preorder(visitor);
    }

    template <typename T1> void inorder(const T1 &visitor)
    {
        if (left != nullptr)
            left->inorder(visitor);
        visitor(data);
        if (right != nullptr)
            right->inorder(visitor);
    }

    template <typename T1> void postorder(const T1 &visitor)
    {
        if (left != nullptr)
            left->postorder(visitor);
        if (right != nullptr)
            right->postorder(visitor);
        visitor(data);
    }

    template <typename T1, typename T2 = decltype(0)> void preorder2(T1 &d, const T2 &level = 0)
    {
        d[level].append(data);
        if (left != nullptr)
            left->preorder2(d, level + 1);
        if (right != nullptr)
            right->preorder2(d, level + 1);
    }

    template <typename T1> auto levelorder(const T1 &visitor)
    {
        DefaultDict<int, Array<int>> d;
        preorder2(d);
        for (auto &&k : sorted(d.keys()))
            for (auto &&v : d[k])
                visitor(v);
    }
};

auto tree = std::make_unique<Node>(1, std::make_unique<Node>(2, std::make_unique<Node>(4, std::make_unique<Node>(7, nullptr, nullptr), nullptr), std::make_unique<Node>(5, nullptr, nullptr)), std::make_unique<Node>(3, std::make_unique<Node>(6, std::make_unique<Node>(8, nullptr, nullptr), std::make_unique<Node>(9, nullptr, nullptr)), nullptr));

auto printwithspace(const int i)
{
    print(u"#. "_S.format(i), u""_S);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"  preorder: "_S, u""_S);
        tree->preorder(printwithspace);
        print();
        print(u"   inorder: "_S, u""_S);
        tree->inorder(printwithspace);
        print();
        print(u" postorder: "_S, u""_S);
        tree->postorder(printwithspace);
        print();
        print(u"levelorder: "_S, u""_S);
        tree->levelorder(printwithspace);
        print();
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Truncatable_primes#C
MAX_PRIME = 1000000
primes = [True] * MAX_PRIME
primes[0] = primes[1] = False

i = 2
while i * i < MAX_PRIME:
    for j in range(i * i, MAX_PRIME, i):
        primes[j] = False
    i += 1
    while i < MAX_PRIME and not primes[i]:
        i += 1

def left_trunc(n):
    tens = 1
    while tens < n:
        tens *= 10

    while n != 0:
        if not primes[n]:
            return False
        tens //= 10
        if n < tens:
            return False
        n %= tens

    return True

def right_trunc(n):
    while n != 0:
        if not primes[n]:
            return False
        n //= 10
    return True

for n in range(MAX_PRIME - 1, 0, -2):
    if left_trunc(n):
        print('Left:', n)
        break

for n in range(MAX_PRIME - 1, 0, -2):
    if right_trunc(n):
        print('Right:', n)
        break
===
V MAX_PRIME = 1000000
V primes = [1B] * MAX_PRIME
primes[0] = primes[1] = 0B

V i = 2
L i * i < MAX_PRIME
   L(j) (i * i .< MAX_PRIME).step(i)
      primes[j] = 0B
   i++
   L i < MAX_PRIME & !primes[i]
      i++

F left_trunc(=n)
   V tens = 1
   L tens < n
      tens *= 10

   L n != 0
      I !:primes[n]
         R 0B
      tens I/= 10
      I n < tens
         R 0B
      n %= tens

   R 1B

F right_trunc(=n)
   L n != 0
      I !:primes[n]
         R 0B
      n I/= 10
   R 1B

L(n) (MAX_PRIME - 1 .< 0).step(-2)
   I left_trunc(n)
      print(‘Left: ’n)
      L.break

L(n) (MAX_PRIME - 1 .< 0).step(-2)
   I right_trunc(n)
      print(‘Right: ’n)
      L.break
===
auto MAX_PRIME = 1000000;
auto primes = create_array({true}) * MAX_PRIME;

struct CodeBlock1
{
    CodeBlock1()
    {
        _set<0>(primes, _set<1>(primes, false));
    }
} code_block_1;

auto i = 2;

struct CodeBlock2
{
    CodeBlock2()
    {
        while (i * i < MAX_PRIME) {
            for (auto j : range_el(i * i, MAX_PRIME).step(i))
                primes.set(j, false);
            i++;
            while (i < MAX_PRIME && !primes[i])
                i++;
        }
    }
} code_block_2;

template <typename T1> auto left_trunc(T1 n)
{
    auto tens = 1;
    while (tens < n)
        tens *= 10;

    while (n != 0) {
        if (!::primes[n])
            return false;
        tens = idiv(tens, 10);
        if (n < tens)
            return false;
        n %= tens;
    }

    return true;
}

template <typename T1> auto right_trunc(T1 n)
{
    while (n != 0) {
        if (!::primes[n])
            return false;
        n = idiv(n, 10);
    }
    return true;
}

struct CodeBlock3
{
    CodeBlock3()
    {
        for (auto n : range_el(MAX_PRIME - 1, 0).step(-2))
            if (left_trunc(n)) {
                print(u"Left: "_S & n);
                break;
            }

        for (auto n : range_el(MAX_PRIME - 1, 0).step(-2))
            if (right_trunc(n)) {
                print(u"Right: "_S & n);
                break;
            }
    }
} code_block_3;


# https://www.rosettacode.org/wiki/Truncate_a_file#Python
import os

def truncate_file(name, length):
    if not os.path.isfile(name):
        return False
    if length >= os.path.getsize(name):
        return False
    os.truncate(name, length)
    return True
===
F truncate_file(name, length)
   I !fs:is_file(name)
      R 0B
   I length >= fs:file_size(name)
      R 0B
   fs:resize_file(name, length)
   R 1B
===
template <typename T1, typename T2> auto truncate_file(const T1 &name, const T2 &length)
{
    if (!fs::is_file(name))
        return false;
    if (length >= fs::file_size(name))
        return false;
    fs::resize_file(name, length);
    return true;
}


# https://www.rosettacode.org/wiki/Unbias_a_random_generator#Python
import random

def randN(n):
    "1,0 random generator factory with 1 appearing 1/n'th of the time"
    def f():
        nonlocal n # =
        return random.randrange(n) == 0
    return f

def unbiased(biased):
    'uses a biased() generator of 1 or 0, to create an unbiased one'
    (this, that) = (biased(), biased())
    while this == that: # Loop until 10 or 01
        (this, that) = (biased(), biased())
    return this         # return the first

for n in range(3, 7):
    biased = randN(n)
    v = [biased() for x in range(1000000)]
    (v1, v0) = (v.count(1), v.count(0))
    print ( "Biased(%i):  count1=%d, count0=%d, percent=%.2f" % (n, v1, v0, 100.0 * v1/(v1 + v0)) )

    v = [unbiased(biased) for x in range(1000000)]
    (v1, v0) = (v.count(1), v.count(0))
    print ( "  Unbiased: count1=%d, count0=%d, percent=%.2f" % (v1, v0, 100.0 * v1/(v1 + v0) ) )
===
F randN(n)
   ‘1,0 random generator factory with 1 appearing 1/n'th of the time’
   F f()
      R random:(@=n) == 0
   R f

F unbiased(biased)
   ‘uses a biased() generator of 1 or 0, to create an unbiased one’
   V (this, that) = (biased(), biased())
   L this == that
      (this, that) = (biased(), biased())
   R this

L(n) 3..6
   V biased = randN(n)
   V v = (0.<1000000).map(x -> @biased())
   V (v1, v0) = (v.count(1), v.count(0))
   print(‘Biased(#.):  count1=#., count0=#., percent=#.2’.format(n, v1, v0, 100.0 * v1 / (v1 + v0)))

   v = (0.<1000000).map(x -> unbiased(@biased))
   (v1, v0) = (v.count(1), v.count(0))
   print(‘  Unbiased: count1=#., count0=#., percent=#.2’.format(v1, v0, 100.0 * v1 / (v1 + v0)))
===
template <typename T1> auto randN(const T1 &n)
{
    u"1,0 random generator factory with 1 appearing 1/n'th of the time"_S;
    auto f = [n]()
    {
        return randomns::_(n) == 0;
    };
    return f;
}

template <typename T1> auto unbiased(const T1 &biased)
{
    u"uses a biased() generator of 1 or 0, to create an unbiased one"_S;
    auto [_this_, that] = make_tuple(biased(), biased());
    while (_this_ == that)
        assign_from_tuple(_this_, that, make_tuple(biased(), biased()));
    return _this_;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto n : range_ee(3, 6)) {
            auto biased = randN(n);
            auto v = range_el(0, 1000000).map([&biased](const auto &x){return biased();});
            auto [v1, v0] = make_tuple(v.count(1), v.count(0));
            print(u"Biased(#.):  count1=#., count0=#., percent=#.2"_S.format(n, v1, v0, 100.0 * v1 / (v1 + v0)));

            v = range_el(0, 1000000).map([&biased](const auto &x){return unbiased(biased);});
            assign_from_tuple(v1, v0, make_tuple(v.count(1), v.count(0)));
            print(u"  Unbiased: count1=#., count0=#., percent=#.2"_S.format(v1, v0, 100.0 * v1 / (v1 + v0)));
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Universal_Turing_machine#Python
from typing import List
Char = str

def run_utm(
        halt,
        state,
        blank : Char,
        rules_in,
        tape : List[Char] = None,
        pos = 0):

    if tape is None:
        tape = []

    st = state
    if len(tape) == 0: tape.append(blank)
    if pos < 0: pos += len(tape)
    #if pos >= len(tape) or pos < 0: raise Error( "bad init position")
    rules = {(r[0], Char(r[1])): (Char(r[2]), r[3], r[4]) for r in rules_in}

    while True:
        #print(st, '\t', end=" ")
        print(st.ljust(4), end=" ")
        for i, v in enumerate(tape):
            if i == pos: print("[%s]" % v, end=" ")
            else: print(v, end=" ")
        print()

        if st == halt: break
        if (st, tape[pos]) not in rules: break

        (v1, dr, s1) = rules[(st, tape[pos])]
        tape[pos] = v1
        if dr == 'left':
            if pos > 0: pos -= 1
            else: tape.insert(0, blank)
        if dr == 'right':
            pos += 1
            if pos >= len(tape): tape.append(blank)
        st = s1

print("incr machine\n")
run_utm(
    halt = 'qf',
    state = 'q0',
    blank = Char('B'),
    rules_in = ["q0 1 1 right q0".split(),
                "q0 B 1 stay  qf".split()],
    tape = ['1', '1', '1']
    )

print("\nbusy beaver\n")
run_utm(
    halt = 'halt',
    state = 'a',
    blank = Char('0'),
    rules_in =
        ["a 0 1 right b".split(),
         "a 1 1 left  c".split(),
         "b 0 1 left  a".split(),
         "b 1 1 right b".split(),
         "c 0 1 left  b".split(),
         "c 1 1 stay  halt".split()]
    )

print("\nsorting test\n")
run_utm(halt = 'STOP',
    state = 'A',
    blank = Char('0'),
    rules_in =
       ["A 1 1 right A".split(),
        "A 2 3 right B".split(),
        "A 0 0 left  E".split(),
        "B 1 1 right B".split(),
        "B 2 2 right B".split(),
        "B 0 0 left  C".split(),
        "C 1 2 left  D".split(),
        "C 2 2 left  C".split(),
        "C 3 2 left  E".split(),
        "D 1 1 left  D".split(),
        "D 2 2 left  D".split(),
        "D 3 1 right A".split(),
        "E 1 1 left  E".split(),
        "E 0 0 right STOP".split()],
    tape = list(map(Char, "2 2 2 1 2 2 1 2 1 2 1 2 1 2".split(' ')))
    )
===
F run_utm(halt, state, Char blank; rules_in, [Char] &tape = [Char](); =pos = 0)

   V st = state
   I tape.empty
      tape.append(blank)
   I pos < 0
      pos += tape.len
   V rules = Dict(rules_in, r -> ((r[0], Char(r[1])), (Char(r[2]), r[3], r[4])))

   L
      print(st.ljust(4), end' ‘ ’)
      L(v) tape
         V i = L.index
         I i == pos
            print(‘[#.]’.format(v), end' ‘ ’)
         E
            print(v, end' ‘ ’)
      print()

      I st == halt
         L.break
      I (st, tape[pos]) !C rules
         L.break

      V (v1, dr, s1) = rules[(st, tape[pos])]
      tape[pos] = v1
      I dr == ‘left’
         I pos > 0
            pos--
         E
            tape.insert(0, blank)
      I dr == ‘right’
         pos++
         I pos >= tape.len
            tape.append(blank)
      st = s1

print("incr machine\n")
run_utm(halt' ‘qf’, state' ‘q0’, blank' Char(‘B’), rules_in' [‘q0 1 1 right q0’.split_py(), ‘q0 B 1 stay  qf’.split_py()], tape' &[‘1’, ‘1’, ‘1’])

print("\nbusy beaver\n")
run_utm(halt' ‘halt’, state' ‘a’, blank' Char(‘0’), rules_in' [‘a 0 1 right b’.split_py(), ‘a 1 1 left  c’.split_py(), ‘b 0 1 left  a’.split_py(), ‘b 1 1 right b’.split_py(), ‘c 0 1 left  b’.split_py(), ‘c 1 1 stay  halt’.split_py()])

print("\nsorting test\n")
run_utm(halt' ‘STOP’, state' ‘A’, blank' Char(‘0’), rules_in' [‘A 1 1 right A’.split_py(), ‘A 2 3 right B’.split_py(), ‘A 0 0 left  E’.split_py(), ‘B 1 1 right B’.split_py(), ‘B 2 2 right B’.split_py(), ‘B 0 0 left  C’.split_py(), ‘C 1 2 left  D’.split_py(), ‘C 2 2 left  C’.split_py(), ‘C 3 2 left  E’.split_py(), ‘D 1 1 left  D’.split_py(), ‘D 2 2 left  D’.split_py(), ‘D 3 1 right A’.split_py(), ‘E 1 1 left  E’.split_py(), ‘E 0 0 right STOP’.split_py()], tape' &‘2 2 2 1 2 2 1 2 1 2 1 2 1 2’.split(‘ ’).map(Char))
===
template <typename T1, typename T2, typename T4, typename T6 = decltype(0)> auto run_utm(const T1 &halt, const T2 &state, const Char &blank, const T4 &rules_in, Array<Char> &tape = make_ref(Array<Char>()), T6 pos = 0)
{

    auto st = state;
    if (tape.empty())
        tape.append(blank);
    if (pos < 0)
        pos += tape.len();
    auto rules = create_dict(rules_in, [](const auto &r){return make_tuple(make_tuple(_get<0>(r), Char(_get<1>(r))), make_tuple(Char(_get<2>(r)), _get<3>(r), _get<4>(r)));});

    while (true) {
        print(st.ljust(4), u" "_S);
        {int Lindex = 0;
        for (auto &&v : tape) {
            auto i = Lindex;
            if (i == pos)
                print(u"[#.]"_S.format(v), u" "_S);
            else
                print(v, u" "_S);
            Lindex++;
        }}
        print();

        if (st == halt)
            break;
        if (!in(make_tuple(st, tape[pos]), rules))
            break;
        auto [v1, dr, s1] = rules[make_tuple(st, tape[pos])];
        tape.set(pos, v1);
        if (dr == u"left") {
            if (pos > 0)
                pos--;
            else
                tape.insert(0, blank);
        }
        if (dr == u"right") {
            pos++;
            if (pos >= tape.len())
                tape.append(blank);
        }
        st = s1;
    }
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"incr machine\n"_S);
        run_utm(u"qf"_S, u"q0"_S, u'B'_C, create_array({u"q0 1 1 right q0"_S.split_py(), u"q0 B 1 stay  qf"_S.split_py()}), make_ref(create_array({u'1'_C, u'1'_C, u'1'_C})));

        print(u"\nbusy beaver\n"_S);
        run_utm(u"halt"_S, u"a"_S, u'0'_C, create_array({u"a 0 1 right b"_S.split_py(), u"a 1 1 left  c"_S.split_py(), u"b 0 1 left  a"_S.split_py(), u"b 1 1 right b"_S.split_py(), u"c 0 1 left  b"_S.split_py(), u"c 1 1 stay  halt"_S.split_py()}));

        print(u"\nsorting test\n"_S);
        run_utm(u"STOP"_S, u"A"_S, u'0'_C, create_array({u"A 1 1 right A"_S.split_py(), u"A 2 3 right B"_S.split_py(), u"A 0 0 left  E"_S.split_py(), u"B 1 1 right B"_S.split_py(), u"B 2 2 right B"_S.split_py(), u"B 0 0 left  C"_S.split_py(), u"C 1 2 left  D"_S.split_py(), u"C 2 2 left  C"_S.split_py(), u"C 3 2 left  E"_S.split_py(), u"D 1 1 left  D"_S.split_py(), u"D 2 2 left  D"_S.split_py(), u"D 3 1 right A"_S.split_py(), u"E 1 1 left  E"_S.split_py(), u"E 0 0 right STOP"_S.split_py()}), make_ref(u"2 2 2 1 2 2 1 2 1 2 1 2 1 2"_S.split(u" "_S).map([](const auto &x){return Char(x);})));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/URL_decoding
def url_decode(s):
    r = ''
    i = 0
    while i < len(s):
        if s[i] == '%':
            b = bytearray()
            while i < len(s) and s[i] == '%':
                i += 1
                b.append(int(s[i:i+2], base = 16))
                i += 2
            r += b.decode('utf-8')
        else:
            r += s[i]
            i += 1
    return r

print(url_decode('http%3A%2F%2Ffoo%20bar%2F'))
print(url_decode('https://ru.wikipedia.org/wiki/%D0%A2%D1%80%D0%B0%D0%BD%D1%81%D0%BF%D0%B0%D0%B9%D0%BB%D0%B5%D1%80'))
===
F url_decode(s)
   V r = ‘’
   V i = 0
   L i < s.len
      I s[i] == ‘%’
         V b = [Byte]()
         L i < s.len & s[i] == ‘%’
            i++
            b.append(Int(s[i .< i + 2], radix' 16))
            i += 2
         r ‘’= b.decode(‘utf-8’)
      E
         r ‘’= s[i]
         i++
   R r

print(url_decode(‘http%3A%2F%2Ffoo%20bar%2F’))
print(url_decode(‘https://ru.wikipedia.org/wiki/%D0%A2%D1%80%D0%B0%D0%BD%D1%81%D0%BF%D0%B0%D0%B9%D0%BB%D0%B5%D1%80’))
===
template <typename T1> auto url_decode(const T1 &s)
{
    auto r = u""_S;
    auto i = 0;
    while (i < s.len())
        if (s[i] == u'%') {
            auto b = Array<Byte>();
            while (i < s.len() && s[i] == u'%') {
                i++;
                b.append(to_int(s[range_el(i, i + 2)], 16));
                i += 2;
            }
            r &= b.decode(u"utf-8"_S);
        }
        else {
            r &= s[i];
            i++;
        }
    return r;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(url_decode(u"http%3A%2F%2Ffoo%20bar%2F"_S));
        print(url_decode(u"https://ru.wikipedia.org/wiki/%D0%A2%D1%80%D0%B0%D0%BD%D1%81%D0%BF%D0%B0%D0%B9%D0%BB%D0%B5%D1%80"_S));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/URL_encoding
def url_encode(s):
    r = ''
    buf = ''

    def flush_buf():
        nonlocal buf, r

        if buf != '':
            bytes = buf.encode('utf-8')
            for b in bytes:
                r += '%' + hex(b)[2:].upper().zfill(2)
            buf = ''

    for c in s:
        if '0' <= c <= '9' or 'a' <= c <= 'z' or 'A' <= c <= 'Z' or c in '_.-~':
            flush_buf()
            r += c
        else:
            buf += c

    flush_buf()
    return r

print(url_encode('http://foo bar/'))
print(url_encode('https://ru.wikipedia.org/wiki/Транспайлер'))
===
F url_encode(s)
   V r = ‘’
   V buf = ‘’

   F flush_buf()

      I @buf != ‘’
         V bytes = @buf.encode(‘utf-8’)
         L(b) bytes
            @r ‘’= ‘%’hex(b).zfill(2)
         @buf = ‘’

   L(c) s
      I c C ‘0’..‘9’ | c C ‘a’..‘z’ | c C ‘A’..‘Z’ | c C ‘_.-~’
         flush_buf()
         r ‘’= c
      E
         buf ‘’= c

   flush_buf()
   R r

print(url_encode(‘http://foo bar/’))
print(url_encode(‘https://ru.wikipedia.org/wiki/Транспайлер’))
===
template <typename T1> auto url_encode(const T1 &s)
{
    auto r = u""_S;
    auto buf = u""_S;

    auto flush_buf = [&buf, &r]()
    {

        if (buf != u"") {
            auto bytes = buf.encode(u"utf-8"_S);
            for (auto &&b : bytes)
                r &= u"%"_S & hex(b).zfill(2);
            buf = u""_S;
        }
    };

    for (auto &&c : s)
        if (in(c, range_ee(u'0'_C, u'9'_C)) || in(c, range_ee(u'a'_C, u'z'_C)) || in(c, range_ee(u'A'_C, u'Z'_C)) || in(c, u"_.-~"_S)) {
            flush_buf();
            r &= c;
        }
        else
            buf &= c;

    flush_buf();
    return r;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(url_encode(u"http://foo bar/"_S));
        print(url_encode(u"https://ru.wikipedia.org/wiki/Транспайлер"_S));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/UTF-8_encode_and_decode#Python
def unicode_code(ch):
    return 'U+' + hex(ord(ch))[2:].upper().zfill(4)

def utf8hex(ch):
    return " ".join([hex(c)[2:].upper() for c in ch.encode('utf-8')])

print('{:<11} {:<15} {:<15}'.format('Character', 'Unicode', 'UTF-8 encoding (hex)'))
chars = ['A', 'ö', 'Ж', '€']
for char in chars:
    print('{:<11} {:<15} {:<15}'.format(char, unicode_code(char), utf8hex(char)))
===
F unicode_code(ch)
   R ‘U+’hex(ch.code).zfill(4)

F utf8hex(ch)
   R (ch.encode(‘utf-8’).map(c -> hex(c))).join(‘ ’)

print(‘#<11 #<15 #<15’.format(‘Character’, ‘Unicode’, ‘UTF-8 encoding (hex)’))
V chars = [‘A’, ‘ö’, ‘Ж’, ‘€’]
L(char) chars
   print(‘#<11 #<15 #<15’.format(char, unicode_code(char), utf8hex(char)))
===
template <typename T1> auto unicode_code(const T1 &ch)
{
    return u"U+"_S & hex(ch.code).zfill(4);
}

template <typename T1> auto utf8hex(const T1 &ch)
{
    return (ch.encode(u"utf-8"_S).map([](const auto &c){return hex(c);})).join(u" "_S);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"#<11 #<15 #<15"_S.format(u"Character"_S, u"Unicode"_S, u"UTF-8 encoding (hex)"_S));
    }
} code_block_1;

auto chars = create_array({u'A'_C, u'ö'_C, u'Ж'_C, u'€'_C});

struct CodeBlock2
{
    CodeBlock2()
    {
        for (auto &&_char_ : chars)
            print(u"#<11 #<15 #<15"_S.format(_char_, unicode_code(_char_), utf8hex(_char_)));
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Validate_International_Securities_Identification_Number#Python
def check_isin(a):
    if len(a) != 12:
        return False
    s : List[int] = []
    for i, c in enumerate(a):
        if c.isdigit():
            if i < 2:
                return False
            s.append(ord(c) - 48)
        elif c.isupper():
            if i == 11:
                return False
            (d, m) = divmod(ord(c) - 55, 10)
            s += [d, m]
        else:
            return False
    v = sum(s[::-2])
    for k in s[-2::-2]:
        k = 2 * k
        v += k - 9 if k > 9 else k
    return v % 10 == 0

print([check_isin(s) for s in ["US0378331005", "US0373831005", "U50378331005", "US03378331005",
                               "AU0000XVGZA3", "AU0000VXGZA3", "FR0000988040"]])
===
F check_isin(a)
   I a.len != 12
      R 0B
   [Int] s
   L(c) a
      V i = L.index
      I c.is_digit()
         I i < 2
            R 0B
         s.append(c.code - 48)
      E I c.is_uppercase()
         I i == 11
            R 0B
         V (d, m) = divmod(c.code - 55, 10)
         s [+]= [d, m]
      E
         R 0B
   V v = sum(s[((len)-1..).step(-2)])
   L(=k) s[((len)-2 ..).step(-2)]
      k = 2 * k
      v += I k > 9 {k - 9} E k
   R v % 10 == 0

print([‘US0378331005’, ‘US0373831005’, ‘U50378331005’, ‘US03378331005’, ‘AU0000XVGZA3’, ‘AU0000VXGZA3’, ‘FR0000988040’].map(s -> check_isin(s)))
===
template <typename T1> auto check_isin(const T1 &a)
{
    if (a.len() != 12)
        return false;
    Array<int> s;
    {int Lindex = 0;
    for (auto &&c : a) {
        auto i = Lindex;
        if (c.is_digit()) {
            if (i < 2)
                return false;
            s.append(c.code - 48);
        }
        else if (c.is_uppercase()) {
            if (i == 11)
                return false;
            auto [d, m] = divmod(c.code - 55, 10);
            s.append(create_array({d, m}));
        }
        else
            return false;
        Lindex++;
    }}
    auto v = sum(s[range_elen_i( - 1).step(-2)]);
    for (auto k : s[range_elen_i( - 2).step(-2)]) {
        k = 2 * k;
        v += k > 9 ? k - 9 : k;
    }
    return mod(v, 10) == 0;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(create_array({u"US0378331005"_S, u"US0373831005"_S, u"U50378331005"_S, u"US03378331005"_S, u"AU0000XVGZA3"_S, u"AU0000VXGZA3"_S, u"FR0000988040"_S}).map([](const auto &s){return check_isin(s);}));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Vogel%27s_approximation_method#Python
import collections
from typing import Dict, List
Char = str

costs  = {'W': {'A': 16, 'B': 16, 'C': 13, 'D': 22, 'E': 17},
          'X': {'A': 14, 'B': 14, 'C': 13, 'D': 19, 'E': 15},
          'Y': {'A': 19, 'B': 19, 'C': 20, 'D': 23, 'E': 50},
          'Z': {'A': 50, 'B': 12, 'C': 50, 'D': 15, 'E': 11}}
demand = {'A': 30, 'B': 20, 'C': 70, 'D': 30, 'E': 60}
cols = sorted(demand.keys())
supply = {'W': 50, 'X': 60, 'Y': 50, 'Z': 50}
def create_default_dict():
    return collections.defaultdict(int) # Char
res = dict((k, create_default_dict()) for k in costs.keys())
g : Dict[Char, List[Char]] = {}
for x in supply:
    g[x] = sorted(costs[x].keys(), key=lambda g: costs[x][g])
for x in demand:
    g[x] = sorted(costs.keys(), key=lambda g: costs[g][x])

while len(g) != 0:
    d : Dict[Char, int] = {}
    for x in demand:
        d[x] = (costs[g[x][1]][x] - costs[g[x][0]][x]) if len(g[x]) > 1 else costs[g[x][0]][x]
    s : Dict[Char, int] = {}
    for x in supply:
        s[x] = (costs[x][g[x][1]] - costs[x][g[x][0]]) if len(g[x]) > 1 else costs[x][g[x][0]]
    f = max(d.keys(), key=lambda n: d[n])
    t = max(s.keys(), key=lambda n: s[n])
    (t, f) = (f, g[f][0]) if d[f] > s[t] else (g[t][0], t)
    v = min(supply[f], demand[t])
    res[f][t] += v
    demand[t] -= v
    if demand[t] == 0:
        for k, n in supply.items():
            if n != 0:
                g[k].remove(t)
        del g[t]
        del demand[t]
    supply[f] -= v
    if supply[f] == 0:
        for k, n in demand.items():
            if n != 0:
                g[k].remove(f)
        del g[f]
        del supply[f]

for n in cols:
    print("\t", n, end=' ')
print()
cost = 0
for g in sorted(costs.keys()):
    print(g, "\t", end=' ')
    for n in cols:
        y = res[g][n]
        if y != 0:
            print(y, end=' ')
        cost += y * costs[g][n]
        print("\t", end=' ')
    print()
print("\n\nTotal Cost = ", cost)
===
V costs = [‘W’ = [‘A’ = 16, ‘B’ = 16, ‘C’ = 13, ‘D’ = 22, ‘E’ = 17], ‘X’ = [‘A’ = 14, ‘B’ = 14, ‘C’ = 13, ‘D’ = 19, ‘E’ = 15], ‘Y’ = [‘A’ = 19, ‘B’ = 19, ‘C’ = 20, ‘D’ = 23, ‘E’ = 50], ‘Z’ = [‘A’ = 50, ‘B’ = 12, ‘C’ = 50, ‘D’ = 15, ‘E’ = 11]]
V demand = [‘A’ = 30, ‘B’ = 20, ‘C’ = 70, ‘D’ = 30, ‘E’ = 60]
V cols = sorted(demand.keys())
V supply = [‘W’ = 50, ‘X’ = 60, ‘Y’ = 50, ‘Z’ = 50]
F create_default_dict()
   R DefaultDict[Char, Int]()
V res = Dict(costs.keys().map(k -> (k, create_default_dict())))
[Char = [Char]] g
L(x) supply.keys()
   g[x] = sorted(costs[x].keys(), key' g -> :costs[@x][g])
L(x) demand.keys()
   g[x] = sorted(costs.keys(), key' g -> :costs[g][@x])

L !g.empty
   [Char = Int] d
   L(x) demand.keys()
      d[x] = I g[x].len > 1 {(costs[g[x][1]][x] - costs[g[x][0]][x])} E costs[g[x][0]][x]
   [Char = Int] s
   L(x) supply.keys()
      s[x] = I g[x].len > 1 {(costs[x][g[x][1]] - costs[x][g[x][0]])} E costs[x][g[x][0]]
   V f = max(d.keys(), key' n -> @d[n])
   V t = max(s.keys(), key' n -> @s[n])
   (t, f) = I d[f] > s[t] {(f, g[f][0])} E (g[t][0], t)
   V v = min(supply[f], demand[t])
   res[f][t] += v
   demand[t] -= v
   I demand[t] == 0
      L(k, n) supply
         I n != 0
            g[k].remove(t)
      g.pop(t)
      demand.pop(t)
   supply[f] -= v
   I supply[f] == 0
      L(k, n) demand
         I n != 0
            g[k].remove(f)
      g.pop(f)
      supply.pop(f)

L(n) cols
   print("\t "n, end' ‘ ’)
print()
V cost = 0
L(g) sorted(costs.keys())
   print(g" \t", end' ‘ ’)
   L(n) cols
      V y = res[g][n]
      I y != 0
         print(y, end' ‘ ’)
      cost += y * costs[g][n]
      print("\t", end' ‘ ’)
   print()
print("\n\nTotal Cost =  "cost)
===
auto costs = create_dict(dict_of(u'W'_C, create_dict(dict_of(u'A'_C, 16)(u'B'_C, 16)(u'C'_C, 13)(u'D'_C, 22)(u'E'_C, 17)))(u'X'_C, create_dict(dict_of(u'A'_C, 14)(u'B'_C, 14)(u'C'_C, 13)(u'D'_C, 19)(u'E'_C, 15)))(u'Y'_C, create_dict(dict_of(u'A'_C, 19)(u'B'_C, 19)(u'C'_C, 20)(u'D'_C, 23)(u'E'_C, 50)))(u'Z'_C, create_dict(dict_of(u'A'_C, 50)(u'B'_C, 12)(u'C'_C, 50)(u'D'_C, 15)(u'E'_C, 11))));
auto demand = create_dict(dict_of(u'A'_C, 30)(u'B'_C, 20)(u'C'_C, 70)(u'D'_C, 30)(u'E'_C, 60));
auto cols = sorted(demand.keys());
auto supply = create_dict(dict_of(u'W'_C, 50)(u'X'_C, 60)(u'Y'_C, 50)(u'Z'_C, 50));
auto create_default_dict()
{
    return DefaultDict<Char, int>();
}
auto res = create_dict(costs.keys().map([](const auto &k){return make_tuple(k, create_default_dict());}));
Dict<Char, Array<Char>> g;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&x : supply.keys())
            g.set(x, sorted(costs[x].keys(), [&x](const auto &g){return ::costs[x][g];}));
        for (auto &&x : demand.keys())
            g.set(x, sorted(costs.keys(), [&x](const auto &g){return ::costs[g][x];}));

        while (!g.empty()) {
            Dict<Char, int> d;
            for (auto &&x : demand.keys())
                d.set(x, g[x].len() > 1 ? (costs[_get<1>(g[x])][x] - costs[_get<0>(g[x])][x]) : costs[_get<0>(g[x])][x]);
            Dict<Char, int> s;
            for (auto &&x : supply.keys())
                s.set(x, g[x].len() > 1 ? (costs[x][_get<1>(g[x])] - costs[x][_get<0>(g[x])]) : costs[x][_get<0>(g[x])]);
            auto f = max_with_key(d.keys(), [&d](const auto &n){return d[n];});
            auto t = max_with_key(s.keys(), [&s](const auto &n){return s[n];});
            assign_from_tuple(t, f, d[f] > s[t] ? make_tuple(f, _get<0>(g[f])) : make_tuple(_get<0>(g[t]), t));
            auto v = min(supply[f], demand[t]);
            res[f][t] += v;
            demand[t] -= v;
            if (demand[t] == 0) {
                for (auto &&[k, n] : supply)
                    if (n != 0)
                        g[k].remove(t);
                g.pop(t);
                demand.pop(t);
            }
            supply[f] -= v;
            if (supply[f] == 0) {
                for (auto &&[k, n] : demand)
                    if (n != 0)
                        g[k].remove(f);
                g.pop(f);
                supply.pop(f);
            }
        }

        for (auto &&n : cols)
            print(u"\t "_S & n, u" "_S);
        print();
    }
} code_block_1;

auto cost = 0;

struct CodeBlock2
{
    CodeBlock2()
    {
        for (auto &&g : sorted(costs.keys())) {
            print(g & u" \t"_S, u" "_S);
            for (auto &&n : cols) {
                auto y = res[g][n];
                if (y != 0)
                    print(y, u" "_S);
                cost += y * costs[g][n];
                print(u"\t"_S, u" "_S);
            }
            print();
        }
        print(u"\n\nTotal Cost =  "_S & cost);
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Weird_numbers#D
import itertools

def divisors(n):
    divs = [1]
    divs2 : List[int] = []
    i = 2
    while i * i <= n:
        if n % i == 0:
            j = n // i
            divs += [i]
            if i != j:
                divs2 += [j]
        i += 1
    return divs2 + list(reversed(divs))

def abundant(n, divs):
    return sum(divs) > n

def semiperfect(n, divs) -> bool:
    if len(divs) != 0:
        h = divs[0]
        t = divs[1:]
        if n < h:
            return semiperfect(n, t)
        else:
            return n == h or semiperfect(n - h, t) or semiperfect(n, t)
    else:
        return False

def sieve(limit):
    w = [False] * limit
    for i in range(2, limit, 2):
        if w[i]:
            continue
        divs = divisors(i)
        if not abundant(i, divs):
            w[i] = True
        elif semiperfect(i, divs):
            for j in range(i, limit, i):
                w[j] = True
    return w

w = sieve(17_000)
count = 0
print('The first 25 weird numbers:')
for n in itertools.count(2, 2):
    if not w[n]:
        print(n, end = ' ')
        count += 1
        if count == 25:
            break
===
F divisors(n)
   V divs = [1]
   [Int] divs2
   V i = 2
   L i * i <= n
      I n % i == 0
         V j = n I/ i
         divs [+]= i
         I i != j
            divs2 [+]= j
      i++
   R divs2 [+] Array(reversed(divs))

F abundant(n, divs)
   R sum(divs) > n

F semiperfect(n, divs) -> Bool
   I !divs.empty
      V h = divs[0]
      V t = divs[1..]
      I n < h
         R semiperfect(n, t)
      E
         R n == h | semiperfect(n - h, t) | semiperfect(n, t)
   E
      R 0B

F sieve(limit)
   V w = [0B] * limit
   L(i) (2 .< limit).step(2)
      I w[i]
         L.continue
      V divs = divisors(i)
      I !abundant(i, divs)
         w[i] = 1B
      E I semiperfect(i, divs)
         L(j) (i .< limit).step(i)
            w[j] = 1B
   R w

V w = sieve(17'000)
V count = 0
print(‘The first 25 weird numbers:’)
L(n) (2..).step(2)
   I !w[n]
      print(n, end' ‘ ’)
      count++
      I count == 25
         L.break
===
template <typename T1> auto divisors(const T1 &n)
{
    auto divs = create_array({1});
    Array<int> divs2;
    auto i = 2;
    while (i * i <= n) {
        if (mod(n, i) == 0) {
            auto j = idiv(n, i);
            divs.append(i);
            if (i != j)
                divs2.append(j);
        }
        i++;
    }
    return divs2 + create_array(reversed(divs));
}

template <typename T1, typename T2> auto abundant(const T1 &n, const T2 &divs)
{
    return sum(divs) > n;
}

template <typename T1, typename T2> bool semiperfect(const T1 &n, const T2 &divs)
{
    if (!divs.empty()) {
        auto h = _get<0>(divs);
        auto t = divs[range_ei(1)];
        if (n < h)
            return semiperfect(n, t);
        else
            return n == h || semiperfect(n - h, t) || semiperfect(n, t);
    }
    else
        return false;
}

template <typename T1> auto sieve(const T1 &limit)
{
    auto w = create_array({false}) * limit;
    for (auto i : range_el(2, limit).step(2)) {
        if (w[i])
            continue;
        auto divs = divisors(i);
        if (!abundant(i, divs))
            w.set(i, true);
        else if (semiperfect(i, divs))
            for (auto j : range_el(i, limit).step(i))
                w.set(j, true);
    }
    return w;
}

auto w = sieve(17'000);
auto count = 0;

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"The first 25 weird numbers:"_S);
        for (auto n : range_ei(2).step(2))
            if (!w[n]) {
                print(n, u" "_S);
                count++;
                if (count == 25)
                    break;
            }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Wireworld#Python
from copy import deepcopy
from typing import NamedTuple, List
Char = str

allstates = 'Ht. '
head      = allstates[0]
tail      = allstates[1]
conductor = allstates[2]
empty     = allstates[3]

w = '''tH.........
.   .
   ...
.   .
Ht.. ......'''

class WW(NamedTuple):
    world : List[List[Char]]
    w : int
    h : int

def readfile(f):
    '''file > initial world configuration'''
    world  = [row.rstrip('\r\n') for row in f]
    height = len(world)
    width  = max(len(row) for row in world)
    # fill right and frame in empty cells
    nonrow = [ ' ' + ' '*width + ' ' ]
    world2 = nonrow + \
               [ ' ' + str(row).ljust(width) + ' ' for row in world ] + \
               nonrow
    world3 = [list(row) for row in world2]
    return WW(world3, width, height)

def newcell(currentworld, x, y):
    istate = currentworld[y][x]
    assert istate in allstates, 'Wireworld cell set to unknown value "%s"' % istate
    ostate = empty
    if istate == head:
        ostate = tail
    elif istate == tail:
        ostate = conductor
    elif istate == empty:
        ostate = empty
    else: # istate == conductor
        n = sum( int(currentworld[y+dy][x+dx] == head)
                 for dx,dy in [ (-1,-1), (-1,+0), (-1,+1),
                                (+0,-1),          (+0,+1),
                                (+1,-1), (+1,+0), (+1,+1) ] )
        ostate = head if 1 <= n <= 2 else conductor
    return ostate

def nextgen(ww):
    'compute next generation of wireworld'
    (world, width, height) = ww
    newworld = deepcopy(world)
    for x in range(1, width+1):
        for y in range(1, height+1):
            newworld[y][x] = newcell(world, x, y)
    return WW(newworld, width, height)

def world2string(ww):
    return '\n'.join( ''.join(row[1:-1]).rstrip() for row in ww.world[1:-1] )

ww = readfile(w.split("\n"))

for gen in range(10):
    print ( ("\n%3i " % gen) + '=' * (ww.w-4) + '\n' )
    print ( world2string(ww) )
    ww = nextgen(ww)
===
V allstates = ‘Ht. ’
V head = allstates[0]
V tail = allstates[1]
V conductor = allstates[2]
V empty = allstates[3]

V w = ‘tH.........
.   .
   ...
.   .
Ht.. ......’

T WW
   [[Char]] world
   Int w
   Int h
   F (world, w, h)
      .world = world
      .w = w
      .h = h

F readfile(f)
   ‘file > initial world configuration’
   V world = f.map(row -> row.rtrim([Char]("\r\n")))
   V height = world.len
   V width = max(world.map(row -> row.len))
   V nonrow = [‘ ’(‘ ’ * width)‘ ’]
   V world2 = nonrow [+] world.map(row -> ‘ ’String(row).ljust(@width)‘ ’) [+] nonrow
   V world3 = world2.map(row -> Array(row))
   R WW(world3, width, height)

F newcell(currentworld, x, y)
   V istate = currentworld[y][x]
   assert(istate C :allstates, ‘Wireworld cell set to unknown value "#."’.format(istate))
   V ostate = :empty
   I istate == :head
      ostate = :tail
   E I istate == :tail
      ostate = :conductor
   E I istate == :empty
      ostate = :empty
   E
      V n = sum([(-1, -1), (-1, +0), (-1, +1), (+0, -1), (+0, +1), (+1, -1), (+1, +0), (+1, +1)].map((dx, dy) -> Int(@currentworld[@y + dy][@x + dx] == :head)))
      ostate = I n C 1..2 {:head} E :conductor
   R ostate

F nextgen(ww)
   ‘compute next generation of wireworld’
   V (world, width, height) = ww
   V newworld = copy(world)
   L(x) 1 .. width
      L(y) 1 .. height
         newworld[y][x] = newcell(world, x, y)
   R WW(newworld, width, height)

F world2string(ww)
   R ww.world[1 .< (len)-1].map(row -> (row[1 .< (len)-1]).join(‘’).rtrim((‘ ’, "\t", "\r", "\n"))).join("\n")

V ww = readfile(w.split("\n"))

L(gen) 10
   print(("\n#3 ".format(gen))‘’(‘=’ * (ww.w - 4))"\n")
   print(world2string(ww))
   ww = nextgen(ww)
===
auto allstates = u"Ht. "_S;
auto head = _get<0>(allstates);
auto tail = _get<1>(allstates);
auto conductor = _get<2>(allstates);
auto empty = _get<3>(allstates);

auto w = uR"(tH.........
.   .
   ...
.   .
Ht.. ......)"_S;

class WW
{
public:
    Array<Array<Char>> world;
    int w;
    int h;
    template <typename T1, typename T2, typename T3> WW(const T1 &world, const T2 &w, const T3 &h) :
        world(world),
        w(w),
        h(h)
    {
    }
};

template <typename T1> auto readfile(const T1 &f)
{
    u"file > initial world configuration"_S;
    auto world = f.map([](const auto &row){return row.rtrim(Array<Char>(u"\r\n"_S));});
    auto height = world.len();
    auto width = max_map(world, [](const auto &row){return row.len();});
    auto nonrow = create_array({u" "_S & (u" "_S * width) & u" "_S});
    auto world2 = nonrow + world.map([&width](const auto &row){return u" "_S & String(row).ljust(width) & u" "_S;}) + nonrow;
    auto world3 = world2.map([](const auto &row){return create_array(row);});
    return WW(world3, width, height);
}

template <typename T1, typename T2, typename T3> auto newcell(const T1 &currentworld, const T2 &x, const T3 &y)
{
    auto istate = currentworld[y][x];
    assert(in(istate, ::allstates), u"Wireworld cell set to unknown value \"#.\""_S.format(istate));
    auto ostate = ::empty;
    if (istate == ::head)
        ostate = ::tail;
    else if (istate == ::tail)
        ostate = ::conductor;
    else if (istate == ::empty)
        ostate = ::empty;
    else {
        auto n = sum_map(create_array({make_tuple(-1, -1), make_tuple(-1, +0), make_tuple(-1, +1), make_tuple(+0, -1), make_tuple(+0, +1), make_tuple(+1, -1), make_tuple(+1, +0), make_tuple(+1, +1)}), [&currentworld, &x, &y](const auto &dx, const auto &dy){return to_int(currentworld[y + dy][x + dx] == ::head);});
        ostate = in(n, range_ee(1, 2)) ? ::head : ::conductor;
    }
    return ostate;
}

template <typename T1> auto nextgen(const T1 &ww)
{
    u"compute next generation of wireworld"_S;
    auto [world, width, height] = ww;
    auto newworld = copy(world);
    for (auto x : range_ee(1, width))
        for (auto y : range_ee(1, height))
            newworld[y].set(x, newcell(world, x, y));
    return WW(newworld, width, height);
}

template <typename T1> auto world2string(const T1 &ww)
{
    return ww.world[range_e_llen(1,  - 1)].map([](const auto &row){return (row[range_e_llen(1,  - 1)]).join(u""_S).rtrim(make_tuple(u" "_S, u"\t"_S, u"\r"_S, u"\n"_S));}).join(u"\n"_S);
}

auto ww = readfile(w.split(u"\n"_S));

struct CodeBlock1
{
    CodeBlock1()
    {
        for (int gen = 0; gen < 10; gen++) {
            print((u"\n#3 "_S.format(gen)) & (u"="_S * (ww.w - 4)) & u"\n"_S);
            print(world2string(ww));
            ww = nextgen(ww);
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Word_break_problem#D
from typing import List
import collections

class Node:
    val : str
    parsed : List[str]
    def __init__(self, val, parsed : List[str] = None):
        if parsed is None: parsed = []
        self.val = val
        self.parsed = parsed

def word_break(s, dictionary):
    matches : List[List[str]] = []
    queue = collections.deque([Node(s)])
    while len(queue) != 0:
        node = queue.popleft()
        # Check if fully parsed
        if len(node.val) == 0:
            matches += [node.parsed]
        else:
            for word in dictionary:
                # Check for match
                if node.val.startswith(word):
                    val_new = node.val[len(word):len(node.val)]
                    parsed_new = node.parsed[:]
                    parsed_new += [word]
                    queue += [Node(val_new, parsed_new)]
    return matches

def process(d, test_strings):
    for test_string in test_strings:
        matches = word_break(test_string, d)
        print("String = " + test_string + ", Dictionary = " + str(d) + ".  Solutions =", len(matches))
        for match in matches:
            print("  Word Break =", match)
        print()

d = ["a", "aa", "b", "ab", "aab"]
process(d, ["aab", "aa b"])

d = ["abc", "a", "ac", "b", "c", "cb", "d"]
process(d, ["abcd", "abbc", "abcbcd", "acdbc", "abcdd"])
===
T Node
   String val
   [String] parsed
   F (val, [String] &parsed = [String]())
      .val = val
      .parsed = parsed

F word_break(s, dictionary)
   [[String]] matches
   V queue = Deque([Node(s)])
   L !queue.empty
      V node = queue.pop_left()
      I node.val.empty
         matches [+]= node.parsed
      E
         L(word) dictionary
            I node.val.starts_with(word)
               V val_new = node.val[word.len .< node.val.len]
               V parsed_new = copy(node.parsed)
               parsed_new [+]= word
               queue [+]= Node(val_new, &parsed_new)
   R matches

F process(d, test_strings)
   L(test_string) test_strings
      V matches = word_break(test_string, d)
      print((‘String = ’test_string‘, Dictionary = ’String(d)‘.  Solutions =’)‘ ’matches.len)
      L(match) matches
         print(‘  Word Break = ’match)
      print()

V d = [‘a’, ‘aa’, ‘b’, ‘ab’, ‘aab’]
process(d, [‘aab’, ‘aa b’])

d = [‘abc’, ‘a’, ‘ac’, ‘b’, ‘c’, ‘cb’, ‘d’]
process(d, [‘abcd’, ‘abbc’, ‘abcbcd’, ‘acdbc’, ‘abcdd’])
===
class Node
{
public:
    String val;
    Array<String> parsed;
    template <typename T1> Node(const T1 &val, Array<String> &parsed = make_ref(Array<String>())) :
        val(val),
        parsed(parsed)
    {
    }
};

template <typename T1, typename T2> auto word_break(const T1 &s, const T2 &dictionary)
{
    Array<Array<String>> matches;
    auto queue = create_deque({Node(s)});
    while (!queue.empty()) {
        auto node = queue.pop_left();
        if (node.val.empty())
            matches.append(node.parsed);
        else
            for (auto &&word : dictionary)
                if (node.val.starts_with(word)) {
                    auto val_new = node.val[range_el(word.len(), node.val.len())];
                    auto parsed_new = copy(node.parsed);
                    parsed_new.append(word);
                    queue.append(Node(val_new, parsed_new));
                }
    }
    return matches;
}

template <typename T1, typename T2> auto process(const T1 &d, const T2 &test_strings)
{
    for (auto &&test_string : test_strings) {
        auto matches = word_break(test_string, d);
        print((u"String = "_S & test_string & u", Dictionary = "_S & String(d) & u".  Solutions ="_S) & u" "_S & matches.len());
        for (auto &&match : matches)
            print(u"  Word Break = "_S & match);
        print();
    }
}

auto d = create_array({u"a"_S, u"aa"_S, u"b"_S, u"ab"_S, u"aab"_S});

struct CodeBlock1
{
    CodeBlock1()
    {
        process(d, create_array({u"aab"_S, u"aa b"_S}));

        d = create_array({u"abc"_S, u"a"_S, u"ac"_S, u"b"_S, u"c"_S, u"cb"_S, u"d"_S});
        process(d, create_array({u"abcd"_S, u"abbc"_S, u"abcbcd"_S, u"acdbc"_S, u"abcdd"_S}));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Yin_and_yang#Python
import math

def yinyang(n=3):
    radii   = [i * n for i in [1, 3, 6]]
    ranges  = [list(range(-r, r+1)) for r in radii]
    squares = [[ (x,y) for x in rnge for y in rnge]
           for rnge in ranges]
    circles = [[ (x,y) for x,y in sqrpoints
             if x*x + y*y <= radius**2 ]
           for sqrpoints, radius in zip(squares, radii)]
    m = {(x,y):' ' for x,y in squares[-1]}
    for x,y in circles[-1]:
        m[(x,y)] = '*'
    for x,y in circles[-1]:
        if x>0: m[(x,y)] = '·'
    for x,y in circles[-2]:
        m[(x,y+3*n)] = '*'
        m[(x,y-3*n)] = '·'
    for x,y in circles[-3]:
        m[(x,y+3*n)] = '·'
        m[(x,y-3*n)] = '*'
    def f(y, m):
        return ''.join(m[(x,y)] for x in reversed(ranges[-1]))
    return '\n'.join(f(y, m) for y in ranges[-1])

print(yinyang(2))
print(yinyang(1))
===
F yinyang(n = 3)
   V radii = [1, 3, 6].map(i -> i * @n)
   V ranges = radii.map(r -> Array(-r .. r))
   V squares = ranges.map(rnge -> multiloop(rnge, rnge, (x, y) -> (x, y)))
   V circles = zip(squares, radii).map((sqrpoints, radius) -> sqrpoints.filter((x, y) -> x * x + y * y <= @radius ^ 2))
   V m = Dict(squares.last, (x, y) -> ((x, y), ‘ ’))
   L(x, y) circles.last
      m[(x, y)] = ‘*’
   L(x, y) circles.last
      I x > 0
         m[(x, y)] = ‘·’
   L(x, y) circles[(len)-2]
      m[(x, y + 3 * n)] = ‘*’
      m[(x, y - 3 * n)] = ‘·’
   L(x, y) circles[(len)-3]
      m[(x, y + 3 * n)] = ‘·’
      m[(x, y - 3 * n)] = ‘*’
   F f(y, m)
      R reversed(@ranges.last).map(x -> @m[(x, @y)]).join(‘’)
   R ranges.last.map(y -> @f(y, @m)).join("\n")

print(yinyang(2))
print(yinyang(1))
===
template <typename T1 = decltype(3)> auto yinyang(const T1 &n = 3)
{
    auto radii = create_array({1, 3, 6}).map([&n](const auto &i){return i * n;});
    auto ranges = radii.map([](const auto &r){return create_array(range_ee(-r, r));});
    auto squares = ranges.map([](const auto &rnge){return multiloop(rnge, rnge, [](const auto &x, const auto &y){return make_tuple(x, y);});});
    auto circles = zip(squares, radii).map([](const auto &sqrpoints, const auto &radius){return sqrpoints.filter([&radius](const auto &x, const auto &y){return x * x + y * y <= square(radius);});});
    auto m = create_dict(squares.last(), [](const auto &x, const auto &y){return make_tuple(make_tuple(x, y), u" "_S);});
    for (auto &&[x, y] : circles.last())
        m.set(make_tuple(x, y), u'*'_C);
    for (auto &&[x, y] : circles.last())
        if (x > 0)
            m.set(make_tuple(x, y), u'·'_C);
    for (auto &&[x, y] : circles.at_plus_len( - 2)) {
        m.set(make_tuple(x, y + 3 * n), u'*'_C);
        m.set(make_tuple(x, y - 3 * n), u'·'_C);
    }
    for (auto &&[x, y] : circles.at_plus_len( - 3)) {
        m.set(make_tuple(x, y + 3 * n), u'·'_C);
        m.set(make_tuple(x, y - 3 * n), u'*'_C);
    }
    auto f = [&ranges](const auto &y, const auto &m)
    {
        return reversed(ranges.last()).map([&m, &y](const auto &x){return m[make_tuple(x, y)];}).join(u""_S);
    };
    return ranges.last().map([&f, &m](const auto &y){return f(y, m);}).join(u"\n"_S);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(yinyang(2));
        print(yinyang(1));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Yin_and_yang#Python
import math

def yinyang(n=3):
    radii   = [i * n for i in [1, 3, 6]]
    ranges  = [list(range(-r, r+1)) for r in radii]
    squares = [[ (x,y) for x in rnge for y in rnge]
           for rnge in ranges]
    circles = [[ (x,y) for x,y in sqrpoints
             if x*x + y*y <= radius**2 ]
           for sqrpoints, radius in zip(squares, radii)]
    m = {(x,y):' ' for x,y in squares[-1]}
    for x,y in circles[-1]:
        m[(x,y)] = '*'
    for x,y in circles[-1]:
        if x>0: m[(x,y)] = '·'
    for x,y in circles[-2]:
        m[(x,y+3*n)] = '*'
        m[(x,y-3*n)] = '·'
    for x,y in circles[-3]:
        m[(x,y+3*n)] = '·'
        m[(x,y-3*n)] = '*'
    #def f(y):
    #    return ''.join(m[(x,y)] for x in reversed(ranges[-1]))
    #return '\n'.join(f(y) for y in ranges[-1])
    return '\n'.join(''.join(m[(x,y)] for x in reversed(ranges[-1])) for y in ranges[-1])

print(yinyang(2))
print(yinyang(1))
===
F yinyang(n = 3)
   V radii = [1, 3, 6].map(i -> i * @n)
   V ranges = radii.map(r -> Array(-r .. r))
   V squares = ranges.map(rnge -> multiloop(rnge, rnge, (x, y) -> (x, y)))
   V circles = zip(squares, radii).map((sqrpoints, radius) -> sqrpoints.filter((x, y) -> x * x + y * y <= @radius ^ 2))
   V m = Dict(squares.last, (x, y) -> ((x, y), ‘ ’))
   L(x, y) circles.last
      m[(x, y)] = ‘*’
   L(x, y) circles.last
      I x > 0
         m[(x, y)] = ‘·’
   L(x, y) circles[(len)-2]
      m[(x, y + 3 * n)] = ‘*’
      m[(x, y - 3 * n)] = ‘·’
   L(x, y) circles[(len)-3]
      m[(x, y + 3 * n)] = ‘·’
      m[(x, y - 3 * n)] = ‘*’
   R ranges.last.map(y -> reversed(@ranges.last).map(x -> @@m[(x, @y)]).join(‘’)).join("\n")

print(yinyang(2))
print(yinyang(1))
===
template <typename T1 = decltype(3)> auto yinyang(const T1 &n = 3)
{
    auto radii = create_array({1, 3, 6}).map([&n](const auto &i){return i * n;});
    auto ranges = radii.map([](const auto &r){return create_array(range_ee(-r, r));});
    auto squares = ranges.map([](const auto &rnge){return multiloop(rnge, rnge, [](const auto &x, const auto &y){return make_tuple(x, y);});});
    auto circles = zip(squares, radii).map([](const auto &sqrpoints, const auto &radius){return sqrpoints.filter([&radius](const auto &x, const auto &y){return x * x + y * y <= square(radius);});});
    auto m = create_dict(squares.last(), [](const auto &x, const auto &y){return make_tuple(make_tuple(x, y), u" "_S);});
    for (auto &&[x, y] : circles.last())
        m.set(make_tuple(x, y), u'*'_C);
    for (auto &&[x, y] : circles.last())
        if (x > 0)
            m.set(make_tuple(x, y), u'·'_C);
    for (auto &&[x, y] : circles.at_plus_len( - 2)) {
        m.set(make_tuple(x, y + 3 * n), u'*'_C);
        m.set(make_tuple(x, y - 3 * n), u'·'_C);
    }
    for (auto &&[x, y] : circles.at_plus_len( - 3)) {
        m.set(make_tuple(x, y + 3 * n), u'·'_C);
        m.set(make_tuple(x, y - 3 * n), u'*'_C);
    }
    return ranges.last().map([&m, &ranges](const auto &y){return reversed(ranges.last()).map([&m, &y](const auto &x){return m[make_tuple(x, y)];}).join(u""_S);}).join(u"\n"_S);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(yinyang(2));
        print(yinyang(1));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Lah_numbers#Python
import math
BigInt = int

def lah(n : BigInt, k : BigInt):
    if k == 1:
        return math.factorial(n)
    if k == n:
        return BigInt(1)
    if k > n:
        return BigInt(0)
    if k < 1 or n < 1:
        return BigInt(0)
    return (math.factorial(n) * math.factorial(n - 1)) // (math.factorial(k) * math.factorial(k - 1)) // math.factorial(n - k)

print("Unsigned Lah numbers: L(n, k):")
print("n/k ", end=' ')
for i in range(13):
    print("%11d" % i, end=' ')
print()
for row in range(13):
    print("%-4d" % row, end=' ')
    for i in range(row + 1):
        l = lah(row, i)
        print("%11d" % l, end=' ')
    print()
print("\nMaximum value from the L(100, *) row:")
maxVal = max([lah(100, a) for a in range(100)])
print(maxVal)
===
F lah(BigInt n, BigInt k)
   I k == 1
      R factorial(n)
   I k == n
      R BigInt(1)
   I k > n
      R BigInt(0)
   I k < 1 | n < 1
      R BigInt(0)
   R (factorial(n) * factorial(n - 1)) I/ (factorial(k) * factorial(k - 1)) I/ factorial(n - k)

print(‘Unsigned Lah numbers: L(n, k):’)
print(‘n/k ’, end' ‘ ’)
L(i) 13
   print(‘#11’.format(i), end' ‘ ’)
print()
L(row) 13
   print(‘#<4’.format(row), end' ‘ ’)
   L(i) 0 .. row
      V l = lah(row, i)
      print(‘#11’.format(l), end' ‘ ’)
   print()
print("\nMaximum value from the L(100, *) row:")
V maxVal = max((0.<100).map(a -> lah(100, a)))
print(maxVal)
===
auto lah(const BigInt &n, const BigInt &k)
{
    if (k == 1)
        return factorial(n);
    if (k == n)
        return BigInt(1);
    if (k > n)
        return BigInt(0);
    if (k < 1 || n < 1)
        return BigInt(0);
    return idiv(idiv((factorial(n) * factorial(n - 1)), (factorial(k) * factorial(k - 1))), factorial(n - k));
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"Unsigned Lah numbers: L(n, k):"_S);
        print(u"n/k "_S, u" "_S);
        for (int i = 0; i < 13; i++)
            print(u"#11"_S.format(i), u" "_S);
        print();
        for (int row = 0; row < 13; row++) {
            print(u"#<4"_S.format(row), u" "_S);
            for (auto i : range_ee(0, row)) {
                auto l = lah(row, i);
                print(u"#11"_S.format(l), u" "_S);
            }
            print();
        }
        print(u"\nMaximum value from the L(100, *) row:"_S);
    }
} code_block_1;

auto maxVal = max_map(range_el(0, 100), [](const auto &a){return lah(100, a);});

struct CodeBlock2
{
    CodeBlock2()
    {
        print(maxVal);
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Lucas-Lehmer_test#D
# Slow BigInt
import math
BigInt = int

def isPrime(p):
    if p < 2 or p % 2 == 0:
        return p == 2
    for i in range(3, int(math.sqrt(p)) + 1):
        if p % i == 0:
            return False
    return True

def isMersennePrime(p):
    if not isPrime(p):
        return False
    if p == 2:
        return True
    mp = BigInt(2) ** p - 1
    s = BigInt(4)
    for _ in range(3, p + 1):
        s = (s ** 2 - 2) % mp
    return s == 0

for p in range(2, 2300):
    if isMersennePrime(p):
        print('M' + str(p), end = ' ')
===
F isPrime(p)
   I p < 2 | p % 2 == 0
      R p == 2
   L(i) 3 .. Int(sqrt(p))
      I p % i == 0
         R 0B
   R 1B

F isMersennePrime(p)
   I !isPrime(p)
      R 0B
   I p == 2
      R 1B
   V mp = BigInt(2) ^ p - 1
   V s = BigInt(4)
   L(_) 3 .. p
      s = (s ^ 2 - 2) % mp
   R s == 0

L(p) 2..2299
   I isMersennePrime(p)
      print(‘M’String(p), end' ‘ ’)
===
template <typename T1> auto isPrime(const T1 &p)
{
    if (p < 2 || mod(p, 2) == 0)
        return p == 2;
    for (auto i : range_ee(3, to_int(sqrt(p))))
        if (mod(p, i) == 0)
            return false;
    return true;
}

template <typename T1> auto isMersennePrime(const T1 &p)
{
    if (!isPrime(p))
        return false;
    if (p == 2)
        return true;
    auto mp = pow(BigInt(2), p) - 1;
    auto s = BigInt(4);
    for (auto _ : range_ee(3, p))
        s = mod((square(s) - 2), mp);
    return s == 0;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto p : range_ee(2, 2299))
            if (isMersennePrime(p))
                print(u"M"_S & String(p), u" "_S);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Most_frequent_k_chars_distance#Python
import collections
def most_freq_khashing(inputString, K):
    occuDict = collections.defaultdict(int) # Char
    for c in inputString:
        occuDict[c] += 1
    occuList = sorted(occuDict.items(), key = lambda x: x[1], reverse = True)
    outputDict = dict(occuList[:K])
    return outputDict

def most_freq_ksimilarity(inputStr1, inputStr2):
    similarity = 0
    for c, cnt1 in inputStr1.items():
        #Reduce the time complexity of lookup operation to about O(1).
        if c in inputStr2:
            cnt2 = inputStr2[c]
            similarity += cnt1 + cnt2
    return similarity

def most_freq_ksdf(inputStr1, inputStr2, K, maxDistance):
    return maxDistance - most_freq_ksimilarity(most_freq_khashing(inputStr1,K), most_freq_khashing(inputStr2,K))

str1 = "LCLYTHIGRNIYYGSYLYSETWNTGIMLLLITMATAFMGYVLPWGQMSFWGATVITNLFSAIPYIGTNLV"
str2 = "EWIWGGFSVDKATLNRFFAFHFILPFTMVALAGVHLTFLHETGSNNPLGLTSDSDKIPFHPYYTIKDFLG"
K = 2
maxDistance = 100
dict1 = most_freq_khashing(str1, 2)
print(dict1, end = ":\n")
print(''.join(c + str(cnt) for c, cnt in dict1.items()))
dict2 = most_freq_khashing(str2, 2)
print(dict2, end = ":\n")
print(''.join(c + str(cnt) for c, cnt in dict2.items()))
print(most_freq_ksdf(str1, str2, K, maxDistance))
===
F most_freq_khashing(inputString, K)
   V occuDict = DefaultDict[Char, Int]()
   L(c) inputString
      occuDict[c]++
   V occuList = sorted(occuDict.items(), key' x -> x[1], reverse' 1B)
   V outputDict = Dict(occuList[0 .< K])
   R outputDict

F most_freq_ksimilarity(inputStr1, inputStr2)
   V similarity = 0
   L(c, cnt1) inputStr1
      I c C inputStr2
         V cnt2 = inputStr2[c]
         similarity += cnt1 + cnt2
   R similarity

F most_freq_ksdf(inputStr1, inputStr2, K, maxDistance)
   R maxDistance - most_freq_ksimilarity(most_freq_khashing(inputStr1, K), most_freq_khashing(inputStr2, K))

V str1 = ‘LCLYTHIGRNIYYGSYLYSETWNTGIMLLLITMATAFMGYVLPWGQMSFWGATVITNLFSAIPYIGTNLV’
V str2 = ‘EWIWGGFSVDKATLNRFFAFHFILPFTMVALAGVHLTFLHETGSNNPLGLTSDSDKIPFHPYYTIKDFLG’
V K = 2
V maxDistance = 100
V dict1 = most_freq_khashing(str1, 2)
print(dict1, end' ":\n")
print(dict1.map((c, cnt) -> c‘’String(cnt)).join(‘’))
V dict2 = most_freq_khashing(str2, 2)
print(dict2, end' ":\n")
print(dict2.map((c, cnt) -> c‘’String(cnt)).join(‘’))
print(most_freq_ksdf(str1, str2, K, maxDistance))
===
template <typename T1, typename T2> auto most_freq_khashing(const T1 &inputString, const T2 &K)
{
    auto occuDict = DefaultDict<Char, int>();
    for (auto &&c : inputString)
        occuDict[c]++;
    auto occuList = sorted(occuDict.items(), [](const auto &x){return _get<1>(x);}, true);
    auto outputDict = create_dict(occuList[range_el(0, K)]);
    return outputDict;
}

template <typename T1, typename T2> auto most_freq_ksimilarity(const T1 &inputStr1, const T2 &inputStr2)
{
    auto similarity = 0;
    for (auto &&[c, cnt1] : inputStr1)
        if (in(c, inputStr2)) {
            auto cnt2 = inputStr2[c];
            similarity += cnt1 + cnt2;
        }
    return similarity;
}

template <typename T1, typename T2, typename T3, typename T4> auto most_freq_ksdf(const T1 &inputStr1, const T2 &inputStr2, const T3 &K, const T4 &maxDistance)
{
    return maxDistance - most_freq_ksimilarity(most_freq_khashing(inputStr1, K), most_freq_khashing(inputStr2, K));
}

auto str1 = u"LCLYTHIGRNIYYGSYLYSETWNTGIMLLLITMATAFMGYVLPWGQMSFWGATVITNLFSAIPYIGTNLV"_S;
auto str2 = u"EWIWGGFSVDKATLNRFFAFHFILPFTMVALAGVHLTFLHETGSNNPLGLTSDSDKIPFHPYYTIKDFLG"_S;
auto K = 2;
auto maxDistance = 100;
auto dict1 = most_freq_khashing(str1, 2);

struct CodeBlock1
{
    CodeBlock1()
    {
        print(dict1, u":\n"_S);
        print(dict1.map([](const auto &c, const auto &cnt){return c & String(cnt);}).join(u""_S));
    }
} code_block_1;

auto dict2 = most_freq_khashing(str2, 2);

struct CodeBlock2
{
    CodeBlock2()
    {
        print(dict2, u":\n"_S);
        print(dict2.map([](const auto &c, const auto &cnt){return c & String(cnt);}).join(u""_S));
        print(most_freq_ksdf(str1, str2, K, maxDistance));
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Mersenne_primes#D
BigInt = int

def is_prime(bi : BigInt):
    if bi < 2: return False
    if bi % 2 == 0: return bi == 2
    if bi % 3 == 0: return bi == 3

    test = BigInt(5)
    while test * test < bi:
        if bi % test == 0: return False
        test += 2
        if bi % test == 0: return False
        test += 4

    return True

base = BigInt(2)
for p in range(1, 32):
    if is_prime(base-1):
        print('2 ^', p, '- 1')
    base *= 2
===
F is_prime(BigInt bi)
   I bi < 2
      R 0B
   I bi % 2 == 0
      R bi == 2
   I bi % 3 == 0
      R bi == 3

   V test = BigInt(5)
   L test * test < bi
      I bi % test == 0
         R 0B
      test += 2
      I bi % test == 0
         R 0B
      test += 4

   R 1B

V base = BigInt(2)
L(p) 1..31
   I is_prime(base - 1)
      print(‘2 ^ ’p‘ - 1’)
   base *= 2
===
auto is_prime(const BigInt &bi)
{
    if (bi < 2)
        return false;
    if (mod(bi, 2) == 0)
        return bi == 2;
    if (mod(bi, 3) == 0)
        return bi == 3;

    auto test = BigInt(5);
    while (test * test < bi) {
        if (mod(bi, test) == 0)
            return false;
        test += 2;
        if (mod(bi, test) == 0)
            return false;
        test += 4;
    }

    return true;
}

auto base = BigInt(2);

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto p : range_ee(1, 31)) {
            if (is_prime(base - 1))
                print(u"2 ^ "_S & p & u" - 1"_S);
            base *= 2;
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Modular_exponentiation#D
BigInt = int

def pow_mod(base : BigInt, exponent : BigInt, modulus : BigInt):
    result : BigInt = 1

    while exponent != 0:
        if exponent % 2 != 0:
            result = (result * base) % modulus
        exponent //= 2
        base = (base * base) % modulus

    return result

print(pow_mod(BigInt('2988348162058574136915891421498819466320163312926952423791023078876139'),
              BigInt('2351399303373464486466122544523690094744975233415544072992656881240319'),
              BigInt(10) ** 40))
===
F pow_mod(BigInt =base, BigInt =exponent, BigInt modulus)
   BigInt result = 1

   L exponent != 0
      I exponent % 2 != 0
         result = (result * base) % modulus
      exponent I/= 2
      base = (base * base) % modulus

   R result

print(pow_mod(BigInt(‘2988348162058574136915891421498819466320163312926952423791023078876139’), BigInt(‘2351399303373464486466122544523690094744975233415544072992656881240319’), BigInt(10) ^ 40))
===
auto pow_mod(BigInt base, BigInt exponent, const BigInt &modulus)
{
    BigInt result = 1;

    while (exponent != 0) {
        if (mod(exponent, 2) != 0)
            result = mod((result * base), modulus);
        exponent = idiv(exponent, 2);
        base = mod((base * base), modulus);
    }

    return result;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(pow_mod(BigInt(u"2988348162058574136915891421498819466320163312926952423791023078876139"_S), BigInt(u"2351399303373464486466122544523690094744975233415544072992656881240319"_S), pow(BigInt(10), 40)));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Next_highest_int_from_digits#Python:_Algorithm_2
def closest_more_than(n, lst):
    "(index of) closest int from lst, to n that is also > n"
    large = max(lst) + 1
    return lst.index(min(lst, key=lambda x: (large if x <= n else x)))

def nexthigh(n):
    "Return nxt highest number from n's digits using scan & re-order"
    this = list(int(digit) for digit in n)[::-1]
    mx = this[0]
    for i, digit in enumerate(this[1:], 1):
        if digit < mx:
            mx_index = closest_more_than(digit, this[:i + 1])
            (this[mx_index], this[i]) = (this[i], this[mx_index])
            this[:i] = sorted(this[:i], reverse=True)
            return ''.join(str(d) for d in this[::-1])
        elif digit > mx:
            mx = digit
    return '0'

for x in ['0', '9', '12', '21', '12453', '738440', '45072010', '95322020',
          '9589776899767587796600']:
    print('%12s -> %12s' % (x, nexthigh(x)))
===
F closest_more_than(n, lst)
   ‘(index of) closest int from lst, to n that is also > n’
   V large = max(lst) + 1
   R lst.index(min(lst, key' x -> (I x <= @n {@large} E x)))

F nexthigh(n)
   ‘Return nxt highest number from n's digits using scan & re-order’
   V this = reversed(Array(n.map(digit -> Int(digit))))
   V mx = this[0]
   L(digit) this[1..]
      V i = L.index + 1
      I digit < mx
         V mx_index = closest_more_than(digit, this[0 .< i + 1])
         swap(&this[mx_index], &this[i])
         this.sort_range(0 .< i, reverse' 1B)
         R reversed(this).map(d -> String(d)).join(‘’)
      E I digit > mx
         mx = digit
   R ‘0’

L(x) [‘0’, ‘9’, ‘12’, ‘21’, ‘12453’, ‘738440’, ‘45072010’, ‘95322020’, ‘9589776899767587796600’]
   print(‘#12 -> #12’.format(x, nexthigh(x)))
===
template <typename T1, typename T2> auto closest_more_than(const T1 &n, const T2 &lst)
{
    u"(index of) closest int from lst, to n that is also > n"_S;
    auto large = max(lst) + 1;
    return lst.index(min_with_key(lst, [&large, &n](const auto &x){return (x <= n ? large : x);}));
}

template <typename T1> auto nexthigh(const T1 &n)
{
    u"Return nxt highest number from n's digits using scan & re-order"_S;
    auto _this_ = reversed(create_array(n.map([](const auto &digit){return to_int(digit);})));
    auto mx = _get<0>(_this_);
    {int Lindex = 0;
    for (auto &&digit : _this_[range_ei(1)]) {
        auto i = Lindex + 1;
        if (digit < mx) {
            auto mx_index = closest_more_than(digit, _this_[range_el(0, i + 1)]);
            swap(_this_[mx_index], _this_[i]);
            _this_.sort_range(range_el(0, i), nullptr, true);
            return reversed(_this_).map([](const auto &d){return String(d);}).join(u""_S);
        }
        else if (digit > mx)
            mx = digit;
        Lindex++;
    }}
    return u"0"_S;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&x : create_array({u"0"_S, u"9"_S, u"12"_S, u"21"_S, u"12453"_S, u"738440"_S, u"45072010"_S, u"95322020"_S, u"9589776899767587796600"_S}))
            print(u"#12 -> #12"_S.format(x, nexthigh(x)));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Sorting_algorithms/Permutation_sort
from _11l import *

def permutation_sort(arr : list):
   while not is_sorted(arr):
      next_permutation(arr)

arr = [7, 6, 5, 9, 8, 4, 3, 1, 2, 0]
permutation_sort(arr)
print(arr)
===
F permutation_sort(&arr)
   L !arr.is_sorted()
      arr.next_permutation()

V arr = [7, 6, 5, 9, 8, 4, 3, 1, 2, 0]
permutation_sort(&arr)
print(arr)
===
template <typename T1> auto permutation_sort(T1 &arr)
{
    while (!arr.is_sorted())
        arr.next_permutation();
}

auto arr = create_array({7, 6, 5, 9, 8, 4, 3, 1, 2, 0});

struct CodeBlock1
{
    CodeBlock1()
    {
        permutation_sort(arr);
        print(arr);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Pell%27s_equation#Python
import math
BigInt = int

def solvePell(n):
    x = int(math.sqrt(n))
    (y, z, r) = (x, 1, x << 1)
    e1 : BigInt = 1
    e2 : BigInt = 0
    f1 : BigInt = 0
    f2 : BigInt = 1
    while True:
        y = r * z - y
        z = (n - y * y) // z
        r = (x + y) // z

        (e1, e2) = (e2, e1 + e2 * r)
        (f1, f2) = (f2, f1 + f2 * r)

        (a, b) = (f2 * x + e2, f2)
        if a * a - n * b * b == 1:
            return (a, b)

for n in [61, 109, 181, 277]:
    (x, y) = solvePell(n)
    print("x^2 - %3d * y^2 = 1 for x = %27d and y = %25d" % (n, x, y))
===
F solvePell(n)
   V x = Int(sqrt(n))
   V (y, z, r) = (x, 1, x << 1)
   BigInt e1 = 1
   BigInt e2 = 0
   BigInt f1 = 0
   BigInt f2 = 1
   L
      y = r * z - y
      z = (n - y * y) I/ z
      r = (x + y) I/ z

      (e1, e2) = (e2, e1 + e2 * r)
      (f1, f2) = (f2, f1 + f2 * r)

      V (a, b) = (f2 * x + e2, f2)
      I a * a - n * b * b == 1
         R (a, b)

L(n) [61, 109, 181, 277]
   V (x, y) = solvePell(n)
   print(‘x^2 - #3 * y^2 = 1 for x = #27 and y = #25’.format(n, x, y))
===
template <typename T1> auto solvePell(const T1 &n)
{
    auto x = to_int(sqrt(n));
    auto [y, z, r] = make_tuple(x, 1, x << 1);
    BigInt e1 = 1;
    BigInt e2 = 0;
    BigInt f1 = 0;
    BigInt f2 = 1;
    while (true) {
        y = r * z - y;
        z = idiv((n - y * y), z);
        r = idiv((x + y), z);
        assign_from_tuple(e1, e2, make_tuple(e2, e1 + e2 * r));
        assign_from_tuple(f1, f2, make_tuple(f2, f1 + f2 * r));
        auto [a, b] = make_tuple(f2 * x + e2, f2);
        if (a * a - n * b * b == 1)
            return make_tuple(a, b);
    }
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&n : create_array({61, 109, 181, 277})) {
            auto [x, y] = solvePell(n);
            print(u"x^2 - #3 * y^2 = 1 for x = #27 and y = #25"_S.format(n, x, y));
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/RSA_code#D
from functools import reduce
BigInt = int

n = BigInt('9516311845790656153499716760847001433441357')
e = BigInt(65537)
d = BigInt('5617843187844953170308463622230283376298685')

txt = 'Rosetta Code'

print('Plain text:            ', txt)

txtN = reduce(lambda a, b: a * 256 + ord(b), txt, BigInt(0))
print('Plain text as a number:', txtN)

enc = pow(txtN, e, n)
print('Encoded:               ', enc)

dec = pow(enc, d, n)
print('Decoded:               ', dec)

decTxt = ''
while dec != 0:
    decTxt += chr(dec % 256)
    dec //= 256

print('Decoded number as text:', decTxt[::-1])
===
V n = BigInt(‘9516311845790656153499716760847001433441357’)
V e = BigInt(65537)
V d = BigInt(‘5617843187844953170308463622230283376298685’)

V txt = ‘Rosetta Code’

print(‘Plain text:             ’txt)

V txtN = txt.reduce(BigInt(0), (a, b) -> a * 256 + b.code)
print(‘Plain text as a number: ’txtN)

V enc = pow(txtN, e, n)
print(‘Encoded:                ’enc)

V dec = pow(enc, d, n)
print(‘Decoded:                ’dec)

V decTxt = ‘’
L dec != 0
   decTxt ‘’= Char(code' dec % 256)
   dec I/= 256

print(‘Decoded number as text: ’reversed(decTxt))
===
auto n = BigInt(u"9516311845790656153499716760847001433441357"_S);
auto e = BigInt(65537);
auto d = BigInt(u"5617843187844953170308463622230283376298685"_S);

auto txt = u"Rosetta Code"_S;

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"Plain text:             "_S & txt);
    }
} code_block_1;

auto txtN = txt.reduce(BigInt(0), [](const auto &a, const auto &b){return a * 256 + b.code;});

struct CodeBlock2
{
    CodeBlock2()
    {
        print(u"Plain text as a number: "_S & txtN);
    }
} code_block_2;

auto enc = pow(txtN, e, n);

struct CodeBlock3
{
    CodeBlock3()
    {
        print(u"Encoded:                "_S & enc);
    }
} code_block_3;

auto dec = pow(enc, d, n);

struct CodeBlock4
{
    CodeBlock4()
    {
        print(u"Decoded:                "_S & dec);
    }
} code_block_4;

auto decTxt = u""_S;

struct CodeBlock5
{
    CodeBlock5()
    {
        while (dec != 0) {
            decTxt &= Char(mod(dec, 256));
            dec = idiv(dec, 256);
        }

        print(u"Decoded number as text: "_S & reversed(decTxt));
    }
} code_block_5;


# https://www.rosettacode.org/wiki/Playfair_cipher#Python
from itertools import product
from typing import Dict

def uniq(seq):
    seen : List[Char] = []
    for x in seq:
        if x not in seen:
            seen.append(x)
    return seen

def partition(seq, n):
    return [seq[i : i + n] for i in range(0, len(seq), n)]

def canonicalize(s):
    return ''.join(filter(lambda c: c.isupper(), s.upper())).replace('J', 'I')

class Playfair:
    dec : Dict[str, str]

    def __init__(self, key):
        # Build 5x5 matrix.
        m = partition(uniq(canonicalize(key + 'ABCDEFGHIJKLMNOPQRSTUVWXYZ')), 5)

        # Pregenerate all forward translations.
        self.enc : Dict[str, str] = {}

        # Map pairs in same row.
        for row in m:
            for i, j in product(range(5), range(5)):
                if i != j:
                    self.enc[row[i] + '' + row[j]] = row[(i + 1) % 5] + '' + row[(j + 1) % 5]

        # Map pairs in same column.
        for ci in range(5):
            c = [m[0][ci], m[1][ci], m[2][ci], m[3][ci], m[4][ci]]
            for i, j in product(range(5), range(5)):
                if i != j:
                    self.enc[c[i] + '' + c[j]] = c[(i + 1) % 5] + '' + c[(j + 1) % 5]

        # Map pairs with cross-connections.
        for i1, j1, i2, j2 in product(range(5), range(5), range(5), range(5)):
            if i1 != i2 and j1 != j2:
                self.enc[m[i1][j1] + '' + m[i2][j2]] = m[i1][j2] + '' + m[i2][j1]

        # Generate reverse translations.
        self.dec = dict((v, k) for k, v in self.enc.items())

    def encode(self, txt):
        c = canonicalize(txt)
        lst : List[str] = []
        i = 0
        while i < len(c) - 1:
            if c[i + 1] == c[i]:
                lst += [c[i] + 'X']
                i += 1
            else:
                lst += [c[i] + '' + c[i + 1]]
                i += 2
        if i == len(c) - 1:
            lst += [c[-1] + 'X']
        return ' '.join(self.enc[a] for a in lst)

    def decode(self, encoded):
        return ' '.join(self.dec[p] for p in partition(canonicalize(encoded), 2))

playfair = Playfair("Playfair example")
orig = "Hide the gold in...the TREESTUMP!!!"
print("Original:", orig)
enc = playfair.encode(orig)
print("Encoded:", enc)
print("Decoded:", playfair.decode(enc))
===
F uniq(seq)
   [Char] seen
   L(x) seq
      I x !C seen
         seen.append(x)
   R seen

F partition(seq, n)
   R (0 .< seq.len).step(n).map(i -> @seq[i .< i + @n])

F canonicalize(s)
   R s.uppercase().filter(c -> c.is_uppercase()).join(‘’).replace(‘J’, ‘I’)

T Playfair
   [String = String] dec

   [String = String] enc

   F (key)
      V m = partition(uniq(canonicalize(key‘ABCDEFGHIJKLMNOPQRSTUVWXYZ’)), 5)

      L(row) m
         L(i, j) cart_product(0.<5, 0.<5)
            I i != j
               .enc[row[i]‘’row[j]] = row[(i + 1) % 5]‘’row[(j + 1) % 5]

      L(ci) 5
         V c = [m[0][ci], m[1][ci], m[2][ci], m[3][ci], m[4][ci]]
         L(i, j) cart_product(0.<5, 0.<5)
            I i != j
               .enc[c[i]‘’c[j]] = c[(i + 1) % 5]‘’c[(j + 1) % 5]

      L(i1, j1, i2, j2) cart_product(0.<5, 0.<5, 0.<5, 0.<5)
         I i1 != i2 & j1 != j2
            .enc[m[i1][j1]‘’m[i2][j2]] = m[i1][j2]‘’m[i2][j1]

      .dec = Dict(.enc.map((k, v) -> (v, k)))

   F encode(txt)
      V c = canonicalize(txt)
      [String] lst
      V i = 0
      L i < c.len - 1
         I c[i + 1] == c[i]
            lst [+]= c[i]‘X’
            i++
         E
            lst [+]= c[i]‘’c[i + 1]
            i += 2
      I i == c.len - 1
         lst [+]= c.last‘X’
      R lst.map(a -> @.enc[a]).join(‘ ’)

   F decode(encoded)
      R partition(canonicalize(encoded), 2).map(p -> @.dec[p]).join(‘ ’)

V playfair = Playfair(‘Playfair example’)
V orig = ‘Hide the gold in...the TREESTUMP!!!’
print(‘Original: ’orig)
V enc = playfair.encode(orig)
print(‘Encoded: ’enc)
print(‘Decoded: ’playfair.decode(enc))
===
template <typename T1> auto uniq(const T1 &seq)
{
    Array<Char> seen;
    for (auto &&x : seq)
        if (!in(x, seen))
            seen.append(x);
    return seen;
}

template <typename T1, typename T2> auto partition(const T1 &seq, const T2 &n)
{
    return range_el(0, seq.len()).step(n).map([&n, &seq](const auto &i){return seq[range_el(i, i + n)];});
}

template <typename T1> auto canonicalize(const T1 &s)
{
    return s.uppercase().filter([](const auto &c){return c.is_uppercase();}).join(u""_S).replace(u"J"_S, u"I"_S);
}

class Playfair
{
public:
    Dict<String, String> dec;

    Dict<String, String> enc;

    template <typename T1> Playfair(const T1 &key)
    {
        auto m = partition(uniq(canonicalize(key & u"ABCDEFGHIJKLMNOPQRSTUVWXYZ"_S)), 5);

        for (auto &&row : m)
            for (auto &&[i, j] : cart_product(range_el(0, 5), range_el(0, 5)))
                if (i != j)
                    enc.set(row[i] & row[j], row[mod((i + 1), 5)] & row[mod((j + 1), 5)]);

        for (int ci = 0; ci < 5; ci++) {
            auto c = create_array({_get<0>(m)[ci], _get<1>(m)[ci], _get<2>(m)[ci], _get<3>(m)[ci], _get<4>(m)[ci]});
            for (auto &&[i, j] : cart_product(range_el(0, 5), range_el(0, 5)))
                if (i != j)
                    enc.set(c[i] & c[j], c[mod((i + 1), 5)] & c[mod((j + 1), 5)]);
        }

        for (auto &&[i1, _j1_, i2, j2] : cart_product(range_el(0, 5), range_el(0, 5), range_el(0, 5), range_el(0, 5)))
            if (i1 != i2 && _j1_ != j2)
                enc.set(m[i1][_j1_] & m[i2][j2], m[i1][j2] & m[i2][_j1_]);

        dec = create_dict(enc.map([](const auto &k, const auto &v){return make_tuple(v, k);}));
    }

    template <typename T1> auto encode(const T1 &txt)
    {
        auto c = canonicalize(txt);
        Array<String> lst;
        auto i = 0;
        while (i < c.len() - 1)
            if (c[i + 1] == c[i]) {
                lst.append(c[i] & u"X"_S);
                i++;
            }
            else {
                lst.append(c[i] & c[i + 1]);
                i += 2;
            }
        if (i == c.len() - 1)
            lst.append(c.last() & u"X"_S);
        return lst.map([this](const auto &a){return enc[a];}).join(u" "_S);
    }

    template <typename T1> auto decode(const T1 &encoded)
    {
        return partition(canonicalize(encoded), 2).map([this](const auto &p){return dec[p];}).join(u" "_S);
    }
};

auto playfair = Playfair(u"Playfair example"_S);
auto orig = u"Hide the gold in...the TREESTUMP!!!"_S;

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"Original: "_S & orig);
    }
} code_block_1;

auto enc = playfair.encode(orig);

struct CodeBlock2
{
    CodeBlock2()
    {
        print(u"Encoded: "_S & enc);
        print(u"Decoded: "_S & playfair.decode(enc));
    }
} code_block_2;


---
# https://www.rosettacode.org/wiki/Generator/Exponential#D

# Rejected this implementation as making lambdas mutable prevent passing them as `const T &` argument
from copy import copy

def powers(e):
    i = 0.0
    def f():
        nonlocal e, i # =
        r = i ** e
        i += 1
        return r
    return f

def filter2(af, bf):
    caf = copy(af)
    cbf = copy(bf)
    a = caf()
    b = cbf()

    def f():
        nonlocal a, b, caf, cbf # =
        r : float
        while True:
            if a < b:
                r = a
                a = caf()
                break
            if b == a:
                a = caf()
            b = cbf()
        return r

    return f

fgen = filter2(powers(2), powers(3))
for i in range(20):
    fgen()
for i in range(10):
    print(fgen(), end = ' ')


# https://www.rosettacode.org/wiki/Generator/Exponential#C.2B.2B
class Generator:
    def next(self) -> float:
        raise NotImplementedError()

class PowersGenerator(Generator):
    i = 0.0
    e : float

    def __init__(self, e):
        self.e = e

    def next(self) -> float:
        r = self.i ** self.e
        self.i += 1
        return r

class Filter:
    gen : Generator
    filter : Generator
    lastG : float
    lastF : float

    def __init__(self, gen_ : Generator, filter : Generator):
        self.gen = gen_
        self.filter = filter
        self.lastG = self.gen.next()
        self.lastF = self.filter.next()

    def __call__(self):
        while self.lastG >= self.lastF:
            if self.lastG == self.lastF:
                self.lastG = self.gen.next()
            self.lastF = self.filter.next()

        out = self.lastG
        self.lastG = self.gen.next()
        return out

gen = Filter(PowersGenerator(2), PowersGenerator(3))

for i in range(20):
    gen()
for i in range(10):
    print(gen(), end = ' ')
===
T Generator
   F.virtual.abstract next() -> Float

T PowersGenerator(Generator)
   i = 0.0
   Float e

   F (e)
      .e = e

   F.virtual.assign next() -> Float
      V r = .i ^ .e
      .i++
      R r

T Filter
   Generator gen
   Generator filter
   Float lastG
   Float lastF

   F (Generator gen_, Generator filter)
      .gen = gen_
      .filter = filter
      .lastG = .gen.next()
      .lastF = .filter.next()

   F ()()
      L .lastG >= .lastF
         I .lastG == .lastF
            .lastG = .gen.next()
         .lastF = .filter.next()

      V out = .lastG
      .lastG = .gen.next()
      R out

V gen = Filter(PowersGenerator(2), PowersGenerator(3))

L(i) 20
   gen()
L(i) 10
   print(gen(), end' ‘ ’)
===
class Generator
{
public:
    virtual double next() = 0;
};

class PowersGenerator : public Generator
{
public:
    decltype(0.0) i = 0.0;
    double e;

    template <typename T1> PowersGenerator(const T1 &e) :
        e(e)
    {
    }

    virtual double next() override
    {
        auto r = pow(i, e);
        i++;
        return r;
    }
};

class Filter
{
public:
    std::unique_ptr<Generator> gen;
    std::unique_ptr<Generator> filter;
    double lastG;
    double lastF;

    Filter(std::unique_ptr<Generator> gen_, std::unique_ptr<Generator> filter) :
        gen(std::move(gen_)),
        filter(std::move(filter))
    {
        lastG = gen->next();
        lastF = this->filter->next();
    }

    auto operator()()
    {
        while (lastG >= lastF) {
            if (lastG == lastF)
                lastG = gen->next();
            lastF = filter->next();
        }

        auto out = lastG;
        lastG = gen->next();
        return out;
    }
};

auto gen = Filter(std::make_unique<PowersGenerator>(2), std::make_unique<PowersGenerator>(3));

struct CodeBlock1
{
    CodeBlock1()
    {
        for (int i = 0; i < 20; i++)
            gen();
        for (int i = 0; i < 10; i++)
            print(gen(), u" "_S);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Langton%27s_ant#Python
from enum import Enum, IntEnum
Char = str

class Dir(IntEnum):
    UP = 0
    RIGHT = 1
    DOWN = 2
    LEFT = 3

color_WHITE = Char(' ')
color_BLACK = Char('#')

def invert_color(grid : list, x, y):
    """Invert the color of grid at x, y coordinate."""
    if grid[y][x] == color_BLACK:
        grid[y][x] = color_WHITE
    else:
        grid[y][x] = color_BLACK

def next_direction(grid, x, y, direction):
    """Compute next direction according to current position and direction."""
    turn_right = grid[y][x] != color_BLACK
    direction_index = int(direction)
    if turn_right:
        direction_index = (direction_index + 1) % 4
    else:
        direction_index = (direction_index + 4 - 1) % 4
    directions = [Dir.UP, Dir.RIGHT, Dir.DOWN, Dir.LEFT]
    direction = directions[direction_index]
    return direction

def next_position(x, y, direction):
    """Compute next position according to direction."""
    if direction == Dir.UP:
        y -= 1
    elif direction == Dir.RIGHT:
        x -= 1
    elif direction == Dir.DOWN:
        y += 1
    elif direction == Dir.LEFT:
        x += 1
    return (x, y)

def print_grid(grid):
    """Display grid."""
    print(80 * "#")
    print("\n".join("".join(row) for row in grid))

def ant(width, height, max_nb_steps):
    """Langton's ant."""
    grid = [[color_WHITE] * width for _ in range(height)]
    x = width // 2
    y = height // 2
    direction = Dir.UP

    i = 0
    while i < max_nb_steps and 0 <= x < width and 0 <= y < height:
        invert_color(grid, x, y)
        direction = next_direction(grid, x, y, direction)
        (x, y) = next_position(x, y, direction)
        #print_grid(grid)
        i += 1

    print_grid(grid)

ant(width=75, height=52, max_nb_steps=12000)
===
T.enum Dir
   UP
   RIGHT
   DOWN
   LEFT

V color_WHITE = Char(‘ ’)
V color_BLACK = Char(‘#’)

F invert_color(&grid, x, y)
   ‘Invert the color of grid at x, y coordinate.’
   I grid[y][x] == :color_BLACK
      grid[y][x] = :color_WHITE
   E
      grid[y][x] = :color_BLACK

F next_direction(grid, x, y, =direction)
   ‘Compute next direction according to current position and direction.’
   V turn_right = grid[y][x] != :color_BLACK
   V direction_index = Int(direction)
   I turn_right
      direction_index = (direction_index + 1) % 4
   E
      direction_index = (direction_index + 4 - 1) % 4
   V directions = [Dir.UP, Dir.RIGHT, Dir.DOWN, Dir.LEFT]
   direction = directions[direction_index]
   R direction

F next_position(=x, =y, direction)
   ‘Compute next position according to direction.’
   I direction == UP
      y--
   E I direction == RIGHT
      x--
   E I direction == DOWN
      y++
   E I direction == LEFT
      x++
   R (x, y)

F print_grid(grid)
   ‘Display grid.’
   print(80 * ‘#’)
   print(grid.map(row -> row.join(‘’)).join("\n"))

F ant(width, height, max_nb_steps)
   ‘Langton's ant.’
   V grid = [[:color_WHITE] * width] * height
   V x = width I/ 2
   V y = height I/ 2
   V direction = Dir.UP

   V i = 0
   L i < max_nb_steps & x C 0 .< width & y C 0 .< height
      invert_color(&grid, x, y)
      direction = next_direction(grid, x, y, direction)
      (x, y) = next_position(x, y, direction)
      i++

   print_grid(grid)

ant(width' 75, height' 52, max_nb_steps' 12000)
===
enum class Dir {
    UP,
    RIGHT,
    DOWN,
    LEFT
};

auto color_WHITE = u' '_C;
auto color_BLACK = u'#'_C;

template <typename T1, typename T2, typename T3> auto invert_color(T1 &grid, const T2 &x, const T3 &y)
{
    u"Invert the color of grid at x, y coordinate."_S;
    if (grid[y][x] == ::color_BLACK)
        grid[y].set(x, ::color_WHITE);
    else
        grid[y].set(x, ::color_BLACK);
}

template <typename T1, typename T2, typename T3, typename T4> auto next_direction(const T1 &grid, const T2 &x, const T3 &y, T4 direction)
{
    u"Compute next direction according to current position and direction."_S;
    auto turn_right = grid[y][x] != ::color_BLACK;
    auto direction_index = to_int(direction);
    if (turn_right)
        direction_index = mod((direction_index + 1), 4);
    else
        direction_index = mod((direction_index + 4 - 1), 4);
    auto directions = create_array({Dir::UP, Dir::RIGHT, Dir::DOWN, Dir::LEFT});
    direction = directions[direction_index];
    return direction;
}

template <typename T1, typename T2, typename T3> auto next_position(T1 x, T2 y, const T3 &direction)
{
    u"Compute next position according to direction."_S;
    if (direction == TYPE_RM_REF(direction)::UP)
        y--;
    else if (direction == TYPE_RM_REF(direction)::RIGHT)
        x--;
    else if (direction == TYPE_RM_REF(direction)::DOWN)
        y++;
    else if (direction == TYPE_RM_REF(direction)::LEFT)
        x++;
    return make_tuple(x, y);
}

template <typename T1> auto print_grid(const T1 &grid)
{
    u"Display grid."_S;
    print(80 * u"#"_S);
    print(grid.map([](const auto &row){return row.join(u""_S);}).join(u"\n"_S));
}

template <typename T1, typename T2, typename T3> auto ant(const T1 &width, const T2 &height, const T3 &max_nb_steps)
{
    u"Langton's ant."_S;
    auto grid = create_array({create_array({::color_WHITE}) * width}) * height;
    auto x = idiv(width, 2);
    auto y = idiv(height, 2);
    auto direction = Dir::UP;

    auto i = 0;
    while (i < max_nb_steps && in(x, range_el(0, width)) && in(y, range_el(0, height))) {
        invert_color(grid, x, y);
        direction = next_direction(grid, x, y, direction);
        assign_from_tuple(x, y, next_position(x, y, direction));
        i++;
    }

    print_grid(grid);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        ant(75, 52, 12000);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Nonogram_solver#Python
from typing import List
ConstList = List
from functools import reduce

def gen_row(w, s):
    """Create all patterns of a row or col that match given runs."""
    def gen_seg(o : ConstList[List[int]], sp : int) -> List[List[int]]:
        if len(o) == 0:
            return [[2] * sp]
        # return [[2] * x + o[0] + tail
        #         for x in range(1, sp - len(o) + 2)
        #         for tail in gen_seg(o[1:], sp - x)]
        r : List[List[int]] = []
        for x in range(1, sp - len(o) + 2):
            for tail in gen_seg(o[1:], sp - x):
                r += [[2] * x + o[0] + tail]
        return r

    return [x[1:] for x in gen_seg([[1] * i for i in s], w + 1 - sum(s))]

def deduce(hr, vr):
    """Fix inevitable value of cells, and propagate."""
    def allowable(row):
        return reduce(lambda a, b: [x | y for x, y in zip(a, b)], row)

    def fits(a, b):
        return all(x & y for x, y in zip(a, b))

    (w, h) = (len(vr), len(hr))
    rows = [gen_row(w, x) for x in hr]
    cols = [gen_row(h, x) for x in vr]
    can_do = list(map(allowable, rows))

    # Initially mark all columns for update.
    mod_rows = set() # int
    mod_cols = set(range(w))

    def fix_col(n):
        """See if any value in a given column is fixed;
        if so, mark its corresponding row for future fixup."""
        c = [x[n] for x in can_do]
        cols[n] = [x for x in cols[n] if fits(x, c)]
        for i, x in enumerate(allowable(cols[n])):
            if x != can_do[i][n]:
                mod_rows.add(i)
                can_do[i][n] &= x

    def fix_row(n):
        """Ditto, for rows."""
        c = can_do[n]
        rows[n] = [x for x in rows[n] if fits(x, c)]
        for i, x in enumerate(allowable(rows[n])):
            if x != can_do[n][i]:
                mod_cols.add(i)
                can_do[n][i] &= x

    def show_gram(m):
        # If there's 'x', something is wrong.
        # If there's '?', needs more work.
        for x in m:
            print(" ".join("x#.?"[i] for i in x))
        print()

    while len(mod_cols) != 0:
        for i in mod_cols:
            fix_col(i)
        mod_cols.clear()
        for i in mod_rows:
            fix_row(i)
        mod_rows.clear()

    if all(can_do[i][j] in (1, 2) for j in range(w) for i in range(h)):
        print("Solution would be unique")  # but could be incorrect!
    else:
        print("Solution may not be unique, doing exhaustive search:")

    # We actually do exhaustive search anyway. Unique solution takes
    # no time in this phase anyway, but just in case there's no
    # solution (could happen?).
    out = [[0]*0] * h

    def try_all(n : int) -> int: # `(n = 0)` does not work here (see [https://stackoverflow.com/questions/22916784/how-should-i-define-a-stdfunction-variable-with-default-arguments <- google:‘c++ std function default argument’])
        if n >= h:
            for j in range(w):
                if [x[j] for x in out] not in cols[j]:
                    return 0
            show_gram(out)
            return 1
        sol = 0
        for x in rows[n]:
            out[n] = x
            sol += try_all(n + 1)
        return sol

    n = try_all(0)
    if n == 0:
        print("No solution.")
    elif n == 1:
        print("Unique solution.")
    else:
        print(n, "solutions.")
    print()

def solve(p, show_runs=True):
    # s = [[[ord(c) - ord('A') + 1 for c in w] for w in l.split()]
    #      for l in p.splitlines()]
    s : List[List[List[int]]] = []
    for l in p.split("\n"):
        s += [[[ord(c) - ord('A') + 1 for c in w] for w in l.split(' ')]]
    if show_runs:
        print("Horizontal runs:", s[0])
        print("Vertical runs:", s[1])
    deduce(s[0], s[1])

for p in open('nonogram_problems.txt').read().split("\n\n"):
    solve(p)

print("Extra example not solvable by deduction alone:")
solve("B B A A\nB B A A")

print("Extra example where there is no solution:")
solve("B A A\nA A A")
===
F gen_row(w, s)
   ‘Create all patterns of a row or col that match given runs.’
   F gen_seg([[Int]] o, Int sp) -> [[Int]]
      I o.empty
         R [[2] * sp]
      [[Int]] r
      L(x) 1 .< sp - o.len + 2
         L(tail) @gen_seg(o[1..], sp - x)
            r [+]= [2] * x [+] o[0] [+] tail
      R r

   R gen_seg(s.map(i -> [1] * i), w + 1 - sum(s)).map(x -> x[1..])

F deduce(hr, vr)
   ‘Fix inevitable value of cells, and propagate.’
   F allowable(row)
      R row.reduce((a, b) -> zip(a, b).map((x, y) -> x [|] y))

   F fits(a, b)
      R all(zip(a, b).map((x, y) -> x [&] y))

   V (w, h) = (vr.len, hr.len)
   V rows = hr.map(x -> gen_row(@w, x))
   V cols = vr.map(x -> gen_row(@h, x))
   V can_do = rows.map(allowable)

   V mod_rows = Set[Int]()
   V mod_cols = Set(0 .< w)

   F fix_col(n)
      ‘See if any value in a given column is fixed;
        if so, mark its corresponding row for future fixup.’
      V c = @can_do.map(x -> x[@n])
      @cols[n] = @cols[n].filter(x -> @@fits(x, @c))
      L(x) @allowable(@cols[n])
         V i = L.index
         I x != @can_do[i][n]
            @mod_rows.add(i)
            @can_do[i][n] [&]= x

   F fix_row(n)
      ‘Ditto, for rows.’
      V c = @can_do[n]
      @rows[n] = @rows[n].filter(x -> @@fits(x, @c))
      L(x) @allowable(@rows[n])
         V i = L.index
         I x != @can_do[n][i]
            @mod_cols.add(i)
            @can_do[n][i] [&]= x

   F show_gram(m)
      L(x) m
         print(x.map(i -> ‘x#.?’[i]).join(‘ ’))
      print()

   L !mod_cols.empty
      L(i) mod_cols
         fix_col(i)
      mod_cols.clear()
      L(i) mod_rows
         fix_row(i)
      mod_rows.clear()

   I all(multiloop((0 .< w), (0 .< h), (j, i) -> @can_do[i][j] C (1, 2)))
      print(‘Solution would be unique’)
   E
      print(‘Solution may not be unique, doing exhaustive search:’)

   V out = [[Int]()] * h

   F try_all(Int n) -> Int
      I n >= @h
         L(j) 0 .< @w
            I @out.map(x -> x[@j]) !C @cols[j]
               R 0
         @show_gram(@out)
         R 1
      V sol = 0
      L(x) @rows[n]
         @out[n] = x
         sol += @try_all(n + 1)
      R sol

   V n = try_all(0)
   S n
      0
         print(‘No solution.’)
      1
         print(‘Unique solution.’)
      E
         print(n‘ solutions.’)
   print()

F solve(p, show_runs = 1B)
   [[[Int]]] s
   L(l) p.split("\n")
      s [+]= l.split(‘ ’).map(w -> w.map(c -> c.code - ‘A’.code + 1))
   I show_runs
      print(‘Horizontal runs: ’s[0])
      print(‘Vertical runs: ’s[1])
   deduce(s[0], s[1])

L(p) File(‘nonogram_problems.txt’).read().split("\n\n")
   solve(p)

print(‘Extra example not solvable by deduction alone:’)
solve("B B A A\nB B A A")

print(‘Extra example where there is no solution:’)
solve("B A A\nA A A")
===
template <typename T1, typename T2> auto gen_row(const T1 &w, const T2 &s)
{
    u"Create all patterns of a row or col that match given runs."_S;
    std::function<Array<Array<int>>(Array<Array<int>>, int)> gen_seg = [&gen_seg](const Array<Array<int>> &o, const int sp)
    {
        if (o.empty())
            return create_array({create_array({2}) * sp});
        Array<Array<int>> r;
        for (auto x : range_el(1, sp - o.len() + 2))
            for (auto &&tail : gen_seg(o[range_ei(1)], sp - x))
                r.append(create_array({2}) * x + _get<0>(o) + tail);
        return r;
    };

    return gen_seg(s.map([](const auto &i){return create_array({1}) * i;}), w + 1 - sum(s)).map([](const auto &x){return x[range_ei(1)];});
}

template <typename T1, typename T2> auto deduce(const T1 &hr, const T2 &vr)
{
    u"Fix inevitable value of cells, and propagate."_S;
    auto allowable = [](const auto &row)
    {
        return row.reduce([](const auto &a, const auto &b){return zip(a, b).map([](const auto &x, const auto &y){return x | y;});});
    };

    auto fits = [](const auto &a, const auto &b)
    {
        return all_map(zip(a, b), [](const auto &x, const auto &y){return x & y;});
    };
    auto [w, h] = make_tuple(vr.len(), hr.len());
    auto rows = hr.map([&w](const auto &x){return gen_row(w, x);});
    auto cols = vr.map([&h](const auto &x){return gen_row(h, x);});
    auto can_do = rows.map(allowable);

    auto mod_rows = Set<int>();
    auto mod_cols = create_set(range_el(0, w));

    auto fix_col = [&allowable, &can_do, &cols, &fits, &mod_rows](const auto &n)
    {
        uR"(See if any value in a given column is fixed;
        if so, mark its corresponding row for future fixup.)"_S;
        auto c = can_do.map([&n](const auto &x){return x[n];});
        cols.set(n, cols[n].filter([&c, &fits](const auto &x){return fits(x, c);}));
        {int Lindex = 0;
        for (auto &&x : allowable(cols[n])) {
            auto i = Lindex;
            if (x != can_do[i][n]) {
                mod_rows.add(i);
                can_do[i][n] &= x;
            }
            Lindex++;
        }}
    };

    auto fix_row = [&allowable, &can_do, &fits, &mod_cols, &rows](const auto &n)
    {
        u"Ditto, for rows."_S;
        auto c = can_do[n];
        rows.set(n, rows[n].filter([&c, &fits](const auto &x){return fits(x, c);}));
        {int Lindex = 0;
        for (auto &&x : allowable(rows[n])) {
            auto i = Lindex;
            if (x != can_do[n][i]) {
                mod_cols.add(i);
                can_do[n][i] &= x;
            }
            Lindex++;
        }}
    };

    auto show_gram = [](const auto &m)
    {
        for (auto &&x : m)
            print(x.map([](const auto &i){return u"x#.?"_S[i];}).join(u" "_S));
        print();
    };

    while (!mod_cols.empty()) {
        for (auto &&i : mod_cols)
            fix_col(i);
        mod_cols.clear();
        for (auto &&i : mod_rows)
            fix_row(i);
        mod_rows.clear();
    }

    if (all(multiloop(range_el(0, w), range_el(0, h), [&can_do](const auto &j, const auto &i){return in(can_do[i][j], make_tuple(1, 2));})))
        print(u"Solution would be unique"_S);
    else
        print(u"Solution may not be unique, doing exhaustive search:"_S);

    auto out = create_array({Array<int>()}) * h;

    std::function<int(int)> try_all = [&cols, &h, &out, &rows, &show_gram, &try_all, &w](const int n)
    {
        if (n >= h) {
            for (auto j : range_el(0, w))
                if (!in(out.map([&j](const auto &x){return x[j];}), cols[j]))
                    return 0;
            show_gram(out);
            return 1;
        }
        auto sol = 0;
        for (auto &&x : rows[n]) {
            out.set(n, x);
            sol += try_all(n + 1);
        }
        return sol;
    };

    auto n = try_all(0);
    switch (n)
    {
    case 0:
        print(u"No solution."_S);
        break;
    case 1:
        print(u"Unique solution."_S);
        break;
    default:
        print(n & u" solutions."_S);
        break;
    }
    print();
}

template <typename T1, typename T2 = decltype(true)> auto solve(const T1 &p, const T2 &show_runs = true)
{
    Array<Array<Array<int>>> s;
    for (auto &&l : p.split(u"\n"_S))
        s.append(l.split(u" "_S).map([](const auto &w){return w.map([](const auto &c){return c.code - u'A'_C.code + 1;});}));
    if (show_runs) {
        print(u"Horizontal runs: "_S & _get<0>(s));
        print(u"Vertical runs: "_S & _get<1>(s));
    }
    deduce(_get<0>(s), _get<1>(s));
}

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&p : File(u"nonogram_problems.txt"_S).read().split(u"\n\n"_S))
            solve(p);

        print(u"Extra example not solvable by deduction alone:"_S);
        solve(u"B B A A\nB B A A"_S);

        print(u"Extra example where there is no solution:"_S);
        solve(u"B A A\nA A A"_S);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Readline_interface#D
from typing import List

histArr : List[str] = []

def hello():
    print("Hello World!")
    global histArr
    histArr += ['hello'];

def hist():
    global histArr
    if len(histArr) == 0:
        print("No history")
    else:
        for cmd in histArr:
            print(" -", cmd)
    histArr += ['hist']

def help():
    print("Available commands:")
    print("  hello")
    print("  hist")
    print("  exit")
    print("  help")
    global histArr
    histArr += ['help']

aa : Dict[str, Callable[[], None]] = {}
aa['help'] = help
aa['hist'] = hist
aa['hello'] = hello

print("Enter a command, type help for a listing.")

while True:
    line = input('>')
    if line == 'exit':
        break
    aa.get(line, help)()
===
[String] histArr

F hello()
   print(‘Hello World!’)
   :histArr [+]= ‘hello’

F hist()
   I :histArr.empty
      print(‘No history’)
   E
      L(cmd) :histArr
         print(‘ - ’cmd)
   :histArr [+]= ‘hist’

F help()
   print(‘Available commands:’)
   print(‘  hello’)
   print(‘  hist’)
   print(‘  exit’)
   print(‘  help’)
   :histArr [+]= ‘help’

[String = (() -> N)] aa
aa[‘help’] = help
aa[‘hist’] = hist
aa[‘hello’] = hello

print(‘Enter a command, type help for a listing.’)

L
   V line = input(‘>’)
   I line == ‘exit’
      L.break
   aa.get(line, help)()
===
Array<String> histArr;

auto hello()
{
    print(u"Hello World!"_S);
    ::histArr.append(u"hello"_S);
}

auto hist()
{
    if (::histArr.empty())
        print(u"No history"_S);
    else
        for (auto &&cmd : ::histArr)
            print(u" - "_S & cmd);
    ::histArr.append(u"hist"_S);
}

auto help()
{
    print(u"Available commands:"_S);
    print(u"  hello"_S);
    print(u"  hist"_S);
    print(u"  exit"_S);
    print(u"  help"_S);
    ::histArr.append(u"help"_S);
}

Dict<String, std::function<void()>> aa;

struct CodeBlock1
{
    CodeBlock1()
    {
        aa.set(u"help"_S, help);
        aa.set(u"hist"_S, hist);
        aa.set(u"hello"_S, hello);

        print(u"Enter a command, type help for a listing."_S);

        while (true) {
            auto line = input(u">"_S);
            if (line == u"exit")
                break;
            aa.get(line, help)();
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Range_modifications#Python
from _11l import *

class Sequence:
    ranges : List[MutTuple[int, int]]

    def __init__(self, sequence_string):
        self.ranges = []
        if sequence_string != '':
            self.ranges = self.to_ranges(sequence_string)
        assert self.ranges == sorted(self.ranges), "Sequence order error"

    def to_ranges(self, txt):
        return [MutTuple(int(r.split('-')[0]),
                         int(r.split('-')[1])) for r in txt.split(',')]
        # return [[int(x) for x in r.split('-')]
        #         for r in txt.split(',')]

    def remove(self, rem):
        for i, r in enumerate(self.ranges):
            if r[0] <= rem <= r[1]:
                if r[0] == rem:     # range min
                    if r[1] > rem:
                        r[0] += 1
                    else:
                        del self.ranges[i]
                elif r[1] == rem:   # range max
                    if r[0] < rem:
                        r[1] -= 1
                    else:
                        del self.ranges[i]
                else:               # inside, range extremes.
                    (r1, splitrange) = (rem - 1, MutTuple(rem + 1, r[1]))
                    r[1] = r1
                    self.ranges.insert(i + 1, splitrange)
                break
            if r[0] > rem:  # Not in sorted list
                break

    def add(self, add):
        for i, r in enumerate(self.ranges):
            if r[0] <= add <= r[1]:     # already included
                break
            elif r[0] - 1 == add:      # rough extend to here
                r[0] = add
                break
            elif r[1] + 1 == add:      # rough extend to here
                r[1] = add
                break
            elif r[0] > add:      # rough insert here
                self.ranges.insert(i, MutTuple(add, add))
                break
        else:
            self.ranges.append(MutTuple(add, add))

        self.consolidate()

    def consolidate(self):
        "Combine overlapping ranges"
        '''ranges = self.ranges
        for this, that in zip(ranges, ranges[1:]):
            if this[1] + 1 >= that[0]:  # Ranges interract
                if this[1] >= that[1]:  # this covers that
                    this[:], that[:] = [], this
                else:   # that extends this
                    this[:], that[:] = [], [this[0], that[1]]
        ranges[:] = [r for r in ranges if r]'''
        for i in range(len(self.ranges) - 1):
            this = i
            that = i + 1
            if self.ranges[this][1] + 1 >= self.ranges[that][0]:  # Ranges interract
                if self.ranges[this][1] >= self.ranges[that][1]:  # this covers that
                    self.ranges[that] = self.ranges[this]
                    self.ranges[this] = MutTuple(-1, -1)
                else:                                             # that extends this
                    self.ranges[that] = MutTuple(self.ranges[this][0], self.ranges[that][1])
                    self.ranges[this] = MutTuple(-1, -1)
        self.ranges = [r for r in self.ranges if r != MutTuple(-1, -1)]

    def __str__(self):
        return ",".join(str(r[0]) + '-' + str(r[1]) for r in self.ranges)

def demo(opp_txt):
    by_line = opp_txt.split("\n")
    start = by_line.pop(0)
    ex = Sequence(start.split(' ')[-1][1:-1])
    lines = [line.lstrip(' ').split(' ') for line in by_line]
    opps = [(word[0], int(word[1])) for word in lines]
    print('Start: "' + str(ex) + '"')
    for op, val in opps:
        #print(f"    {op.__name__:>6} {val:2} => {op(val)}")
        if op == 'add':
            ex.add(val)
        else:
            assert(op == 'remove')
            ex.remove(val)
        print('    %6s %2d => %s' % (op, val, ex))
    print()

demo(
"""   Start with ""
            add 77
            add 79
            add 78
            remove 77
            remove 78
            remove 79""")
demo(
"""   Start with "1-3,5-5"
            add 1
            remove 4
            add 7
            add 8
            add 6
            remove 7""")
demo(
"""   Start with "1-5,10-25,27-30"
            add 26
            add 9
            add 7
            remove 26
            remove 9
            remove 7""")
===
T Sequence
   [(Int, Int)] ranges

   F (sequence_string)
      I sequence_string != ‘’
         .ranges = .to_ranges(sequence_string)
      assert(.ranges == sorted(.ranges), ‘Sequence order error’)

   F to_ranges(txt)
      R txt.split(‘,’).map(r -> (Int(r.split(‘-’)[0]), Int(r.split(‘-’)[1])))

   F remove(rem)
      L(r) .ranges
         V i = L.index
         I rem C r[0] .. r[1]
            I r[0] == rem
               I r[1] > rem
                  r[0]++
               E
                  .ranges.pop(i)
            E I r[1] == rem
               I r[0] < rem
                  r[1]--
               E
                  .ranges.pop(i)
            E
               V (r1, splitrange) = (rem - 1, (rem + 1, r[1]))
               r[1] = r1
               .ranges.insert(i + 1, splitrange)
            L.break
         I r[0] > rem
            L.break

   F add(add)
      L(r) .ranges
         V i = L.index
         I add C r[0] .. r[1]
            L.break
         E I r[0] - 1 == add
            r[0] = add
            L.break
         E I r[1] + 1 == add
            r[1] = add
            L.break
         E I r[0] > add
            .ranges.insert(i, (add, add))
            L.break
      L.was_no_break
         .ranges.append((add, add))

      .consolidate()

   F consolidate()
      ‘Combine overlapping ranges’
      ‘ranges = self.ranges
        for this, that in zip(ranges, ranges[1:]):
            if this[1] + 1 >= that[0]:  # Ranges interract
                if this[1] >= that[1]:  # this covers that
                    this[:], that[:] = [], this
                else:   # that extends this
                    this[:], that[:] = [], [this[0], that[1]]
        ranges[:] = [r for r in ranges if r]’
      L(i) 0 .< .ranges.len - 1
         V this = i
         V that = i + 1
         I .ranges[this][1] + 1 >= .ranges[that][0]
            I .ranges[this][1] >= .ranges[that][1]
               .ranges[that] = .ranges[this]
               .ranges[this] = (-1, -1)
            E
               .ranges[that] = (.ranges[this][0], .ranges[that][1])
               .ranges[this] = (-1, -1)
      .ranges = .ranges.filter(r -> r != (-1, -1))

   F String()
      R .ranges.map(r -> String(r[0])‘-’String(r[1])).join(‘,’)

F demo(opp_txt)
   V by_line = opp_txt.split("\n")
   V start = by_line.pop(0)
   V ex = Sequence(start.split(‘ ’).last[1 .< (len)-1])
   V lines = by_line.map(line -> line.ltrim(‘ ’).split(‘ ’))
   V opps = lines.map(word -> (word[0], Int(word[1])))
   print(‘Start: "’String(ex)‘"’)
   L(op, val) opps
      I op == ‘add’
         ex.add(val)
      E
         assert(op == ‘remove’)
         ex.remove(val)
      print(‘    #6 #2 => #.’.format(op, val, ex))
   print()

demo(‘   Start with ""
            add 77
            add 79
            add 78
            remove 77
            remove 78
            remove 79’)
demo(‘   Start with "1-3,5-5"
            add 1
            remove 4
            add 7
            add 8
            add 6
            remove 7’)
demo(‘   Start with "1-5,10-25,27-30"
            add 26
            add 9
            add 7
            remove 26
            remove 9
            remove 7’)
===
class Sequence
{
public:
    Array<ivec2> ranges;

    template <typename T1> Sequence(const T1 &sequence_string)
    {
        if (sequence_string != u"")
            ranges = to_ranges(sequence_string);
        assert(ranges == sorted(ranges), u"Sequence order error"_S);
    }

    template <typename T1> auto to_ranges(const T1 &txt)
    {
        return txt.split(u","_S).map([](const auto &r){return make_tuple(to_int(_get<0>(r.split(u"-"_S))), to_int(_get<1>(r.split(u"-"_S))));});
    }

    template <typename T1> auto remove(const T1 &rem)
    {
        {int Lindex = 0;
        for (auto &&r : ranges) {
            auto i = Lindex;
            if (in(rem, range_ee(_get<0>(r), _get<1>(r)))) {
                if (_get<0>(r) == rem) {
                    if (_get<1>(r) > rem)
                        _get<0>(r)++;
                    else
                        ranges.pop(i);
                }
                else if (_get<1>(r) == rem) {
                    if (_get<0>(r) < rem)
                        _get<1>(r)--;
                    else
                        ranges.pop(i);
                }
                else {
                    auto [r1, splitrange] = make_tuple(rem - 1, make_tuple(rem + 1, _get<1>(r)));
                    _set<1>(r, r1);
                    ranges.insert(i + 1, splitrange);
                }
                break;
            }
            if (_get<0>(r) > rem)
                break;
            Lindex++;
        }}
    }

    template <typename T1> auto add(const T1 &add)
    {
        {int Lindex = 0;
        for (auto &&r : ranges) {
            auto i = Lindex;
            if (in(add, range_ee(_get<0>(r), _get<1>(r))))
                goto break_;
            else if (_get<0>(r) - 1 == add) {
                _set<0>(r, add);
                goto break_;
            }
            else if (_get<1>(r) + 1 == add) {
                _set<1>(r, add);
                goto break_;
            }
            else if (_get<0>(r) > add) {
                ranges.insert(i, make_tuple(add, add));
                goto break_;
            }
            Lindex++;
        }}
        ranges.append(make_tuple(add, add));
        break_:;

        consolidate();
    }

    auto consolidate()
    {
        u"Combine overlapping ranges"_S;
        uR"(ranges = self.ranges
        for this, that in zip(ranges, ranges[1:]):
            if this[1] + 1 >= that[0]:  # Ranges interract
                if this[1] >= that[1]:  # this covers that
                    this[:], that[:] = [], this
                else:   # that extends this
                    this[:], that[:] = [], [this[0], that[1]]
        ranges[:] = [r for r in ranges if r])"_S;
        for (auto i : range_el(0, ranges.len() - 1)) {
            auto _this_ = i;
            auto that = i + 1;
            if (_get<1>(ranges[_this_]) + 1 >= _get<0>(ranges[that])) {
                if (_get<1>(ranges[_this_]) >= _get<1>(ranges[that])) {
                    ranges.set(that, ranges[_this_]);
                    ranges.set(_this_, make_tuple(-1, -1));
                }
                else {
                    ranges.set(that, make_tuple(_get<0>(ranges[_this_]), _get<1>(ranges[that])));
                    ranges.set(_this_, make_tuple(-1, -1));
                }
            }
        }
        ranges = ranges.filter([](const auto &r){return r != make_tuple(-1, -1);});
    }

    operator String() const
    {
        return ranges.map([](const auto &r){return String(_get<0>(r)) & u"-"_S & String(_get<1>(r));}).join(u","_S);
    }
};

template <typename T1> auto demo(const T1 &opp_txt)
{
    auto by_line = opp_txt.split(u"\n"_S);
    auto start = by_line.pop(0);
    auto ex = Sequence(start.split(u" "_S).last()[range_e_llen(1,  - 1)]);
    auto lines = by_line.map([](const auto &line){return line.ltrim(u" "_S).split(u" "_S);});
    auto opps = lines.map([](const auto &word){return make_tuple(_get<0>(word), to_int(_get<1>(word)));});
    print(u"Start: \""_S & String(ex) & u"\""_S);
    for (auto &&[op, val] : opps) {
        if (op == u"add")
            ex.add(val);
        else {
            assert(op == u"remove");
            ex.remove(val);
        }
        print(u"    #6 #2 => #."_S.format(op, val, ex));
    }
    print();
}

struct CodeBlock1
{
    CodeBlock1()
    {
        demo(uR"(   Start with ""
            add 77
            add 79
            add 78
            remove 77
            remove 78
            remove 79)"_S);
        demo(uR"(   Start with "1-3,5-5"
            add 1
            remove 4
            add 7
            add 8
            add 6
            remove 7)"_S);
        demo(uR"(   Start with "1-5,10-25,27-30"
            add 26
            add 9
            add 7
            remove 26
            remove 9
            remove 7)"_S);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Sum_to_100#Kotlin
from enum import IntEnum
import collections

NUMBER_OF_DIGITS = 9
THREE_POW_4 = 3 * 3 * 3 * 3
NUMBER_OF_EXPRESSIONS = 2 * THREE_POW_4 * THREE_POW_4

class Op(IntEnum):
    ADD = 0
    SUB = 1
    JOIN = 2

class Expression:
    def __init__(self):
        self.code = [Op.ADD] * NUMBER_OF_DIGITS

    def inc(self):
        for i in range(len(self.code)):
            self.code[i] = Op((int(self.code[i]) + 1) % 3)
            if self.code[i] != Op.ADD:
                break

    def toInt(self):
        value = 0
        number = 0
        sign = 1
        for digit in range(1, 10):
            c = self.code[NUMBER_OF_DIGITS - digit]
            if   c == Op.ADD: value += sign * number; number = digit; sign =  1
            elif c == Op.SUB: value += sign * number; number = digit; sign = -1
            else: number = 10 * number + digit
        return value + sign * number

    def __str__(self):
        s = ''
        for digit in range(1, NUMBER_OF_DIGITS + 1):
            c = self.code[NUMBER_OF_DIGITS - digit]
            if c == Op.ADD:
                if digit > 1: s += ' + '
            elif c == Op.SUB:
                s += ' - '
            s += str(digit)
        return s.lstrip(' ')

def printe(givenSum):
    expression = Expression()
    for i in range(NUMBER_OF_EXPRESSIONS):
        if expression.toInt() == givenSum:
            print('%9d' % givenSum, '=', expression)
        expression.inc()

class Stat:
    def __init__(self):
        self.countSum : DefaultDict[int, int] = collections.defaultdict(int)
        self.sumCount : DefaultDict[int, Set[int]] = collections.defaultdict(set)
        expression = Expression()
        for i in range(NUMBER_OF_EXPRESSIONS):
            sum = expression.toInt()
            self.countSum[sum] += 1
            expression.inc()
        for k, v in self.countSum.items():
            self.sumCount[v].add(k)

print("100 has the following solutions:\n")
printe(100)

stat = Stat()
maxCount = max(stat.sumCount.keys())
maxSum = max(stat.sumCount[maxCount])
print("\n%d has the maximum number of solutions, namely %d" % (maxSum, maxCount))

value = 0
while value in stat.countSum:
    value += 1
print("\n%d is the lowest positive number with no solutions" % value)

print("\nThe ten highest numbers that do have solutions are:\n")
for i in sorted(stat.countSum.keys(), reverse = True)[:10]:
    printe(i)
===
V NUMBER_OF_DIGITS = 9
V THREE_POW_4 = 3 * 3 * 3 * 3
V NUMBER_OF_EXPRESSIONS = 2 * THREE_POW_4 * THREE_POW_4

T.enum Op
   ADD
   SUB
   JOIN

T Expression
   code = [Op.ADD] * :NUMBER_OF_DIGITS
   F ()
   {
   }

   F inc()
      L(i) 0 .< .code.len
         .code[i] = Op((Int(.code[i]) + 1) % 3)
         I .code[i] != ADD
            L.break

   F toInt()
      V value = 0
      V number = 0
      V _sign_ = 1
      L(digit) 1..9
         V c = .code[:NUMBER_OF_DIGITS - digit]
         I c == ADD
            value += _sign_ * number
            number = digit
            _sign_ = 1
         E I c == SUB
            value += _sign_ * number
            number = digit
            _sign_ = -1
         E
            number = 10 * number + digit
      R value + _sign_ * number

   F String()
      V s = ‘’
      L(digit) 1 .. :NUMBER_OF_DIGITS
         V c = .code[:NUMBER_OF_DIGITS - digit]
         I c == ADD
            I digit > 1
               s ‘’= ‘ + ’
         E I c == SUB
            s ‘’= ‘ - ’
         s ‘’= String(digit)
      R s.ltrim(‘ ’)

F printe(givenSum)
   V expression = Expression()
   L(i) 0 .< :NUMBER_OF_EXPRESSIONS
      I expression.toInt() == givenSum
         print((‘#9’.format(givenSum))‘ = ’expression)
      expression.inc()

T Stat
   DefaultDict[Int, Int] countSum
   DefaultDict[Int, Set[Int]] sumCount
   F ()
      V expression = Expression()
      L(i) 0 .< :NUMBER_OF_EXPRESSIONS
         V sum = expression.toInt()
         .countSum[sum]++
         expression.inc()
      L(k, v) .countSum
         .sumCount[v].add(k)

print("100 has the following solutions:\n")
printe(100)

V stat = Stat()
V maxCount = max(stat.sumCount.keys())
V maxSum = max(stat.sumCount[maxCount])
print("\n#. has the maximum number of solutions, namely #.".format(maxSum, maxCount))

V value = 0
L value C stat.countSum
   value++
print("\n#. is the lowest positive number with no solutions".format(value))

print("\nThe ten highest numbers that do have solutions are:\n")
L(i) sorted(stat.countSum.keys(), reverse' 1B)[0.<10]
   printe(i)
===
auto NUMBER_OF_DIGITS = 9;
auto THREE_POW_4 = 3 * 3 * 3 * 3;
auto NUMBER_OF_EXPRESSIONS = 2 * THREE_POW_4 * THREE_POW_4;
enum class Op {
    ADD,
    SUB,
    JOIN
};

class Expression
{
public:
    decltype(create_array({Op::ADD}) * ::NUMBER_OF_DIGITS) code = create_array({Op::ADD}) * ::NUMBER_OF_DIGITS;
    Expression()
    {
    }

    auto inc()
    {
        for (auto i : range_el(0, code.len())) {
            code.set(i, Op(mod((to_int(code[i]) + 1), 3)));
            if (code[i] != TYPE_RM_REF(code[i])::ADD)
                break;
        }
    }

    auto toInt()
    {
        auto value = 0;
        auto number = 0;
        auto _sign_ = 1;
        for (auto digit : range_ee(1, 9)) {
            auto c = code[::NUMBER_OF_DIGITS - digit];
            if (c == TYPE_RM_REF(c)::ADD) {
                value += _sign_ * number;
                number = digit;
                _sign_ = 1;
            }
            else if (c == TYPE_RM_REF(c)::SUB) {
                value += _sign_ * number;
                number = digit;
                _sign_ = -1;
            }
            else
                number = 10 * number + digit;
        }
        return value + _sign_ * number;
    }

    operator String() const
    {
        auto s = u""_S;
        for (auto digit : range_ee(1, ::NUMBER_OF_DIGITS)) {
            auto c = code[::NUMBER_OF_DIGITS - digit];
            if (c == TYPE_RM_REF(c)::ADD) {
                if (digit > 1)
                    s &= u" + "_S;
            }
            else if (c == TYPE_RM_REF(c)::SUB)
                s &= u" - "_S;
            s &= String(digit);
        }
        return s.ltrim(u" "_S);
    }
};

template <typename T1> auto printe(const T1 &givenSum)
{
    auto expression = Expression();
    for (auto i : range_el(0, ::NUMBER_OF_EXPRESSIONS)) {
        if (expression.toInt() == givenSum)
            print((u"#9"_S.format(givenSum)) & u" = "_S & expression);
        expression.inc();
    }
}

class Stat
{
public:
    DefaultDict<int, int> countSum;
    DefaultDict<int, Set<int>> sumCount;
    Stat()
    {
        auto expression = Expression();
        for (auto i : range_el(0, ::NUMBER_OF_EXPRESSIONS)) {
            auto sum = expression.toInt();
            countSum[sum]++;
            expression.inc();
        }
        for (auto &&[k, v] : countSum)
            sumCount[v].add(k);
    }
};

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"100 has the following solutions:\n"_S);
        printe(100);
    }
} code_block_1;

auto _stat_ = Stat();
auto maxCount = max(_stat_.sumCount.keys());
auto maxSum = max(_stat_.sumCount[maxCount]);

struct CodeBlock2
{
    CodeBlock2()
    {
        print(u"\n#. has the maximum number of solutions, namely #."_S.format(maxSum, maxCount));
    }
} code_block_2;

auto value = 0;

struct CodeBlock3
{
    CodeBlock3()
    {
        while (in(value, _stat_.countSum))
            value++;
        print(u"\n#. is the lowest positive number with no solutions"_S.format(value));

        print(u"\nThe ten highest numbers that do have solutions are:\n"_S);
        for (auto &&i : sorted(_stat_.countSum.keys(), nullptr, true)[range_el(0, 10)])
            printe(i);
    }
} code_block_3;


# https://www.rosettacode.org/wiki/Tarjan#Python:_As_function
# (Wrong output)
from typing import List
import collections

class Node:
    def __init__(self):
        # root is one of:
        #   -2: not yet visited
        #   -1: already processed
        #   non-negative integer: what Wikipedia pseudo code calls 'lowlink'
        self.root = -2
        self.succ : List[Node] = []
        self.id = 0

def from_edges(edges):
    '''translate list of edges to list of nodes'''

    nodes = collections.defaultdict(Node) # int
    for v,w in edges:
        nodes[v].succ.append(nodes[w])

    for i,v in nodes.items(): # name the nodes for final output
        v.id = i

    return nodes.values()

def trajan(vv : list):
    def strongconnect(v : "Node", s : List[Node]) -> List[List[int]]:
        pos = len(s)
        v.root = pos
        s.append(v)
        r : List[List[int]] = []

        for w in v.succ:
            if w.root == -2:  # not yet visited
                r.extend(strongconnect(w, s))

            if w.root >= 0:  # still on stack
                v.root = min(v.root, w.root)

        if v.root == pos:  # v is the root, return everything above
            res = s[pos:]
            del s[pos:]
            for w in res:
                w.root = -1
            r.append([r.id for r in res])
        return r

    r : List[List[int]] = []
    for v in vv:
        if v.root == -2:
            l : List[Node] = []
            r.extend(strongconnect(v, l))
    return r

table1 = [(1,2), (3,1), (3,6), (6,7), (7,6), (2,3), (4,2),
          (4,3), (4,5), (5,6), (5,4), (8,5), (8,7), (8,6)]

#table2 = [('A', 'B'), ('B', 'C'), ('C', 'A'), ('A', 'Other')]

for g in trajan(from_edges(table1)):
    print(g)
# print()
# for g in trajan(from_edges(table2)):
#     print(g)
===
T Node
   root = -2
   [Node] succ
   id = 0
   F ()
   {
   }

F from_edges(edges)
   ‘translate list of edges to list of nodes’

   V nodes = DefaultDict[Int, Node]()
   L(v, w) edges
      nodes[v].succ.append(nodes[w])

   L(i, v) nodes
      v.id = i

   R nodes.values()

F trajan(&vv)
   F strongconnect(Node &v, [Node] &s) -> [[Int]]
      V pos = s.len
      v.root = pos
      s.append(v)
      [[Int]] r

      L(w) v.succ
         I w.root == -2
            r.extend(@strongconnect(&w, &s))

         I w.root >= 0
            v.root = min(v.root, w.root)

      I v.root == pos
         V res = s[pos ..]
         s.del(pos ..)
         L(w) res
            w.root = -1
         r.append(res.map(r -> r.id))
      R r

   [[Int]] r
   L(v) vv
      I v.root == -2
         [Node] l
         r.extend(strongconnect(&v, &l))
   R r

V table1 = [(1, 2), (3, 1), (3, 6), (6, 7), (7, 6), (2, 3), (4, 2), (4, 3), (4, 5), (5, 6), (5, 4), (8, 5), (8, 7), (8, 6)]

L(g) trajan(&from_edges(table1))
   print(g)
===
class Node
{
public:
    decltype(-2) root = -2;
    Array<Node> succ;
    decltype(0) id = 0;
    Node()
    {
    }
};

template <typename T1> auto from_edges(const T1 &edges)
{
    u"translate list of edges to list of nodes"_S;

    auto nodes = DefaultDict<int, Node>();
    for (auto &&[v, w] : edges)
        nodes[v].succ.append(nodes[w]);

    for (auto &&[i, v] : nodes)
        v.id = i;

    return nodes.values();
}

template <typename T1> auto trajan(T1 &vv)
{
    std::function<Array<Array<int>>(Node&, Array<Node>&)> strongconnect = [&strongconnect](Node &v, Array<Node> &s)
    {
        auto pos = s.len();
        v.root = pos;
        s.append(v);
        Array<Array<int>> r;

        for (auto &&w : v.succ) {
            if (w.root == -2)
                r.extend(strongconnect(w, s));

            if (w.root >= 0)
                v.root = min(v.root, w.root);
        }

        if (v.root == pos) {
            auto res = s[range_ei(pos)];
            s.del(range_ei(pos));
            for (auto &&w : res)
                w.root = -1;
            r.append(res.map([](const auto &r){return r.id;}));
        }
        return r;
    };

    Array<Array<int>> r;
    for (auto &&v : vv)
        if (v.root == -2) {
            Array<Node> l;
            r.extend(strongconnect(v, l));
        }
    return r;
}

auto table1 = create_array({make_tuple(1, 2), make_tuple(3, 1), make_tuple(3, 6), make_tuple(6, 7), make_tuple(7, 6), make_tuple(2, 3), make_tuple(4, 2), make_tuple(4, 3), make_tuple(4, 5), make_tuple(5, 6), make_tuple(5, 4), make_tuple(8, 5), make_tuple(8, 7), make_tuple(8, 6)});

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&g : trajan(make_ref(from_edges(table1))))
            print(g);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Tarjan#Python:_As_class
import collections
from typing import Dict, List
Char = str

def move(obj):
    return obj

class Graph:
    name : str
    graph : Dict[Char, List[Char]]
    _order : int

    #"Directed Graph Tarjan's strongly connected components algorithm"

    def __init__(self, name, connections):
        self.name = name
        #self.connections = connections
        g : DefaultDict[Char, List[Char]] = collections.defaultdict(list)  # map node vertex to direct connections
        for n in connections:
            (n1, n2) = (n[0], n[1])
            if n1 != n2:
                g[n1].append(n2)
            else:
                g[n1]
        #for _, n2 in connections:
            g[n2]   # For leaf nodes having no edges from themselves
        self.graph = dict(move(g))

        self.disc : Dict[Char, int] = {}
        self.low  : Dict[Char, int] = {}
        self.stack : List[Char] = []
        self.scc : List[List[Char]] = []
        self.tarjan_algo()

    def _visitor(self, this) -> None:
        '''
        Recursive function that finds SCC's
        using DFS traversal of vertices.

        Arguments:
            this        --> Vertex to be visited in this call.
            disc{}      --> Discovery order of visited vertices.
            low{}       --> Connected vertex of earliest discovery order
            stack       --> Ancestor node stack during DFS.
        '''

        self.disc[this] = self.low[this] = self._order
        self._order += 1
        self.stack.append(this)

        for neighbr in self.graph[this]:
            if neighbr not in self.disc:
                # neighbour not visited so do DFS recurrence.
                self._visitor(neighbr)
                self.low[this] = min(self.low[this], self.low[neighbr])  # Prior connection?

            elif neighbr in self.stack:
                # Update low value of this only if neighbr in stack
                self.low[this] = min(self.low[this], self.disc[neighbr])

        if self.low[this] == self.disc[this]:
            # Head node found of SCC
            new : List[Char] = []
            while True:
                top = self.stack.pop()
                new.append(top)
                if top == this:
                    break
            self.scc.append(new)

    def tarjan_algo(self):
        '''
        Recursive function that finds strongly connected components
        using the Tarjan Algorithm and function _visitor() to visit nodes.
        '''

        self._order = 0         # Visitation order counter
        #self.disc, self.low = {}, {}
        #self.stack = []

        #self.scc = []           # SCC result accumulator
        for vertex in sorted(self.graph.keys()):
            if vertex not in self.disc:
                self._visitor(vertex)

for n, m in [('Tx1', '10 02 21 03 34'.split(' ')),
             ('Tx2', '01 12 23'.split(' ')),
             ('Tx3', '01 12 20 13 14 16 35 45'.split(' ')),
             ('Tx4', '01 03 12 14 20 26 32 45 46 56 57 58 59 64 79 89 98 AA'.split(' ')),
             ('Tx5', '01 12 23 24 30 42'.split(' ')),
             ]:
    print("\n\nGraph('%s', %s):\n" % (n, m))
    g = Graph(n, m)
    print("               : ", '  '.join(str(v) for v in sorted(g.disc.keys())))
    print("    DISC of", g.name + ':', [v for _, v in sorted(g.disc.items())])
    print("     LOW of", g.name + ':', [v for _, v in sorted(g.low.items())])
    scc = (str(g.scc).replace("'", '').replace(',', '')[1:-1] if len(g.scc) else '')
    print("\n   SCC's of", g.name + ':', scc)
===
T Graph
   String name
   [Char = [Char]] graph
   Int _order

   [Char = Int] disc
   [Char = Int] low
   [Char] stack
   [[Char]] scc

   F (name, connections)
      .name = name
      DefaultDict[Char, [Char]] g
      L(n) connections
         V (n1, n2) = (n[0], n[1])
         I n1 != n2
            g[n1].append(n2)
         E
            g[n1]
         g[n2]
      .graph = Dict(move(g))
      .tarjan_algo()

   F _visitor(this) -> N
      ‘
        Recursive function that finds SCC's
        using DFS traversal of vertices.

        Arguments:
            this        --> Vertex to be visited in this call.
            disc{}      --> Discovery order of visited vertices.
            low{}       --> Connected vertex of earliest discovery order
            stack       --> Ancestor node stack during DFS.
        ’

      .disc[this] = .low[this] = ._order
      ._order++
      .stack.append(this)

      L(neighbr) .graph[this]
         I neighbr !C .disc
            ._visitor(neighbr)
            .low[this] = min(.low[this], .low[neighbr])

         E I neighbr C .stack
            .low[this] = min(.low[this], .disc[neighbr])

      I .low[this] == .disc[this]
         [Char] new
         L
            V top = .stack.pop()
            new.append(top)
            I top == this
               L.break
         .scc.append(new)

   F tarjan_algo()
      ‘
        Recursive function that finds strongly connected components
        using the Tarjan Algorithm and function _visitor() to visit nodes.
        ’

      ._order = 0

      L(vertex) sorted(.graph.keys())
         I vertex !C .disc
            ._visitor(vertex)

L(n, m) [(‘Tx1’, ‘10 02 21 03 34’.split(‘ ’)), (‘Tx2’, ‘01 12 23’.split(‘ ’)), (‘Tx3’, ‘01 12 20 13 14 16 35 45’.split(‘ ’)), (‘Tx4’, ‘01 03 12 14 20 26 32 45 46 56 57 58 59 64 79 89 98 AA’.split(‘ ’)), (‘Tx5’, ‘01 12 23 24 30 42’.split(‘ ’))]
   print("\n\nGraph('#.', #.):\n".format(n, m))
   V g = Graph(n, m)
   print(‘               :  ’sorted(g.disc.keys()).map(v -> String(v)).join(‘  ’))
   print(‘    DISC of ’(g.name‘:’)‘ ’sorted(g.disc.items()).map((_, v) -> v))
   print(‘     LOW of ’(g.name‘:’)‘ ’sorted(g.low.items()).map((_, v) -> v))
   V scc = (I !g.scc.empty {String(g.scc).replace(‘'’, ‘’).replace(‘,’, ‘’)[1 .< (len)-1]} E ‘’)
   print("\n   SCC's of "(g.name‘:’)‘ ’scc)
===
class Graph
{
public:
    String name;
    Dict<Char, Array<Char>> graph;
    int _order;

    Dict<Char, int> disc;
    Dict<Char, int> low;
    Array<Char> stack;
    Array<Array<Char>> scc;

    template <typename T1, typename T2> Graph(const T1 &name, const T2 &connections) :
        name(name)
    {
        DefaultDict<Char, Array<Char>> g;
        for (auto &&n : connections) {
            auto [n1, n2] = make_tuple(_get<0>(n), _get<1>(n));
            if (n1 != n2)
                g[n1].append(n2);
            else
                g[n1];
            g[n2];
        }
        graph = create_dict(std::move(g));
        tarjan_algo();
    }

    template <typename T1> void _visitor(const T1 &_this_)
    {
        uR"(
        Recursive function that finds SCC's
        using DFS traversal of vertices.

        Arguments:
            this        --> Vertex to be visited in this call.
            disc{}      --> Discovery order of visited vertices.
            low{}       --> Connected vertex of earliest discovery order
            stack       --> Ancestor node stack during DFS.
        )"_S;

        disc.set(_this_, low.set(_this_, _order));
        _order++;
        stack.append(_this_);

        for (auto &&neighbr : graph[_this_])
            if (!in(neighbr, disc)) {
                _visitor(neighbr);
                low.set(_this_, min(low[_this_], low[neighbr]));
            }

            else if (in(neighbr, stack))
                low.set(_this_, min(low[_this_], disc[neighbr]));

        if (low[_this_] == disc[_this_]) {
            Array<Char> _new_;
            while (true) {
                auto top = stack.pop();
                _new_.append(top);
                if (top == _this_)
                    break;
            }
            scc.append(_new_);
        }
    }

    auto tarjan_algo()
    {
        uR"(
        Recursive function that finds strongly connected components
        using the Tarjan Algorithm and function _visitor() to visit nodes.
        )"_S;

        _order = 0;

        for (auto &&vertex : sorted(graph.keys()))
            if (!in(vertex, disc))
                _visitor(vertex);
    }
};

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&[n, m] : create_array({make_tuple(u"Tx1"_S, u"10 02 21 03 34"_S.split(u" "_S)), make_tuple(u"Tx2"_S, u"01 12 23"_S.split(u" "_S)), make_tuple(u"Tx3"_S, u"01 12 20 13 14 16 35 45"_S.split(u" "_S)), make_tuple(u"Tx4"_S, u"01 03 12 14 20 26 32 45 46 56 57 58 59 64 79 89 98 AA"_S.split(u" "_S)), make_tuple(u"Tx5"_S, u"01 12 23 24 30 42"_S.split(u" "_S))})) {
            print(u"\n\nGraph('#.', #.):\n"_S.format(n, m));
            auto g = Graph(n, m);
            print(u"               :  "_S & sorted(g.disc.keys()).map([](const auto &v){return String(v);}).join(u"  "_S));
            print(u"    DISC of "_S & (g.name & u":"_S) & u" "_S & sorted(g.disc.items()).map([](const auto &_, const auto &v){return v;}));
            print(u"     LOW of "_S & (g.name & u":"_S) & u" "_S & sorted(g.low.items()).map([](const auto &_, const auto &v){return v;}));
            auto scc = (!g.scc.empty() ? String(g.scc).replace(u"'"_S, u""_S).replace(u","_S, u""_S)[range_e_llen(1,  - 1)] : u""_S);
            print(u"\n   SCC's of "_S & (g.name & u":"_S) & u" "_S & scc);
        }
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Tic-tac-toe#Python
from typing import Optional, Tuple, List
UInt32 = int
Char = str

seed : UInt32 = 0
def nonrandom_choice(lst):
    global seed
    seed = (1664525 * seed + 1013904223) & 0xFFFF_FFFF
    return lst[seed % UInt32(len(lst))]

board = list('123456789')
wins = ([0,1,2], [3,4,5], [6,7,8],
        [0,3,6], [1,4,7], [2,5,8],
        [0,4,8], [2,4,6])

def printboard():
    print('\n'.join(' '.join(board[x:x+3]) for x in[0,3,6]))

def score(board=board) -> Optional[Tuple[Char, List[int]]]:
    for w in wins:
        b = board[w[0]]
        if b in 'XO' and all (board[i] == b for i in w):
            return (b, [i+1 for i in w])
    return None

def finished():
    return all (b in 'XO' for b in board)

def space(board=board):
    return [ b for b in board if b not in 'XO']

def my_turn(xo, board : list):
    options = space()
    choice = nonrandom_choice(options)
    board[int(choice)-1] = xo
    return choice

def my_better_turn(xo, board : list):
    'Will return a next winning move or block your winning move if possible'
    ox = Char('O') if xo =='X' else Char('X')
    oneblock : Optional[int] = None
    options  = [int(s)-1 for s in space(board)]
    choice : int
    for chc in options:
        brd = board[:]
        brd[chc] = xo
        if score(brd) is not None:
            choice = chc
            break
        if oneblock is None:
            brd[chc] = ox
            if score(brd) is not None:
                oneblock = chc
    else:
        choice = oneblock if oneblock is not None else nonrandom_choice(options)
    board[choice] = xo
    return choice+1

def your_turn(xo, board : list):
    options = space()
    while True:
        choice = input("\nPut your %s in any of these positions: %s "
                       % (xo, ''.join(options))).strip()
        if choice in options:
            board[int(choice)-1] = xo
            return choice
        print( "Whoops I don't understand the input" )

def me(xo=Char('X')):
    printboard()
    print('\nI go at', my_better_turn(xo, board))
    return score()

def you(xo=Char('O')):
    printboard()
    # Call my_turn(xo, board) below for it to play itself
    print('\nYou went at', my_turn(xo, board))
    return score()

while not finished():
    s : Optional[Tuple[Char, List[int]]] = me(Char('X'))
    if s is not None:
        printboard()
        print("\n%s wins along %s" % (s[0], s[1]))
        break
    if not finished():
        s = you(Char('O'))
        if s is not None:
            printboard()
            print("\n%s wins along %s" % (s[0], s[1]))
            break
else:
    print('\nA draw')
===
UInt32 seed = 0
F nonrandom_choice(lst)
   :seed = (1664525 * :seed + 1013904223) [&] FFFF'FFFF
   R lst[:seed % UInt32(lst.len)]

V board = Array(‘123456789’)
V wins = ([0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6])

F printboard()
   print([0, 3, 6].map(x -> (:board[x .< x + 3]).join(‘ ’)).join("\n"))

F score(board = board) -> (Char, [Int])?
   L(w) :wins
      V b = board[w[0]]
      I b C ‘XO’ & all(w.map(i -> @board[i] == @b))
         R (b, w.map(i -> i + 1))
   R N

F finished()
   R all(:board.map(b -> b C ‘XO’))

F space(board = board)
   R board.filter(b -> b !C ‘XO’)

F my_turn(xo, &board)
   V options = space()
   V choice = nonrandom_choice(options)
   board[Int(choice) - 1] = xo
   R choice

F my_better_turn(xo, &board)
   ‘Will return a next winning move or block your winning move if possible’
   V ox = I xo == ‘X’ {Char(‘O’)} E Char(‘X’)
   Int? oneblock
   V options = space(board).map(s -> Int(s) - 1)
   Int choice
   L(chc) options
      V brd = copy(board)
      brd[chc] = xo
      I score(brd) != N
         choice = chc
         L.break
      I oneblock == N
         brd[chc] = ox
         I score(brd) != N
            oneblock = chc
   L.was_no_break
      choice = oneblock ? nonrandom_choice(options)
   board[choice] = xo
   R choice + 1

F your_turn(xo, &board)
   V options = space()
   L
      V choice = input("\nPut your #. in any of these positions: #. ".format(xo, options.join(‘’))).trim((‘ ’, "\t", "\r", "\n"))
      I choice C options
         board[Int(choice) - 1] = xo
         R choice
      print(‘Whoops I don't understand the input’)

F me(xo = Char(‘X’))
   printboard()
   print("\nI go at "my_better_turn(xo, &:board))
   R score()

F you(xo = Char(‘O’))
   printboard()
   print("\nYou went at "my_turn(xo, &:board))
   R score()

L !finished()
   (Char, [Int])? s = me(Char(‘X’))
   I s != N
      printboard()
      print("\n#. wins along #.".format(s[0], s[1]))
      L.break
   I !finished()
      s = you(Char(‘O’))
      I s != N
         printboard()
         print("\n#. wins along #.".format(s[0], s[1]))
         L.break
L.was_no_break
   print("\nA draw")
===
uint32_t seed = 0;
template <typename T1> auto nonrandom_choice(const T1 &lst)
{
    ::seed = (1664525 * ::seed + 1013904223) & 0xFFFF'FFFF;
    return lst[mod(::seed, to_uint32(lst.len()))];
}

auto board = create_array(u"123456789"_S);
auto wins = make_tuple(create_array({0, 1, 2}), create_array({3, 4, 5}), create_array({6, 7, 8}), create_array({0, 3, 6}), create_array({1, 4, 7}), create_array({2, 5, 8}), create_array({0, 4, 8}), create_array({2, 4, 6}));

auto printboard()
{
    print(create_array({0, 3, 6}).map([](const auto &x){return (::board[range_el(x, x + 3)]).join(u" "_S);}).join(u"\n"_S));
}

template <typename T1 = decltype(board)> Nullable<Tuple<Char, Array<int>>> score(const T1 &board = board)
{
    for (auto &&w : ::wins) {
        auto b = board[_get<0>(w)];
        if (in(b, u"XO"_S) && all_map(w, [&b, &board](const auto &i){return board[i] == b;}))
            return make_tuple(b, w.map([](const auto &i){return i + 1;}));
    }
    return nullptr;
}

auto finished()
{
    return all_map(::board, [](const auto &b){return in(b, u"XO"_S);});
}

template <typename T1 = decltype(board)> auto space(const T1 &board = board)
{
    return board.filter([](const auto &b){return !in(b, u"XO"_S);});
}

template <typename T1, typename T2> auto my_turn(const T1 &xo, T2 &board)
{
    auto options = space();
    auto choice = nonrandom_choice(options);
    board.set(to_int(choice) - 1, xo);
    return choice;
}

template <typename T1, typename T2> auto my_better_turn(const T1 &xo, T2 &board)
{
    u"Will return a next winning move or block your winning move if possible"_S;
    auto ox = xo == u'X' ? u'O'_C : u'X'_C;
    Nullable<int> oneblock;
    auto options = space(board).map([](const auto &s){return to_int(s) - 1;});
    int choice;
    for (auto &&chc : options) {
        auto brd = copy(board);
        brd.set(chc, xo);
        if (score(brd) != nullptr) {
            choice = chc;
            goto break_;
        }
        if (oneblock == nullptr) {
            brd.set(chc, ox);
            if (score(brd) != nullptr)
                oneblock = chc;
        }
    }
    choice = [&]{auto R = oneblock; return R != nullptr ? *R : nonrandom_choice(options);}();
    break_:;
    board.set(choice, xo);
    return choice + 1;
}

template <typename T1, typename T2> auto your_turn(const T1 &xo, T2 &board)
{
    auto options = space();
    while (true) {
        auto choice = input(u"\nPut your #. in any of these positions: #. "_S.format(xo, options.join(u""_S))).trim(make_tuple(u" "_S, u"\t"_S, u"\r"_S, u"\n"_S));
        if (in(choice, options)) {
            board.set(to_int(choice) - 1, xo);
            return choice;
        }
        print(u"Whoops I don't understand the input"_S);
    }
}

template <typename T1 = decltype(u'X'_C)> auto me(const T1 &xo = u'X'_C)
{
    printboard();
    print(u"\nI go at "_S & my_better_turn(xo, ::board));
    return score();
}

template <typename T1 = decltype(u'O'_C)> auto you(const T1 &xo = u'O'_C)
{
    printboard();
    print(u"\nYou went at "_S & my_turn(xo, ::board));
    return score();
}

struct CodeBlock1
{
    CodeBlock1()
    {
        while (!finished()) {
            Nullable<Tuple<Char, Array<int>>> s = me(u'X'_C);
            if (s != nullptr) {
                printboard();
                print(u"\n#. wins along #."_S.format(_get<0>(*s), _get<1>(*s)));
                goto break_1;
            }
            if (!finished()) {
                s = you(u'O'_C);
                if (s != nullptr) {
                    printboard();
                    print(u"\n#. wins along #."_S.format(_get<0>(*s), _get<1>(*s)));
                    goto break_1;
                }
            }
        }
        print(u"\nA draw"_S);
        break_1:;
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Unprimeable_numbers#Python
import itertools

limit = 10_000_000
is_prime = [False] * 2 + [True] * (limit - 1)
for n in range(int(limit**0.5 + 1.5)): # stop at ``sqrt(limit)``
    if is_prime[n]:
        for i in range(n*n, limit+1, n):
            is_prime[i] = False

def unprimeable(a):
    if is_prime[a]:
        return False

    d = 1
    while d <= a:
        base = (a//(d*10))*(d*10) + (a%d) # remove current digit
        if any(is_prime[y] for y in range(base, base + d*10, d)):
            return False
        d *= 10
    return True

def unprime(n):
    r : List[int] = []
    for a in itertools.count(1):
        if unprimeable(a):
            r += [a]
            if len(r) == n:
                break
    return r

print('First 35:')
print(' '.join(str(i) for i in unprime(35)))

print('\nThe 600-th:')
print(unprime(600)[-1])
print()

first = [0]*10
need = 10
for p in itertools.count(1):
    if unprimeable(p):
        i = p%10
        if first[i] != 0: continue

        first[i] = p
        need -= 1
        if need == 0:
            break

for i,v in enumerate(first):
    print(i, 'ending:', v)
===
V limit = 10'000'000
V is_prime = [0B] * 2 [+] [1B] * (limit - 1)
L(n) 0 .< Int(limit ^ 0.5 + 1.5)
   I is_prime[n]
      L(i) (n * n .< limit + 1).step(n)
         is_prime[i] = 0B

F unprimeable(a)
   I :is_prime[a]
      R 0B

   V d = 1
   L d <= a
      V base = (a I/ (d * 10)) * (d * 10) + (a % d)
      I any((base .< base + d * 10).step(d).map(y -> :is_prime[y]))
         R 0B
      d *= 10
   R 1B

F unprime(n)
   [Int] r
   L(a) 1..
      I unprimeable(a)
         r [+]= a
         I r.len == n
            L.break
   R r

print(‘First 35:’)
print(unprime(35).map(i -> String(i)).join(‘ ’))

print("\nThe 600-th:")
print(unprime(600).last)
print()

V first = [0] * 10
V need = 10
L(p) 1..
   I unprimeable(p)
      V i = p % 10
      I first[i] != 0
         L.continue

      first[i] = p
      I --need == 0
         L.break

L(v) first
   V i = L.index
   print(i‘ ending: ’v)
===
auto limit = 10'000'000;
auto is_prime = create_array({false}) * 2 + create_array({true}) * (limit - 1);

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto n : range_el(0, to_int(pow(limit, 0.5) + 1.5)))
            if (is_prime[n])
                for (auto i : range_el(n * n, limit + 1).step(n))
                    is_prime.set(i, false);
    }
} code_block_1;

template <typename T1> auto unprimeable(const T1 &a)
{
    if (::is_prime[a])
        return false;

    auto d = 1;
    while (d <= a) {
        auto base = (idiv(a, (d * 10))) * (d * 10) + (mod(a, d));
        if (any_map(range_el(base, base + d * 10).step(d), [](const auto &y){return ::is_prime[y];}))
            return false;
        d *= 10;
    }
    return true;
}

template <typename T1> auto unprime(const T1 &n)
{
    Array<int> r;
    for (auto a : range_ei(1))
        if (unprimeable(a)) {
            r.append(a);
            if (r.len() == n)
                break;
        }
    return r;
}

struct CodeBlock2
{
    CodeBlock2()
    {
        print(u"First 35:"_S);
        print(unprime(35).map([](const auto &i){return String(i);}).join(u" "_S));

        print(u"\nThe 600-th:"_S);
        print(unprime(600).last());
        print();
    }
} code_block_2;

auto first = create_array({0}) * 10;
auto need = 10;

struct CodeBlock3
{
    CodeBlock3()
    {
        for (auto p : range_ei(1))
            if (unprimeable(p)) {
                auto i = mod(p, 10);
                if (first[i] != 0)
                    continue;

                first.set(i, p);
                if (--need == 0)
                    break;
            }
        {int Lindex = 0;

        for (auto &&v : first) {
            auto i = Lindex;
            print(i & u" ending: "_S & v);
            Lindex++;
        }}
    }
} code_block_3;


# https://www.rosettacode.org/wiki/Vector#D
class Vector:
    x : float
    y : float

    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __add__(self, vector):
        return Vector(self.x + vector.x, self.y + vector.y)

    def __sub__(self, vector):
        return Vector(self.x - vector.x, self.y - vector.y)

    def __mul__(self, mult):
        return Vector(self.x * mult, self.y * mult)

    def __truediv__(self, denom):
        return Vector(self.x / denom, self.y / denom)

    def __str__(self):
        return '(%s, %s)' % (self.x, self.y)

print(Vector(5, 7) + Vector(2, 3))
print(Vector(5, 7) - Vector(2, 3))
print(Vector(5, 7) * 11)
print(Vector(5, 7) / 2)
===
T Vector
   Float x
   Float y

   F (x, y)
      .x = x
      .y = y

   F +(vector)
      R Vector(.x + vector.x, .y + vector.y)

   F -(vector)
      R Vector(.x - vector.x, .y - vector.y)

   F *(mult)
      R Vector(.x * mult, .y * mult)

   F /(denom)
      R Vector(.x / denom, .y / denom)

   F String()
      R ‘(#., #.)’.format(.x, .y)

print(Vector(5, 7) + Vector(2, 3))
print(Vector(5, 7) - Vector(2, 3))
print(Vector(5, 7) * 11)
print(Vector(5, 7) / 2)
===
class Vector
{
public:
    double x;
    double y;

    template <typename T1, typename T2> Vector(const T1 &x, const T2 &y) :
        x(x),
        y(y)
    {
    }

    template <typename T1> auto operator+(const T1 &vector) const
    {
        return Vector(x + vector.x, y + vector.y);
    }
    template <typename Ty> auto &operator+=(const Ty &t)
    {
        *this = *this + t;
        return *this;
    }

    template <typename T1> auto operator-(const T1 &vector) const
    {
        return Vector(x - vector.x, y - vector.y);
    }
    template <typename Ty> auto &operator-=(const Ty &t)
    {
        *this = *this - t;
        return *this;
    }

    template <typename T1> auto operator*(const T1 &mult) const
    {
        return Vector(x * mult, y * mult);
    }
    template <typename Ty> auto &operator*=(const Ty &t)
    {
        *this = *this * t;
        return *this;
    }

    template <typename T1> auto operator/(const T1 &denom) const
    {
        return Vector(x / denom, y / denom);
    }
    template <typename Ty> auto &operator/=(const Ty &t)
    {
        *this = *this / t;
        return *this;
    }

    operator String() const
    {
        return u"(#., #.)"_S.format(x, y);
    }
};

struct CodeBlock1
{
    CodeBlock1()
    {
        print(Vector(5, 7) + Vector(2, 3));
        print(Vector(5, 7) - Vector(2, 3));
        print(Vector(5, 7) * 11);
        print(Vector(5, 7) / 2.0);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Write_language_name_in_3D_ASCII
# Inspired by UNIX Shell solution
s = \
'''  XX
   X
   X
   X
   X
   X
 XXXXX'''

lines = s.split("\n")
width = max(len(l) for l in lines)

for i, line in enumerate(lines):
    print(' ' * (len(lines) - i - 1) + line.ljust(width).replace(' ', '   ').replace('X', '__/') * 3)
===
V s = ‘  XX
   X
   X
   X
   X
   X
 XXXXX’

V lines = s.split("\n")
V width = max(lines.map(l -> l.len))

L(line) lines
   V i = L.index
   print((‘ ’ * (lines.len - i - 1))‘’line.ljust(width).replace(‘ ’, ‘   ’).replace(‘X’, ‘__/’) * 3)
===
auto s = uR"(  XX
   X
   X
   X
   X
   X
 XXXXX)"_S;

auto lines = s.split(u"\n"_S);
auto width = max_map(lines, [](const auto &l){return l.len();});

struct CodeBlock1
{
    CodeBlock1()
    {
        {int Lindex = 0;

        for (auto &&line : lines) {
            auto i = Lindex;
            print((u" "_S * (lines.len() - i - 1)) & line.ljust(width).replace(u" "_S, u"   "_S).replace(u"X"_S, u"__/"_S) * 3);
            Lindex++;
        }}
    }
} code_block_1;


# https://www.rosettacode.org/wiki/100_prisoners#Python
import random

def play_random(n):
    # using 0-99 instead of ranges 1-100
    pardoned = 0
    in_drawer = list(range(100))
    sampler = list(range(100))
    for _round in range(n):
        random.shuffle(in_drawer)
        found = False
        for prisoner in range(100):
            found = False
            for reveal in random.sample(sampler, 50):
                card = in_drawer[reveal]
                if card == prisoner:
                    found = True
                    break
            if not found:
                break
        if found:
            pardoned += 1
    return float(pardoned) / n * 100   # %

def play_optimal(n):
    # using 0-99 instead of ranges 1-100
    pardoned = 0
    in_drawer = list(range(100))
    for _round in range(n):
        random.shuffle(in_drawer)
        found = False
        for prisoner in range(100):
            reveal = prisoner
            found = False
            for go in range(50):
                card = in_drawer[reveal]
                if card == prisoner:
                    found = True
                    break
                reveal = card
            if not found:
                break
        if found:
            pardoned += 1
    return float(pardoned) / n * 100   # %

n = 100_000
print(" Simulation count:", n)
print(" Random play wins: %4.1f%% of simulations" % play_random(n))
print("Optimal play wins: %4.1f%% of simulations" % play_optimal(n))
===
F play_random(n)
   V pardoned = 0
   V in_drawer = Array(0.<100)
   V sampler = Array(0.<100)
   L(_round) 0 .< n
      random:shuffle(&in_drawer)
      V found = 0B
      L(prisoner) 100
         found = 0B
         L(reveal) random:sample(sampler, 50)
            V card = in_drawer[reveal]
            I card == prisoner
               found = 1B
               L.break
         I !found
            L.break
      I found
         pardoned++
   R Float(pardoned) / n * 100

F play_optimal(n)
   V pardoned = 0
   V in_drawer = Array(0.<100)
   L(_round) 0 .< n
      random:shuffle(&in_drawer)
      V found = 0B
      L(prisoner) 100
         V reveal = prisoner
         found = 0B
         L(go) 50
            V card = in_drawer[reveal]
            I card == prisoner
               found = 1B
               L.break
            reveal = card
         I !found
            L.break
      I found
         pardoned++
   R Float(pardoned) / n * 100

V n = 100'000
print(‘ Simulation count: ’n)
print(‘ Random play wins: #2.1% of simulations’.format(play_random(n)))
print(‘Optimal play wins: #2.1% of simulations’.format(play_optimal(n)))
===
template <typename T1> auto play_random(const T1 &n)
{
    auto pardoned = 0;
    auto in_drawer = create_array(range_el(0, 100));
    auto sampler = create_array(range_el(0, 100));
    for (auto _round : range_el(0, n)) {
        randomns::shuffle(in_drawer);
        auto found = false;
        for (int prisoner = 0; prisoner < 100; prisoner++) {
            found = false;
            for (auto &&reveal : randomns::sample(sampler, 50)) {
                auto card = in_drawer[reveal];
                if (card == prisoner) {
                    found = true;
                    break;
                }
            }
            if (!found)
                break;
        }
        if (found)
            pardoned++;
    }
    return to_float(pardoned) / n * 100;
}

template <typename T1> auto play_optimal(const T1 &n)
{
    auto pardoned = 0;
    auto in_drawer = create_array(range_el(0, 100));
    for (auto _round : range_el(0, n)) {
        randomns::shuffle(in_drawer);
        auto found = false;
        for (int prisoner = 0; prisoner < 100; prisoner++) {
            auto reveal = prisoner;
            found = false;
            for (int go = 0; go < 50; go++) {
                auto card = in_drawer[reveal];
                if (card == prisoner) {
                    found = true;
                    break;
                }
                reveal = card;
            }
            if (!found)
                break;
        }
        if (found)
            pardoned++;
    }
    return to_float(pardoned) / n * 100;
}

auto n = 100'000;

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u" Simulation count: "_S & n);
        print(u" Random play wins: #2.1% of simulations"_S.format(play_random(n)));
        print(u"Optimal play wins: #2.1% of simulations"_S.format(play_optimal(n)));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Almkvist-Giullera_formula_for_pi#C.23
BigInt = int

def isqrt(x : BigInt):
    q : BigInt = 1
    r : BigInt = 0
    t : BigInt
    while q <= x:
        q *= 4
    while q > 1:
        q //= 4
        t = x - r - q
        r //= 2
        if t >= 0:
            x = t
            r += q
    return r

def dump(digs, show):
    gb = 1
    digs += 1
    dg = digs + gb
    t1 : BigInt = 1
    t2 : BigInt = 9
    t3 : BigInt = 1
    te : BigInt
    su : BigInt = 0
    t = BigInt(10) ** (0 if dg <= 60 else dg - 60)
    d : BigInt = -1
    fn : BigInt = 1

    n = 0
    while n < dg:
        if n > 0:
            t3 *= BigInt(n) ** 6
        te = t1 * t2 // t3
        z = dg - 1 - n * 6
        if z > 0:
            te *= BigInt(10) ** z
        else:
            te //= BigInt(10) ** -z
        if show and n < 10:
            print("{:2} {:62}".format(n, te * 32 // 3 // t))
        su += te

        if te < 10:
            if show:
                digs -= 1
                print("\n{0} iterations required for {1} digits after the decimal point.\n".format(n, digs))
            break

        for j in range(n * 6 + 1, n * 6 + 6 + 1):
            t1 *= j
        d += 2
        t2 += 126 + 532 * d

        n += 1

    s = str(isqrt(BigInt(10) ** (dg * 2 + 3) // su // 32 * 3 * BigInt(10) ** (dg + 5)))
    return s[0] + "." + s[1:1+digs]

print(dump(70, True))
===
F isqrt(BigInt =x)
   BigInt q = 1
   BigInt r = 0
   BigInt t
   L q <= x
      q *= 4
   L q > 1
      q I/= 4
      t = x - r - q
      r I/= 2
      I t >= 0
         x = t
         r += q
   R r

F dump(=digs, show)
   V gb = 1
   digs++
   V dg = digs + gb
   BigInt t1 = 1
   BigInt t2 = 9
   BigInt t3 = 1
   BigInt te
   BigInt su = 0
   V t = BigInt(10) ^ (I dg <= 60 {0} E dg - 60)
   BigInt d = -1
   BigInt _fn_ = 1

   V n = 0
   L n < dg
      I n > 0
         t3 *= BigInt(n) ^ 6
      te = t1 * t2 I/ t3
      V z = dg - 1 - n * 6
      I z > 0
         te *= BigInt(10) ^ z
      E
         te I/= BigInt(10) ^ -z
      I show & n < 10
         print(‘#2 #62’.format(n, te * 32 I/ 3 I/ t))
      su += te

      I te < 10
         I show
            digs--
            print("\n#. iterations required for #. digits after the decimal point.\n".format(n, digs))
         L.break

      L(j) n * 6 + 1 .. n * 6 + 6
         t1 *= j
      d += 2
      t2 += 126 + 532 * d

      n++

   V s = String(isqrt(BigInt(10) ^ (dg * 2 + 3) I/ su I/ 32 * 3 * BigInt(10) ^ (dg + 5)))
   R s[0]‘.’s[1 .< 1 + digs]

print(dump(70, 1B))
===
auto isqrt(BigInt x)
{
    BigInt q = 1;
    BigInt r = 0;
    BigInt t;
    while (q <= x)
        q *= 4;
    while (q > 1) {
        q = idiv(q, 4);
        t = x - r - q;
        r = idiv(r, 2);
        if (t >= 0) {
            x = t;
            r += q;
        }
    }
    return r;
}

template <typename T1, typename T2> auto dump(T1 digs, const T2 &show)
{
    auto gb = 1;
    digs++;
    auto dg = digs + gb;
    BigInt t1 = 1;
    BigInt t2 = 9;
    BigInt t3 = 1;
    BigInt te;
    BigInt su = 0;
    auto t = pow(BigInt(10), (dg <= 60 ? 0 : dg - 60));
    BigInt d = -1;
    BigInt _fn_ = 1;

    auto n = 0;
    while (n < dg) {
        if (n > 0)
            t3 *= pow(BigInt(n), 6);
        te = idiv(t1 * t2, t3);
        auto z = dg - 1 - n * 6;
        if (z > 0)
            te *= pow(BigInt(10), z);
        else
            te = idiv(te, pow(BigInt(10), -z));
        if (show && n < 10)
            print(u"#2 #62"_S.format(n, idiv(idiv(te * 32, 3), t)));
        su += te;

        if (te < 10) {
            if (show) {
                digs--;
                print(u"\n#. iterations required for #. digits after the decimal point.\n"_S.format(n, digs));
            }
            break;
        }

        for (auto j : range_ee(n * 6 + 1, n * 6 + 6))
            t1 *= j;
        d += 2;
        t2 += 126 + 532 * d;

        n++;
    }

    auto s = String(isqrt(idiv(idiv(pow(BigInt(10), (dg * 2 + 3)), su), 32) * 3 * pow(BigInt(10), (dg + 5))));
    return _get<0>(s) & u"."_S & s[range_el(1, 1 + digs)];
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(dump(70, true));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Alternade_words#Nim
from typing import List

def alternating_words(word):
    r = ['', '']
    for i, c in enumerate(word):
        r[i & 1] += str(c)
    return r

words = set(open('unixdict.txt').read().split("\n"))

result : List[str] = []
for word in words:
    if len(word) >= 6:
        alt_words = alternating_words(word)
        if alt_words[0] in words and alt_words[1] in words:
            result.append(word.rjust(8) + ' → ' + alt_words[0] + ' ' + alt_words[1])
result.sort()
for i, line in enumerate(result):
    print('%2d:' % (i + 1), line)
===
F alternating_words(word)
   V r = [‘’, ‘’]
   L(c) word
      V i = L.index
      r[i [&] 1] ‘’= String(c)
   R r

V words = Set(File(‘unixdict.txt’).read().split("\n"))

[String] result
L(word) words
   I word.len >= 6
      V alt_words = alternating_words(word)
      I alt_words[0] C words & alt_words[1] C words
         result.append(word.rjust(8)‘ → ’alt_words[0]‘ ’alt_words[1])
result.sort()
L(line) result
   V i = L.index
   print((‘#2:’.format(i + 1))‘ ’line)
===
template <typename T1> auto alternating_words(const T1 &word)
{
    auto r = create_array({u""_S, u""_S});
    {int Lindex = 0;
    for (auto &&c : word) {
        auto i = Lindex;
        r[i & 1] &= String(c);
        Lindex++;
    }}
    return r;
}

auto words = create_set(File(u"unixdict.txt"_S).read().split(u"\n"_S));

Array<String> result;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&word : words)
            if (word.len() >= 6) {
                auto alt_words = alternating_words(word);
                if (in(_get<0>(alt_words), words) && in(_get<1>(alt_words), words))
                    result.append(word.rjust(8) & u" → "_S & _get<0>(alt_words) & u" "_S & _get<1>(alt_words));
            }
        result.sort();
        {int Lindex = 0;
        for (auto &&line : result) {
            auto i = Lindex;
            print((u"#2:"_S.format(i + 1)) & u" "_S & line);
            Lindex++;
        }}
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Base58Check_encoding#Python
BigInt = int

ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"

def convertToBase58(num):
    sb = ''
    while (num > 0):
        r = int(num % 58)
        sb = sb + ALPHABET[r]
        num = num // 58;
    return sb[::-1]

s = BigInt('25420294593250030202636073700053352635053786165627414518')
b = convertToBase58(s)
print("%s -> %s" % (s, b))

hash_arr = ['61', '626262', '636363', '73696d706c792061206c6f6e6720737472696e67', '516b6fcd0f', 'bf4f89001e670274dd', '572e4794', 'ecac89cad93923c02321', '10c8511e']
for num in hash_arr:
    b = convertToBase58(BigInt(num, base = 16))
    print("0x%-54s -> %s" % (num, b))
===
V ALPHABET = ‘123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz’

F convertToBase58(=num)
   V sb = ‘’
   L (num > 0)
      V r = Int(num % 58)
      sb = sb‘’:ALPHABET[r]
      num = num I/ 58
   R reversed(sb)

V s = BigInt(‘25420294593250030202636073700053352635053786165627414518’)
V b = convertToBase58(s)
print(‘#. -> #.’.format(s, b))

V hash_arr = [‘61’, ‘626262’, ‘636363’, ‘73696d706c792061206c6f6e6720737472696e67’, ‘516b6fcd0f’, ‘bf4f89001e670274dd’, ‘572e4794’, ‘ecac89cad93923c02321’, ‘10c8511e’]
L(num) hash_arr
   b = convertToBase58(BigInt(num, radix' 16))
   print(‘0x#<54 -> #.’.format(num, b))
===
auto ALPHABET = u"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"_S;

template <typename T1> auto convertToBase58(T1 num)
{
    auto sb = u""_S;
    while ((num > 0)) {
        auto r = to_int(mod(num, 58));
        sb = sb & ::ALPHABET[r];
        num = idiv(num, 58);
    }
    return reversed(sb);
}

auto s = BigInt(u"25420294593250030202636073700053352635053786165627414518"_S);
auto b = convertToBase58(s);

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"#. -> #."_S.format(s, b));
    }
} code_block_1;

auto hash_arr = create_array({u"61"_S, u"626262"_S, u"636363"_S, u"73696d706c792061206c6f6e6720737472696e67"_S, u"516b6fcd0f"_S, u"bf4f89001e670274dd"_S, u"572e4794"_S, u"ecac89cad93923c02321"_S, u"10c8511e"_S});

struct CodeBlock2
{
    CodeBlock2()
    {
        for (auto &&num : hash_arr) {
            b = convertToBase58(BigInt(num, 16));
            print(u"0x#<54 -> #."_S.format(num, b));
        }
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Bell_numbers#Python
BigInt = int

def bellTriangle(n):
    tri : List[List[BigInt]] = []
    for i in range(n):
        tri.append([BigInt(0)] * i    )
    tri[1][0] = 1
    for i in range(2, n):
        tri[i][0] = tri[i - 1][i - 2]
        for j in range(1, i):
            tri[i][j] = tri[i][j - 1] + tri[i - 1][j - 1]
    return tri

bt = bellTriangle(51)
print("First fifteen and fiftieth Bell numbers:")
for i in range(1, 16):
    print("%2d: %d" % (i, bt[i][0]))
print("50:", bt[50][0])
print()
print("The first ten rows of Bell's triangle:")
for i in range(1, 11):
    print(bt[i])
===
F bellTriangle(n)
   [[BigInt]] tri
   L(i) 0 .< n
      tri.append([BigInt(0)] * i)
   tri[1][0] = 1
   L(i) 2 .< n
      tri[i][0] = tri[i - 1][i - 2]
      L(j) 1 .< i
         tri[i][j] = tri[i][j - 1] + tri[i - 1][j - 1]
   R tri

V bt = bellTriangle(51)
print(‘First fifteen and fiftieth Bell numbers:’)
L(i) 1..15
   print(‘#2: #.’.format(i, bt[i][0]))
print(‘50: ’bt[50][0])
print()
print(‘The first ten rows of Bell's triangle:’)
L(i) 1..10
   print(bt[i])
===
template <typename T1> auto bellTriangle(const T1 &n)
{
    Array<Array<BigInt>> tri;
    for (auto i : range_el(0, n))
        tri.append(create_array({BigInt(0)}) * i);
    _set<0>(_get<1>(tri), 1);
    for (auto i : range_el(2, n)) {
        _set<0>(tri[i], tri[i - 1][i - 2]);
        for (auto j : range_el(1, i))
            tri[i].set(j, tri[i][j - 1] + tri[i - 1][j - 1]);
    }
    return tri;
}

auto bt = bellTriangle(51);

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"First fifteen and fiftieth Bell numbers:"_S);
        for (auto i : range_ee(1, 15))
            print(u"#2: #."_S.format(i, _get<0>(bt[i])));
        print(u"50: "_S & _get<0>(_get<50>(bt)));
        print();
        print(u"The first ten rows of Bell's triangle:"_S);
        for (auto i : range_ee(1, 10))
            print(bt[i]);
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Bin_given_limits#Python
def bisect_right(a, x):
    lo = 0
    hi = len(a)
    while lo < hi:
        mid = (lo+hi)//2
        if x < a[mid]: hi = mid
        else: lo = mid+1
    return lo

def bin_it(limits, data):
    "Bin data according to (ascending) limits."
    bins = [0] * (len(limits) + 1)      # adds under/over range bins too
    for d in data:
        bins[bisect_right(limits, d)] += 1
    return bins

def bin_print(limits, bins):
    print("          < {:3} := {:3}".format(limits[0], bins[0]))
    for lo, hi, count in zip(limits, limits[1:], bins[1:]):
        print(">= {:3} .. < {:3} := {:3}".format(lo, hi, count))
    print(">= {:3}          := {:3}".format(limits[-1], bins[-1]))

print("RC FIRST EXAMPLE\n")
limits  = [23, 37, 43, 53, 67, 83]
data = [95,21,94,12,99,4,70,75,83,93,52,80,57,5,53,86,65,17,92,83,71,61,54,58,47,
        16, 8, 9,32,84,7,87,46,19,30,37,96,6,98,40,79,97,45,64,60,29,49,36,43,55]
bins = bin_it(limits, data)
bin_print(limits, bins)

print("\nRC SECOND EXAMPLE\n")
limits = [14, 18, 249, 312, 389, 392, 513, 591, 634, 720]
data = [445,814,519,697,700,130,255,889,481,122,932, 77,323,525,570,219,367,523,442,933,
        416,589,930,373,202,253,775, 47,731,685,293,126,133,450,545,100,741,583,763,306,
        655,267,248,477,549,238, 62,678, 98,534,622,907,406,714,184,391,913, 42,560,247,
        346,860, 56,138,546, 38,985,948, 58,213,799,319,390,634,458,945,733,507,916,123,
        345,110,720,917,313,845,426,  9,457,628,410,723,354,895,881,953,677,137,397, 97,
        854,740, 83,216,421, 94,517,479,292,963,376,981,480, 39,257,272,157,  5,316,395,
        787,942,456,242,759,898,576, 67,298,425,894,435,831,241,989,614,987,770,384,692,
        698,765,331,487,251,600,879,342,982,527,736,795,585, 40, 54,901,408,359,577,237,
        605,847,353,968,832,205,838,427,876,959,686,646,835,127,621,892,443,198,988,791,
        466, 23,707,467, 33,670,921,180,991,396,160,436,717,918,  8,374,101,684,727,749]
bins = bin_it(limits, data)
bin_print(limits, bins)
===
F bisect_right(a, x)
   V lo = 0
   V hi = a.len
   L lo < hi
      V mid = (lo + hi) I/ 2
      I x < a[mid]
         hi = mid
      E
         lo = mid + 1
   R lo

F bin_it(limits, data)
   ‘Bin data according to (ascending) limits.’
   V bins = [0] * (limits.len + 1)
   L(d) data
      bins[bisect_right(limits, d)]++
   R bins

F bin_print(limits, bins)
   print(‘          < #3 := #3’.format(limits[0], bins[0]))
   L(lo, hi, count) zip(limits, limits[1..], bins[1..])
      print(‘>= #3 .. < #3 := #3’.format(lo, hi, count))
   print(‘>= #3          := #3’.format(limits.last, bins.last))

print("RC FIRST EXAMPLE\n")
V limits = [23, 37, 43, 53, 67, 83]
V data = [95, 21, 94, 12, 99, 4, 70, 75, 83, 93, 52, 80, 57, 5, 53, 86, 65, 17, 92, 83, 71, 61, 54, 58, 47, 16, 8, 9, 32, 84, 7, 87, 46, 19, 30, 37, 96, 6, 98, 40, 79, 97, 45, 64, 60, 29, 49, 36, 43, 55]
V bins = bin_it(limits, data)
bin_print(limits, bins)

print("\nRC SECOND EXAMPLE\n")
limits = [14, 18, 249, 312, 389, 392, 513, 591, 634, 720]
data = [445, 814, 519, 697, 700, 130, 255, 889, 481, 122, 932, 77, 323, 525, 570, 219, 367, 523, 442, 933, 416, 589, 930, 373, 202, 253, 775, 47, 731, 685, 293, 126, 133, 450, 545, 100, 741, 583, 763, 306, 655, 267, 248, 477, 549, 238, 62, 678, 98, 534, 622, 907, 406, 714, 184, 391, 913, 42, 560, 247, 346, 860, 56, 138, 546, 38, 985, 948, 58, 213, 799, 319, 390, 634, 458, 945, 733, 507, 916, 123, 345, 110, 720, 917, 313, 845, 426, 9, 457, 628, 410, 723, 354, 895, 881, 953, 677, 137, 397, 97, 854, 740, 83, 216, 421, 94, 517, 479, 292, 963, 376, 981, 480, 39, 257, 272, 157, 5, 316, 395, 787, 942, 456, 242, 759, 898, 576, 67, 298, 425, 894, 435, 831, 241, 989, 614, 987, 770, 384, 692, 698, 765, 331, 487, 251, 600, 879, 342, 982, 527, 736, 795, 585, 40, 54, 901, 408, 359, 577, 237, 605, 847, 353, 968, 832, 205, 838, 427, 876, 959, 686, 646, 835, 127, 621, 892, 443, 198, 988, 791, 466, 23, 707, 467, 33, 670, 921, 180, 991, 396, 160, 436, 717, 918, 8, 374, 101, 684, 727, 749]
bins = bin_it(limits, data)
bin_print(limits, bins)
===
template <typename T1, typename T2> auto bisect_right(const T1 &a, const T2 &x)
{
    auto lo = 0;
    auto hi = a.len();
    while (lo < hi) {
        auto mid = idiv((lo + hi), 2);
        if (x < a[mid])
            hi = mid;
        else
            lo = mid + 1;
    }
    return lo;
}

template <typename T1, typename T2> auto bin_it(const T1 &limits, const T2 &data)
{
    u"Bin data according to (ascending) limits."_S;
    auto bins = create_array({0}) * (limits.len() + 1);
    for (auto &&d : data)
        bins[bisect_right(limits, d)]++;
    return bins;
}

template <typename T1, typename T2> auto bin_print(const T1 &limits, const T2 &bins)
{
    print(u"          < #3 := #3"_S.format(_get<0>(limits), _get<0>(bins)));
    for (auto &&[lo, hi, count] : zip(limits, limits[range_ei(1)], bins[range_ei(1)]))
        print(u">= #3 .. < #3 := #3"_S.format(lo, hi, count));
    print(u">= #3          := #3"_S.format(limits.last(), bins.last()));
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"RC FIRST EXAMPLE\n"_S);
    }
} code_block_1;

auto limits = create_array({23, 37, 43, 53, 67, 83});
auto data = create_array({95, 21, 94, 12, 99, 4, 70, 75, 83, 93, 52, 80, 57, 5, 53, 86, 65, 17, 92, 83, 71, 61, 54, 58, 47, 16, 8, 9, 32, 84, 7, 87, 46, 19, 30, 37, 96, 6, 98, 40, 79, 97, 45, 64, 60, 29, 49, 36, 43, 55});
auto bins = bin_it(limits, data);

struct CodeBlock2
{
    CodeBlock2()
    {
        bin_print(limits, bins);

        print(u"\nRC SECOND EXAMPLE\n"_S);
        limits = create_array({14, 18, 249, 312, 389, 392, 513, 591, 634, 720});
        data = create_array({445, 814, 519, 697, 700, 130, 255, 889, 481, 122, 932, 77, 323, 525, 570, 219, 367, 523, 442, 933, 416, 589, 930, 373, 202, 253, 775, 47, 731, 685, 293, 126, 133, 450, 545, 100, 741, 583, 763, 306, 655, 267, 248, 477, 549, 238, 62, 678, 98, 534, 622, 907, 406, 714, 184, 391, 913, 42, 560, 247, 346, 860, 56, 138, 546, 38, 985, 948, 58, 213, 799, 319, 390, 634, 458, 945, 733, 507, 916, 123, 345, 110, 720, 917, 313, 845, 426, 9, 457, 628, 410, 723, 354, 895, 881, 953, 677, 137, 397, 97, 854, 740, 83, 216, 421, 94, 517, 479, 292, 963, 376, 981, 480, 39, 257, 272, 157, 5, 316, 395, 787, 942, 456, 242, 759, 898, 576, 67, 298, 425, 894, 435, 831, 241, 989, 614, 987, 770, 384, 692, 698, 765, 331, 487, 251, 600, 879, 342, 982, 527, 736, 795, 585, 40, 54, 901, 408, 359, 577, 237, 605, 847, 353, 968, 832, 205, 838, 427, 876, 959, 686, 646, 835, 127, 621, 892, 443, 198, 988, 791, 466, 23, 707, 467, 33, 670, 921, 180, 991, 396, 160, 436, 717, 918, 8, 374, 101, 684, 727, 749});
        bins = bin_it(limits, data);
        bin_print(limits, bins);
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Binary_strings#Python
x = b'abc'
print(x[0])
===
V x = Bytes(‘abc’)
print(x[0])
===
auto x = "abc"_B;

struct CodeBlock1
{
    CodeBlock1()
    {
        print(_get<0>(x));
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Bioinformatics/base_count#Python
import collections

def basecount(dna):
    d = collections.defaultdict(int) # Char
    for c in dna:
        d[c] += 1
    return sorted(d.items())

def seq_split(dna, n=50):
    return [dna[i: i+n] for i in range(0, len(dna), n)]

def seq_pp(dna, n=50):
    for i, part in enumerate(seq_split(dna, n)):
        print("{:>5}: {}".format(i*n, part))
    print("\n  BASECOUNT:")
    tot = 0
    for base, count in basecount(dna):
        print("    {:>3}: {}".format(base, count))
        tot += count
    (base, count) = ('TOT', tot)
    print("    {:>3}= {}".format(base, count))

print("SEQUENCE:")
sequence = '''\
CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATG\
CTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTG\
AGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGAT\
GGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT\
CGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGG\
TCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA\
TTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTAT\
CGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTG\
TCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGAC\
GACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT'''
seq_pp(sequence)
===
F basecount(dna)
   V d = DefaultDict[Char, Int]()
   L(c) dna
      d[c]++
   R sorted(d.items())

F seq_split(dna, n = 50)
   R (0 .< dna.len).step(n).map(i -> @dna[i .< i + @n])

F seq_pp(dna, n = 50)
   L(part) seq_split(dna, n)
      V i = L.index
      print(‘#5: #.’.format(i * n, part))
   print("\n  BASECOUNT:")
   V tot = 0
   L(base, count) basecount(dna)
      print(‘    #3: #.’.format(base, count))
      tot += count
   V (base, count) = (‘TOT’, tot)
   print(‘    #3= #.’.format(base, count))

print(‘SEQUENCE:’)
V sequence = "\
CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATG\
CTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTG\
AGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGAT\
GGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT\
CGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGG\
TCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA\
TTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTAT\
CGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTG\
TCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGAC\
GACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT"
seq_pp(sequence)
===
template <typename T1> auto basecount(const T1 &dna)
{
    auto d = DefaultDict<Char, int>();
    for (auto &&c : dna)
        d[c]++;
    return sorted(d.items());
}

template <typename T1, typename T2 = decltype(50)> auto seq_split(const T1 &dna, const T2 &n = 50)
{
    return range_el(0, dna.len()).step(n).map([&dna, &n](const auto &i){return dna[range_el(i, i + n)];});
}

template <typename T1, typename T2 = decltype(50)> auto seq_pp(const T1 &dna, const T2 &n = 50)
{
    {int Lindex = 0;
    for (auto &&part : seq_split(dna, n)) {
        auto i = Lindex;
        print(u"#5: #."_S.format(i * n, part));
        Lindex++;
    }}
    print(u"\n  BASECOUNT:"_S);
    auto tot = 0;
    for (auto &&[base, count] : basecount(dna)) {
        print(u"    #3: #."_S.format(base, count));
        tot += count;
    }
    auto [base, count] = make_tuple(u"TOT"_S, tot);
    print(u"    #3= #."_S.format(base, count));
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"SEQUENCE:"_S);
    }
} code_block_1;

auto sequence = u"\
CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATG\
CTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTG\
AGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGAT\
GGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT\
CGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGG\
TCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA\
TTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTAT\
CGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTG\
TCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGAC\
GACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT"_S;

struct CodeBlock2
{
    CodeBlock2()
    {
        seq_pp(sequence);
    }
} code_block_2;


# https://www.rosettacode.org/wiki/Bitmap/Python#Alternative_version
from copy import copy
from typing import NamedTuple, List

Byte = int
class Colour(NamedTuple):
    r : Byte
    g : Byte
    b : Byte

    def __eq__(self, other):
        return self.r == other.r and self.g == other.g and self.b == other.b

black = Colour(0,0,0)
white = Colour(255,255,255) # Colour ranges are not enforced.

class Bitmap:
    width : int
    height : int
    background : Colour
    map : List[List[Colour]]

    def __init__(self, width = 40, height = 40, background=white):
        assert width > 0 and height > 0# and type(background) == Colour
        self.width = width
        self.height = height
        self.background = background
        self.map = [[copy(background) for w in range(width)] for h in range(height)]

    def fillrect(self, x, y, width, height, colour=black):
        assert x >= 0 and y >= 0 and width > 0 and height > 0# and type(colour) == Colour
        for h in range(height):
            for w in range(width):
                self.map[y+h][x+w] = copy(colour)

    def chardisplay(self):
        txt = [''.join((' ' if bit==self.background else '@')
                       for bit in row)
               for row in self.map]
        # Boxing
        txt = ['|'+row+'|' for row in txt]
        txt.insert(0, '+' + '-' * self.width + '+')
        txt.append('+' + '-' * self.width + '+')
        print('\n'.join(reversed(txt)))

    def set(self, x, y, colour=black):
        #assert type(colour) == Colour
        self.map[y][x]=colour

    def get(self, x, y):
        return self.map[y][x]

bitmap = Bitmap(20,10)
bitmap.fillrect(4, 5, 6, 3)
assert bitmap.get(5, 5) == black
assert bitmap.get(0, 1) == white
bitmap.set(0, 1, black)
assert bitmap.get(0, 1) == black
bitmap.chardisplay()
===
T Colour
   Byte r
   Byte g
   Byte b

   F ==(other)
      R .r == other.r & .g == other.g & .b == other.b
   F (r, g, b)
      .r = r
      .g = g
      .b = b

V black = Colour(0, 0, 0)
V white = Colour(255, 255, 255)

T Bitmap
   Int width
   Int height
   Colour background
   [[Colour]] map

   F (width = 40, height = 40, background = white)
      assert(width > 0 & height > 0)
      .width = width
      .height = height
      .background = background
      .map = (0 .< height).map(h -> (0 .< @width).map(w -> copy(@@background)))

   F fillrect(x, y, width, height, colour = black)
      assert(x >= 0 & y >= 0 & width > 0 & height > 0)
      L(h) 0 .< height
         L(w) 0 .< width
            .map[y + h][x + w] = copy(colour)

   F chardisplay()
      V txt = .map.map(row -> row.map(bit -> (I bit == @@.background {‘ ’} E ‘@’)).join(‘’))
      txt = txt.map(row -> ‘|’row‘|’)
      txt.insert(0, ‘+’(‘-’ * .width)‘+’)
      txt.append(‘+’(‘-’ * .width)‘+’)
      print(reversed(txt).join("\n"))

   F set(x, y, colour = black)
      .map[y][x] = colour

   F get(x, y)
      R .map[y][x]

V bitmap = Bitmap(20, 10)
bitmap.fillrect(4, 5, 6, 3)
assert(bitmap.get(5, 5) == black)
assert(bitmap.get(0, 1) == white)
bitmap.set(0, 1, black)
assert(bitmap.get(0, 1) == black)
bitmap.chardisplay()
===
class Colour
{
public:
    Byte r;
    Byte g;
    Byte b;

    template <typename T1> auto operator==(const T1 &other) const
    {
        return r == other.r && g == other.g && b == other.b;
    }
    template <typename T1, typename T2, typename T3> Colour(const T1 &r, const T2 &g, const T3 &b) :
        r(r),
        g(g),
        b(b)
    {
    }
};

auto black = Colour(0, 0, 0);
auto white = Colour(255, 255, 255);

class Bitmap
{
public:
    int width;
    int height;
    Colour background;
    Array<Array<Colour>> map;

    template <typename T1 = decltype(40), typename T2 = decltype(40), typename T3 = decltype(white)> Bitmap(const T1 &width = 40, const T2 &height = 40, const T3 &background = white) :
        width(width),
        height(height),
        background(background)
    {
        assert(width > 0 && height > 0);
        map = range_el(0, height).map([&background, &width](const auto &h){return range_el(0, width).map([&background](const auto &w){return copy(background);});});
    }

    template <typename T1, typename T2, typename T3, typename T4, typename T5 = decltype(black)> auto fillrect(const T1 &x, const T2 &y, const T3 &width, const T4 &height, const T5 &colour = black)
    {
        assert(x >= 0 && y >= 0 && width > 0 && height > 0);
        for (auto h : range_el(0, height))
            for (auto w : range_el(0, width))
                map[y + h].set(x + w, copy(colour));
    }

    auto chardisplay()
    {
        auto txt = map.map([this](const auto &row){return row.map([this](const auto &bit){return (bit == background ? u" "_S : u"@"_S);}).join(u""_S);});
        txt = txt.map([](const auto &row){return u"|"_S & row & u"|"_S;});
        txt.insert(0, u"+"_S & (u"-"_S * width) & u"+"_S);
        txt.append(u"+"_S & (u"-"_S * width) & u"+"_S);
        print(reversed(txt).join(u"\n"_S));
    }

    template <typename T1, typename T2, typename T3 = decltype(black)> auto set(const T1 &x, const T2 &y, const T3 &colour = black)
    {
        map[y].set(x, colour);
    }

    template <typename T1, typename T2> auto get(const T1 &x, const T2 &y)
    {
        return map[y][x];
    }
};

auto bitmap = Bitmap(20, 10);

struct CodeBlock1
{
    CodeBlock1()
    {
        bitmap.fillrect(4, 5, 6, 3);
        assert(bitmap.get(5, 5) == black);
        assert(bitmap.get(0, 1) == white);
        bitmap.set(0, 1, black);
        assert(bitmap.get(0, 1) == black);
        bitmap.chardisplay();
    }
} code_block_1;


# https://www.rosettacode.org/wiki/Bitwise_IO#Python
from typing import BinaryIO, List
Byte = int
Char = str

class BitWriter:
    out : BinaryIO

    def __init__(self, fname):
        self.accumulator = 0
        self.bcount = 0
        self.out = open(fname, 'wb')

    def _writebit(self, bit):
        if self.bcount == 8:
            self.flush()
        if bit > 0:
            self.accumulator |= 1 << (7-self.bcount)
        self.bcount += 1

    def writebits(self, bits, n):
        while n > 0:
            self._writebit(bits & 1 << (n-1))
            n -= 1

    def flush(self):
        self.out.write(bytes([Byte(self.accumulator)]))
        self.accumulator = 0
        self.bcount = 0

    def close(self):
        self.flush()
        self.out.close()

class BitReader:
    input : BinaryIO

    def __init__(self, fname):
        self.input = open(fname, 'rb')
        self.accumulator = 0
        self.bcount = 0
        self.read = 0

    def _readbit(self):
        if self.bcount == 0:
            a = self.input.read(1)
            if len(a):
                self.accumulator = a[0]
            self.bcount = 8
            self.read = len(a)
        rv = (self.accumulator & (1 << (self.bcount-1))) >> (self.bcount-1)
        self.bcount -= 1
        return rv

    def readbits(self, n):
        v = 0
        while n > 0:
            v = (v << 1) | self._readbit()
            n -= 1
        return v

writer = BitWriter('bitio_test.dat')
chars = '12345abcde'
for ch in chars:
    writer.writebits(ord(ch), 7)
writer.close()

reader = BitReader('bitio_test.dat')
charsa : List[Char] = []
while True:
    x = reader.readbits(7)
    if reader.read == 0:  # End-of-file?
        break
    charsa.append(chr(x))
print(''.join(charsa))
===
T BitWriter
   File out
   accumulator = 0
   bcount = 0

   F (fname)
      .out = File(fname, ‘w’)

   F _writebit(bit)
      I .bcount == 8
         .flush()
      I bit > 0
         .accumulator [|]= 1 << (7 - .bcount)
      .bcount++

   F writebits(bits, =n)
      L n > 0
         ._writebit(bits [&] 1 << (n - 1))
         n--

   F flush()
      .out.write_bytes([Byte(.accumulator)])
      .accumulator = 0
      .bcount = 0

   F close()
      .flush()
      .out.close()

T BitReader
   File input
   accumulator = 0
   bcount = 0
   read = 0

   F (fname)
      .input = File(fname, ‘r’)

   F _readbit()
      I .bcount == 0
         V a = .input.read_bytes(1)
         I !a.empty
            .accumulator = a[0]
         .bcount = 8
         .read = a.len
      V rv = (.accumulator [&] (1 << (.bcount - 1))) >> (.bcount - 1)
      .bcount--
      R rv

   F readbits(=n)
      V v = 0
      L n > 0
         v = (v << 1) [|] ._readbit()
         n--
      R v

V writer = BitWriter(‘bitio_test.dat’)
V chars = ‘12345abcde’
L(ch) chars
   writer.writebits(ch.code, 7)
writer.close()

V reader = BitReader(‘bitio_test.dat’)
[Char] charsa
L
   V x = reader.readbits(7)
   I reader.read == 0
      L.break
   charsa.append(Char(code' x))
print(charsa.join(‘’))
===
class BitWriter
{
public:
    File out;
    decltype(0) accumulator = 0;
    decltype(0) bcount = 0;

    template <typename T1> BitWriter(const T1 &fname)
    {
        out = File(fname, u"w"_S);
    }

    template <typename T1> auto _writebit(const T1 &bit)
    {
        if (bcount == 8)
            flush();
        if (bit > 0)
            accumulator |= 1 << (7 - bcount);
        bcount++;
    }

    template <typename T1, typename T2> auto writebits(const T1 &bits, T2 n)
    {
        while (n > 0) {
            _writebit(bits & 1 << (n - 1));
            n--;
        }
    }

    auto flush()
    {
        out.write_bytes(create_array({Byte(accumulator)}));
        accumulator = 0;
        bcount = 0;
    }

    auto close()
    {
        flush();
        out.close();
    }
};

class BitReader
{
public:
    File input;
    decltype(0) accumulator = 0;
    decltype(0) bcount = 0;
    decltype(0) read = 0;

    template <typename T1> BitReader(const T1 &fname)
    {
        input = File(fname, u"r"_S);
    }

    auto _readbit()
    {
        if (bcount == 0) {
            auto a = input.read_bytes(1);
            if (!a.empty())
                accumulator = _get<0>(a);
            bcount = 8;
            read = a.len();
        }
        auto rv = (accumulator & (1 << (bcount - 1))) >> (bcount - 1);
        bcount--;
        return rv;
    }

    template <typename T1> auto readbits(T1 n)
    {
        auto v = 0;
        while (n > 0) {
            v = (v << 1) | _readbit();
            n--;
        }
        return v;
    }
};

auto writer = BitWriter(u"bitio_test.dat"_S);
auto chars = u"12345abcde"_S;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto &&ch : chars)
            writer.writebits(ch.code, 7);
        writer.close();
    }
} code_block_1;

auto reader = BitReader(u"bitio_test.dat"_S);
Array<Char> charsa;

struct CodeBlock2
{
    CodeBlock2()
    {
        while (true) {
            auto x = reader.readbits(7);
            if (reader.read == 0)
                break;
            charsa.append(Char(x));
        }
        print(charsa.join(u""_S));
    }
} code_block_2;