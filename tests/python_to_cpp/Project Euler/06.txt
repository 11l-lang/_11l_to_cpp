# 60
import eulerlib, math
from typing import Optional, Dict
Int64 = int

PRIME_LIMIT = 100000  # Arbitrary initial cutoff
primes = eulerlib.list_primes(PRIME_LIMIT)

# Tests whether the given integer is prime. The implementation performs trial division,
# first using the list of primes named 'primes', then switching to simple incrementation.
# This requires the last number in 'primes' (if any) to be an odd number.
def is_prime(x : Int64):
    if x < 0:
        raise ValueError(x)
    elif x in (Int64(0), Int64(1)):
        return False
    else:
        end = int(math.sqrt(x))
        for p in primes:
            if p > end:
                break
            if x % p == 0:
                return False
        for i in range(primes[-1] + 2, end + 1, 2):
            if x % i == 0:
                return False
        return True

is_concat_primes : Dict[Int64, bool] = {}
# Tests whether concat(primes[x], primes[y]) is a prime number, with memoization.
def is_concat_prime(x, y):
    i = Int64(str(primes[x]) + str(primes[y]))
    if i in is_concat_primes:
        return is_concat_primes[i]
    r = is_prime(i)
    is_concat_primes[i] = r
    return r

# Tries to find any suitable set and return its sum, or None if none is found.
# A set is suitable if it contains only primes, its size is targetsize,
# its sum is less than or equal to sumlimit, and each pair concatenates to a prime.
# 'prefix' is an array of ascending indices into the 'primes' array,
# which describes the set found so far.
# The function blindly assumes that each pair of primes in 'prefix' concatenates to a prime.
#
# For example, find_set_sum([1, 3, 28], 5, 10000) means "find the sum of any set
# where the set has size 5, consists of primes with the lowest elements being [3, 7, 109],
# has sum 10000 or less, and has each pair concatenating to form a prime".
def find_set_sum(prefix : "list", targetsize, sumlimit) -> Optional[int]:
    if len(prefix) == targetsize:
        return sum(primes[i] for i in prefix)
    else:
        istart = 0 if (len(prefix) == 0) else (prefix[-1] + 1)
        for i in range(istart, len(primes)):
            if primes[i] > sumlimit:
                break
            if all((is_concat_prime(i, j) and is_concat_prime(j, i)) for j in prefix):
                prefix.append(i)
                result = find_set_sum(prefix, targetsize, sumlimit - primes[i])
                prefix.pop()
                if result is not None:
                    return result
        return None

sumlimit = PRIME_LIMIT
while True:
    setsum : Optional[int] = find_set_sum([0] * 0, 5, sumlimit - 1)
    if setsum is None:  # No smaller sum found
        print(sumlimit)
        break
    sumlimit = setsum
===
V PRIME_LIMIT = 100000
V primes = eulerlib:list_primes(PRIME_LIMIT)

F is_prime(Int64 x)
   I x < 0
      X ValueError(x)
   E I x C (Int64(0), Int64(1))
      R 0B
   E
      V end = Int(sqrt(x))
      L(p) :primes
         I p > end
            L.break
         I x % p == 0
            R 0B
      L(i) (:primes.last + 2 .. end).step(2)
         I x % i == 0
            R 0B
      R 1B

[Int64 = Bool] is_concat_primes
F is_concat_prime(x, y)
   V i = Int64(String(:primes[x])‘’String(:primes[y]))
   I i C :is_concat_primes
      R :is_concat_primes[i]
   V r = is_prime(i)
   :is_concat_primes[i] = r
   R r

F find_set_sum(&prefix, targetsize, sumlimit) -> Int?
   I prefix.len == targetsize
      R sum(prefix.map(i -> :primes[i]))
   E
      V istart = I (prefix.empty) {0} E (prefix.last + 1)
      L(i) istart .< :primes.len
         I :primes[i] > sumlimit
            L.break
         I all(prefix.map(j -> (is_concat_prime(@i, j) & is_concat_prime(j, @i))))
            prefix.append(i)
            V result = find_set_sum(&prefix, targetsize, sumlimit - :primes[i])
            prefix.pop()
            I result != N
               R result
      R N

V sumlimit = PRIME_LIMIT
L
   Int? setsum = find_set_sum(&[Int](), 5, sumlimit - 1)
   I setsum == N
      print(sumlimit)
      L.break
   sumlimit = setsum
===
namespace eulerlib {
#include "eulerlib.hpp"
}

auto PRIME_LIMIT = 100000;
auto primes = eulerlib::list_primes(PRIME_LIMIT);

auto is_prime(const Int64 &x)
{
    if (x < 0)
        throw ValueError(x);
    else if (in(x, make_tuple(to_int64(0), to_int64(1))))
        return false;
    else {
        auto end = to_int(sqrt(x));
        for (auto &&p : ::primes) {
            if (p > end)
                break;
            if (mod(x, p) == 0)
                return false;
        }
        for (auto i : range_ee(::primes.last() + 2, end).step(2))
            if (mod(x, i) == 0)
                return false;
        return true;
    }
}

Dict<Int64, bool> is_concat_primes;
template <typename T1, typename T2> auto is_concat_prime(const T1 &x, const T2 &y)
{
    auto i = to_int64(String(::primes[x]) & String(::primes[y]));
    if (in(i, ::is_concat_primes))
        return ::is_concat_primes[i];
    auto r = is_prime(i);
    ::is_concat_primes.set(i, r);
    return r;
}

template <typename T1, typename T2, typename T3> Nullable<int> find_set_sum(T1 &prefix, const T2 &targetsize, const T3 &sumlimit)
{
    if (prefix.len() == targetsize)
        return sum_map(prefix, [](const auto &i){return ::primes[i];});
    else {
        auto istart = (prefix.empty()) ? 0 : (prefix.last() + 1);
        for (auto i : range_el(istart, ::primes.len())) {
            if (::primes[i] > sumlimit)
                break;
            if (all_map(prefix, [&i](const auto &j){return (is_concat_prime(i, j) && is_concat_prime(j, i));})) {
                prefix.append(i);
                auto result = find_set_sum(prefix, targetsize, sumlimit - ::primes[i]);
                prefix.pop();
                if (result != nullptr)
                    return result;
            }
        }
        return nullptr;
    }
}

auto sumlimit = PRIME_LIMIT;

struct CodeBlock1
{
    CodeBlock1()
    {
        while (true) {
            Nullable<int> setsum = find_set_sum(make_ref(Array<int>()), 5, sumlimit - 1);
            if (setsum == nullptr) {
                print(sumlimit);
                break;
            }
            sumlimit = *setsum;
        }
    }
} code_block_1;


# 61
import itertools
from typing import Optional

def figurate_number(sides, n):
    return n * ((sides - 2) * n - (sides - 4)) // 2

def compute():
    # Build table of numbers
    # numbers[i][j] is the set of figurate numbers of i sides (3 <= i <= 8), having 4 digits, beginning with the 2 digits equal to j
    def create_set():
        s = set() # int
        return s
    numbers = [[create_set() for j in range(100)] for i in range(9)]
    for sides in range(3, 9):
        for n in itertools.count(1):
            num = figurate_number(sides, n)
            if num >= 10000:
                break
            if num >= 1000:
                numbers[sides][num // 100].add(num)

    # Note: sidesused is a bit set
    def find_solution_sum(begin : int, current : int, sidesused : int, sum : int) -> Optional[int]:
        if sidesused == 0b111111000:
            if current % 100 == begin // 100:
                return sum
        else:
            for sides in range(4, 9):
                if (sidesused >> sides) & 1 != 0:
                    continue
                for num in numbers[sides][current % 100]:
                    temp = find_solution_sum(begin, num, sidesused | (1 << sides), sum + num)
                    if temp is not None:
                        return temp
        return None

    # Do search
    for i in range(10, 100):
        for num in numbers[3][i]:
            temp : Optional[int] = find_solution_sum(num, num, 1 << 3, num)
            if temp is not None:
                return str(temp)
    raise AssertionError("No solution")

print(compute())
===
F figurate_number(sides, n)
   R n * ((sides - 2) * n - (sides - 4)) I/ 2

F compute()
   F create_set()
      V s = Set[Int]()
      R s
   V numbers = (0.<9).map(i -> (0.<100).map(j -> @@create_set()))
   L(sides) 3..8
      L(n) 1..
         V num = figurate_number(sides, n)
         I num >= 10000
            L.break
         I num >= 1000
            numbers[sides][num I/ 100].add(num)

   F find_solution_sum(Int begin, Int current, Int sidesused, Int sum) -> Int?
      I sidesused == 111111000b
         I current % 100 == begin I/ 100
            R sum
      E
         L(sides) 4..8
            I (sidesused >> sides) [&] 1 != 0
               L.continue
            L(num) @numbers[sides][current % 100]
               V temp = @find_solution_sum(begin, num, sidesused [|] (1 << sides), sum + num)
               I temp != N
                  R temp
      R N

   L(i) 10..99
      L(num) numbers[3][i]
         Int? temp = find_solution_sum(num, num, 1 << 3, num)
         I temp != N
            R String(temp)
   X AssertionError(‘No solution’)

print(compute())
===
template <typename T1, typename T2> auto figurate_number(const T1 &sides, const T2 &n)
{
    return idiv(n * ((sides - 2) * n - (sides - 4)), 2);
}

auto compute()
{
    auto create_set = []()
    {
        auto s = Set<int>();
        return s;
    };
    auto numbers = range_el(0, 9).map([&create_set](const auto &i){return range_el(0, 100).map([&create_set](const auto &j){return create_set();});});
    for (auto sides : range_ee(3, 8))
        for (auto n : range_ei(1)) {
            auto num = figurate_number(sides, n);
            if (num >= 10000)
                break;
            if (num >= 1000)
                numbers[sides][idiv(num, 100)].add(num);
        }

    std::function<Nullable<int>(int, int, int, int)> find_solution_sum = [&find_solution_sum, &numbers](const int begin, const int current, const int sidesused, const int sum) -> Nullable<int>
    {
        if (sidesused == 0b111111000) {
            if (mod(current, 100) == idiv(begin, 100))
                return sum;
        }
        else
            for (auto sides : range_ee(4, 8)) {
                if (((sidesused >> sides) & 1) != 0)
                    continue;
                for (auto &&num : numbers[sides][mod(current, 100)]) {
                    auto temp = find_solution_sum(begin, num, sidesused | (1 << sides), sum + num);
                    if (temp != nullptr)
                        return temp;
                }
            }
        return nullptr;
    };

    for (auto i : range_ee(10, 99))
        for (auto &&num : _get<3>(numbers)[i]) {
            Nullable<int> temp = find_solution_sum(num, num, 1 << 3, num);
            if (temp != nullptr)
                return String(*temp);
        }
    throw AssertionError(u"No solution"_S);
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(compute());
    }
} code_block_1;


# 62
import itertools
from typing import Dict, Tuple
Int64 = int

numdigits = 0
data : Dict[str, Tuple[int, int]] = {}  # str numclass -> (int lowest, int count)
for i in itertools.count(0):
    digits = [int(c) for c in str(Int64(i)**3)]
    digits.sort()
    numclass = "".join(str(d) for d in digits)

    if len(numclass) > numdigits:
        # Process and flush data for smaller number of digits
        candidates = [lowest for lowest, count in data.values() if count == 5]
        if len(candidates) > 0:
            print(Int64(min(candidates))**3)
            break
        data.clear()
        numdigits = len(numclass)

    (lowest, count) = data.get(numclass, (i, 0))
    data[numclass] = (lowest, count + 1)
===
V numdigits = 0
[String = (Int, Int)] data
L(i) 0..
   V digits = String(Int64(i) ^ 3).map(c -> Int(c))
   digits.sort()
   V numclass = digits.map(d -> String(d)).join(‘’)

   I numclass.len > numdigits
      V candidates = data.values().filter((lowest, count) -> count == 5).map((lowest, count) -> lowest)
      I candidates.len > 0
         print(Int64(min(candidates)) ^ 3)
         L.break
      data.clear()
      numdigits = numclass.len

   V (lowest, count) = data.get(numclass, (i, 0))
   data[numclass] = (lowest, count + 1)
===
auto numdigits = 0;
Dict<String, ivec2> data;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto i : range_ei(0)) {
            auto digits = String(cube(to_int64(i))).map([](const auto &c){return to_int(c);});
            digits.sort();
            auto numclass = digits.map([](const auto &d){return String(d);}).join(u""_S);

            if (numclass.len() > numdigits) {
                auto candidates = data.values().filter([](const auto &lowest, const auto &count){return count == 5;}).map([](const auto &lowest, const auto &count){return lowest;});
                if (candidates.len() > 0) {
                    print(cube(to_int64(min(candidates))));
                    break;
                }
                data.clear();
                numdigits = numclass.len();
            }

            auto [lowest, count] = data.get(numclass, make_tuple(i, 0));
            data.set(numclass, make_tuple(lowest, count + 1));
        }
    }
} code_block_1;


# 63
BigInt = int

ans = 0
for i in range(1, 10):
    for j in range(1, 22):
        if len(str(BigInt(i)**j)) == j:
            ans += 1
print(ans)
===
V ans = 0
L(i) 1..9
   L(j) 1..21
      I String(BigInt(i) ^ j).len == j
         ans++
print(ans)
===
auto ans = 0;

struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto i : range_ee(1, 9))
            for (auto j : range_ee(1, 21))
                if (String(pow(BigInt(i), j)).len() == j)
                    ans++;
        print(ans);
    }
} code_block_1;