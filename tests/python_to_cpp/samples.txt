def parse_int(s):
    i = 0
    r = 0
    while i < len(s) and '0' <= s[i] <= '9':
        r = r*10 + ord(s[i]) - ord('0')
        i += 1
    return r
===
F parse_int(s)
   A i = 0
   A r = 0
   L i < s.len & s[i] C ‘0’..‘9’
      r = r * 10 + s[i].code - ‘0’.code
      i++
   R r
===
template <typename T1> auto parse_int(const T1 &s)
{
    auto i = 0;
    auto r = 0;
    while (i < s.len() && in(s[i], range_ee(u'0'_C, u'9'_C))) {
        r = r * 10 + s[i].code - u'0'_C.code;
        i++;
    }
    return r;
}


class Object:
    a : int
    b : int
    def __init__(self, a = 1, b = 2):
        self.a = a
        self.b = b
object = Object(b = 3)
===
T Object
   Int a
   Int b
   F (a = 1, b = 2)
      .a = a
      .b = b
A object = Object(b' 3)
===
class Object
{
public:
    int a;
    int b;
    template <typename T1 = decltype(1), typename T2 = decltype(2)> Object(const T1 &a = 1, const T2 &b = 2)
    {
        this->a = a;
        this->b = b;
    }
};
auto object = Object(1, 3);


def print_seconds(sec):
    r60 = sec % 60
    print(chr(ord('0') + r60 // 10) + ''
        + chr(ord('0') + r60 %  10))
===
F print_seconds(sec)
   A r60 = sec % 60
   print(Char(code' ‘0’.code + r60 I/ 10)‘’Char(code' ‘0’.code + r60 % 10))
===
template <typename T1> auto print_seconds(const T1 &sec)
{
    auto r60 = mod(sec, 60);
    print(Char(u'0'_C.code + int(r60)/int(10)) + Char(u'0'_C.code + mod(r60, 10)));
}


print("Prepare files' list...", end = '')
print("Prepare files' list...", flush = True)
===
print(‘Prepare files' list...’, end' ‘’)
print(‘Prepare files' list...’, flush' 1B)
===
struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"Prepare files' list..."_S, u""_S);
        print(u"Prepare files' list..."_S, u"\n"_S, true);
    }
} code_block_1;


def f(a = 1, b = 2):
    return a + b
print(f(b = 3))
print(f(0, b = 3))
def f2(a = 1, b = 2, c = 3):
    return a + b + c
print(f2(b = 3, c = 4))
===
F f(a = 1, b = 2)
   R a + b
print(f(b' 3))
print(f(0, b' 3))
F f2(a = 1, b = 2, c = 3)
   R a + b + c
print(f2(b' 3, c' 4))
===
template <typename T1 = decltype(1), typename T2 = decltype(2)> auto f(const T1 &a = 1, const T2 &b = 2)
{
    return a + b;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        print(f(1, 3));
        print(f(0, 3));
    }
} code_block_1;
template <typename T1 = decltype(1), typename T2 = decltype(2), typename T3 = decltype(3)> auto f2(const T1 &a = 1, const T2 &b = 2, const T3 &c = 3)
{
    return a + b + c;
}

struct CodeBlock2
{
    CodeBlock2()
    {
        print(f2(1, 3, 4));
    }
} code_block_2;


def f(a = 10, *, b, c = 20):
    return a + b + c
f(b = 1)
===
F f(a = 10, ', b, c = 20)
   R a + b + c
f(b' 1)
===
template <typename T1, typename T2, typename T3 = decltype(20)> auto f(const T1 &a, const T2 &b, const T3 &c = 20)
{
    return a + b + c;
}

struct CodeBlock1
{
    CodeBlock1()
    {
        f(10, 1);
    }
} code_block_1;


def f():
    for i in range(0, 11, 2):
        print(i)
    for i in range(11):
        print(i)
===
F f()
   L(i) (0.<11).step(2)
      print(i)
   L(i) 0.<11
      print(i)
===
auto f()
{
    for (auto i : range_el(0, 11).step(2))
        print(i);
    for (auto i : range_el(0, 11))
        print(i);
}


def f():
    dict : Dict[str, int] = {}
    dict['key'] = 1
    assert('key' in dict)
    arr : List[int] = []
    arr += [10]
===
F f()
   Dict[String, Int] dict
   dict[‘key’] = 1
   assert(‘key’ C dict)
   Array[Int] arr
   arr [+]= 10
===
auto f()
{
    Dict<String, int> dict;
    dict.set(u"key"_S, 1);
    assert(in(u"key"_S, dict));
    Array<int> arr;
    arr.append(10);
}


R"\""
R"""\""""
R"a\\"
R"""a\\"""
r'''\''''
r'''a
b'''
r'''ab'''
r'''a\b''' # (((((((((
r'''a\)"b'''
r'''a\)"b)'"c'''
'''\
<html>"'''
"""\
<html>'"""
'''\
<html>
<head>'''
'''a'''
"\n"
"'"
'"'
"‘"
"’"
"don‘t"
r"don‘t"
"don’‘t"
"don’t"
r"don’t"
'\''
"\""
===
‘\"’
‘\"’
‘a\\’
‘a\\’
‘\'’
‘a
b’
‘ab’
‘a\b’
‘a\)"b’
‘a\)"b)'"c’
"\
<html>\""
"\
<html>'"
"\
<html>\n\
<head>"
‘a’
"\n"
‘'’
‘"’
"‘"
"’"
"don‘t"
‘don‘t’’'
'‘‘don’‘t’’'
"don’t"
'‘‘don’t’
"'"
"\""
===
struct CodeBlock1
{
    CodeBlock1()
    {
        uR"(\")"_S;
        uR"(\")"_S;
        uR"(a\\)"_S;
        uR"(a\\)"_S;
        uR"(\')"_S;
        uR"(a
b)"_S;
        u"ab"_S;
        uR"(a\b)"_S;
        uR"'(a\)"b)'"_S;
        uR"''(a\)"b)'"c)''"_S;
        u"\
<html>\""_S;
        u"\
<html>'"_S;
        u"\
<html>\n\
<head>"_S;
        u"a"_S;
        u"\n"_S;
        u"'"_S;
        u"\""_S;
        u"‘"_S;
        u"’"_S;
        u"don‘t"_S;
        u"don‘t"_S;
        u"don’‘t"_S;
        u"don’t"_S;
        u"don’t"_S;
        u"'"_S;
        u"\""_S;
    }
} code_block_1;


x = ~1 ^ 2
===
A x = (-)1 (+) 2
===
auto x = ~1 ^ 2;


if __name__ == '__main__':
    f : Callable[[str, int], str]
    def ff(s, i):
        return s * i
    f = ff
    assert(f('s', 2) == 'ss')
===
:start:
(String, Int -> String) f
F ff(s, i)
   R s * i
f = ff
assert(f(‘s’, 2) == ‘ss’)
===
int main()
{
    std::function<String(const String&, const int)> f;
    auto ff = [](const auto &s, const auto &i)
    {
        return s * i;
    };
    f = ff;
    assert(f(u"s"_S, 2) == u"ss");
}


def find_ending_pair_quote(instr, i):
    nesting_level = 0
    while True:
        ch = instr[i]
        if ch == "‘":
            nesting_level += 1
        elif ch == "’":
            nesting_level -= 1
            if nesting_level == 0:
                return i
        else:
            return -1
        i += 1
===
F find_ending_pair_quote(instr, =i)
   A nesting_level = 0
   L
      S instr[i]
         "‘"
            nesting_level++
         "’"
            I --nesting_level == 0
               R i
         E
            R -1
      i++
===
template <typename T1, typename T2> auto find_ending_pair_quote(const T1 &instr, T2 i)
{
    auto nesting_level = 0;
    while (true) {
        switch (instr[i])
        {
        case u'‘':
            nesting_level++;
            break;
        case u'’':
            if (--nesting_level == 0)
                return i;
            break;
        default:
            return -1;
            break;
        }
        i++;
    }
}


def exit_with_error(message, pos):
    pass
def write_http_link(instr, i, endpos, q_offset = 1):
    nesting_level = 0
    i += 2
    while True:
        if i == len(instr):
            exit_with_error('Unended link', endpos+q_offset)
        ch = instr[i]
        if ch == "[":
            nesting_level += 1
        elif ch == "]":
            if nesting_level == 0:
                break
            nesting_level -= 1
        elif ch == " ":
            break
        i += 1
===
F exit_with_error(message, pos)
{
}
F write_http_link(instr, =i, endpos, q_offset = 1)
   A nesting_level = 0
   i += 2
   L
      I i == instr.len
         exit_with_error(‘Unended link’, endpos + q_offset)
      S instr[i]
         ‘[’
            nesting_level++
         ‘]’
            I nesting_level == 0
               L.break
            nesting_level--
         ‘ ’
            L.break
      i++
===
template <typename T1, typename T2> auto exit_with_error(const T1 &message, const T2 &pos)
{
}

template <typename T1, typename T2, typename T3, typename T4 = decltype(1)> auto write_http_link(const T1 &instr, T2 i, const T3 &endpos, const T4 &q_offset = 1)
{
    auto nesting_level = 0;
    i += 2;
    while (true) {
        if (i == instr.len())
            exit_with_error(u"Unended link"_S, endpos + q_offset);
        switch (instr[i])
        {
        case u'[':
            nesting_level++;
            break;
        case u']':
            if (nesting_level == 0)
                goto break_;
            nesting_level--;
            break;
        case u' ':
            goto break_;
            break;
        }
        i++;
    }
    break_:
}


import os, tempfile

print(os.pathsep + os.path.join(tempfile.gettempdir(), 'right'))
print(os.getenv('PATH'))
os.environ['PATH'] += os.pathsep + 'KDiff3'
print(os.getenv('PATH'))
print(os.listdir())
os.system('pause')
===
//import os, tempfile
print(os:env_path_sep‘’fs:path:join(fs:get_temp_dir(), ‘right’))
print(os:getenv(‘PATH’))
os:environ[‘PATH’] += os:env_path_sep‘KDiff3’
print(os:getenv(‘PATH’))
print(fs:list_dir())
os:(‘pause’)
===
struct CodeBlock1
{
    CodeBlock1()
    {
        print(os::env_path_sep + fs::path::join(fs::get_temp_dir(), u"right"_S));
        print(os::getenv(u"PATH"_S));
        os::environ[u"PATH"_S] += os::env_path_sep + u"KDiff3"_S;
        print(os::getenv(u"PATH"_S));
        print(fs::list_dir());
        os::_(u"pause"_S);
    }
} code_block_1;


import os

def process_files(exclude_dir):
    for root, dirs, files in os.walk('.'):
        dirs[:] = [d for d in dirs if d[0] != '.' and d != exclude_dir] # exclude hidden folders (e.g. `.hg`)
        for name in files:
            print(os.path.join(root, name))

def process_files2():
    for root, dirs, files in os.walk('.'):
        for name in files:
            print(os.path.join(root, name))
===
//import os

F process_files(exclude_dir)
   L(_fname) fs:walk_dir(‘.’, dir_filter' d -> d[0] != ‘.’ & d != @exclude_dir, files_only' 0B)
      A root = fs:path:dir_name(_fname)
      [String] dirs, files
      I fs:is_directory(_fname) {dirs [+]= fs:path:base_name(_fname)} E files [+]= fs:path:base_name(_fname)
      L(name) files
         print(fs:path:join(root, name))

F process_files2()
   L(_fname) fs:walk_dir(‘.’, files_only' 0B)
      A root = fs:path:dir_name(_fname)
      [String] dirs, files
      I fs:is_directory(_fname) {dirs [+]= fs:path:base_name(_fname)} E files [+]= fs:path:base_name(_fname)
      L(name) files
         print(fs:path:join(root, name))
===
template <typename T1> auto process_files(const T1 &exclude_dir)
{
    for (auto _fname : fs::walk_dir(u"."_S, [&exclude_dir](const auto &d){return _get<0>(d) != u'.' && d != exclude_dir;}, false)) {
        auto root = fs::path::dir_name(_fname);
        Array<String> dirs, files;
        if (fs::is_directory(_fname))
            dirs.append(fs::path::base_name(_fname));
        else
            files.append(fs::path::base_name(_fname));
        for (auto name : files)
            print(fs::path::join(root, name));
    }
}

auto process_files2()
{
    for (auto _fname : fs::walk_dir(u"."_S, nullptr, false)) {
        auto root = fs::path::dir_name(_fname);
        Array<String> dirs, files;
        if (fs::is_directory(_fname))
            dirs.append(fs::path::base_name(_fname));
        else
            files.append(fs::path::base_name(_fname));
        for (auto name : files)
            print(fs::path::join(root, name));
    }
}


print(round(1.12345, 3))
===
print(round(1.12345, 3))
===
struct CodeBlock1
{
    CodeBlock1()
    {
        print(round(1.12345, 3));
    }
} code_block_1;


import time
start = time.perf_counter()
time.sleep(0.1)
print(time.perf_counter() - start)
===
//import time
A start = time:perf_counter()
sleep(0.1)
print(time:perf_counter() - start)
===
auto start = timens::perf_counter();

struct CodeBlock1
{
    CodeBlock1()
    {
        sleep(0.1);
        print(timens::perf_counter() - start);
    }
} code_block_1;


import datetime
d = datetime.timedelta(days = 1, hours = 2, minutes = 3, seconds = 4.5)
assert(datetime.datetime(2018, 8, 2) - datetime.datetime(2018, 7, 1) == datetime.timedelta(days = 32))
assert(datetime.date    (2018, 8, 2) - datetime.date    (2018, 7, 1) == datetime.timedelta(days = 32))
print(d)
print(str(d.days) + ', ' + str(d.total_seconds()))
print(datetime.date.today())
print(datetime.datetime.now() - datetime.date.today())
===
//import datetime
A d = time:delta(days' 1, hours' 2, minutes' 3, seconds' 4.5)
assert(time:(2018, 8, 2) - time:(2018, 7, 1) == time:delta(days' 32))
assert(time:(2018, 8, 2) - time:(2018, 7, 1) == time:delta(days' 32))
print(d)
print(String(d.days())‘, ’String(d.seconds))
print(time:today())
print(time:() - time:today())
===
auto d = timens::delta(1, 2, 3, 4.5);

struct CodeBlock1
{
    CodeBlock1()
    {
        assert(timens::_(2018, 8, 2) - timens::_(2018, 7, 1) == timens::delta(32));
        assert(timens::_(2018, 8, 2) - timens::_(2018, 7, 1) == timens::delta(32));
        print(d);
        print(String(d.days()) + u", "_S + String(d.seconds));
        print(timens::today());
        print(timens::_() - timens::today());
    }
} code_block_1;


import datetime
print(datetime.datetime(2001, 2, 3, 4, 5, 6).strftime('%Y.%m.%d %H:%M:%S') == '2001.02.03 04:05:06')
print(datetime.datetime(2001, 2, 3, 4, 5, 6).format('YYYY.MM.DD hh:mm:ss') == '2001.02.03 04:05:06')
print(datetime.datetime(2001, 2, 3, 4, 5, 6).format('ГГГГ.ММ.ДД чч:мм:сс') == '2001.02.03 04:05:06')
print(datetime.datetime.strptime('2001.02.03 04:05:06', '%Y.%m.%d %H:%M:%S') == datetime.datetime(2001, 2, 3, 4, 5, 6))
print(datetime.datetime(1970, 1, 2).timestamp())
print(datetime.datetime.fromtimestamp(datetime.datetime(1970, 1, 2).timestamp()))
# [-TODO: Add `time:gmtime()` and `time:timegm()` [<- `calendar.timegm()`] (need good (practical) test cases!)-]
===
//import datetime
print(time:(2001, 2, 3, 4, 5, 6).strftime(‘%Y.%m.%d %H:%M:%S’) == ‘2001.02.03 04:05:06’)
print(time:(2001, 2, 3, 4, 5, 6).format(‘YYYY.MM.DD hh:mm:ss’) == ‘2001.02.03 04:05:06’)
print(time:(2001, 2, 3, 4, 5, 6).format(‘ГГГГ.ММ.ДД чч:мм:сс’) == ‘2001.02.03 04:05:06’)
print(time:strptime(‘2001.02.03 04:05:06’, ‘%Y.%m.%d %H:%M:%S’) == time:(2001, 2, 3, 4, 5, 6))
print(time:(1970, 1, 2).unix_time())
print(time:from_unix_time(time:(1970, 1, 2).unix_time()))
===
struct CodeBlock1
{
    CodeBlock1()
    {
        print(timens::_(2001, 2, 3, 4, 5, 6).strftime(u"%Y.%m.%d %H:%M:%S"_S) == u"2001.02.03 04:05:06");
        print(timens::_(2001, 2, 3, 4, 5, 6).format(u"YYYY.MM.DD hh:mm:ss"_S) == u"2001.02.03 04:05:06");
        print(timens::_(2001, 2, 3, 4, 5, 6).format(u"ГГГГ.ММ.ДД чч:мм:сс"_S) == u"2001.02.03 04:05:06");
        print(timens::strptime(u"2001.02.03 04:05:06"_S, u"%Y.%m.%d %H:%M:%S"_S) == timens::_(2001, 2, 3, 4, 5, 6));
        print(timens::_(1970, 1, 2).unix_time());
        print(timens::from_unix_time(timens::_(1970, 1, 2).unix_time()));
    }
} code_block_1;


for line in open('1.py').readlines():
    print(line)
===
L(line) File(‘1.py’).read_lines(1B)
   print(line)
===
struct CodeBlock1
{
    CodeBlock1()
    {
        for (auto line : File(u"1.py"_S).read_lines(true))
            print(line);
    }
} code_block_1;


items = ['A', 'B', 'C']
for index, item in enumerate(items):
    print(str(index) + '. ' + item)
for index, item in enumerate(items, 1):
    print(str(index) + '. ' + item)
===
A items = [‘A’, ‘B’, ‘C’]
L(item) items
   A index = L.index
   print(String(index)‘. ’item)
L(item) items
   A index = L.index + 1
   print(String(index)‘. ’item)
===
auto items = create_array({u'A'_C, u'B'_C, u'C'_C});

struct CodeBlock1
{
    CodeBlock1()
    {
        {int Lindex = 0;
        for (auto item : items) {
            auto index = Lindex;
            print(String(index) + u". "_S + item);
            Lindex++;
        }}
        {int Lindex = 0;
        for (auto item : items) {
            auto index = Lindex + 1;
            print(String(index) + u". "_S + item);
            Lindex++;
        }}
    }
} code_block_1;


from typing import List

class Animal:
    def say(self) -> None:
        raise NotImplementedError()

class Sheep(Animal):
    def say(self):
        print('baa')

class Cat(Animal):
    def say(self):
        print('meow')

if __name__ == '__main__':
    animals : List[Animal] = []
    animals += [Sheep()]
    animals += [Cat()]
    animal = Sheep()
    animal.say()
    animals += [animal]
    for animal in animals:
        animal.say()
===

T Animal
   F.virtual.abstract say() -> N

T Sheep(Animal)
   F.virtual.override say() -> N
      print(‘baa’)

T Cat(Animal)
   F.virtual.override say() -> N
      print(‘meow’)

:start:
Array[Animal] animals
animals [+]= Sheep()
animals [+]= Cat()
A animal = Sheep()
animal.say()
animals [+]= animal
L(animal) animals
   animal.say()
===
class Animal
{
public:
    virtual void say() = 0;
};

class Sheep : public Animal
{
public:
    virtual void say() override
    {
        print(u"baa"_S);
    }
};

class Cat : public Animal
{
public:
    virtual void say() override
    {
        print(u"meow"_S);
    }
};

int main()
{
    Array<std::unique_ptr<Animal>> animals;
    animals.append(std::make_unique<Sheep>());
    animals.append(std::make_unique<Cat>());
    auto animal = std::make_unique<Sheep>();
    animal->say();
    animals.append(std::move(animal));
    for (auto &&animal : animals)
        animal->say();
}


print("\t word \t".rstrip("\t") == "\t word ")
print("\t word \t".lstrip("\t") ==   " word \t")
print("\t word \t". strip("\t") ==   " word ")
print("\t word \t".rstrip("\t ") == "\t word")
print("\t word \t".lstrip("\t ") ==    "word \t")
print("\t word \t". strip("\t ") ==    "word")
===
print("\t word \t".rtrim("\t") == "\t word ")
print("\t word \t".ltrim("\t") == " word \t")
print("\t word \t".trim("\t") == ‘ word ’)
print("\t word \t".rtrim(Array[Char]("\t ")) == "\t word")
print("\t word \t".ltrim(Array[Char]("\t ")) == "word \t")
print("\t word \t".trim(Array[Char]("\t ")) == ‘word’)
===
struct CodeBlock1
{
    CodeBlock1()
    {
        print(u"\t word \t"_S.rtrim(u"\t"_S) == u"\t word ");
        print(u"\t word \t"_S.ltrim(u"\t"_S) == u" word \t");
        print(u"\t word \t"_S.trim(u"\t"_S) == u" word ");
        print(u"\t word \t"_S.rtrim(Array<Char>(u"\t "_S)) == u"\t word");
        print(u"\t word \t"_S.ltrim(Array<Char>(u"\t "_S)) == u"word \t");
        print(u"\t word \t"_S.trim(Array<Char>(u"\t "_S)) == u"word");
    }
} code_block_1;


import math

print(math.ceil(3.6) == 4)
print(math.floor(3.6) == 3)
print(math.trunc(-3.6) == -3)
print(math.fabs(-3.5) == 3.5)
print(math.exp(2) - 7.38905609893065 + 1)
print(math.log(math.exp(1)) == 1)
print(math.log(25, 5) == 2)
print(math.log2(8) == 3)
print(math.log10(100) == 2)
print(math.pow(2, 3) == 2 ** 3)
print(math.sqrt(4) == 2)
print(math.acos(0.5) - 0.0471975511965979)
print(math.asin(1) - 0.5707963267948966)
print(math.atan(1) - 0.7853981633974483 + 1)
print(math.atan2(1, 2) - 0.4636476090008061 + 1)
print(math.cos(1) - 0.5403023058681398 + 1)
print(math.sin(1) - 0.8414709848078965 + 1)
print(math.tan(1) - 1.5574077246549023 + 1)
print(math.degrees(1) - 57.29577951308232 + 1)
print(math.radians(1) - 0.017453292519943295 + 1)
print(math.pi - 2.141592653589793)
===
//import math
print(ceil(3.6) == 4)
print(floor(3.6) == 3)
print(trunc(-3.6) == -3)
print(fabs(-3.5) == 3.5)
print(exp(2) - 7.38905609893065 + 1)
print(log(exp(1)) == 1)
print(log(25, 5) == 2)
print(log2(8) == 3)
print(log10(100) == 2)
print(pow(2, 3) == 2 ^ 3)
print(sqrt(4) == 2)
print(acos(0.5) - 0.0471975511965979)
print(asin(1) - 0.5707963267948966)
print(atan(1) - 0.7853981633974483 + 1)
print(atan2(1, 2) - 0.4636476090008061 + 1)
print(cos(1) - 0.5403023058681398 + 1)
print(sin(1) - 0.8414709848078965 + 1)
print(tan(1) - 1.5574077246549023 + 1)
print(degrees(1) - 57.29577951308232 + 1)
print(radians(1) - 0.017453292519943295 + 1)
print(pi - 2.141592653589793)
===
struct CodeBlock1
{
    CodeBlock1()
    {
        print(ceil(3.6) == 4);
        print(floor(3.6) == 3);
        print(trunc(-3.6) == -3);
        print(fabs(-3.5) == 3.5);
        print(exp(2) - 7.38905609893065 + 1);
        print(log(exp(1)) == 1);
        print(log(25, 5) == 2);
        print(log2(8) == 3);
        print(log10(100) == 2);
        print(pow(2, 3) == pow(2, 3));
        print(sqrt(4) == 2);
        print(acos(0.5) - 0.0471975511965979);
        print(asin(1) - 0.5707963267948966);
        print(atan(1) - 0.7853981633974483 + 1);
        print(atan2(1, 2) - 0.4636476090008061 + 1);
        print(cos(1) - 0.5403023058681398 + 1);
        print(sin(1) - 0.8414709848078965 + 1);
        print(tan(1) - 1.5574077246549023 + 1);
        print(degrees(1) - 57.29577951308232 + 1);
        print(radians(1) - 0.017453292519943295 + 1);
        print(pi - 2.141592653589793);
    }
} code_block_1;


import re

print(re.search('[a-z]', '_12b').start(0) == 3)
print(re.search('[a-z]', '_12b').end(0) == 4)
print(re.compile('[a-z]').search('_12b').start(0) == 3)
print(re.search('([a-z])a', '1a2ba').group(1) == 'b')
print(re.split(' |:', ' 1 2:3') == ['', '1', '2', '3'])
print(re.split(' |:', ' 1 2:3 ') == ['', '1', '2', '3', ''])
===
//import re
print(re:‘[a-z]’.search(‘_12b’).start(0) == 3)
print(re:‘[a-z]’.search(‘_12b’).end(0) == 4)
print(re:(‘[a-z]’).search(‘_12b’).start(0) == 3)
print(re:‘([a-z])a’.search(‘1a2ba’).group(1) == ‘b’)
print(‘ 1 2:3’.split(re:‘ |:’) == [‘’, ‘1’, ‘2’, ‘3’])
print(‘ 1 2:3 ’.split(re:‘ |:’) == [‘’, ‘1’, ‘2’, ‘3’, ‘’])
===
struct CodeBlock1
{
    CodeBlock1()
    {
        print(re::_(u"[a-z]"_S).search(u"_12b"_S).start(0) == 3);
        print(re::_(u"[a-z]"_S).search(u"_12b"_S).end(0) == 4);
        print(re::_(u"[a-z]"_S).search(u"_12b"_S).start(0) == 3);
        print(re::_(u"([a-z])a"_S).search(u"1a2ba"_S).group(1) == u'b');
        print(u" 1 2:3"_S.split(re::_(u" |:"_S)) == create_array({u""_S, u"1"_S, u"2"_S, u"3"_S}));
        print(u" 1 2:3 "_S.split(re::_(u" |:"_S)) == create_array({u""_S, u"1"_S, u"2"_S, u"3"_S, u""_S}));
    }
} code_block_1;